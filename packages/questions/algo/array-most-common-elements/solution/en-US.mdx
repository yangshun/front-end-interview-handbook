import MDXCodeBlock from 'MDXCodeBlock';

import mostCommonElements from '../setup/src/array-most-common-elements.ts';
import mostCommonElementsUsingMap from '../setup/src/array-most-common-elements-using-map.ts';
import mostCommonElementsBruteForce from '../setup/src/array-most-common-elements-brute-force.ts';

## 1. Brute Force

A naive approach is to calculate the frequency of each element using nested loops. The frequencies are stored in a separate array, and then the array is sorted to find the most common elements.

### Algorithm

1. Initialize an empty array `frequency` to store objects with `value` and `count` properties.
2. Iterate through the input array:
   - For each number, check if it already exists in the `frequency` array.
   - If it exists, increment its `count`.
   - If it does not exist, add it to the `frequency` array with an initial `count` of 1.
3. Sort the `frequency` array in descending order of `count`.
4. Extract the first `k` elements from the sorted `frequency` array.
5. Return an array containing the `value` of the top `k` elements.

<MDXCodeBlock>{mostCommonElementsBruteForce}</MDXCodeBlock>

### Big-O analysis

- **Time complexity: O(n<sup>2</sup>)**. This is due to the nested loop for frequency calculation.
- **Space complexity: O(n)**. If all `n` elements in numbers are unique, the frequency array will have a size of O(n).

## 2. Using Heap

The brute force solution had a major bottleneck due to its nested loops for calculating frequencies and sorting the entire frequency array. This led to redundant comparisons and high time complexity. The optimized approach uses a hash map for frequency counting, which avoids duplicate computations, and a min-heap to maintain the top `k` frequent elements efficiently. This significantly reduces unnecessary sorting and comparisons, focusing only on the required elements.

### Algorithm

1. Check if `k` is equal to the size of the input array. If true, return the array as all elements are required.
2. Create a hash map to count the frequency of each element in the array:
   - Iterate through the array, updating the frequency count for each element in the hash map.
3. Initialize a min-heap with a custom comparator to sort elements by their frequency.
4. Iterate through the elements in the hash map:
   - Insert each element into the heap while maintaining the heap's size to `k`.
   - After each insertion, sort the heap using the comparator and remove the least frequent element if the heap size exceeds `k`.
5. Return the elements in the heap, which are the `k` most frequent elements.

<MDXCodeBlock>{mostCommonElements}</MDXCodeBlock>

### Big-O analysis

- **Time complexity: O(n log k)**. Maintaining the heap requires sorting up to `k` elements for each of the n unique elements, which takes O(n log k) in total.
- **Space complexity: O(n + k)**. The hash map requires O(n) space to store no more than `n` unique elements, and the heap requires O(k) space to store the top `k` elements.

## 3. Using Map

Another approach uses a frequency map to count occurrences of each number. A `buckets` array is then built to group elements by their frequencies, where the index corresponds to the frequency. Traversing the `buckets` array from highest frequency to lowest frequency efficiently collects the top `k` frequent elements without incurring an O(n log n) sorting step. This approach reduces the overall complexity to O(n).

### Algorithm

1. Build a frequency map `frequencyMap` that maps each number to its frequency count .
2. Build a `buckets` array, where each index corresponds to a frequency and stores an array of numbers with that frequency.
3. Iterate through `buckets` from the highest frequency bucket to the lowest frequency bucket and select numbers until `k` is reached.

<MDXCodeBlock>{mostCommonElementsUsingMap}</MDXCodeBlock>

### Big-O analysis

- **Time complexity: O(n)**. Counting frequencies and then populating buckets both run in O(n), followed by a final pass that selects at most `k` elements, still O(n).
- **Space complexity: O(n)**. The `frequencyMap` and `buckets` array each take up to O(n) space.
