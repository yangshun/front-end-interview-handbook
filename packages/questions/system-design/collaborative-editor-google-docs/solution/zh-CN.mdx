## 需求探索

* 功能
  * 任何参与者都可以编辑/查看文档
  * 同一文档上的同行更新会自动反映
  * 如果参与者编辑同一部分，则会解决冲突
  * 所有参与者最终都应该看到相同的文档修订版
  * 离线使用？不需要，但如果有时间，我们会讨论
* 非功能性
  * 其他人的更新会实时反映
  * 支持多达 100 个并发编辑器（[Google 也有相同的限制](https://support.google.com/docs/answer/2494822)）

***

## 背景

首先，让我们了解一下 Google 文档上的协作编辑会话需要什么。以下是协作编辑会话的观察/要求：

* **响应式（在延迟方面）**：参与者采取的操作（例如，插入/删除字符、格式化）应立即反映出来。
* **实时更新**：同伴采取的操作应几乎立即反映出来。
* **容易发生冲突**：在会话期间，由于参与者处理和修改文档的同一部分，因此很有可能发生访问冲突，例如，当另一个参与者正在修改句子时删除该句子。
* **分布式**：参与者在自己的机器上访问 Web 应用程序，没有任何地理限制。
* **临时**：参与者可以在会话期间自由地来来去去；他们可能随时退出或加入。
* **不可预测**：一般来说，参与者没有遵循预先计划的脚本，不可能预测将访问什么信息以及以什么顺序访问。

这种协作软件的技术术语是“群件系统”。Google Workspace（以前称为 G Suite）中的大多数产品（如 Google Sheets 和 Google Slides）也支持实时协作。

请注意，参与者应在浏览器选项卡级别考虑。用户可以在两个单独的选项卡上打开同一文档。假设同一用户的浏览器选项卡之间没有直接通信，将每个选项卡视为一个单独的参与者并同步其文档状态会更简单。

实时协作编辑解决方案的复杂性主要源于通信延迟。理想情况下，如果通信是瞬时的，那么开发一个实时协作编辑器将像创建一个单用户编辑器一样简单，因为来自同伴的更新将显示为由活动用户进行的更新。

但是，网络延迟限制了通信速度，从而带来了一个根本性的挑战：用户希望他们自己的编辑立即合并到文档中。然而，如果这些编辑立即应用，由于通信延迟，它们必然会插入到文档的不同修订版中。

考虑以下示例：Alice 和 Bob 从包含单词“Mary”的文档开始。Bob 删除字母“M”然后插入“H”，打算将单词更改为“Hary”。与此同时，Alice 在没有收到 Bob 的编辑的情况下，删除了字母“r”然后删除了“a”，打算将单词更改为“My”。因此，Alice 和 Bob 都将收到应用于他们自己机器上从未存在过的文档版本的编辑，并且在没有任何特殊处理的情况下，文档状态可能会发生分歧。

因此，实时协作编辑的挑战在于确定如何正确应用来自远程用户的编辑，这些编辑最初是在本地不存在的文档版本中进行的，并且可能与用户自己的本地更改发生冲突。

通常，对于前端系统设计，我们只需要关心客户端内部发生的事情。但是，对于协作编辑，服务器也在协作协议中发挥着重要作用，因此也有必要讨论服务器的状态和职责。

***

## 方法

通过孤立地查看各个部分来设计整个复杂系统很困难，但如果在没有解释我们如何做出这些决定的情况下向您展示最终架构，也不利于学习。

因此，我们将讨论系统的各个方面、可以采取的各种方法、涉及的权衡，然后对整体方法做出决定。

需要注意的是，我们所做的其中一些决定相互依赖，并且只有在作为整体方法的一部分一起使用时，这些决定才有意义。因此，如果您在阅读时想知道我们如何知道某个决定更好，请先阅读，希望后面的部分能证明之前的决定的合理性。

在确定了整体方法后，我们将深入研究架构、数据模型和 API 以继续进行。

### 渲染和编辑富文本

在架构良好的系统中，渲染文档 UI 很大程度上独立于幕后的通信模型和协议。我们在[富文本编辑器系统设计文章](/questions/system-design/rich-text-editor)中更详细地解释了协作编辑器的“前端”。

以下是构建 Web 富文本编辑器的几种方法的摘要：

* **带有增强的假光标的 DOM**：使用包含使用 HTML 元素和样式的格式化文本的常规 DOM，并使用假光标进行增强。由于需要计算光标高度和定位，因此这种方法很复杂。
* **`contenteditable` 属性**：通过将 `contenteditable` 属性添加到 DOM 元素，其内容变为可编辑，甚至支持用于粗体、斜体、下划线格式的键盘快捷键。但是，它在不同的浏览器中的行为不同，并且格式化选项有限。
* **HTML `<canvas>` 元素**：这是一种高级方法，它使用 `<canvas>` 元素并在 canvas 元素内渲染所有内容——文本、布局、光标等。这种方法基本上绕过了浏览器提供的很多东西，并且需要在 canvas 上下文中重新实现所有内容。

在实践中，Web 上大多数富文本编辑器都是使用 `contenteditable` 属性构建的，并由自定义事件处理程序支持，并允许更多内容元素。

2021 年，Google [宣布 Google Docs 将转向基于 canvas 的渲染方法](https://workspaceupdates.googleblog.com/2021/05/Google-Docs-Canvas-Based-Rendering-Update.html?utm_source=the+new+stack\&utm_medium=referral\&utm_content=inline-mention\&utm_campaign=tns+platform)，以“提高内容在不同平台上的显示性能和一致性”。虽然 Google Docs 使用基于 canvas 的方法，但它过于复杂，大多数前端开发人员对 canvas 也没有太多经验。我们建议首先熟悉 `contenteditable` 属性方法。

总而言之，Web 上大多数富文本编辑器都使用 `contenteditable` 并采用以下高级方法：

1. 设计一个特定于编辑器的文档内容模型，通常是基于树的
2. 在模型和 DOM 元素之间创建映射
3. 定义一组对该模型支持的操作（例如，在某个位置插入文本、删除文本、格式化文本）
4. 将用户事件（按键和鼠标点击）转换为一系列这些支持的操作
5. 根据这些操作更新 DOM，理想情况下使用最少的 DOM 操作调用

在[富文本编辑器系统设计文章](/questions/system-design/rich-text-editor)中阅读更多关于协作编辑器的“前端”的信息。

### 请求负载内容

当参与者进行更新或从其他人那里收到更新时，请求负载应该包含什么？

两种常见的方法是：

* **负载包含整个当前文档**：发送和接收整个当前文档状态。
* **负载仅包含更改（增量）**：仅发送和接收所做的更新。

#### 传输整个文档

每次更新都传输整个文档具有以下属性：

* **清晰的文档状态**：接收者知道发送者在更新时正在查看的文档的完整状态。
* **发送者的意图不明确**：仅通过接收更新后的文档，接收者并不知道进行了哪些更改，除非他们将其与自己的文档修订版或发送者的先前文档修订版进行比较，这两者都难以计算。
* **不可扩展**：随着文档的增长，要传输的数据量将成比例增加。对于大型文档，每个请求将需要更长的传输时间。

#### 仅传输更改

仅传输更改具有以下属性：

* **请求负载小**：由于仅发送更改，请求负载通常很小，通常仅包含命令（例如插入、删除、格式化）和相关元数据（例如要插入/删除的字符和位置）。
* **高效的请求负载大小**：文档的长度对请求负载大小没有影响，因为更改不依赖于当前的文档状态。
* **没有文档状态信息**：不清楚更改是针对哪个版本的文档进行的。这可以通过在请求负载中包含文档修订号来缓解——稍后会详细介绍。

#### 请求应该包含什么？

为了获得实时的 WYSIWIS（所见即所得）体验，需要较短的响应时间（低于 500 毫秒）。 也就是说，当用户进行编辑时，所有其他参与者都应该在 500 毫秒内在其屏幕上看到该更改的反映。 如果参与者看到略有不同或过时的文档版本，则会破坏会话的内聚力。

参与者所做的更新应以轻量级方式进行通信，因此更新的请求负载应该理想地**仅包含更改**。

### 网络架构/通信模型

组建系统参与者之间有两种常见的网络通信模型：

* **客户端-服务器模型**：中央服务器；所有参与者仅与服务器通信
* **对等**：没有中央服务器；所有参与者同时充当服务器和客户端

#### 客户端-服务器模型

在客户端-服务器网络模型中，参与者（客户端）从中央服务器请求资源并向其发送负载。 服务器处理这些请求并提供适当的响应。

![客户端-服务器架构](/img/questions/collaborative-editor-google-docs/client-server-architecture.png)

**优点**：

* **集中式真实来源**：所有更新都必须首先通过服务器。 服务器确定最新的文档修订版并保存真实来源。
* **稳健性**：当新参与者加入或现有客户端之一崩溃（由于错误、网络不稳定等）时，可以从服务器获取最新的文档。

**缺点**：

* **单点故障**：中央服务器是一个关键组件；如果它发生故障，整个网络可能会中断。
* **成本**：由于需要强大的中央服务器，基础设施和维护成本更高。
* **可扩展性**：如果客户端数量没有得到适当的扩展，可能会成为瓶颈。

#### 对等 (P2P) 模型

在 P2P 网络模型中，每个参与者同时充当客户端和服务器。 对等方直接相互通信，而无需中央服务器。

![对等架构](/img/questions/collaborative-editor-google-docs/peer-to-peer-architecture.png)

**优点**：

* **较低的延迟**：每个参与者直接相互通信，而无需中间人，通常会导致较低的延迟。
* **具有成本效益**：没有中央服务器，基础设施成本较低。
* **负载分配**：当更多参与者加入时，额外的网络负载会在所有参与者之间分配，从而防止瓶颈。

**缺点**：

* **同步问题**：如果没有中央机构，参与者很难确定他们的文档版本是否为最新版本以及缺少哪些更新。 每个参与者都需要跟踪对等方的文档状态并确保它们是最新的。
* **复杂的共识**：当新参与者加入或现有客户端之一崩溃（由于错误、网络不稳定等）时，新成员必须弄清楚如何在所有对等方之间获取最新的文档修订版。
* **仍然需要服务器**：由于文档需要持久保存到数据库中，因此无论如何都需要服务器。
* **安全性**：如果参与者变得流氓，所有连接的参与者都将受到影响。

#### 使用哪种模型？

尽管客户端-服务器模型似乎优势较少，但服务器上的事实来源是一个重要的功能属性，它决定了整个系统的成败：

* **数据库持久性**：文档状态必须保存在数据库中。如果没有一个中央服务器来频繁地保存文档，如果客户端在将文档保存到数据库之前断开连接，更新可能会丢失。
* **事实来源**：由于新参与者可以随时加入，将事实来源放在服务器上简化了可靠地获取最新文档的逻辑——新参与者可以从一个一致的位置（服务器）获取最新文档。
* **优化可靠性和性能**：可靠性和性能是实现无缝协作体验和确保所有参与者都得到更新的最重要因素。在实践中，大多数会话在任何给定时间都不会看到大量参与者（> 20 个）；最多只有几个参与者。我们应该优化可靠性和性能，而不是服务器成本。

考虑到这些原因，首选客户端-服务器模型。P2P 模型更适合视频聊天等应用程序，在这种应用程序中，可以容忍请求丢失，并且并非所有数据都需要持久保存。

### 并发控制模型

在讨论协作编辑器时，需要进行两种操作：

* **本地更新**：用户对其正在查看的文档进行的更新。
* **合并来自同伴的更新**：同伴对文档进行的更新。

所有这些更新都必须合并到当前文档中。如果两个用户正在编辑文档的同一部分（例如，当另一个人正在向句子中添加一个单词时，有人删除了一个句子），则可能会出现冲突。

并发控制是协调并行运行的干扰操作以保持参与者之间的一致性并解决参与者之间出现的冲突的活动。

它们可以大致分为乐观型和悲观型：

* **悲观**：悲观方法保证不会发生冲突。它们的主要目标是避免不一致。它们需要在进行任何数据更改之前与其他站点或中央协调器进行通信。这种通信可以是显式的（例如，楼层控制策略），也可以是隐式的，用户的程序在后台处理它（例如，锁定）。一般来说，悲观方法不需要冲突解决，但网络延迟较高，响应时间较长。
* **乐观**：乐观方法不费心避免冲突更新。它们在进行本地更改之前不需要事先通信，并且非常适合高延迟通信通道，因为用户操作的结果可以显示出来，而无需等待通信往返。用户立即应用更改并更新服务器，然后服务器通知同伴。如果多个参与者同时进行更改，则冲突解决算法会创建补偿更改，以确保每个人都达到相同的最终状态。乐观方法具有零/接近零的本地响应时间，但可能需要冲突解决。

文本编辑不同于传统的表单提交，用户可以容忍更新需要几秒钟才能完成。用户进行的文本更新应立即反映出来，没有任何延迟。为了支持零延迟的本地更新，客户端应在本地维护文档状态的副本，并且用户更新是针对该副本进行的，以便它们可以立即反映在他们的 UI 上。

让我们看看各种并发控制机制、它们的属性以及它们的优缺点。

#### 最后写入者胜出模型

对于传统的 Web 应用程序，如管理仪表板。如果两个用户同时修改同一个实体（例如，更改一个人的姓名），则会发生竞争条件。保存在数据库中的最终名称将是最后到达的请求提交的名称。

在分布式计算中，这种行为被称为“最后写入者胜出”。显然，“最后写入者胜出”不适用于协作编辑器，至少在文档级别上不适用。它根本不被认为是协作的！

#### 楼层控制模型

“楼层控制”是一种协议，它确定哪个用户拥有控制权（拥有楼层）以及在多个人访问资源（在本例中为文档）时如何轮流。

* **基于令牌**：令牌在参与者之间循环，只有持有令牌的参与者才能进行更改。参与者可以请求令牌，预定义的策略（例如，先到先得或自由竞争）决定是否授予该请求。
* **主席控制**：指定的**主席**或**主持人**授予和撤销参与者对资源的访问权限。

没有控制权的参与者仍然可以看到以实时方式进行的更新。

楼层控制有助于防止冲突并确保有序交互。显然，这种方法不能满足要求，因为一次只能有一个参与者进行编辑；同伴必须等待轮到他们编辑。解决这个问题的一种方法是允许参与者随时接管令牌的控制权，但这对于仍在打字的参与者来说，突然被剥夺控制权并不是一个很好的用户体验。

#### 锁模型

锁定是防止对数据进行未经授权的访问（读取和/或写入）的概念。在协作编辑的上下文中，当编辑者开始编辑文档时，可以锁定文档（或其部分），以防止来自同伴的未经授权的修改。

关于锁定，有几个问题需要讨论：

* **锁定粒度**：锁定可以在文档级别、段落级别、句子级别、单词级别等进行。文档级锁定本质上是“楼层控制”机制。细粒度更好，但是当包含句子的段落被删除时，句子级锁定应该发生什么？
* **锁定请求**：锁定可以用乐观和悲观两种方式请求。
  * **悲观锁定**：客户端发出网络请求以获取锁。客户端只有在获得锁后才会开始允许修改。获取锁涉及网络延迟，因此用户在能够执行任何操作之前会遇到延迟，这可能会很烦人。
  * **乐观锁定**：客户端同时允许修改和请求锁。如果锁的请求被拒绝（可能是因为另一个人也同时请求了锁），客户端将回滚在请求锁之前的更新。
* **锁释放**：获取锁后，应该何时释放它？应该在移动光标或按下按键时请求锁吗？例如，如果移动光标时释放锁，则用户可以移动到一个地方复制一些文本，但无法将其粘贴到以前的位置。另一方面，如果锁保留得过于慷慨，即使在用户不再需要锁时，也可能仍然授予用户锁，例如，当用户离开文档但离开键盘时，锁是多余的。确定空闲阈值很棘手。与楼层控制类似，允许用户随时接管锁的控制权是缓解锁释放问题的一种方法。

锁定是对楼层控制（从技术上讲，它也是一种锁定）的改进，并且在适当的粒度下，通过乐观锁定和适当的锁释放策略是可行的，因为它易于实现。事实上，像 [Quip](https://quip.com/) 这样的协作编辑应用程序在其产品的早期版本中使用了基于锁的并发模型。如果编辑同一部分的可能性很低，锁定实际上是实时协作的可行方法。

#### 基于事务的模型

基于事务的方法是一种乐观方法，用户在本地进行更改，并在事务结束时验证更改，类似于 Git 和 Mercurial 等分布式版本控制系统。版本控制系统通过维护不同的版本并允许用户合并更改来管理对文档或资源的更改。

每个用户在其计算机中都有一个文档副本，并且可以在本地进行更改，而没有任何锁定或其他限制。更改不会立即推送。当用户完成更新后，更改将被提交并推送到服务器。如果存在任何冲突，则事务将回滚，用户必须解决这些冲突才能更新服务器。

这种方法具有零延迟本地更新的优点，并且所有参与者都可以同时更新他们的文档，而没有任何锁定限制。但是，在这种方法中，更新不是实时的——用户需要显式地推送他们的更新并显式地从其他人那里提取更新。此外，它要求用户自己解决冲突，这很烦人，并且期望普通用户这样做是不合理的。

#### 版本检测模型

在版本检测模型中，文档状态在每个用户的机器中复制，参与者可以在本地进行更改，然后尽快将这些更改传播给同伴。在良好的网络连接下，用户应该会在一秒钟内看到来自同伴的更新。

每个更新请求都包含新数据和更改所依据的文档修订版。当服务器收到更新请求时，它首先检查请求中的修订版是否与当前修订版相同。如果修订版匹配，服务器将更新文档，将其保存为新修订版，并将此信息广播给所有同伴，以便每个人都使用最新修订版。如果它们不同，则存在“版本不匹配”，可以通过以下方式之一解决：

* **拒绝请求**：这避免了必须进行任何冲突解决，但并不理想，因为当有多个参与者同时更新文档的同一部分时，这种情况发生的频率可能非常高。
* **补偿更改**：自动补偿更改以纠正版本不匹配并将系统带入一致状态。在大多数情况下，如果对文档的不同部分进行了更改，补偿是直接的（可能根本不需要补偿！）。如果更改确实发生冲突，我们可以使用冲突解决方法，如操作转换 (OT)。另一方面，如果使用无冲突复制数据类型 (CRDT)，则无需补偿。

具有补偿功能的版本检测模型具有零延迟本地更新的优势，所有参与者都能够同时实时更新他们的文档，没有任何锁定限制，并且如果存在强大的冲突检测和解决方法，最终将收敛到同一版本的文档。

版本检测胜过基于事务的模型，并满足所有实时协作要求。唯一的问题是——冲突到底是如何解决的？我们将在下面更详细地探讨它们。

#### 使用哪种并发模型？

只有**版本检测一致性模型**能够满足所有实时协作编辑要求，因为它具有以下属性：

* **已复制**：文档在所有参与者的机器中复制。这对于模型进行乐观更新是必要的。
* **乐观且非阻塞**：更新在本地进行，无需担心冲突。乐观行为对于本地更新期间的零延迟响应是必要的——您的网络连接的速度或可靠性不会影响用户键入的速度。
* **无锁定**：整个文档始终可供每个参与者使用。
* **自动冲突解决**：任何检测到的冲突都会在服务器上自动解决。可能的方法包括创建补偿更改并通知客户端 (OT)，或使用自动解决冲突的数据结构 (CRDT)。

从每个参与者的角度来看，它会感觉好像他们正在编辑一个离线 Word 文档——编辑时没有任何延迟。

### 冲突解决方法

当两个或多个参与者编辑文档的同一部分时，可能会出现冲突。让我们通过一个例子来运行一下。

假设我们有一个包含单个单词“ABCDE”的文档，Alice 和 Bob 同时编辑它：

1. Alice 删除第四个字符“D”。她的计算机发送请求`DEL @3`，以指示删除第四个字符，该字符位于索引 3（从零开始索引）。
2. Bob 删除第二个字符“B”。他的计算机发送请求`DEL @1`，以指示删除第二个字符，该字符位于索引 1（从零开始索引）。

服务器将处理这两个请求。目前，服务器只是执行命令并转发它们，没有任何特殊处理）。在两次删除后，预期的最终结果是“ACE”。

由于网络延迟是不可预测的，可能发生以下两种情况：

![Alice and Bob network diagram without operational transformations](/img/questions/collaborative-editor-google-docs/alice-bob-without-ot.png)

1. **Alice first**：服务器先收到 Alice 的请求，然后是 Bob 的请求，导致服务器删除第四个字符，然后删除第二个字符“ABCDE” -> “ABCE” -> “ACE”。在这种情况下，服务器上的文档正确地删除了 Alice 和 Bob 想要删除的字符。服务器最终得到“ACE”。
2. **Bob first**：服务器先收到 Bob 的请求，然后是 Alice 的请求，导致服务器删除第二个字符，然后删除第四个字符：“ABCDE” -> “ACDE” -> “ACD”。请注意，当服务器处理 Alice 的请求时，文档的第四个字符现在是“E”，但 Alice 想删除“D”。服务器最终得到“ACD”。

在这种幼稚的方法中，根据服务器首先收到谁的请求，服务器最终会得到不同的文档状态。

事实上，无论谁的请求先到达服务器，Bob 最终都会得到“ACD”。请记住，更新首先在本地进行，然后发送到服务器以广播给其他人。问题在于偏移量取决于编辑时文档的状态。请求有效负载包括偏移量，但不包括它们所依赖的上下文，这会导致差异。

这只是可能导致冲突的场景之一。还有其他可能的组合，如插入 + 插入、删除 + 插入、删除 + 删除等。

#### 冲突解决属性

因此，我们需要一种尽可能遵守这些属性的冲突解决方法：

* **收敛性**：所有副本最终将达到相同的状态，前提是它们已收到并应用了相同的操作集（静止状态）。
* **因果关系保留**：确保操作的顺序尊重它们之间的因果关系。例如，如果一个操作在逻辑上跟随另一个操作，则系统必须按该顺序应用这些操作以保持一致性（例如，在插入字符后删除字符）。
* **意图保留**：确保在合并并发操作后保留操作的原始意图。这意味着合并并发操作的结果应与用户期望其操作实现的目标保持一致，即使存在冲突。例如，Alice 将整个句子设为粗体，而 Bob 同时向句子中添加一个单词，最终结果应该是包含 Bob 单词的句子为粗体。

使用了两种常见的冲突解决方法：

* **操作转换 (OT)**：OT 考虑编辑时的上下文并相应地转换操作（例如，通过修改插入/删除的偏移量）。
* **无冲突复制数据类型 (CRDT)**：CRDT 强制使用数据结构，其中更新是可交换和可结合的，因此操作的顺序无关紧要。

**注意**：详细解释每种冲突解决方法超出了本文的范围（无论如何，在面试期间没有足够的时间）。但是，您应该能够使用一个示例来解释一般原则。我们将解释每种方法的工作原理，并提供示例和指向资源的链接，供您进一步阅读。

#### 操作转换 (OT)

OT 最初是为协作编辑文本文档而开发的，允许多个用户同时编辑而不会发生冲突。它通过根据其他并发操作的上下文转换操作来保持不同客户端之间文档状态的一致性。

OT 系统通常使用复制的文档存储模型，其中每个客户端都维护文档的本地副本。用户在其本地副本上操作，更改会传播到其他客户端。当客户端收到来自另一个客户端的更改时，它会应用转换函数以确保本地文档与更新保持一致。

OT 的关键组成部分包括：

1. **操作**：这些是用户执行的基本操作，例如插入、删除或修改文本。每个操作都与文档中的一个位置相关联。
2. **转换函数**：这些函数确定如何在发生冲突时调整操作。例如，如果两个用户在同一位置插入文本，则转换函数将解决冲突以保持一致的文档状态。
3. **控制算法**：这些算法管理转换的顺序和上下文。它们根据操作的因果关系决定哪些操作应该与其他操作进行转换，确保操作的顺序尊重每个用户的意图。

让我们回顾一下 Alice 和 Bob 的例子，看看应用 OT 如何解决这个问题。

![Alice 和 Bob 网络图，使用操作转换](/img/questions/collaborative-editor-google-docs/alice-bob-with-ot.png)

1. **Alice 在 Bob 之前**: 服务器在 Bob 之前收到 Alice 的请求，导致服务器删除第四个字符，然后删除第二个字符 "ABCDE" -> "ABCE" -> "ACE"。在这种情况下，服务器上的文档正确地删除了 Alice 和 Bob 想要删除的字符。但是，Bob 的计算机意识到 Alice 的更改是在 Bob 的删除之前进行的，因此它将 Alice 的更改从 `DEL @3` -> `DEL @2` 转换，因为 Bob 删除了一个较早的字符。Bob 最终得到 "ACE"。
2. **Bob 在 Alice 之前**: 服务器在 Alice 之前收到 Bob 的请求，导致服务器删除第二个字符："ABCDE" -> "ACDE"。当服务器收到 Alice 的请求时，它意识到 Alice 的更改是在 Bob 的删除之前进行的，因此它将 Alice 的更改从 `DEL @3` -> `DEL @2` 转换，以考虑 Bob 删除较早字符的情况。服务器正确地删除了 "D"（第三个字符），并将此转换后的操作传递给 Bob。服务器和 Bob 最终都得到 "ACE"。

服务器和客户端都可以执行 OT，并且必须处理插入、删除和格式更改可以相互配对和转换的各种方式。上面的例子展示了如何将删除转换为删除。转换的其他一些例子：

* 格式化在针对插入进行转换时会扩展：`FORMAT BOLD @10-20` 转换为 `INS "ABC" @15` 结果为 `FORMAT BOLD @10-23`。
* 并非所有更改都会冲突，在这些情况下，不需要转换。例如 `FORMAT BOLD @10-20` 和 `FORMAT ITALIC @15-25` 不会冲突，因为文本可以同时是粗体和斜体。

服务器如何知道 Alice 和 Bob 的请求是否在考虑了另一方的更改的情况下发出的，以及是否需要进行任何转换？每次在服务器上进行更新并修改文档时，文档都会保存为一个新的修订版本（例如，使用时间戳或 [单调](https://en.wikipedia.org/wiki/Monotonic_function) 递增的整数）。时间戳不是一个好的选择，因为机器时间可以被操纵，这会导致按时间排序时出现错误的顺序，更喜欢单调递增的正整数。

请求和响应可以包括文档修订号，以便服务器和客户端都知道另一方在发出请求时看到的文档版本，并且可以正确确定操作是否需要转换。

**OT 分析**：让我们看看 OT 如何满足冲突解决属性：

* **收敛**：OT 使用转换函数来修改操作，以便它们可以在所有副本中一致地应用，即使它们以不同的顺序到达。核心思想是，如果两个操作冲突，转换函数会调整一个或两个操作，以确保它们可以按任何顺序应用，但仍然导致相同的最终状态。
* **因果关系保留**：OT 系统通常使用因果历史跟踪来确保操作以尊重其因果依赖关系的顺序应用。这通常通过使用元数据（例如时间戳或修订号）标记操作来完成，这些元数据指示它们的因果关系。
* **意图保留**：OT 负载通常包括命令意图和上下文（文档修订号）。转换函数考虑了最初应用操作的上下文。命令以及上下文感知有助于在文档由于其他并发操作而发生更改时保留原始意图。

OT 适用于基于文本的文档，但对于其他类型的数据结构（例如分层或非线性数据）可能效果较差。为这些类型的数据实现 OT 需要额外的努力和定制。

OT 算法和各种一致性模型有很多实现，这超出了本文的范围。如果您有兴趣，请查看以下链接：

* [新的 Google 文档有什么不同：冲突解决](https://drive.googleblog.com/2010/09/whats-different-about-new-google-docs_22.html)
* [操作转换作为自动冲突解决的算法](https://medium.com/coinmonks/operational-transformations-as-an-algorithm-for-automatic-conflict-resolution-3bf8920ea447)
* [使用中央服务器的 OT 可视化](https://operational-transformation.github.io/)

#### 无冲突复制数据类型 (CRDTs)

如果您想知道——为什么在更新时使用偏移索引，因为它们与当前文档状态高度耦合，并且需要经历使用像 OT 这样的复杂算法来解决冲突的麻烦？为什么不使用不同的有效负载或数据结构来提供有关更新的更多信息，并使合并更新更容易？这正是无冲突复制数据类型 (CRDTs) 的目标。

CRDT 是为分布式系统设计的先进数据结构，允许多个用户或应用程序并发更新共享数据，而无需协调，当所有更新都已收到并应用时，最终会收敛到相同的状态（强最终一致性）。CRDT 不是使用 OT 解决冲突，而是构建 CRDT，以便对数据执行的操作本质上是无冲突的，或者可以以一致的方式自动解决。

CRDT 具有以下属性：

1. **并发更新**：CRDT 允许跨多个数据副本进行独立更新。每个副本都可以被修改，而无需与其他副本协调，这使得它们非常适合网络连接可能间歇的环境。可以使用 gossip 协议传播更新，而无需中央机构。
2. **单调递增更新**：对 CRDT 的更新必须是单调的，确保新值始终大于或不同于先前的值。这允许状态变化的清晰进展。
3. **可交换和关联操作**：CRDT 中的操作必须是可交换的（顺序无关紧要 -> `A + B + C === C + B + A`），关联的（分组无关紧要 -> `(A + B) + C === A + (B + C)`）。这确保了所有副本，即使它们以不同的顺序接收操作或在不同的时间合并状态，最终也会处于相同的状态。
4. **自动冲突解决**：CRDT 包含预定义的算法（例如，最后写入者获胜），这些算法会自动解决可能因并发更新而引起的不一致性。这意味着即使不同的副本进行了冲突的更改，CRDT 也可以在没有手动用户干预的情况下合并这些更改。
5. **最终一致性**：尽管副本在任何时间点都可能具有不同的状态，但 CRDT 保证所有副本最终将收敛到相同的最终状态，一旦所有更新都已传播，无论接收这些更新的顺序如何。这通常被称为“强最终一致性”，它确保不保留不一致的状态。

CRDT 模型有点类似于 Git——组织中的每个开发人员都拥有存储库的副本，并被允许在本地进行更改。最后，开发人员可以根据自己的喜好与其他每个开发人员合并更改：成对、循环或通过中央存储库。一旦所有合并完成，每个开发人员都将拥有相同的状态。但是，与 Git 不同的是，CRDT 规定了一种自动合并冲突的方式，并且可以合并无序更改。

**CRDT 示例 – 仅增长集**：CRDT 的一个示例是仅增长集。仅增长集是一个无序集，仅允许添加唯一元素。它是一个 CRDT，因为：

* 该集合可以被复制。
* 每个副本都可以添加它喜欢的任何元素，并且添加是单调递增的更新。
* 每个副本都可以按任何顺序合并在一起。
* 一旦所有合并完成，所有副本将具有相同的内容（所有单个集合的并集）。

**在 CRDT 中表示文本**：可以使用序列 CRDT（如列表（例如 [线性序列和可复制增长数组](https://www.bartoszsypytkowski.com/operation-based-crdts-arrays-1/)））和树来表示协作文本文件。 毫不奇怪，文本 CRDT 的实现比仅增长集合更复杂。 [Cola](https://nomad.foo/blog/cola) 是用 Rust 编写的文本 CRDT，但该数据结构可以用任何语言实现。

{/* TODO: 给出列表 CRDT 的结构作为示例 */}

文本编辑也涉及删除。 我们如何在 CRDT 中表示删除？ 诀窍是通过使用两个单独的仅增长数据结构来跟踪删除，一个用于跟踪插入，另一个用于跟踪删除（称为墓碑标记）。 结果值是插入集中的项目减去删除集中的项目。 复杂的 CRDT 通常由较小的 CRDT 组合而成，这极大地有助于保留 CRDT 属性。

**CRDT 分析**：让我们看看 CRDT 如何满足冲突解决属性： 

* **收敛**：CRDT 操作被设计为可交换和关联的，这意味着应用操作的顺序和分组不会影响最终状态。 这是所有副本收敛到相同状态的关键原因。
* **因果关系保留**：操作以尊重因果关系的方式应用于其他副本。 例如，操作可以按任何顺序传播，但操作可能会被缓冲，直到所有先前的因果相关操作都已应用。 例如，删除只有在插入发生后才会生效。 在 Last-Writer-Wins Register (LWW-Register) 中，更新会标记时间戳，确保最近的更新（根据因果关系）优先。 
* **意图保留**：CRDT 包含预定义的冲突解决策略，旨在保留用户意图。 这些策略通常是特定于应用程序的，并确保合并状态反映所有并发操作的组合意图。 CRDT 操作的特定语义旨在确保当两个操作冲突时，解决方案保留每个操作的最有意义的方面。 但是，存在一定程度的主观性，并且高度依赖于实现和用例。

**CRDT 的缺点**：虽然与 OT 相比，CRDT 更现代化，但它确实存在一些缺点：

* **元数据开销**：CRDT 经常需要额外的元数据来跟踪操作、修订或唯一标识符。 这种元数据会随着时间的推移而增长，从而导致存储需求增加，尤其是在大型系统或复杂数据类型中。
* **不断增加的大小**：CRDT 具有单调递增的状态，通常必须跟踪未出现在最终视觉结果中的删除。 这意味着数据只会随着时间的推移而增长。 可以使用垃圾收集或清理机制，但如果没有导致副本不一致，则它们在技术上可能难以实现。
* **冲突解决**：虽然 CRDT 旨在通过以预定义的方式合并并发更新来解决冲突，但这种自动冲突解决可能并不总是与所需的应用程序语义保持一致，从而导致意外结果。

CRDT 完全绕过了对因果关系保留的需求，因为更新可以按任何顺序合并，并且仍然会收敛到相同的结束状态。 CRDT 是否可以保留意图取决于所选的冲突解决策略和实现。

#### 使用哪种冲突解决方法？

OT 和 CRDT 都旨在以在所有副本中保持一致性的方式管理对共享数据的并发更新，但它们使用不同的方法，并具有不同的权衡。

**收敛**：OT 可以保证收敛，但需要更仔细地处理操作顺序和上下文。 它通常需要一个中央服务器或更紧密协调的通信协议来确保一致性。 CRDT 旨在保证副本之间的最终一致性，并且只要它们收到所有更新，就会收敛到相同的状态。 CRDT 在这里更胜一筹，因为它具有更强的收敛保证。

**技术复杂性**：为复杂或分层数据结构实现 CRDT 具有挑战性，需要仔细设计以确保操作保持所需的属性。 实现 OT 也很复杂，尤其是在设计必须处理所有可能的冲突和并发操作的转换函数时。 尽管 CRDT 的一致性模型更容易理解，但为文本结构理解和实现 CRDT 却更难。 在文本编辑的背景下，OT 占据主导地位。

**生态系统**：OT 是一项成熟的技术，已在几个著名的协作编辑系统中实现，并且有许多成熟的库和工具可用——Google Docs 本身使用 OT。 CRDT 是后起之秀，但多年来一直受到很好的研究，并且已经创建了许多实现 CRDT 的库。 协作设计编辑软件 Figma 使用 CRDT。 就生态系统而言，没有明确的赢家，因为这两种方法都得到了很好的研究（并且受到了批评）。

总的来说，没有明显更好的选择。 CRDT 和 OT 都可以用于实现协作编辑器。 CRDT 是通用的，而 OT 源于文档编辑。 虽然 CRDT 较新且更流行，但 OT 已经成熟，并且在低延迟、即时反馈和对用户意图的精细控制至关重要的实时协作编辑应用程序中表现出色。

本文的其余部分假定使用 OT 作为冲突解决方法。 主要原因是 Google Docs 本身是使用 OT 实现的，因此在实现使用 OT 而不是 CRDT 的协作文本编辑器方面也有更多资源。 解释 OT 的工作原理也比文本 CRDT 容易，文本 CRDT 具有非常复杂的结构。

### 协作协议

我们已经讨论了冲突解决方法，但这只是故事的一部分。 还有其他与使用 OT 进行协作编辑相关但未解答的问题： 

* **请求调度**：何时发送更新请求？ 每次按键、用户停止输入后或其他？ 如果用户进行多次连续更新，是否应该在进行时将它们全部发送到服务器，或者是否有更好的方法来调度它们？
* **多个参与者**：上面的 OT 示例演示了转换如何适用于两个参与者。 当会话中有两个以上的参与者并且必须针对多个对等方转换操作时会发生什么情况？
* **参与者加入**：加入编辑会话的中间用户如何开始更新他们的副本并从其他人那里接收更新？

可以设计协作协议来回答这些问题。 在继续阅读之前，尝试一下这个 [具有中央服务器的 OT 交互式可视化](https://operational-transformation.github.io/) 可能会有所帮助。

#### 中央服务器

虽然 OT 在其核心不需要中央服务器，但拥有中央服务器可以简化某些事情。

一个中心服务器架构使客户端可以轻松地与服务器保持同步。服务器的作用是接收更新并充当文档状态的权威，当客户端发送与最新文档冲突的请求时转换操作。如果有效负载无效，或者操作是在过时的文档修订版上进行的，或者操作太难转换，或者要转换的操作太多，服务器也可以拒绝操作。

当服务器收到更新请求时，它将向连接的客户端广播更新。客户端不需要关心有多少其他连接的客户端。它依靠服务器来通知自己要进行的更改。从客户端的角度来看，拥有 N 个对等客户端（其中 N 是对等客户端的数量）每秒轮流进行更新，这等同于单个对等客户端每秒进行更新。对于客户端来说，拥有一个对等客户端与拥有十个对等客户端相同。这使我们能够通过在每个客户端-服务器对之间运行 N 个独立的双向同步来实现 N 路同步。客户端只需专注于与服务器的同步，服务器可以平等地对待所有客户端；没有需要考虑的特殊客户端。

中途加入的参与者将在请求时获得该文档的版本。从那时起，他们就是一个连接的客户端，并且可以像任何其他参与者一样发送和接收更新，只要更新是在下载初始文档后按顺序接收的。

#### 将文档存储为修订日志

该文档可以存储为仅追加操作/更改的日志，类似于 [Event Sourcing pattern](https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing)。可以通过从开始到该点的操作重放来重建文档的任何修订版。因此，可以通过重放自开始以来的所有操作来获得文档的最新修订版。这种存储数据的方法也允许客户端查看文档的版本历史记录。

| 修订版号 | 用户 | 操作 | 时间戳 | 文档状态（未存储） |
| --- | --- | --- | --- | --- |
| 0 | N/A | N/A | 2024-08-03 10:00 | \<EMPTY> |
| 1 | Charlie | `INS "Hello" @0` | 2024-08-03 10:05 | "Hello" |
| 2 | Alice | `INS " world" @5` | 2024-08-03 10:10 | "Hello world" |
| 3 | Bob | `INS "!" @11` | 2024-08-03 10:15 | "Hello world!" |

请注意，文档状态未存储在每个日志条目中，因为它可以从前面的操作中导出。

存储为日志是必要的，因为某些客户端可能非常过时，需要赶上当前文档。想象一下用户断开了协作会话并保持选项卡打开的情况。当他们第二天重新连接并且其他人自那时以来进行了更新时，在重新连接时，客户端会发送其当前过时的文档修订号，这允许服务器确定自该文档修订版以来的细粒度更改，并使用要对客户端执行的操作列表进行响应，这也可能需要转换。

加入非空文档的编辑会话的客户端不需要从头开始获取整个日志；服务器会响应文档的当前状态。后续文档修订版可以通过将新操作（本地和来自对等方）应用于初始会话文档状态来计算。

上面没有演示，但每个日志条目也可以包含多个操作。

#### 何时发送更新请求

何时应该发送更新请求？应该在每次按键时、用户停止输入后或其他时间发送更新请求吗？

* **按键**: 每次按键发送一个请求。不太好，因为它可能会给服务器带来负担，并创建许多潜在的冗余操作日志。
* **去抖动**: 在用户停止输入一小段时间（例如 300 毫秒）后发送一个请求。对于不停止打字的用户来说，这可能并不理想，因为如果他们的浏览器在更新发送出去之前崩溃，他们可能会丢失数据。
* **节流**: 在连续打字期间每隔固定时间间隔（例如 300 毫秒）发送一个请求。似乎可行，但确定节流持续时间值很棘手。

上述策略均不可行，因为它们都允许用户并行发送请求，这意味着多个请求同时处于传输中。这是一个问题，因为不能保证服务器会按发送顺序接收请求，这可能导致竞争条件和不可能的操作。

有一些方法可以解决乱序请求，但它们并不简单。客户端可以为会话中的每个请求包含一个单调递增的整数，但服务器必须跟踪到目前为止发送的最后一个请求，如果它收到乱序请求，则推迟未来的请求，然后等待丢失的请求（缓冲未来的操作）。

Google Docs 采用的一种优雅方式是确保每个用户最多只有一个正在传输的更新请求（也称为待处理），方法是使用本地更新缓冲区（队列）。在以下情况下，将清除本地更新缓冲区并将缓冲区中的操作发送到服务器：

* 如果没有待处理的请求，则在短时间空闲后（约 200 毫秒）
* 如果有待处理的请求，则在待处理的请求返回时

当用户开始输入时：

1. 用户操作在客户端计算机上本地反映并添加到本地更新缓冲区中
2. 短时间后，发出一个请求，其中包含本地更新缓冲区中的操作
3. 发送请求后，清除本地更新缓冲区，并且在有待处理请求时进行的任何新的本地更新都将添加到本地更新缓冲区中
4. 如果本地更新缓冲区不为空，则仅在收到服务器对当前请求的响应后，才发送下一个请求，即使空闲时间已过
5. 这将重复，直到本地更新缓冲区为空（当用户停止输入时）并且没有更多操作要发送到服务器

**快速与慢速连接**：由于只能有一个待处理的更新请求，因此请求的频率高度依赖于客户端的连接速度。

![编辑请求的快速与慢速连接](/img/questions/collaborative-editor-google-docs/fast-slow-connection-requests.png)

* **快速连接**：网络连接速度更快的客户端将更快地发送请求和接收响应，从而导致更频繁的请求，并且每个请求包含的负载更小。本地更新缓冲区将更频繁地被清除。
* **慢速连接**：网络连接速度较慢的客户端将看到较少的请求，并且每个请求将包含更大的负载。本地更新缓冲区将不那么频繁地被清除。

通过使用本地更新缓冲区来保存本地操作，并且每个客户端只有一个待处理的请求，客户端可以确保操作按顺序发送，并且服务器可以在收到客户端请求后立即处理它，因为服务器知道来自客户端的每个请求都是最新的。

#### 操作粒度

合适的操作粒度是既不会导致太多操作，又允许区分意图的粒度。考虑以下场景：

* 如果用户正在连续打字，那么进行一个包含多个字符的插入操作，而不是每个字符进行一个插入操作，会更有效率。
* 如果用户按住退格键并删除多个字符，那么进行一个包含已删除字符的删除操作，而不是每个字符进行一个删除操作，会更有效率。
* 如果用户输入一些字符，意识到有拼写错误，删除错误的字符，然后再次输入，这些操作构成“连续打字”，可以合并成一个插入操作。在这种情况下，当操作发送到服务器时，服务器根本看不到任何删除。

选择了以下准则：

* **连续范围的合并**：连续范围上的操作可以合并/合并成一个相同类型的操作。
* **每个意图一个操作**：每个意图（插入、删除、格式化）将是一种不同的操作，除非它们是连续打字的一部分。
* **连续打字操作的合并**：连续打字事件包括正向打字、向后删除和向前删除。

#### 更新请求负载

虽然没有明确提及，但每个更新负载可以包含多个操作。在请求往返时间较慢的网络连接上，用户有更大的窗口进行本地更新，有时这可能包括不同类型的操作，而不仅仅是插入。

在早期的网络图中，更新请求只显示单个操作，但 Google Docs 上的请求实际上包含一个操作数组，即更新缓冲区中的所有操作。服务器按顺序迭代操作数组，并在必要时转换它们。

通过允许更新请求包含一个操作数组，缓冲区被更频繁地清除，并且丢失未发送更改（可能由于崩溃或关闭选项卡）的可能性更低。

#### 将它们放在一起

我们已经在上面解释了客户端-服务器架构如何能够很好地扩展以支持大量参与者。因此，我们可以专注于客户端和服务器之间的通信以及每个跟踪的信息。

每个客户端跟踪以下信息：

1. **最新文档修订版**：从服务器发送到客户端的最新修订版的标识符。Google Docs 使用单调递增的整数作为文档修订版 ID/编号。此值包含在每个更新请求的请求负载和响应中。
2. **本地更新缓冲区**：已在本地进行但尚未发送到服务器的更改（操作）。这是前面解释的更新缓冲区。
3. **已发送更新缓冲区**：已在本地进行、已发送到服务器但尚未被服务器确认的更改（操作）。跟踪已发送的操作是必要的，因为请求可能会失败，并且如果请求失败，客户端应该重试该请求。
4. **更新日志**：自初始化文档修订版以来文档的已提交更改（操作）。这些更改可能是用户已确认的更新，也可能是服务器推送到客户端的对等更新。这些操作可能已经在服务器上进行了转换，或者根据更新的顺序在客户端上进行了转换。
5. **初始文档状态**：客户端首次加入编辑会话时文档的状态。
6. **文档状态**：客户端上显示的文档的当前状态。这可以从初始文档状态、接收到的更新、更新缓冲区和待处理更新中计算得出。

请注意，本地更新缓冲区和待处理更新缓冲区中的操作可能会根据从服务器接收到的更新内容进行转换。客户端的责任是：

* 跟踪本地更新的状态 – 将它们发送到服务器并在适当的时候将它们移动到已发送更新缓冲区。
* 在已发送更新被确认后，将已发送更新移动到更新日志。
* 从服务器接收更新并转换任何相关的本地更新。
* 将初始文档状态与更新日志相结合，以计算最新的文档状态并显示它。

服务器包含以下信息：

1. **待处理更新队列**：从客户端接收到的尚未处理的所有更改（操作）的列表。
2. **修订日志**：提供文档完整历史记录的处理更改列表。
3. **文档状态**：截至上次处理更改时文档的当前状态。可以通过重放自开始以来的所有更改来派生此值，但会对其进行计算和缓存，以便可以立即将其发送给加入会话的新客户端。每当处理新更改时，它都会被重新计算。

服务器的职责是：

* 当客户端加入编辑会话时，向客户端发送文档的最新状态。
* 转换客户端的更新，如果它们最初是在过时的修订版本上进行的。
* 向其他客户端广播更新。

*来源：[What’s different about the new Google Docs: Making collaboration fast](https://drive.googleblog.com/2010/09/whats-different-about-new-google-docs.html)*

让我们通过一个实际的例子来演示服务器如何与客户端一起使用操作转换来实现实时协作编辑。

![Collaboration part 1](/img/questions/collaborative-editor-google-docs/collaboration-part-1.png)

1. Alice、Bob 和服务器从一个空文档开始
2. Alice 键入“Hello”，插入操作被添加到她的“本地更新”中。Alice 在她的文档副本中立即看到“Hello”
3. Alice 插入“Hello”被发送到服务器，并从“本地更新”移动到“已发送更新”
4. 服务器接收到请求，并将 Alice 的插入操作添加到其“待处理更新”队列中
5. 同时，Alice 键入字符“ world”。此插入被添加到“本地更新”中，但在“已发送更新”为空之前不会发送到服务器
6. 服务器处理 Alice 的第一次插入并更新其文档状态。然后它向 Alice 发送一个确认
7. Alice 从“已发送更新”中删除该操作，并将其最新修订号更新为 1
8. 服务器将 Alice 的插入广播给 Bob，Bob 将该操作应用于他的文档副本，并将其最新修订号更新为 1

![Collaboration part 2](/img/questions/collaborative-editor-google-docs/collaboration-part-2.png)

9. Alice 的第二次插入“ world”现在可以处理。该操作被发送到服务器，并从“本地更新”移动到“已发送更新”
10. 服务器接收到 Alice 的第二个请求，并将她的操作添加到其“待处理更新”队列中
11. 同时，Bob 在“Hello”的末尾插入一个“!”字符
12. Bob 插入“!”被发送到服务器并添加到服务器的“待处理更新”队列中。Bob 将操作从“本地更新”移动到“已发送更新”
13. 服务器首先处理 Alice 的第二次插入，并向 Alice 发送一个确认
14. Alice 从“已发送更新”中删除该操作，并将其最新修订号更新为 2
15. 服务器将 Alice 的插入广播给 Bob。但是，Bob 有未提交的更新，因此他需要根据 Alice 的更新来转换它们。Bob 插入“!”被转换为第 11 个位置，以便为 Alice 的“ world”腾出空间。Bob 将其最新修订号更新为 2
16. 服务器接下来处理 Bob 的插入。它看到 Bob 的操作是针对修订版 1 制作的，这并没有考虑到 Alice 的第二次插入。因此，服务器将 Bob 插入“!”转换为第 11 个位置，以便为 Alice 的“ world”腾出空间。这种转变与 Bob 的客户端首次收到 Alice 插入“ world”时所做的转变相同
17. 服务器处理 Bob 的转换后的插入，并向 Bob 发送一个确认。Bob 从“已发送更新”中删除该操作，并将其最新修订号更新为 3
18. 服务器将 Bob 的插入广播给 Alice。它已经被转换，因此 Alice 可以简单地应用该操作并将其最新修订号更新为 3

Alice、Bob 和服务器最终都得到了相同版本的文档。

**注意**：Alice 和 Bob 的更新日志未在图中显示，但它们反映了服务器的修订日志。

### 传输机制

到目前为止讨论的协作方法不限制或规定任何传输机制。但是，所选传输机制需要满足某些要求：

* **双向**：服务器需要能够主动向对等客户端发送数据，只要收到来自客户端的更新。
* **低延迟**：尽管用户编辑首先在本地进行并立即显示，并且更新有效负载很小，但低延迟传输机制将帮助用户更频繁地接收对等更新并保留更改，从而降低因崩溃而导致数据丢失的可能性。
* **有序**：服务器假定广播到客户端的更新将按照发送的顺序接收，因为转换是在假设操作按顺序进行的情况下进行的。因此，传输机制需要保证在广播期间按顺序发送消息。

虽然延迟主要取决于网络连接速度和可靠性，但协议也起着作用。某些传输方法是持久性的，因此效率更高，因为不需要重复握手和初始化。可能的方法是：

* **长轮询**：在长轮询中，客户端向服务器发送请求，服务器保持连接打开状态，直到有新数据可用。一旦发送了数据，客户端会立即重新打开连接以等待下一次更新。
* **WebSockets**：WebSockets 通过单个、长寿命的持久连接提供全双工通信通道。一旦在客户端和服务器之间建立了 WebSocket 连接，服务器就可以在更新发生时将更新推送到客户端。非常适合客户端和服务器都需要持续交换数据的场景，例如在聊天应用程序、多人游戏或协作编辑工具中。
* **服务器发送事件 (SSE)**：SSE 是一种标准，允许服务器通过 HTTP 将基于文本的事件更新推送到客户端。与 WebSockets 不同，SSE 是单向的（服务器到客户端），更适合于仅服务器需要将数据推送到客户端的单向场景。对于客户端到服务器的通信，可以使用标准 HTTP 请求。SSE 非常适合更新不频繁或数据主要从服务器发送到客户端的应用程序。

#### 分析

**可靠性**：可靠性是这里最大的问题——我们如何确保从服务器发送的消息一定能被客户端收到？如果用户在移动或在咖啡馆，连接可能不稳定。持久连接可能会断开并需要重新连接。当客户端连接、重新连接或离线时，它可能会错过服务器上发生但无法到达客户端的消息。

这个问题在长轮询中尤其重要。虽然长轮询试图模拟实时更新，但在服务器上有新数据可用到客户端收到新数据之间可能存在延迟。这种延迟的发生是因为服务器需要等待现有的长轮询请求返回，然后客户端才能接收到新数据。重新连接实际上是内置于长轮询的工作方式中的，因此错失服务器更新的窗口更大。

**排序**：上述传输机制均不能保证消息的有序传递。由于客户端级别的消息排序，客户端到服务器的通信得到保证，方法是强制一次只有一个正在进行的请求。服务器到客户端的通信排序由通信协议要求，但未内置于其中。在 SSE 中，如果连接断开，它会自动重试，但其他方法则不然。

总的来说，**WebSockets 是协作编辑的最佳传输机制**，因为它具有低延迟和双向通信特性。WebSockets 被许多生产级应用程序广泛用于实时更新。虽然 WebSockets 不能保证消息排序，但可以通过应用程序层中的自定义逻辑（例如 [Socket.io](https://socket.io)）来弥补这一差距。

也可以使用 SSE。我们可以使用 SSE 接收对等更新，并使用常规 HTTP 请求发送消息，但使用两种不同的传输机制进行协作编辑可能会令人困惑。

鉴于有更多克服其缺点的现代技术，长轮询不可行。

### 总体方法总结

让我们总结一下总体方法的主要方面。

* **高效的请求负载**：在更新期间仅发送和接收操作类型和必要信息，从而使请求变得小而高效。负载大小不受文档长度的影响。
* **客户端-服务器网络架构**：选择客户端-服务器模型，参与者连接到中央服务器。拥有中央服务器简化了协作协议，使其更易于理解和实现，因为客户端只需专注于与服务器同步，而不是与其他客户端同步。服务器可以以相同的方式处理所有客户端。
* **通过版本检测进行并发控制**：版本检测模型是最理想的，每个客户端都保存文档的副本，并且更改会尽快传播给对等方。文档永远不会被锁定，每个用户都可以在本地乐观地进行更改，而无需等待服务器确认。网络连接的速度和可靠性不会限制用户打字的速度。版本冲突可以通过转换操作 (OT) 来解决，或者使用特殊的数据结构 (CRDT) 来处理。
* **通过 OT 进行冲突解决**：选择 OT 是因为它已经成熟，并且 OT 源于文档编辑。每个操作都提供了足够的信息来合并更新。多年来，Google Docs 也一直坚持使用 OT 技术，直到今天仍在继续使用 OT。
* **将文档存储为修订日志**：文档存储为仅追加操作/更改的日志，这使得版本历史记录和高效计算客户端状态和服务器状态之间的差异成为可能。
* **更新调度**：每个客户端维护一个“本地更新”缓冲区和“已发送更新”缓冲区，确保在任何时候都只有一个网络请求正在进行。
* **操作粒度**：操作粒度是在意图级别决定的，并且连续的打字操作被合并。
* **WebSockets 用于传输**：WebSockets 是低延迟和双向的，适用于服务器到客户端的通信。消息乱序问题可以通过应用层中的自定义逻辑来解决。

我们强烈建议查看这个[关于带有中央服务器的 OT 的交互式可视化](https://operational-transformation.github.io/)，它确实有助于理解协作协议。

现在我们已经讨论了各种选项并确定了一种方法，我们可以使用 RADIO 框架部分重新组织和呈现它们。

***

## 架构/高级设计

上面已经广泛地介绍了高级架构。总而言之，考虑到需求，客户端-服务器架构是最合适的：

* 中央服务器，所有客户端都与之通信。客户端之间不直接通信。
* 服务器将真实来源保存为修订日志，这使得可以计算最新的文档状态。
* 客户端尽快与服务器同步。

![协作编辑器架构](/img/questions/collaborative-editor-google-docs/collaborative-editor-architecture.png)

### 组件职责

我们将重点关注协作编辑器的关键组件。

* **UI**：显示文档并将事件发送到富文本编辑器核心。
* **富文本编辑器核心**：保存文档状态/模型，类似于富文本编辑器系统设计的核心。通过操作底层文档状态来响应用户事件，从而触发 DOM 事件。提供用于外部修改文档状态的 API。
* **同步引擎**：负责将本地更新同步到服务器、接收来自服务器的更新（转换适当的操作）并更新编辑器核心的模块。上面讨论的大部分内容都存在于此模块中。
  * **本地更新缓冲区**：尚未发送到服务器的本地操作。
  * **已发送更新缓冲区**：已发送到服务器但尚未得到服务器确认的本地操作。
  * **更新日志**：已作为文档历史记录一部分提交的修订。
* **服务器**：可以接收更新并将其推送到客户端的 WebSocket 服务器。
  * **待处理更新**：尚未提交的来自客户端的操作。
  * **修订日志**：已处理的操作，可以提供文档的完整历史记录。

编辑器核心和 UI 与同步引擎和服务器后端完全解耦。编辑器核心为同步引擎提供了 API，以便根据接收到的操作修改文档模型。

***

## 数据模型

这里要讨论的核心状态是文档状态。根据[富文本编辑器系统设计文章](/questions/system-design/rich-text-editor)，在富文本编辑器核心中，文档状态被建模为一棵树。

但是，在同步引擎中，文档存储为初始文档状态 + 多个操作列表（序列）（本地、已发送、已接收）。可以通过在初始文档状态之上应用这些操作来构造最新的文档状态。每个已提交的操作都会增加修订号。

| 修订号 | 用户    | 操作            | 时间戳            | 文档           |
| ------- | ------- | ----------------- | ---------------- | -------------- |
| 0       | N/A     | N/A               | 2024-08-03 10:00 | \<EMPTY>  |
| 1       | Charlie | `INS "Hello" @0`  | 2024-08-03 10:05 | "Hello"        |
| 2       | Alice   | `INS " world" @5` | 2024-08-03 10:10 | "Hello world"  |
| 3       | Bob     | `INS "!" @11`     | 2024-08-03 10:15 | "Hello world!" |

当新用户加入会话或当前用户刷新页面时，他们初始化的文档是最新版本，由服务器上所有已提交的操作构成；所有客户端操作列表都将为空。

![用户加入协作编辑会话](/img/questions/collaborative-editor-google-docs/join-session.png)

上图演示了在不同时间加入的客户端的状态。当文档处于修订版 1 且仅包含“Hello”时，Alice 加入会话。她向文档添加了“ world”，并在她的屏幕上看到了“Hello world”。Alice 的文档由“Hello”的初始文档状态和她的插入操作“ world”构成。

Bob 然后在修订版 2 中加入会话，他直接使用“Hello world”的当前文档状态进行初始化，没有任何细粒度的操作历史记录。

### 文档级别的操作转换

到目前为止，我们在本文中提到的操作（和转换）都是在纯文本上下文中在句子级别执行的。但是文档是富文本，如何在文档上执行转换？

在[富文本编辑器系统设计文章](/questions/system-design/rich-text-editor)中，我们讨论了如何使用树数据结构来表示富文本文档，因此我们需要可以在树结构上使用的 OT。讨论 OT 的技术细节超出了本文的范围，但我们将简要讨论大致方法。

完整的富文本文档表示为一棵树，并且有两种类型的节点——元素节点和文本节点。元素节点可以包含子节点，即其他元素节点或文本节点，而文本节点是叶子，只能包含文本内容（纯文本）并具有格式标志。标题和段落是元素节点的子类，因为它们可以包含子文本节点。在高层次上，文档包含一个根节点，其中包含标题元素、段落元素列表，作为其直接子节点等。

操作转换在类似列表的字符串结构上运行良好。元素节点的子节点也位于列表结构中，看到这里的相似之处了吗？

让我们看看编辑文档时的一些潜在场景：

* **在同一句子中插入字符**：假设该句子包含在单个文本节点中。我们已经彻底地讨论了这种冲突。必须转换（增加偏移量）后部的插入，以便为前面的插入腾出空间。
* **同时插入段落**：假设这些段落是文档根节点的直接子节点。插入段落等同于修改根节点的直接子节点，一个类似列表的结构。请注意，在同一句子中插入字符也会修改一个列表（字符列表），其中后部的插入操作需要移动。因此，可以使用类似的转换来解决段落插入的冲突。
* **在不同的段落中插入字符**：这里没有冲突，因为修改了不同的节点。

这里的模式是，当修改相同的节点时会产生冲突，幸运的是，这在较长的文档中并不常见。 OT 技术可用于解决列表中的冲突，无论它们是字符列表（在句子和段落中）还是段落列表（在文档的根节点中）。

***

## 接口定义 (API)

我们将重点关注客户端和服务器之间同步所需的核心 API。

### 初始化 API

此 API 为客户端提供了启动协作编辑会话的必要信息。一个示例响应如下所示：

```json
{
  "revision": 145,
  "document": "..." // 富文本编辑器格式
}
```

### 更新/保存 API

此 API 允许将本地更新发送到服务器。由于这是使用 WebSockets 完成的，因此需要一个 `type` 字段来区分请求。请注意，单个更新请求中允许使用多个操作。

请求

```json
{
  "type": "UPDATE",
  "requestId": 2, // 每个客户端单调递增的整数
  "revision": 146, // 执行更新所依据的基本修订版
  "isUndo": false, // 区分新操作和撤消操作
  "operations": [
    {
      "type": "INSERT",
      "nodeId": 24, // 在文档上下文中需要
      "payload": {
        "characters": "Hello",
        "index": 4
      }
    },
    {
      "type": "INSERT",
      "nodeId": 25,
      "payload": {
        "characters": "Bye",
        "index": 2
      }
    }
  ]
}
```

### 更新确认回调

服务器在确认更新请求后将其发送给客户端。确认后，客户端可以将操作从“已发送更新”移动到“更新日志”。

```json
{
  "type": "ACK",
  "requestIdAcknowledged": 2,
  "requestId": 3,
  "revision": 147
}
```

### On update callback

这些是服务器发起的、表明对等方进行了更新的消息。

```json
{
  "type": "PEER_UPDATE",
  "revision": 148,
  "userId": 6543, // User who made the update
  "operations": [
    {
      "type": "INSERT",
      "nodeId": 24, // Needed in a document context to identify the node to modify
      "payload": {
        "characters": "Goodbye",
        "index": 8
      }
    },
    {
      "type": "INSERT",
      "nodeId": 25,
      "payload": {
        "characters": " earth",
        "index": 4
      }
    }
  ]
}
```

### On reconnect callback

当客户端断开连接并最终重新连接时，服务器应向其发送客户端断开连接期间错过的任何修订。

```json
{
  "type": "SYNC",
  "revisions": [
    {
      "revision": 147,
      "userId": 6543, // User who made the update
      "operations": [
        {
          "type": "INSERT",
          "nodeId": 24, // Needed in a document context to identify the node to modify
          "payload": {
            "characters": "Goodbye",
            "index": 8
          }
        },
        {
          "type": "INSERT",
          "nodeId": 25,
          "payload": {
            "characters": " earth",
            "index": 4
          }
        }
      ]
    }
  ]
}
```

***

## 优化和深入研究

### 历史记录和版本控制

Google Docs 允许用户将文档历史记录作为版本列表查看。通过将文档存储为操作/更新的日志，我们可以“穿越时间”并返回到文档在任何时间点的状态。每个文档修订都由一个单调递增的正整数标识，该整数由该点之前的操作构成。

| 修订版号 | 用户 | 操作 | 时间戳 | 文档状态 |
| --- | --- | --- | --- | --- |
| 0 | N/A | N/A | 2024-08-03 10:00 |  |
| 1 | Charlie | `INS "Hello" @0` | 2024-08-03 10:05 | "Hello" |
| 2 | Alice | `INS " world" @5` | 2024-08-03 10:10 | "Hello world" |
| 3 | Bob | `INS "!" @11` | 2024-08-03 10:15 | "Hello world!" |
| 4 | Donald | `INS " Goodbye" @12` | 2024-08-05 09:00 | "Hello world! Goodbye" |
| 5 | Erin | `INS " earth" @20` | 2024-08-05 09:10 | "Hello world! Goodbye earth" |

尽管每个细微的变化都存储在数据库中，但显示一个版本日志更有意义，该日志将多个修订版组合在一起。在短时间内一起进行的更改是同一版本的一部分：

| 版本 | 时间 | 最后编辑者 |
| ------- | ---------------- | ------------------- |
| 1       | 2024-08-03 10:15 | Charlie, Bob, Alice |
| 2       | 2024-08-05 09:10 | Donald, Erin        |

这与您单击“版本历史记录”按钮时 Google Docs 显示的内容类似。

### 撤消/重做

对于富文本编辑器来说，撤消/重做是一个棘手的话题，对于协作编辑器来说更是如此。

用户的撤消/重做历史记录应该在用户级别还是文档级别（所有参与者共享相同的撤消/重做）？ 仅撤消您自己的操作更有意义，因为用户不太可能知道其他人正在做什么，并且希望撤消它们。

该文档的修订日志是仅附加的；我们只能添加，不能删除。与此同时，删除已经提交的操作很复杂，因为它可能需要其他客户端撤消某些转换。Google Docs 通过将前一个操作的否定作为新更新来实施撤消。客户端可以过滤其“更新日志”以查找由他们所做的更改，并附加这些操作的否定。

因此，更新操作需要一个 `isUndo` 标志来区分新操作与撤消操作，并在识别其最后一个非撤消操作时将它们过滤掉，否则用户将陷入撤消/重做（撤消撤消）最近的操作。

| 修订版号 | 用户 | 操作 | 是否撤消 | 文档 |
| --- | --- | --- | --- | --- |
| 4 | Donald | `INS " Goodbye" @12` | False | "Hello world! Goodbye" |
| 5 | Erin | `INS " earth" @20` | False | "Hello world! Goodbye earth" |
| 6 | Erin | `INS "..." @26` | False | "Hello world! Goodbye earth…" |
| 7 | Erin | `DEL 3 @29` | True | "Hello world! Goodbye earth" |
| 8 | Erin | `DEL 6 @26` | True | "Hello world! Goodbye" |

上面的修订日志演示了 Erin 的插入如何作为删除操作（插入的否定）附加到修订日志中，作为修订版 7 和 8。

### 可靠性

可靠性是确保从服务器发送的消息保证按发送顺序被客户端接收。客户端可以随时断开连接，这可能导致服务器发送消息而客户端未收到。客户端也可能处于不稳定的网络连接上，并且某些消息会在传输过程中丢失。

如果消息包含整个文档状态，则丢失的消息不是问题，但如上所述，这效率不高。在我们的方法中，消息包含关键的细粒度更新，并且错过其中任何一个都将导致文档副本不同步。客户端必须接收所有对等操作才能收敛到一致的文档状态。

这就是文档修订号派上用场的地方，如果服务器知道客户端拥有的文档修订版，它可以使用该信息来计算客户端缺少哪些更新。

谁应该跟踪每个客户端的最新文档修订号？让服务器跟踪每个客户端的文档修订号既麻烦又不可扩展。一种可扩展的方法涉及客户端维护他们拥有的最新文档修订号，并将其包含在服务器请求中。这样，服务器可以保持相对无状态。

如果客户端使用修订版 5 重新连接到会话，而服务器当前位于修订版 8，则服务器知道客户端缺少修订版 6、7 和 8，因此可以发送修订版 6、7 和 8 的更新。

其他可靠性要求包括按顺序传递、重试和确认。WebSocket 不包含这些功能，因此必须通过 [Socket.io](https://socket.io/) 等库将自定义逻辑添加到应用层。

上面概述的协作协议可以很好地处理不稳定的连接。只要客户端保留文档修订号并将其作为请求负载的一部分发送到服务器，服务器就能够确定客户端缺少哪些更新。每个更新操作也都有一个唯一的 ID 标记，这有助于在重复请求的情况下进行去重。

### 离线编辑

截至撰写本文时（2024 年 8 月），Google Docs 不支持离线编辑。但是，使用当前的架构可以相对轻松地支持离线编辑。当客户端检测到没有网络连接时，用户可以继续编辑，但任何更新都保留在“本地更新”缓冲区中，并且不会发送出去。

当客户端重新获得网络连接时：

* **将本地更新发送到服务器**：“本地更新”被发送到服务器并移动到“发送更新”缓冲区。
* **从服务器获取更新**：客户端可能在离线时错过了某些更新，服务器应该推送自客户端上次同步修订以来的缺失更新。

### 文档格式

Google Docs 和 Microsoft Word 等文字处理器支持多种文件格式。其中，`.docx` (Microsoft Word) 和 `.odt` (OpenDocument Text) 文件格式最受欢迎。

`.docx` 和 `.odt` 文件格式的规范是公开提供的：

* `.docx`：[Office Open XML (.docx) 文件的 Word 扩展](https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b839fe1f-e1ca-4fa6-8c26-5954d0abbccd)
* `.odt`：[OpenDocument 技术规范](https://en.wikipedia.org/wiki/OpenDocument_technical_specification)

虽然 Google Docs 可以打开这些文件格式，但这并不意味着内部文档状态与它们完全匹配。只要文字处理器包含在外部格式与其内部状态之间进行导入和导出的模块，该软件就可以在内部使用任何格式。

让我们简要地看一下 `.odt` 文件中包含的内容。`.odt` 文件是 OpenDocument Text 文件，这是一种主要由 LibreOffice Writer 和 Apache OpenOffice 等文字处理应用程序使用的格式。它们类似于 Microsoft Word 使用的 `.docx` 文件，但基于 OpenDocument 格式，这是一种用于文档文件类型的开放标准。

`.odt` 文件本质上是一个 ZIP 存档，其中包含几个 XML 文件和目录，每个文件和目录都用于存储文档的内容、样式、设置和其他方面。以下是 `.odt` 文件中主要 XML 文件的示例：

**`content.xml`**: 这是包含文档实际文本内容及其结构的核心文件。它包括段落、表格、列表和其他文档元素，采用 XML 格式。

```xml
<office:text>
  <text:p>这是文档中的一个文本段落。</text:p>
  <text:table>
    <!-- 表格数据在这里 -->
  </text:table>
</office:text>
```

**`styles.xml`**: 此文件定义了文档中使用的样式，例如段落样式、字符样式、表格样式和页面布局。它确保了文档的格式一致性。

```xml
<office:styles>
  <style:style style:name="Heading1" style:family="paragraph">
    <style:text-properties fo:font-size="18pt" fo:font-weight="bold"/>
  </style:style>
</office:styles>
```

**`meta.xml`**: 包含有关文档的元数据，例如标题、作者、创建和修改日期、字数以及其他描述性信息。

```xml
<office:meta>
  <meta:initial-creator>John Doe</meta:initial-creator>
  <dc:title>我的文档</dc:title>
  <meta:creation-date>2024-08-14T10:00:00</meta:creation-date>
</office:meta>
```

**`settings.xml`**: 存储与文档相关的各种设置，例如页面视图选项、打印机设置以及影响文档显示或打印方式的其他用户首选项。

```xml
<office:settings>
  <config:config-item-set config:name="ooow:ViewSettings">
    <config:config-item config:name="ViewMode" config:type="string">Normal</config:config-item>
  </config:config-item-set>
</office:settings>
```

**`manifest.xml`**: 此文件列出了 `.odt` 存档中包含的所有文件及其 MIME 类型。它充当存档内容的目录。

```xml
<manifest:manifest>
  <manifest:file-entry manifest:full-path="/" manifest:media-type="application/vnd.oasis.opendocument.text"/>
  <manifest:file-entry manifest:full-path="content.xml" manifest:media-type="text/xml"/>
</manifest:manifest>
```

**其他文件**:

* **图像**：如果文档包含图像，则它们将作为单独的文件存储在包中。
* **嵌入对象**：其他类型的嵌入对象，例如图表或电子表格，也可能作为单独的文件包含在内。

这些 XML 文件协同工作，定义文档的内容、外观、元数据和设置，使其能够在支持 OpenDocument 格式的不同文字处理软件中一致地打开、编辑和显示。

***

## 参考资料

* [群件系统中的并发控制](https://dl.acm.org/doi/pdf/10.1145/67544.66963)
* [Jupiter 协作系统中的高延迟、低带宽窗口](https://dl.acm.org/doi/pdf/10.1145/215585.215706)
