import MDXCodeBlock from 'MDXCodeBlock';

import deepEqualJs from '../setup/src/deep-equal.js';
import deepEqualTs from '../setup/src/deep-equal.ts';
import deepEqualAlt from '../setup/src/deep-equal-alt';

## Solution

Value comparison in JavaScript can be deceptively simple. Normally a triple equal `===`, i.e. strict equality, can do the job: for primitive values, it compares the actual values; for objects, it compares their identities/references, instead of their "contents". For example, `const a = {id: 1}; const b = {id: 1}` are considered different objects by `===` even if they contain the exactly same `id` property. Most of the time this is what we want. For this question though, we are going to implement a function that can deeply compare objects. Therefore we can't solely rely on `===` for comparison.

Outside its reference-checking nature, strict equality `===` does have a few edge cases that it doesn't cover:

1. Two `NaN` values are considered different `NaN === NaN // false`.
2. Numerical values `-0 `and `+0` are considered as equal.

A better choice here is to use `Object.is`. This is also what React uses during its reconciliation phase to detect props change for a given component. Check out [`Object.is` on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is) if you want to learn more about it and see how it differs from `===`.

We don't test for the above cases but you might want to point this out when explaining why you used `Object.is`.

There are two main ways to go about solving this question:

1. Handling arrays/objects first, primitives last.
1. Handling primitives first, arrays/objects last.

### Approach 1: Handling arrays/objects first

The tricky part of the question about deep-comparing objects and arrays. Firstly, we need to know how to detect their data types. The `typeof` operator is probably the first solution that comes to mind but it is not enough for our use case here.

`typeof null` gives you `object`, so we cannot use `typeof` to distinguish between objects, arrays, and `null`s. More importantly, it doesn't distinguish other built-in objects such as `Date` and `Regex` from plain objects and array. That is, it return `object` for all of the built-in objects (except for functions). This is not useful because we can only sensibly traverse and deep-compare objects and arrays, and everything else should be compared by references via `Object.is`.

To get around this, you can combine the `instanceof` operator to check for the constructor of a given object. But an easier and cleaner way to detect data types is to use `Object.prototype.toString`. Check out [this article by Zhenghao](https://www.zhenghao.io/posts/js-data-type) if you want to dive deep into this topic.

A utility function `shouldDeepCompare` will be useful for determining whether we should traverse down the current property of the input object based on the data type retrieved by `getType`. When the current property is _not_ an object or an array, we can proceed to compare their types and values via `Object.is`.

```js
// Warning: Incomplete solution. Refer to below.
function shouldDeepCompare(type) {
  return type === '[object Object]' || type === '[object Array]';
}

function getType(value) {
  return Object.prototype.toString.call(value);
}

export default function deepEqual(value1, value2) {
  const type1 = getType(value1);
  const type2 = getType(value2);

  if (type1 === type2 && shouldDeepCompare(type1) && shouldDeepCompare(type2)) {
    // When both props are objects or arrays, we traverse into them by calling `isEqual` again.
  }

  return Object.is(value1, value2);
}
```

Now let's work on the case where both input values are objects or arrays. Because we need to recurse into any objects/arrays we found in the input. If it is an array, we can just loop through the items. However if it is an object, we either use `for ... in` statement to loop through all the keys (own keys _and_ inherited keys), or we can convert its own enumerable, non-symbol-keyed properties into an array of key-value pairs with `Object.entries` and then we can loop through that array instead. The benefits with the second approach are:

1. We only get its own properties, as opposed to inherited ones.
1. We can bail out of comparison if the lengths of two arrays are different. That is, two objects/arrays have different numbers of properties/items.

Here is the complete solution:

<MDXCodeBlock languages={{ jsx: deepEqualJs, tsx: deepEqualTs }} />

### Approach 2: Handling primitives first

We can also get primitives out of the way by handling them with `Object.is()` first. If they fail the primitive equality check, then we can check if they're both arrays or objects. If it also fails that check, it means there's a mismatch between the type of values and we can `return false`.

The next part is to check if both arrays/objects have the same entries (keys/values). The approach provided here is an alternative to the earlier solution but the idea is the same:

1. Check that both objects have the same keys:
   1. Both objects have the same number of keys.
   1. All of the first object's keys exist in the other object.
1. Recursively check that the each key's value are the same.

<MDXCodeBlock>{deepEqualAlt}</MDXCodeBlock>

## Edge cases

- Comparing `null`s, `Object`s, `Array`s.
- Equality of +0 and -0.
- Cyclic objects, i.e. objects with circular references are not handled.
- [Property descriptors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors) are not taken into account when comparing properties.
- Non-enumerable properties and symbol-keyed properties are not compared.
