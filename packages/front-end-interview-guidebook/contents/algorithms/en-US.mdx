---
title: Data Structures and Algorithms Interviews
description: Front end engineer's guide to DSA - important concepts to know, top practice questions to do and other tips
seo_title: Data Structures and Algorithms for Front End Interviews
seo_description: Guide to prepare for Data Structures and Algorithms Questions tailored for front end interviews - important concepts to know, common questions asked and useful tips
social_title: Cracking Data Structures and Algorithms | Front End Interview Playbook
---

Algorithmic coding questions are exactly the questions you can find on LeetCode. Algorithmic questions usually have the following traits:

- They aren't specific to the front end domain; they can be solved in most mainstream programming languages.
- Usually accompanied with impractical scenarios. You would not have encountered such a problem during real world development. Who ever had to flip a binary tree or count the number of palindromic substrings in a string?
- Efficiency of the code (time and space complexity) is important and producing the most efficient solution requires solid knowledge of data structures and algorithms.

Although algorithmic coding questions aren't specific to front end, the skills needed to excel in these questions â€” strong analytical thinking, effective communication, a solid grasp of the common data structures and algorithms, good code hygiene, are still crucial skills good Front End Engineers should possess. Good Front End Engineers are also good Software Engineers and good Software Engineers should have mastery over basic DSA. Hence it's no surprise that many companies still ask algorithmic coding questions during the interview process. Familiarity with data structures and algorithms is also helpful for solving JavaScript coding questions and User Interface coding questions.

There are a ton of resources out there that cover algorithmic coding interviews and since they are not specific to front end, we won't go into too much detail on this page. We recommend referring to [Tech Interview Handbook](https://www.techinterviewhandbook.org) as a free resource if you would like to learn more about algorithmic coding interviews.

## Examples

- Reverse a linked list.
- Determine if a string contains balanced brackets.
- Determine how many substrings in a string are palindromes.

## How to Prepare

1. Pick a good programming language to use. If you want to save preparation time you should probably stick with JavaScript for algorithmic questions, although note that the JavaScript language doesn't contain certain common useful data structures and algorithms whereas other languages like Python, Java, and C++ do. Personally I use Python for solving algorithmic interview questions.
1. Plan your time and tackle topics and questions in order of importance.
1. Combine studying and practicing for a single topic.
1. Accompany practice with coding interview cheat sheets to internalize the must-dos and must-remembers.

Refer to [Tech Interview Handbook's step-by-step guide on how to prepare for algorithmic coding interviews](https://www.techinterviewhandbook.org/coding-interview-prep/).

## Important Concepts

Although you can still be asked any algorithmic question, companies tend to go easier on Front End Engineer candidates and probably will not ask questions involving hard topics like dynamic programming or complex graph algorithms.

Since the DOM is a tree, prioritize learning about trees and the various tree traversal algorithms.

| Category | Important Topics |
| --- | --- |
| Data Structures | Arrays, Maps, Stacks, Trees, Graphs, Matrix (2D Arrays), Sets |
| Algorithms | Binary Search, Breadth-first Search, Depth-first Search, Topological Sorting, Recursion |

## Common JavaScript Operations

### `Array`

| Operation                   | Time Complexity |
| --------------------------- | --------------- |
| `Array.prototype.concat()`  | O(m + n)        |
| `Array.prototype.every()`   | O(n)            |
| `Array.prototype.fill()`    | O(n)            |
| `Array.prototype.filter()`  | O(n)            |
| `Array.prototype.find()`    | O(n)            |
| `Array.prototype.pop()`     | O(1)            |
| `Array.prototype.push()`    | O(1)            |
| `Array.prototype.reduce()`  | O(n)            |
| `Array.prototype.reverse()` | O(n)            |
| `Array.prototype.shift()`   | O(n)            |
| `Array.prototype.slice()`   | O(n)            |
| `Array.prototype.some()`    | O(n)            |
| `Array.prototype.sort()`    | O(nlgn)         |
| `Array.prototype.splice()`  | O(n)            |
| `Array.prototype.unshift()` | O(m + n)        |

<sup>*</sup> `n` is the number of elements in the array and `m`` is the number of
elements to be added.

### `Map`

| Operation | Time Complexity |
| --- | --- |
| `Map.prototype.clear()` | O(n) |
| `Map.prototype.delete()` | O(1) |
| `Map.prototype.entries()` | O(1) because it returns an iterator. Getting all the entries will take O(n) time. |
| `Map.prototype.forEach()` | O(n) |
| `Map.prototype.get()` | O(1) |
| `Map.prototype.has()` | O(1) |
| `Map.prototype.keys()` | O(1) because it returns an iterator. Getting all the keys will take O(n) time. |
| `Map.prototype.set()` | O(1) |
| `Map.prototype.values()` | O(1) because it returns an iterator. Getting all the values will take O(n) time. |

<sup>*</sup> `n` is the number of keys in the map.

### `Set`

| Operation | Time Complexity |
| --- | --- |
| `Set.prototype.add()` | O(1) |
| `Set.prototype.clear()` | O(n) |
| `Set.prototype.delete()` | O(1) |
| `Set.prototype.entries()` | O(1) because it returns an iterator. Getting all the entries will take O(n) time. |
| `Set.prototype.forEach()` | O(n) |
| `Set.prototype.has()` | O(1) |
| `Set.prototype.keys()` | O(1) because it returns an iterator. Getting all the keys will take O(n) time. |
| `Set.prototype.values()` | O(1) because it returns an iterator. Getting all the values will take O(n) time. |

<sup>*</sup> `n` is the number of elements in the set.

## Algorithmic Coding Interview Rubrics

During algorithmic coding interviews, interviewers are evaluating candidates on the following skills:

- **Problem Solving**: Use a systematic and logical approach to understanding and addressing a problem. Break down the problem into smaller independent problems. Evaluate different approaches and their tradeoffs.
- **Technical Competence**: Ability to translate solutions into working code and demonstrating a strong understanding of the language being used.
- **Communication**: Ask questions to clarify details and clearly explain one's approach and considerations.
- **Verification**: Identify various scenarios to test the code against, including edge cases. Be able to diagnose and fix any issues that arise.

## Useful Tips

- **Wishful thinking**. JavaScript's standard library doesn't have some useful data structures and algorithms like queue, heap, binary search, which can make your life easier during JavaScript coding interviews. However, you can ask the interviewer if you can pretend such a data structure/algorithm exists and use it directly in your solution without implementing it.
- **Pure functions**. Aim to write pure functions which have the benefit of reusability and modularity, aka functions which don't rely on state outside of the function and doesn't cause side effects.
- **Choose data structures wisely.** Pay attention to your choice of data structures and be aware of the time complexities of the code. Be familiar with the time/space complexities of the basic JavaScript Array, Object, Set, Map operations should you want to use them in your solution. Some of these time/space complexities differ across languages. Don't write code that runs in O(n<sup>2</sup>) if it can accomplished in O(n) runtime with the use of hash maps.
- **Recursion edge cases**.
  - If you have identified that solving the question requires recursion, ask about the input size and how to handle the case of recursion stack overflow. Usually you won't have to handle it but raising this issue is a good signal.
  - Nested deep data structures can have recursive references to itself, which makes certain operations like serialization much trickier. Ask the interviewer if you have to handle such cases. Usually you won't have to handle it but raising this issue is a good signal.

## Practice Questions

Currently the best platform to practice algorithmic questions is undeniably LeetCode. However, GreatFrontEnd provides some [practice questions for Data Structures and Algorithms](/questions/js/coding/data-structures-algorithms) where you can practice implementing common data structures ([Stack](/questions/javascript/stack), [Queue](/questions/javascript/queue)) and algorithms ([Binary Search](/questions/javascript/binary-search), [Merge Sort](/questions/javascript/merge-sort)), etc in JavaScript.
