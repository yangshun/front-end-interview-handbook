---
title: 'Entrevistas para Desenvolvedor Front-End - Perguntas de Codificação Algorítmica: Como se Preparar'
description: Guia para se Preparar para Perguntas de Codificação Algorítmica em Entrevistas para Desenvolvedor Front-End / Web - Conceitos para Saber, Critérios de Entrevista e Questões de Prática Importantes.
---

Perguntas de codificação algorítmica são exatamente as questões que você pode encontrar no LeetCode. Perguntas algorítmicas geralmente possuem as seguintes características:

- Elas não são específicas para o domínio de front-end; podem ser resolvidas na maioria das linguagens de programação populares.
- Normalmente são acompanhadas por cenários pouco práticos. Você não teria encontrado um problema desse tipo durante o desenvolvimento do mundo real. Quem já precisou inverter uma árvore binária ou contar o número de substrings palindrômicas em uma string?
- A eficiência do código (complexidade de tempo e espaço) é importante, e produzir a solução mais eficiente requer um conhecimento sólido de estruturas de dados e algoritmos.

Embora as perguntas de codificação algorítmica não sejam específicas para o front-end, as habilidades necessárias para se destacar nessas questões - pensamento analítico sólido, comunicação eficaz, compreensão sólida das estruturas de dados e algoritmos comuns, boas práticas de codificação - ainda são habilidades cruciais que bons Engenheiros Front-End devem possuir. Bons Engenheiros Front-End também são bons Engenheiros de Software, e bons Engenheiros de Software devem ter domínio sobre estruturas de dados e algoritmos básicos. Portanto, não é surpresa que muitas empresas ainda façam perguntas de codificação algorítmica durante o processo de entrevista. Familiaridade com estruturas de dados e algoritmos também é útil para resolver perguntas de codificação em JavaScript e perguntas de codificação de Interface do Usuário.

Existem muitos recursos disponíveis que abordam entrevistas de codificação algorítmica, e como elas não são específicas para o front end, não entraremos em muitos detalhes nesta página. Recomendamos consultar o [Manual de Entrevistas Técnicas](https://www.techinterviewhandbook.org) como um recurso gratuito se você deseja aprender mais sobre entrevistas de codificação algorítmica.

## Exemplos

- Inverter uma lista ligada.
- Determinar se uma string contém colchetes balanceados.
- Determinar quantas substrings em uma string são palíndromos.

## Como se Preparar

1.  Escolha uma linguagem de programação adequada para utilizar. Se você deseja economizar tempo de preparação, provavelmente deve optar pelo JavaScript para perguntas algorítmicas, embora seja importante observar que a linguagem JavaScript não contém certas estruturas de dados e algoritmos comuns e úteis presentes em outras linguagens como Python, Java e C++. Pessoalmente, eu uso Python para resolver perguntas de entrevistas algorítmicas.
2.  Planeje o seu tempo e aborde tópicos e questões em ordem de importância.
3.  Combine o estudo e a prática para um único tópico.
4.  Acompanhe a prática com folhas de consulta de entrevista de codificação para internalizar as ações essenciais e os pontos importantes para lembrar.

Consulte o guia passo a passo do [Manual de Entrevistas Técnicas sobre como se preparar para entrevistas de codificação algorítmica.](https://www.techinterviewhandbook.org/coding-interview-prep/)

## Conceitos Importantes

Embora você ainda possa ser questionado sobre qualquer tópico algorítmico, as empresas tendem a ser mais brandas com os candidatos a Engenheiro Front-End e provavelmente não farão perguntas envolvendo tópicos difíceis como programação dinâmica ou algoritmos de grafos complexos.

Como o DOM é uma árvore, priorize aprender sobre árvores e os diversos algoritmos de travessia de árvores.

| Categoria | Tópicos Importantes |
| --- | --- |
| Estruturas de Dados | Arrays, Mapas, Pilhas, Árvores, Gráficos, Matriz (Arrays 2D), Conjuntos |
| Algoritmos | Busca Binária, Busca em Largura, Busca em Profundidade, Ordenação Topológica, Recursão |

## Operações Comuns em JavaScript

### `Array`

| Operação                    | Complexidade de Tempo |
| --------------------------- | --------------------- |
| `Array.prototype.concat()`  | O(m + n)              |
| `Array.prototype.every()`   | O(n)                  |
| `Array.prototype.fill()`    | O(n)                  |
| `Array.prototype.filter()`  | O(n)                  |
| `Array.prototype.find()`    | O(n)                  |
| `Array.prototype.pop()`     | O(1)                  |
| `Array.prototype.push()`    | O(1)                  |
| `Array.prototype.reduce()`  | O(n)                  |
| `Array.prototype.reverse()` | O(n)                  |
| `Array.prototype.shift()`   | O(n)                  |
| `Array.prototype.slice()`   | O(n)                  |
| `Array.prototype.some()`    | O(n)                  |
| `Array.prototype.sort()`    | O(nlgn)               |
| `Array.prototype.splice()`  | O(n)                  |
| `Array.prototype.unshift()` | O(m + n)              |

<sup>*</sup> `n` é o número de elementos do array e `m`` é o número de elementos
a serem adicionados.

### `Map`

| Operação | Complexidade de Tempo |
| --- | --- |
| `Map.prototype.clear()` | O(n) |
| `Map.prototype.delete()` | O(1) |
| `Map.prototype.entries()` | O(1) because it returns an iterator. Obter todas as entradas levará tempo O(n). |
| `Map.prototype.forEach()` | O(n) |
| `Map.prototype.get()` | O(1) |
| `Map.prototype.has()` | O(1) |
| `Map.prototype.keys()` | O(1) porque retorna um iterador. Obter todas as chaves levará tempo O(n). |
| `Map.prototype.set()` | O(1) |
| `Map.prototype.values()` | O(1) porque retorna um iterador. Obter todos os valores levará tempo O(n). |

<sup>*</sup> `n` é o número de chaves no mapa.

### `Set`

| Operação | Complexidade de Tempo |
| --- | --- |
| `Set.prototype.add()` | O(1) |
| `Set.prototype.clear()` | O(n) |
| `Set.prototype.delete()` | O(1) |
| `Set.prototype.entries()` | O(1) porque retorna um iterador. Obter todas as entradas levará tempo O(n). |
| `Set.prototype.forEach()` | O(n) |
| `Set.prototype.has()` | O(1) |
| `Set.prototype.keys()` | O(1) porque retorna um iterador. Obter todas as chaves levará tempo O(n). |
| `Set.prototype.values()` | O(1) porque retorna um iterador. Obter todos os valores levará tempo O(n). |

<sup>*</sup> `n` é o número de chaves no conjunto (set).

## Critérios de Avaliação para Entrevistas de Codificação Algorítmica

Durante entrevistas de codificação algorítmica, os entrevistadores estão avaliando os candidatos com base nas seguintes habilidades:

- **Solução de problemas**: use uma abordagem sistemática e lógica para a compreensão e resolução de um problema. Dividir o problema em problemas menores e independentes. Avaliar abordagens diferentes e suas compensações.
- **Competência Técnica**: Habilidade de traduzir soluções em código funcional e demonstrar um forte entendimento da linguagem sendo utilizada.
- **Comunicação**: Fazer perguntas para esclarecer detalhes e explicar claramente a abordagem e as considerações.
- **Verificação**: Identificar vários cenários para testar o código, incluindo casos extremos. Ser capaz de diagnosticar e resolver quaisquer problemas que surjam.

## Useful Tips

- **Pensamento Positivo**. A biblioteca padrão do JavaScript não possui algumas estruturas de dados e algoritmos úteis, como fila, heap e busca binária, que podem facilitar sua vida durante entrevistas de codificação em JavaScript. No entanto, você pode perguntar ao entrevistador se pode fazer de conta que tal estrutura de dados/algoritmo existe e usá-la diretamente em sua solução sem implementá-la.
- **Funções Puras**. Tente escrever funções puras, que têm a vantagem de serem reutilizáveis e modulares, ou seja, funções que não dependem de estados externos à função e não causam efeitos colaterais.
- **Escolha com sabedoria estruturas de dados.** Preste atenção à sua escolha de estruturas de dados e esteja ciente das complexidades do tempo do código. Esteja familiarizado com as complexidades de tempo/espaço das operações básicas de Array, Object, Set e Map do JavaScript, caso queira utilizá-las em sua solução. Algumas dessas complexidades de tempo/espaço podem ser diferentes em diferentes linguagens. Não escreva código que seja executado em O(n<sup>2</sup>) se ele puder ser executado em O(n) com o uso de hash mapas.
- **Casos Extremos de Recursão**.
  - Se você identificou que resolver a pergunta requer recursão, pergunte sobre o tamanho da entrada e como lidar com o caso de estouro da pilha de recursão. Normalmente, você não precisará lidar com isso, mas levantar essa questão é um bom sinal.
  - Estruturas de dados profundamente aninhadas podem ter referências recursivas a si mesmas, o que torna certas operações, como a serialização, muito mais complicadas. Pergunte ao entrevistador se você precisa lidar com tais casos. Normalmente, você não precisará lidar com isso, mas levantar essa questão é um bom sinal.

## Questões de Prática

Atualmente, a melhor plataforma para praticar perguntas algorítmicas é indiscutivelmente o LeetCode. No entanto, o GreatFrontEnd fornece algumas [perguntas práticas para Estruturas de Dados e Algoritmos](/questions/javascript-interview-questions/algo-coding) onde você pode praticar a implementação de estruturas de dados comuns ([Stack](/questions/algo/stack), [Queue](/questions/algo/queue)) e algoritmos ([Binary Search](/questions/algo/binary-search), [Merge Sort](/questions/algo/merge-sort)), etc em JavaScript.
