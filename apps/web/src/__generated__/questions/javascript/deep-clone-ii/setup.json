{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/deep-clone-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/deep-clone-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/deep-clone-ii.run.test.ts": "import deepClone from './deep-clone-ii';\n\ndescribe('deepClone', () => {\n  test('single primitive value', () => {\n    expect(deepClone(123)).toStrictEqual(123);\n    expect(deepClone('foo')).toStrictEqual('foo');\n    expect(deepClone(true)).toStrictEqual(true);\n    expect(deepClone(null)).toStrictEqual(null);\n  });\n\n  test('object with no nesting', () => {\n    const obj = { role: 'foo' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo' });\n    expect(clonedObj).toStrictEqual({ role: 'bar' });\n  });\n\n  test('object with no nesting and symbol-key prop', () => {\n    const symbol = Symbol('bar');\n    const obj = { role: 'foo', [symbol]: 'bar' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo', [symbol]: 'bar' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo', [symbol]: 'bar' });\n  });\n\n  test('object with circular references', () => {\n    const obj: any = { a: {} };\n    obj.a.b = obj;\n    const clonedObj = deepClone(obj);\n    clonedObj.a.b = 'something new';\n    expect(obj.a.b).toStrictEqual(obj);\n  });\n});\n",
    "/src/deep-clone-ii.submit.test.ts": "import deepClone from './deep-clone-ii';\n\n// TODO: Change tests to test for non-serializable properties in Jest.\ndescribe('deepClone', () => {\n  test('single primitive value', () => {\n    expect(deepClone(123)).toStrictEqual(123);\n    expect(deepClone('foo')).toStrictEqual('foo');\n    expect(deepClone(true)).toStrictEqual(true);\n    expect(deepClone(null)).toStrictEqual(null);\n  });\n\n  test('object with no nesting', () => {\n    const obj = { role: 'foo' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo' });\n    expect(clonedObj).toStrictEqual({ role: 'bar' });\n  });\n\n  test('object with no nesting and symbol-key prop', () => {\n    const symbol = Symbol('bar');\n    const obj = { role: 'foo', [symbol]: 'bar' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo', [symbol]: 'bar' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo', [symbol]: 'bar' });\n  });\n\n  test('object with one-level nesting', () => {\n    const symbol = Symbol('s');\n    const date = new Date();\n    const obj = {\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: /\\/bar\\/ig/,\n      [symbol]: 'baz',\n    };\n    const clonedObj: any = deepClone(obj);\n    expect(clonedObj).toStrictEqual({\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: /\\/bar\\/ig/,\n      [symbol]: 'baz',\n    });\n    clonedObj.name = 'bar';\n    clonedObj.arr.pop();\n\n    expect(obj).toStrictEqual({\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: /\\/bar\\/ig/,\n      [symbol]: 'baz',\n    });\n  });\n\n  test('object with circular references', () => {\n    const obj: any = { a: {} };\n    obj.a.b = obj;\n    const clonedObj = deepClone(obj);\n    clonedObj.a.b = 'something new';\n    expect(obj.a.b).toStrictEqual(obj);\n  });\n\n  test('object prototype is also copied', () => {\n    const Foo = function () {};\n    let foo = new (Foo as any)();\n    const cloned = deepClone(foo);\n\n    expect(Object.getPrototypeOf(cloned)).toStrictEqual(\n      Object.getPrototypeOf(foo),\n    );\n  });\n});\n",
    "/src/deep-clone-ii.ts": "function isPrimitiveTypeOrFunction(value: unknown): boolean {\n  return (\n    typeof value !== 'object' || typeof value === 'function' || value === null\n  );\n}\n\nfunction getType(value: unknown) {\n  const type = typeof value;\n  if (type !== 'object') {\n    return type;\n  }\n\n  return Object.prototype.toString\n    .call(value)\n    .replace(/^\\[object (\\S+)\\]$/, '$1')\n    .toLowerCase();\n}\n\nfunction deepCloneWithCache<T>(value: T, cache: Map<any, any>): T {\n  if (isPrimitiveTypeOrFunction(value)) {\n    return value;\n  }\n\n  const type = getType(value);\n\n  if (type === 'set') {\n    const cloned = new Set();\n    (value as Set<any>).forEach((item) => {\n      cloned.add(deepCloneWithCache(item, cache));\n    });\n    return cloned as T;\n  }\n\n  if (type === 'map') {\n    const cloned = new Map();\n    (value as Map<any, any>).forEach((value_, key) => {\n      cloned.set(key, deepCloneWithCache(value_, cache));\n    });\n    return cloned as T;\n  }\n\n  if (type === 'function') {\n    return value;\n  }\n\n  if (type === 'array') {\n    return (value as Array<any>).map((item) =>\n      deepCloneWithCache(item, cache),\n    ) as T;\n  }\n\n  if (type === 'date') {\n    return new Date(value as Date) as T;\n  }\n\n  if (type === 'regexp') {\n    return new RegExp(value as RegExp) as T;\n  }\n\n  if (cache.has(value)) {\n    return cache.get(value);\n  }\n\n  const cloned = Object.create(Object.getPrototypeOf(value));\n\n  cache.set(value, cloned);\n  for (const key of Reflect.ownKeys(value as Object)) {\n    const item = (value as any)[key];\n    cloned[key] = isPrimitiveTypeOrFunction(item)\n      ? item\n      : deepCloneWithCache(item, cache);\n  }\n\n  return cloned;\n}\n\nexport default function deepClone<T>(value: T): T {\n  return deepCloneWithCache(value, new Map());\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {T} value\n * @return {T}\n */\nexport default function deepClone(value) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function deepClone<T>(value: T): T {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/deep-clone-ii.ts",
    "run": "/src/deep-clone-ii.run.test.ts",
    "submit": "/src/deep-clone-ii.submit.test.ts"
  }
}