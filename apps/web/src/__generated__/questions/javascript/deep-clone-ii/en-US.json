{
  "description": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var m=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),j=(n,e)=>{for(var t in e)i(n,t,{get:e[t],enumerable:!0})},r=(n,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!g.call(n,a)&&a!==t&&i(n,a,{get:()=>e[a],enumerable:!(l=u(e,a))||l.enumerable});return n};var f=(n,e,t)=>(t=n!=null?h(b(n)):{},r(e||!n||!n.__esModule?i(t,\"default\",{value:n,enumerable:!0}):t,n)),w=n=>r(i({},\"__esModule\",{value:!0}),n);var c=m((D,s)=>{s.exports=_jsx_runtime});var C={};j(C,{default:()=>v,frontmatter:()=>x});var o=f(c()),x={title:\"Deep Clone II\",excerpt:\"Implement a function that performs a deep copy of a value, but also handles circular references\"};function d(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of the \",(0,o.jsx)(e.a,{href:\"/questions/javascript/deep-clone\",children:\"Deep Clone\"}),\" question, which you should complete first before attempting this question.\"]}),`\n`,(0,o.jsxs)(e.p,{children:[\"It is not realistic to expect candidates to produce a complete deep clone solution in typical interview settings, though the interviewer might ask you a simple version a la \",(0,o.jsx)(e.a,{href:\"/questions/javascript/deep-clone\",children:\"Deep Clone\"}),\" and engage you in a discussion regarding the edge cases and how you would handle them.\"]}),`\n`,(0,o.jsxs)(e.p,{children:[\"Implement a \",(0,o.jsx)(e.code,{children:\"deepClone\"}),\" function that performs a deep clone as thoroughly as possible, while also handling the following:\"]}),`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"The input object can contain any data type.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Handle the edge case where the input object is cyclic, i.e. the circular references should also be cloned.\"}),`\n`]}),`\n`,(0,o.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`const obj1 = {\n  num: 0,\n  str: '',\n  boolean: true,\n  unf: undefined,\n  nul: null,\n  obj: { name: 'foo', id: 1 },\n  arr: [0, 1, 2],\n  date: new Date(),\n  reg: new RegExp('/bar/ig'),\n  [Symbol('s')]: 'baz',\n};\n\nconst clonedObj1 = deepClone(obj1);\nclonedObj1.arr.push(3);\nobj1.arr; // Should still be [0, 1, 2]\n\nconst obj2 = { a: {} };\nobj2.a.b = obj2; // Circular reference\n\nconst clonedObj2 = deepClone(obj2); // Should not cause a stack overflow by recursing into an infinite loop.\n\nclonedObj2.a.b = 'something new';\n\nobj2.a.b === obj2; // This should still be true\n`})})]})}function y(n={}){let{wrapper:e}=n.components||{};return e?(0,o.jsx)(e,Object.assign({},n,{children:(0,o.jsx)(d,n)})):d(n)}var v=y;return w(C);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/deep-clone-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/deep-clone-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/deep-clone-ii.run.test.ts": "import deepClone from './deep-clone-ii';\n\ndescribe('deepClone', () => {\n  test('single primitive value', () => {\n    expect(deepClone(123)).toStrictEqual(123);\n    expect(deepClone('foo')).toStrictEqual('foo');\n    expect(deepClone(true)).toStrictEqual(true);\n    expect(deepClone(null)).toStrictEqual(null);\n  });\n\n  test('object with no nesting', () => {\n    const obj = { role: 'foo' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo' });\n    expect(clonedObj).toStrictEqual({ role: 'bar' });\n  });\n\n  test('object with no nesting and symbol-key prop', () => {\n    const symbol = Symbol('bar');\n    const obj = { role: 'foo', [symbol]: 'bar' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo', [symbol]: 'bar' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo', [symbol]: 'bar' });\n  });\n\n  test('object with circular references', () => {\n    const obj: any = { a: {} };\n    obj.a.b = obj;\n    const clonedObj = deepClone(obj);\n    clonedObj.a.b = 'something new';\n    expect(obj.a.b).toStrictEqual(obj);\n  });\n});\n",
    "/src/deep-clone-ii.submit.test.ts": "import deepClone from './deep-clone-ii';\n\n// TODO: Change tests to test for non-serializable properties in Jest.\ndescribe('deepClone', () => {\n  test('single primitive value', () => {\n    expect(deepClone(123)).toStrictEqual(123);\n    expect(deepClone('foo')).toStrictEqual('foo');\n    expect(deepClone(true)).toStrictEqual(true);\n    expect(deepClone(null)).toStrictEqual(null);\n  });\n\n  test('object with no nesting', () => {\n    const obj = { role: 'foo' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo' });\n    expect(clonedObj).toStrictEqual({ role: 'bar' });\n  });\n\n  test('object with no nesting and symbol-key prop', () => {\n    const symbol = Symbol('bar');\n    const obj = { role: 'foo', [symbol]: 'bar' };\n    const clonedObj = deepClone(obj);\n    expect(clonedObj).toStrictEqual({ role: 'foo', [symbol]: 'bar' });\n    clonedObj.role = 'bar';\n    expect(obj).toStrictEqual({ role: 'foo', [symbol]: 'bar' });\n  });\n\n  test('object with one-level nesting', () => {\n    const symbol = Symbol('s');\n    const date = new Date();\n    const obj = {\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: /\\/bar\\/ig/,\n      [symbol]: 'baz',\n    };\n    const clonedObj: any = deepClone(obj);\n    expect(clonedObj).toStrictEqual({\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: /\\/bar\\/ig/,\n      [symbol]: 'baz',\n    });\n    clonedObj.name = 'bar';\n    clonedObj.arr.pop();\n\n    expect(obj).toStrictEqual({\n      num: 0,\n      str: '',\n      boolean: true,\n      unf: undefined,\n      nul: null,\n      obj: { name: 'foo', id: 1 },\n      arr: [0, 1, 2],\n      date,\n      reg: /\\/bar\\/ig/,\n      [symbol]: 'baz',\n    });\n  });\n\n  test('object with circular references', () => {\n    const obj: any = { a: {} };\n    obj.a.b = obj;\n    const clonedObj = deepClone(obj);\n    clonedObj.a.b = 'something new';\n    expect(obj.a.b).toStrictEqual(obj);\n  });\n\n  test('object prototype is also copied', () => {\n    const Foo = function () {};\n    let foo = new (Foo as any)();\n    const cloned = deepClone(foo);\n\n    expect(Object.getPrototypeOf(cloned)).toStrictEqual(\n      Object.getPrototypeOf(foo),\n    );\n  });\n});\n",
    "/src/deep-clone-ii.ts": "function isPrimitiveTypeOrFunction(value: unknown): boolean {\n  return (\n    typeof value !== 'object' || typeof value === 'function' || value === null\n  );\n}\n\nfunction getType(value: unknown) {\n  const type = typeof value;\n  if (type !== 'object') {\n    return type;\n  }\n\n  return Object.prototype.toString\n    .call(value)\n    .replace(/^\\[object (\\S+)\\]$/, '$1')\n    .toLowerCase();\n}\n\nfunction deepCloneWithCache<T>(value: T, cache: Map<any, any>): T {\n  if (isPrimitiveTypeOrFunction(value)) {\n    return value;\n  }\n\n  const type = getType(value);\n\n  if (type === 'set') {\n    const cloned = new Set();\n    (value as Set<any>).forEach((item) => {\n      cloned.add(deepCloneWithCache(item, cache));\n    });\n    return cloned as T;\n  }\n\n  if (type === 'map') {\n    const cloned = new Map();\n    (value as Map<any, any>).forEach((value_, key) => {\n      cloned.set(key, deepCloneWithCache(value_, cache));\n    });\n    return cloned as T;\n  }\n\n  if (type === 'function') {\n    return value;\n  }\n\n  if (type === 'array') {\n    return (value as Array<any>).map((item) =>\n      deepCloneWithCache(item, cache),\n    ) as T;\n  }\n\n  if (type === 'date') {\n    return new Date(value as Date) as T;\n  }\n\n  if (type === 'regexp') {\n    return new RegExp(value as RegExp) as T;\n  }\n\n  if (cache.has(value)) {\n    return cache.get(value);\n  }\n\n  const cloned = Object.create(Object.getPrototypeOf(value));\n\n  cache.set(value, cloned);\n  for (const key of Reflect.ownKeys(value as Object)) {\n    const item = (value as any)[key];\n    cloned[key] = isPrimitiveTypeOrFunction(item)\n      ? item\n      : deepCloneWithCache(item, cache);\n  }\n\n  return cloned;\n}\n\nexport default function deepClone<T>(value: T): T {\n  return deepCloneWithCache(value, new Map());\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "zhenghao",
    "companies": [],
    "created": 1653177600,
    "difficulty": "hard",
    "duration": 45,
    "excerpt": "Implement a function that performs a deep copy of a value, but also handles circular references",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/deep-clone-ii",
    "importance": "medium",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "deep-clone"
    ],
    "slug": "deep-clone-ii",
    "subtitle": null,
    "title": "Deep Clone II",
    "topics": [
      "recursion"
    ]
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {T} value\n * @return {T}\n */\nexport default function deepClone(value) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function deepClone<T>(value: T): T {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var v=Object.create;var c=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),w=(n,e)=>{for(var o in e)c(n,o,{get:e[o],enumerable:!0})},i=(n,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of f(e))!m.call(n,a)&&a!==o&&c(n,a,{get:()=>e[a],enumerable:!(r=y(e,a))||r.enumerable});return n};var j=(n,e,o)=>(o=n!=null?v(g(n)):{},i(e||!n||!n.__esModule?c(o,\"default\",{value:n,enumerable:!0}):o,n)),C=n=>i(c({},\"__esModule\",{value:!0}),n);var s=b((P,l)=>{l.exports=_jsx_runtime});var S={};w(S,{default:()=>x});var t=j(s());var u=MDXCodeBlock;var h=`function isPrimitiveTypeOrFunction(value) {\n  return (\n    typeof value !== 'object' || typeof value === 'function' || value === null\n  );\n}\n\nfunction getType(value) {\n  const type = typeof value;\n  if (type !== 'object') {\n    return type;\n  }\n\n  return Object.prototype.toString\n    .call(value)\n    .replace(/^\\\\[object (\\\\S+)\\\\]$/, '$1')\n    .toLowerCase();\n}\n\nfunction deepCloneWithCache(value, cache) {\n  if (isPrimitiveTypeOrFunction(value)) {\n    return value;\n  }\n\n  const type = getType(value);\n\n  if (type === 'set') {\n    const cloned = new Set();\n    value.forEach((item) => {\n      cloned.add(deepCloneWithCache(item, cache));\n    });\n    return cloned;\n  }\n\n  if (type === 'map') {\n    const cloned = new Map();\n    value.forEach((value_, key) => {\n      cloned.set(key, deepCloneWithCache(value_, cache));\n    });\n    return cloned;\n  }\n\n  if (type === 'function') {\n    return value;\n  }\n\n  if (type === 'array') {\n    return value.map((item) => deepCloneWithCache(item));\n  }\n\n  if (type === 'date') {\n    return new Date(value);\n  }\n\n  if (type === 'regexp') {\n    return new RegExp(value);\n  }\n\n  if (cache.has(value)) {\n    return cache.get(value);\n  }\n\n  const cloned = Object.create(Object.getPrototypeOf(value));\n\n  cache.set(value, cloned);\n  for (const key of Reflect.ownKeys(value)) {\n    const item = value[key];\n    cloned[key] = isPrimitiveTypeOrFunction(item)\n      ? item\n      : deepCloneWithCache(item, cache);\n  }\n\n  return cloned;\n}\n\n/**\n * @template T\n * @param {T} value\n * @return {T}\n */\nexport default function deepClone(value) {\n  return deepCloneWithCache(value, new Map());\n}\n`;var d=`function isPrimitiveTypeOrFunction(value: unknown): boolean {\n  return (\n    typeof value !== 'object' || typeof value === 'function' || value === null\n  );\n}\n\nfunction getType(value: unknown) {\n  const type = typeof value;\n  if (type !== 'object') {\n    return type;\n  }\n\n  return Object.prototype.toString\n    .call(value)\n    .replace(/^\\\\[object (\\\\S+)\\\\]$/, '$1')\n    .toLowerCase();\n}\n\nfunction deepCloneWithCache<T>(value: T, cache: Map<any, any>): T {\n  if (isPrimitiveTypeOrFunction(value)) {\n    return value;\n  }\n\n  const type = getType(value);\n\n  if (type === 'set') {\n    const cloned = new Set();\n    (value as Set<any>).forEach((item) => {\n      cloned.add(deepCloneWithCache(item, cache));\n    });\n    return cloned as T;\n  }\n\n  if (type === 'map') {\n    const cloned = new Map();\n    (value as Map<any, any>).forEach((value_, key) => {\n      cloned.set(key, deepCloneWithCache(value_, cache));\n    });\n    return cloned as T;\n  }\n\n  if (type === 'function') {\n    return value;\n  }\n\n  if (type === 'array') {\n    return (value as Array<any>).map((item) =>\n      deepCloneWithCache(item, cache),\n    ) as T;\n  }\n\n  if (type === 'date') {\n    return new Date(value as Date) as T;\n  }\n\n  if (type === 'regexp') {\n    return new RegExp(value as RegExp) as T;\n  }\n\n  if (cache.has(value)) {\n    return cache.get(value);\n  }\n\n  const cloned = Object.create(Object.getPrototypeOf(value));\n\n  cache.set(value, cloned);\n  for (const key of Reflect.ownKeys(value as Object)) {\n    const item = (value as any)[key];\n    cloned[key] = isPrimitiveTypeOrFunction(item)\n      ? item\n      : deepCloneWithCache(item, cache);\n  }\n\n  return cloned;\n}\n\nexport default function deepClone<T>(value: T): T {\n  return deepCloneWithCache(value, new Map());\n}\n`;function p(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",h2:\"h2\",ul:\"ul\",li:\"li\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of the \",(0,t.jsx)(e.a,{href:\"/questions/javascript/deep-clone\",children:\"Deep Clone\"}),\" question, which you should complete first before attempting this question.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This is a follow-up question based on Deep Clone, with much more depth and obscure corners of the JavaScript language covered.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"It is not realistic to expect anyone to come up with a complete deep clone solution in typical interview settings. However, this question serves a good tool to test your knowledge on checking various data types, object properties, leverage various built-in APIs and \",(0,t.jsx)(e.code,{children:\"Object\"}),\" methods to traverse a given object and various edge cases you might only encounter when writing library code.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Before we go about writing out the deep clone function, we need a way to identify the data type of a given JavaScript value. It is ok to go with \",(0,t.jsx)(e.code,{children:\"typeof\"}),\" and \",(0,t.jsx)(e.code,{children:\"instanceof\"}),\" but you have to be aware of their limitations. In this solution, we leverage \",(0,t.jsx)(e.code,{children:\"Object.prototype.toString\"}),\". Check out Zhenghao's post \",(0,t.jsx)(e.a,{href:\"https://www.zhenghao.io/posts/js-data-type\",children:'\"A Complete Guide To Check Data Types In JavaScript\"'}),\" if you like to understand how this works exactly.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Since we want to implement it as thoroughly as possible, here are a few things to consider:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"This advanced \",(0,t.jsx)(e.code,{children:\"deepClone\"}),\" should work with objects that have symbol-keyed properties. That is, symbol-keyed properties are also copied. On top of that, non-enumerable properties should also be copied. Neither the \",(0,t.jsx)(e.code,{children:\"for ... in\"}),\" statement or the \",(0,t.jsx)(e.code,{children:\"Object.entries()\"}),\"/\",(0,t.jsx)(e.code,{children:\"Object.keys()\"}),\" reveals them, so we need to leverage a lesser-known API called \",(0,t.jsx)(e.code,{children:\"Reflect.ownKeys()\"}),\". Check out \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys\",children:\"this MDN page\"}),\" to learn more about it.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The input object's property descriptors should also be copied. For that, we can use the method \",(0,t.jsx)(e.code,{children:\"Object.getOwnPropertyDescriptors()\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The input object's prototype should not be lost after the copying. We can use \",(0,t.jsx)(e.code,{children:\"Object.getPrototypeOf()\"}),\" to get a reference to the prototype of a given object.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"We should account for circular references in the input object and avoid erroring. We can achieve this by having a \",(0,t.jsx)(e.code,{children:\"cache\"}),\" (a \",(0,t.jsx)(e.code,{children:\"Map\"}),\" underneath) that acts as a cache to store visited properties. After cloning an object, we can put the cloned object in \",(0,t.jsx)(e.code,{children:\"cache\"}),\" with the original object as the key. If we encounter the same value again in the original object while cloning, we can retrieve the cloned value from the \",(0,t.jsx)(e.code,{children:\"cache\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(u,{languages:{jsx:h,tsx:d}}),`\n`,(0,t.jsx)(e.h2,{children:\"One-liner Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"As of writing, all major browsers have native support for performing deep clone via the \",(0,t.jsx)(e.code,{children:\"structuredClone\"}),\" API. Check out \",(0,t.jsx)(e.a,{href:\"https://web.dev/structured-clone/\",children:'\"Deep-copying in JavaScript using structuredClone\" on web.dev'}),\" if you want to learn more about \",(0,t.jsx)(e.code,{children:\"structuredClone\"}),\"'s features and limitations.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const clonedObj = structuredClone(obj);\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\",children:\"Property descriptors\"}),\" are not copied.\"]}),`\n`]})]})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var x=k;return C(S);})();\n;return Component;",
  "workspace": {
    "main": "/src/deep-clone-ii.ts",
    "run": "/src/deep-clone-ii.run.test.ts",
    "submit": "/src/deep-clone-ii.submit.test.ts"
  }
}