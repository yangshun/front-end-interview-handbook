{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/array-reduce\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/array-reduce.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/array-reduce.run.test.ts": "import './array-reduce';\n\nconst add = (prev: any, curr: any) => prev + curr;\n\ndescribe('Array.prototype.myReduce', () => {\n  test('add numbers', () => {\n    expect([-4, 10].myReduce(add, 0)).toEqual(6);\n  });\n\n  test('add strings', () => {\n    expect(['b', 'c', 'd'].myReduce(add, '')).toEqual('bcd');\n  });\n});\n",
    "/src/array-reduce.submit.test.ts": "import './array-reduce';\n\nconst add = (prev: any, curr: any) => prev + curr;\nconst multiplyByIndex = (prev: number, curr: number, index: number) =>\n  prev + curr * index;\nconst subtract = (prev: number, curr: number) => prev - curr;\nconst sumOfSquares = (prev: any, curr: any, index: number, array: Array<any>) =>\n  prev + curr * array[index];\nconst combineObj = (prev: Object, curr: Object) => ({ ...prev, ...curr });\nconst combineArr = (prev: Array<any>, curr: any) => [...prev, curr];\n\ndescribe('Array.prototype.myReduce', () => {\n  test('empty array equals initial value', () => {\n    expect([].myReduce(add, 0)).toEqual(0);\n    expect([].myReduce(subtract, 0)).toEqual(0);\n  });\n\n  test('one value', () => {\n    expect([1].myReduce(add, 0)).toEqual(1);\n    expect(['a'].myReduce(add, '')).toEqual('a');\n  });\n\n  test('two values', () => {\n    expect([-4, 10].myReduce(add, 0)).toEqual(6);\n    expect(['b', 'c', 'd'].myReduce(add, '')).toEqual('bcd');\n  });\n\n  test('multiple values', () => {\n    expect([1, 2, 3].myReduce(add, 0)).toEqual(6);\n    expect(['a', 'b', 'c', 'd'].myReduce(add, '')).toEqual('abcd');\n  });\n\n  test('object values', () => {\n    expect([{ foo: 1 }, { bar: 2 }].myReduce(combineObj)).toEqual({\n      foo: 1,\n      bar: 2,\n    });\n    expect([{ foo: 1 }, { bar: 2 }].myReduce(combineObj, {})).toEqual({\n      foo: 1,\n      bar: 2,\n    });\n  });\n\n  test('array values', () => {\n    expect([1, 2, 3].myReduce(combineArr, [])).toEqual([1, 2, 3]);\n  });\n\n  test('reducer uses index argument when provided', () => {\n    expect([1, 2, 3].myReduce(multiplyByIndex, 0)).toEqual(8);\n    expect([-1, -3, 4].myReduce(multiplyByIndex, 0)).toEqual(5);\n  });\n\n  test('reducer uses array argument when provided', () => {\n    expect([1, 2, 3, 4].myReduce(sumOfSquares, 0)).toEqual(30);\n    expect([-1, -3, 4].myReduce(sumOfSquares, 0)).toEqual(26);\n  });\n\n  test('no initial value provided and array is empty', () => {\n    expect(() => {\n      [].myReduce(add);\n    }).toThrow();\n  });\n\n  test('no initial value provided and array is non-empty', () => {\n    expect([1, 2, 3].myReduce(add)).toEqual(6);\n    expect([-1, -3, 4].myReduce(sumOfSquares, 0)).toEqual(26);\n  });\n\n  test('sparse arrays', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    expect([1, 2, , 3].myReduce(add)).toEqual(6);\n    // eslint-disable-next-line no-sparse-arrays\n    expect([-1, -3, 4, , ,].myReduce(sumOfSquares, 0)).toEqual(26);\n  });\n});\n",
    "/src/array-reduce.ts": "interface Array<T> {\n  myReduce<U>(\n    callbackFn: (\n      previousValue: U,\n      currentValue: T,\n      currentIndex: number,\n      array: T[],\n    ) => U,\n    initialValue?: U,\n  ): U;\n}\n\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  const noInitialValue = initialValue === undefined;\n  const len = this.length;\n\n  if (noInitialValue && len === 0) {\n    throw new TypeError('Reduce of empty array with no initial value');\n  }\n\n  let acc = noInitialValue ? this[0] : initialValue;\n  let startingIndex = noInitialValue ? 1 : 0;\n\n  for (let k = startingIndex; k < len; k++) {\n    if (Object.hasOwn(this, k)) {\n      acc = callbackFn(acc, this[k], k, this);\n    }\n  }\n\n  return acc;\n};\n"
  },
  "skeleton": {
    "js": "/**\n * @template T, U\n * @param {(previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U} callbackFn\n * @param {U} [initialValue]\n * @return {U}\n */\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  throw 'Not implemented!';\n};",
    "ts": "interface Array<T> {\n  myReduce<U>(\n    callbackFn: (\n      previousValue: U,\n      currentValue: T,\n      currentIndex: number,\n      array: T[],\n    ) => U,\n    initialValue?: U,\n  ): U;\n}\n\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  throw 'Not implemented!';\n};"
  },
  "workspace": {
    "main": "/src/array-reduce.ts",
    "run": "/src/array-reduce.run.test.ts",
    "submit": "/src/array-reduce.submit.test.ts"
  }
}