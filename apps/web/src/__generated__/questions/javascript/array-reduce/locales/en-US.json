{
  "description": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),f=(r,e)=>{for(var t in e)a(r,t,{get:e[t],enumerable:!0})},d=(r,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of u(e))!y.call(r,c)&&c!==t&&a(r,c,{get:()=>e[c],enumerable:!(o=h(e,c))||o.enumerable});return r};var b=(r,e,t)=>(t=r!=null?p(m(r)):{},d(e||!r||!r.__esModule?a(t,\"default\",{value:r,enumerable:!0}):t,r)),v=r=>d(a({},\"__esModule\",{value:!0}),r);var l=g((D,i)=>{i.exports=_jsx_runtime});var w={};f(w,{default:()=>A,frontmatter:()=>x});var n=b(l()),x={title:\"Array.prototype.reduce\",excerpt:\"Implement the Array.prototype.reduce() method\"};function s(r){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),' is a way of \"reducing\" elements in an array by calling a \"reducer\" callback function on each element of the array in order, passing in the return value from the calculation on the preceding element. The final result of running the reducer across all elements of the array is a single value.']}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement \",(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),\". To avoid overwriting the actual \",(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),\" which is being used by the autograder, we shall instead implement it as \",(0,n.jsx)(e.code,{children:\"Array.prototype.myReduce\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`[1, 2, 3].myReduce((prev, curr) => prev + curr, 0); // 6\n[1, 2, 3].myReduce((prev, curr) => prev + curr, 4); // 10\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"There are some nuances regarding how the \",(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),\" function works and what values are being passed to the reducer callback. You are recommended to read the specification for \",(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),\" on \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\",children:\"MDN Docs\"}),\" before attempting.\"]})]})}function j(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(s,r)})):s(r)}var A=j;return v(w);})();\n;return Component;",
  "info": {
    "excerpt": "Implement the Array.prototype.reduce() method",
    "title": "Array.prototype.reduce"
  },
  "solution": "var Component=(()=>{var y=Object.create;var r=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var a in e)r(t,a,{get:e[a],enumerable:!0})},o=(t,e,a,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of k(e))!g.call(t,i)&&i!==a&&r(t,i,{get:()=>e[i],enumerable:!(c=m(e,i))||c.enumerable});return t};var V=(t,e,a)=>(a=t!=null?y(b(t)):{},o(e||!t||!t.__esModule?r(a,\"default\",{value:t,enumerable:!0}):a,t)),v=t=>o(r({},\"__esModule\",{value:!0}),t);var h=w((E,d)=>{d.exports=_jsx_runtime});var R={};x(R,{default:()=>j});var n=V(h());var l=MDXCodeBlock;var s=`/**\n * @template T, U\n * @param {(previousValue: U, currentValue: T, currentIndex: number, array: T[]) => U} callbackFn\n * @param {U} [initialValue]\n * @return {Array<U>}\n */\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  const noInitialValue = initialValue === undefined;\n  const len = this.length;\n\n  if (noInitialValue && len === 0) {\n    throw new TypeError('Reduce of empty array with no initial value');\n  }\n\n  let acc = noInitialValue ? this[0] : initialValue;\n  let startingIndex = noInitialValue ? 1 : 0;\n\n  for (let k = startingIndex; k < len; k++) {\n    if (Object.hasOwn(this, k)) {\n      acc = callbackFn(acc, this[k], k, this);\n    }\n  }\n\n  return acc;\n};\n`;var u=`interface Array<T> {\n  myReduce<U>(\n    callbackFn: (\n      previousValue: U,\n      currentValue: T,\n      currentIndex: number,\n      array: T[],\n    ) => U,\n    initialValue?: U,\n  ): U;\n}\n\nArray.prototype.myReduce = function (callbackFn, initialValue) {\n  const noInitialValue = initialValue === undefined;\n  const len = this.length;\n\n  if (noInitialValue && len === 0) {\n    throw new TypeError('Reduce of empty array with no initial value');\n  }\n\n  let acc = noInitialValue ? this[0] : initialValue;\n  let startingIndex = noInitialValue ? 1 : 0;\n\n  for (let k = startingIndex; k < len; k++) {\n    if (Object.hasOwn(this, k)) {\n      acc = callbackFn(acc, this[k], k, this);\n    }\n  }\n\n  return acc;\n};\n`;var p=`Array.prototype.myReduce = function (callbackFn, initialValue) {\n  const len = this.length;\n\n  if (\n    typeof callbackFn !== 'function' ||\n    !callbackFn.call ||\n    !callbackFn.apply\n  ) {\n    throw new TypeError(\\`\\${callbackFn} is not a function\\`);\n  }\n\n  if (len === 0 && initialValue === undefined) {\n    throw new TypeError('Reduce of empty array with no initial value');\n  }\n\n  let k = 0;\n  let accumulator = undefined;\n\n  if (initialValue !== undefined) {\n    accumulator = initialValue;\n  } else {\n    let kPresent = false;\n    while (!kPresent && k < len) {\n      // Ignore index if value is not defined for index (e.g. in sparse arrays).\n      kPresent = Object.hasOwn(this, k);\n      if (kPresent) {\n        accumulator = this[k];\n      }\n      k = k + 1;\n    }\n\n    if (!kPresent) {\n      throw new TypeError('Reduce of empty array with no initial value');\n    }\n  }\n\n  while (k < len) {\n    const kPresent = Object.hasOwn(this, k);\n    if (kPresent) {\n      const kValue = this[k];\n      accumulator = callbackFn(accumulator, kValue, k, this);\n    }\n    k = k + 1;\n  }\n\n  return accumulator;\n};\n`;function f(t){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h2:\"h2\",pre:\"pre\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"This question might seem easy on first glance, but the nuances make the question trickier than it seems on the surface. Knowing the nuances differentiates senior candidates and gives you bonus points. Are you aware that:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The reducer callback is passed the \",(0,n.jsx)(e.code,{children:\"currentIndex\"}),\" and \",(0,n.jsx)(e.code,{children:\"array\"}),\" as the third and fourth argument respectively?\"]}),`\n`,(0,n.jsx)(e.li,{children:\"If there is no initial value supplied to the reduce function, the array element at index 0 is used and the iteration starts from the next element (index 1 instead of index 0).\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The rest of the implementation is straightforward with these nuances taken into account. As we loop through the array (via \",(0,n.jsx)(e.code,{children:\"this\"}),\"), call the callback on each array element with the following parameters: \",(0,n.jsx)(e.code,{children:\"acc\"}),\", \",(0,n.jsx)(e.code,{children:\"element\"}),\", \",(0,n.jsx)(e.code,{children:\"index\"}),\", and \",(0,n.jsx)(e.code,{children:\"this\"}),\". The returned value will become the new \",(0,n.jsx)(e.code,{children:\"acc\"}),\" to be passed to the next call of the \",(0,n.jsx)(e.code,{children:\"callbackFn\"}),\".\"]}),`\n`,(0,n.jsx)(l,{languages:{jsx:s,tsx:u}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Empty array, with and without the \",(0,n.jsx)(e.code,{children:\"initialValue\"}),\" argument.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Single-value array, with and without the \",(0,n.jsx)(e.code,{children:\"initialValue\"}),\" argument.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Passing the \",(0,n.jsx)(e.code,{children:\"index\"}),\" and \",(0,n.jsx)(e.code,{children:\"array\"}),\" to the reducer callback.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Sparse arrays, e.g. \",(0,n.jsx)(e.code,{children:\"[1, 2, , 4]\"}),\". The empty values should be ignored while traversing the array.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsx)(e.p,{children:\"Mutating the array in the reduce callback is a bad idea and can cause unintended consequences. It is a positive signal to mention that mutation of the array within the callback is possible. The provided solution follows the TC39 specification for array mutation scenarios:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The range of elements processed by \",(0,n.jsx)(e.code,{children:\"reduce\"}),\" is set before the first callback is called.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Elements appended to the array after the call to \",(0,n.jsx)(e.code,{children:\"reduce\"}),\" begins will not be visited by the callback.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If existing elements of the array are changed, their value as passed to the callback will be the value at the time \",(0,n.jsx)(e.code,{children:\"reduce\"}),\" visits them.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Elements that are deleted after the call to \",(0,n.jsx)(e.code,{children:\"reduce\"}),\" begins and before being visited are not visited.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"One-liner solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"You can cheat the autograder by doing this:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`Array.prototype.myReduce = Array.prototype.reduce;\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Spec solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here's a solution that is based off the \",(0,n.jsxs)(e.a,{href:\"https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reduce\",children:[(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),\" ECMAScript specification\"]}),\".\"]}),`\n`,(0,n.jsx)(l,{children:p}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\",children:[(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),\" | MDN\"]})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.reduce\",children:[(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),\" ECMAScript specification\"]})}),`\n`]})]})}function F(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var j=F;return v(R);})();\n;return Component;"
}