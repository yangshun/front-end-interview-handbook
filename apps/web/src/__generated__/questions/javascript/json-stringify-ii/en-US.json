{
  "description": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var y=(i,n)=>()=>(n||i((n={exports:{}}).exports,n),n.exports),S=(i,n)=>{for(var r in n)o(i,r,{get:n[r],enumerable:!0})},l=(i,n,r,a)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let t of g(n))!p.call(i,t)&&t!==r&&o(i,t,{get:()=>n[t],enumerable:!(a=h(n,t))||a.enumerable});return i};var j=(i,n,r)=>(r=i!=null?d(u(i)):{},l(n||!i||!i.__esModule?o(r,\"default\",{value:i,enumerable:!0}):r,i)),m=i=>l(o({},\"__esModule\",{value:!0}),i);var c=y((N,s)=>{s.exports=_jsx_runtime});var v={};S(v,{default:()=>O,frontmatter:()=>b});var e=j(c()),b={title:\"JSON.stringify II\",excerpt:\"Implement a function that converts a JavaScript value into a JSON string\"};function f(i){let n=Object.assign({p:\"p\",code:\"code\",a:\"a\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},i.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"Implement your a \",(0,e.jsx)(n.code,{children:\"jsonStringify\"}),\" function that converts a JavaScript value into a JSON string, similar to \",(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\",children:(0,e.jsx)(n.code,{children:\"JSON.stringify\"})}),\".\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"You may ignore the \",(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#parameters\",children:\"second and the third\"}),\" optional parameters in the original API.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"The function should behave exactly like \",(0,e.jsx)(n.code,{children:\"JSON.stringify()\"}),\" for any data type. Refer to the examples below.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"Other cases:\",`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"Cyclic references: throw \",(0,e.jsx)(n.code,{children:\"TypeError('Converting circular structure to JSON')\"}),\".\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"BigInt\"}),\": throw \",(0,e.jsx)(n.code,{children:\"TypeError('Do not know how to serialize a BigInt')\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`jsonStringify({ foo: 'bar' }); // '{\"foo\":\"bar\"}'\njsonStringify({ foo: 'bar', bar: [1, 2, 3] }); // '{\"foo\":\"bar\",bar:[1,2,3]}'\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"Other types and their expected behavior:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`jsonStringify(); // undefined\njsonStringify(undefined); // undefined\njsonStringify(null); // 'null'\njsonStringify(true); // 'true'\njsonStringify(false); // 'false'\njsonStringify(1); // '1'\njsonStringify(Infinity); // 'null'\njsonStringify(NaN); // 'null'\njsonStringify('foo'); // '\"foo\"'\njsonStringify('\"foo\"') === '\"\\\\\\\\\"foo\\\\\\\\\"\"'; // Double quotes present in the original input are escaped using backslashes\njsonStringify(Symbol('foo')); // undefined\njsonStringify(() => {}); // undefined\njsonStringify(['foo', 'bar']); // '[\"foo\",\"bar\"]'\njsonStringify(/foo/); // '{}'\njsonStringify(new Map()); // '{}'\njsonStringify(new Set()); // '{}'\n`})})]})}function x(i={}){let{wrapper:n}=i.components||{};return n?(0,e.jsx)(n,Object.assign({},i,{children:(0,e.jsx)(f,i)})):f(i)}var O=x;return m(v);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/json-stringify-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/json-stringify-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/json-stringify-ii.run.test.ts": "import jsonStringify from './json-stringify-ii';\n\ndescribe('jsonStringify', () => {\n  test('strings', () => {\n    expect(jsonStringify('123')).toEqual('\"123\"');\n  });\n\n  test('array', () => {\n    expect(jsonStringify([1, 2, 3])).toEqual('[1,2,3]');\n  });\n\n  test('object', () => {\n    expect(jsonStringify({ name: 'John', age: 30 })).toEqual(\n      '{\"name\":\"John\",\"age\":30}',\n    );\n  });\n});\n",
    "/src/json-stringify-ii.submit.test.ts": "import jsonStringify from './json-stringify-ii';\n\ndescribe('jsonStringify', () => {\n  describe('primitives', () => {\n    test('undefined', () => {\n      expect(jsonStringify(undefined)).toEqual(undefined);\n    });\n\n    test('null', () => {\n      expect(jsonStringify(null)).toEqual('null');\n    });\n\n    test('boolean', () => {\n      expect(jsonStringify(true)).toEqual('true');\n      expect(jsonStringify(false)).toEqual('false');\n    });\n\n    test('numbers', () => {\n      expect(jsonStringify(1)).toEqual('1');\n      expect(jsonStringify(-1)).toEqual('-1');\n    });\n\n    test('strings', () => {\n      expect(jsonStringify('123')).toEqual('\"123\"');\n      expect(jsonStringify('foo')).toEqual('\"foo\"');\n      expect(jsonStringify('\"foo\"')).toEqual('\"\\\\\"foo\\\\\"\"');\n    });\n  });\n\n  describe('special values', () => {\n    test('NaN', () => {\n      expect(jsonStringify(NaN)).toEqual('null');\n    });\n\n    test('infinity', () => {\n      expect(jsonStringify(Infinity)).toEqual('null');\n    });\n\n    test('symbol', () => {\n      expect(jsonStringify(Symbol('foo'))).toEqual(undefined);\n    });\n\n    test('functions', () => {\n      expect(jsonStringify(() => {})).toEqual(undefined);\n      expect(jsonStringify(function () {})).toEqual(undefined);\n    });\n\n    test('regexp', () => {\n      expect(jsonStringify(/foo/)).toEqual('{}');\n    });\n\n    test('map', () => {\n      expect(jsonStringify(new Map())).toEqual('{}');\n    });\n\n    test('set', () => {\n      expect(jsonStringify(new Set())).toEqual('{}');\n    });\n\n    test('date', () => {\n      const date = new Date();\n      expect(jsonStringify(date)).toEqual(`\"${date.toISOString()}\"`);\n    });\n\n    test('BigInt throws', () => {\n      expect(() => jsonStringify(BigInt(1234567890))).toThrow();\n    });\n  });\n\n  describe('arrays', () => {\n    test('empty', () => {\n      expect(jsonStringify([])).toEqual('[]');\n    });\n\n    test('non-nested', () => {\n      expect(jsonStringify([1, 2, 3])).toEqual('[1,2,3]');\n      expect(jsonStringify([true, false])).toEqual('[true,false]');\n      expect(jsonStringify(['1', '2', '3'])).toEqual('[\"1\",\"2\",\"3\"]');\n      expect(jsonStringify([{}, {}])).toEqual('[{},{}]');\n      expect(jsonStringify([null, null])).toEqual('[null,null]');\n    });\n\n    test('nested', () => {\n      expect(jsonStringify([[]])).toEqual('[[]]');\n      expect(jsonStringify([[[]]])).toEqual('[[[]]]');\n      expect(jsonStringify([[], []])).toEqual('[[],[]]');\n      expect(jsonStringify([[1], [2]])).toEqual('[[1],[2]]');\n      expect(jsonStringify([1, [2, [3, [4, []]]]])).toEqual(\n        '[1,[2,[3,[4,[]]]]]',\n      );\n      expect(jsonStringify([1, 2, [3, 4, [5, 6], 7, 8]])).toEqual(\n        '[1,2,[3,4,[5,6],7,8]]',\n      );\n    });\n\n    test('mixed', () => {\n      expect(\n        jsonStringify([\n          42,\n          'Hello, World!',\n          true,\n          null,\n          { name: 'John', age: 30 },\n          [1, 2, 3],\n        ]),\n      ).toEqual(\n        '[42,\"Hello, World!\",true,null,{\"name\":\"John\",\"age\":30},[1,2,3]]',\n      );\n    });\n  });\n\n  describe('objects', () => {\n    test('empty', () => {\n      expect(jsonStringify({})).toEqual('{}');\n    });\n\n    test('non-nested', () => {\n      expect(jsonStringify({ foo: 1 })).toEqual('{\"foo\":1}');\n      expect(jsonStringify({ foo: true })).toEqual('{\"foo\":true}');\n      expect(jsonStringify({ foo: false })).toEqual('{\"foo\":false}');\n      expect(jsonStringify({ foo: 'bar' })).toEqual('{\"foo\":\"bar\"}');\n      expect(jsonStringify({ foo: [] })).toEqual('{\"foo\":[]}');\n      expect(jsonStringify({ foo: null })).toEqual('{\"foo\":null}');\n    });\n\n    test('nested', () => {\n      expect(jsonStringify({ foo: { foo: true } })).toEqual(\n        '{\"foo\":{\"foo\":true}}',\n      );\n      expect(jsonStringify({ foo: true, bar: { foo: 2 } })).toEqual(\n        '{\"foo\":true,\"bar\":{\"foo\":2}}',\n      );\n    });\n\n    test('mixed', () => {\n      expect(\n        jsonStringify({\n          name: 'foo',\n          age: 18,\n          attr: ['coding', 123],\n        }),\n      ).toEqual('{\"name\":\"foo\",\"age\":18,\"attr\":[\"coding\",123]}');\n    });\n\n    test('JSON-incompatible values', () => {\n      expect(jsonStringify([1, 2, 3])).toEqual('[1,2,3]');\n      expect(\n        jsonStringify({\n          name: 'foo',\n          age: 18,\n          attr: ['coding', 123],\n          uni: Symbol(2),\n          sayHi: function () {\n            console.log('hi');\n          },\n          info: {\n            sister: 'lily',\n            age: 16,\n            intro: {\n              money: undefined,\n              job: null,\n            },\n          },\n        }),\n      ).toEqual(\n        '{\"name\":\"foo\",\"age\":18,\"attr\":[\"coding\",123],\"info\":{\"sister\":\"lily\",\"age\":16,\"intro\":{\"job\":null}}}',\n      );\n    });\n  });\n\n  test('cyclic objects', () => {\n    const foo: any = {};\n    foo.a = foo;\n\n    expect(() => {\n      jsonStringify(foo);\n    }).toThrow('Converting circular structure to JSON');\n  });\n});\n",
    "/src/json-stringify-ii.ts": "function isCyclic(input: unknown): boolean {\n  const seen = new Set();\n\n  function dfsHelper(value: unknown): boolean {\n    if (typeof value !== 'object' || value === null) {\n      return false;\n    }\n\n    seen.add(value);\n    return Object.values(value).some(\n      (value_) => seen.has(value_) || dfsHelper(value_),\n    );\n  }\n\n  return dfsHelper(input);\n}\n\nconst QUOTE_ESCAPE = /\"/g;\n\nexport default function jsonStringify(value: unknown): string | undefined {\n  if (isCyclic(value)) {\n    throw new TypeError('Converting circular structure to JSON');\n  }\n\n  if (typeof value === 'bigint') {\n    throw new TypeError('Do not know how to serialize a BigInt');\n  }\n\n  if (value === null) {\n    // Handle null first because the type of null is 'object'.\n    return 'null';\n  }\n\n  const type = typeof value;\n\n  if (type === 'number') {\n    if (Number.isNaN(value) || !Number.isFinite(value)) {\n      // For NaN and Infinity we return 'null'.\n      return 'null';\n    }\n    return String(value);\n  }\n\n  if (type === 'boolean') {\n    return String(value);\n  }\n\n  if (type === 'function' || type === 'undefined' || type === 'symbol') {\n    return undefined; // Not the string 'undefined'.\n  }\n\n  if (type === 'string') {\n    // Wrap in double quotes/\n    return `\"${(value as string).replace(QUOTE_ESCAPE, '\\\\\"')}\"`;\n  }\n\n  // At this point `value` is either an array, a plain object,\n  // or other unsupported object types such as `Map` and `Set`.\n  if (typeof (value as any).toJSON === 'function') {\n    // If value has user-provided `toJSON` method, we use that instead.\n    return jsonStringify((value as any).toJSON());\n  }\n\n  if (Array.isArray(value)) {\n    const arrayValues = value.map((item) => jsonStringify(item));\n    return `[${arrayValues.join(',')}]`;\n  }\n\n  // `value` is a plain object.\n  const objectEntries = Object.entries(value as Object)\n    .map(([key, value]) => {\n      const shouldIgnoreEntry =\n        typeof key === 'symbol' ||\n        value === undefined ||\n        typeof value === 'function' ||\n        typeof value === 'symbol';\n\n      if (shouldIgnoreEntry) {\n        return;\n      }\n\n      return `\"${key}\":${jsonStringify(value)}`;\n    })\n    .filter((value) => value !== undefined);\n\n  return `{${objectEntries.join(',')}}`;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "zhenghao",
    "companies": [
      "snap",
      "amazon",
      "google"
    ],
    "created": 1653177600,
    "difficulty": "hard",
    "duration": 45,
    "excerpt": "Implement a function that converts a JavaScript value into a JSON string",
    "featured": true,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/json-stringify-ii",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "html-serializer"
    ],
    "slug": "json-stringify-ii",
    "subtitle": null,
    "title": "JSON.stringify II",
    "topics": [
      "recursion"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {*} value\n * @return {string}\n */\nexport default function jsonStringify(value) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function jsonStringify(value: unknown): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),S=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!m.call(t,i)&&i!==r&&o(t,i,{get:()=>e[i],enumerable:!(a=y(e,i))||a.enumerable});return t};var j=(t,e,r)=>(r=t!=null?p(g(t)):{},l(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>l(o({},\"__esModule\",{value:!0}),t);var s=b((C,u)=>{u.exports=_jsx_runtime});var E={};S(E,{default:()=>J});var n=j(s());var c=MDXCodeBlock;var d=`function isCyclic(input) {\n  const seen = new Set();\n\n  function dfsHelper(value) {\n    if (typeof value !== 'object' || value === null) {\n      return false;\n    }\n\n    seen.add(value);\n    return Object.values(value).some(\n      (value_) => seen.has(value_) || dfsHelper(value_),\n    );\n  }\n\n  return dfsHelper(input);\n}\n\nconst QUOTE_ESCAPE = /\"/g;\n\n/**\n * @param {*} value\n * @return {string}\n */\nexport default function jsonStringify(value) {\n  if (isCyclic(value)) {\n    throw new TypeError('Converting circular structure to JSON');\n  }\n\n  if (typeof value === 'bigint') {\n    throw new TypeError('Do not know how to serialize a BigInt');\n  }\n\n  if (value === null) {\n    // Handle null first because the type of null is 'object'.\n    return 'null';\n  }\n\n  const type = typeof value;\n\n  if (type === 'number') {\n    if (Number.isNaN(value) || !Number.isFinite(value)) {\n      // For NaN and Infinity we return 'null'.\n      return 'null';\n    }\n    return String(value);\n  }\n\n  if (type === 'boolean') {\n    return String(value);\n  }\n\n  if (type === 'function' || type === 'undefined' || type === 'symbol') {\n    return undefined; // Not the string 'undefined'.\n  }\n\n  if (type === 'string') {\n    // Wrap in double quotes/\n    return \\`\"\\${value.replace(QUOTE_ESCAPE, '\\\\\\\\\"')}\"\\`;\n  }\n\n  // At this point \\`value\\` is either an array, a plain object,\n  // or other unsupported object types such as \\`Map\\` and \\`Set\\`.\n  if (typeof value.toJSON === 'function') {\n    // If value has user-provided \\`toJSON\\` method, we use that instead.\n    return jsonStringify(value.toJSON());\n  }\n\n  if (Array.isArray(value)) {\n    const arrayValues = value.map((item) => jsonStringify(item));\n    return \\`[\\${arrayValues.join(',')}]\\`;\n  }\n\n  // \\`value\\` is a plain object.\n  const objectEntries = Object.entries(value)\n    .map(([key, value]) => {\n      const shouldIgnoreEntry =\n        typeof key === 'symbol' ||\n        value === undefined ||\n        typeof value === 'function' ||\n        typeof value === 'symbol';\n\n      if (shouldIgnoreEntry) {\n        return;\n      }\n\n      return \\`\"\\${key}\":\\${jsonStringify(value)}\\`;\n    })\n    .filter((value) => value !== undefined);\n\n  return \\`{\\${objectEntries.join(',')}}\\`;\n}\n`;var h=`function isCyclic(input: unknown): boolean {\n  const seen = new Set();\n\n  function dfsHelper(value: unknown): boolean {\n    if (typeof value !== 'object' || value === null) {\n      return false;\n    }\n\n    seen.add(value);\n    return Object.values(value).some(\n      (value_) => seen.has(value_) || dfsHelper(value_),\n    );\n  }\n\n  return dfsHelper(input);\n}\n\nconst QUOTE_ESCAPE = /\"/g;\n\nexport default function jsonStringify(value: unknown): string | undefined {\n  if (isCyclic(value)) {\n    throw new TypeError('Converting circular structure to JSON');\n  }\n\n  if (typeof value === 'bigint') {\n    throw new TypeError('Do not know how to serialize a BigInt');\n  }\n\n  if (value === null) {\n    // Handle null first because the type of null is 'object'.\n    return 'null';\n  }\n\n  const type = typeof value;\n\n  if (type === 'number') {\n    if (Number.isNaN(value) || !Number.isFinite(value)) {\n      // For NaN and Infinity we return 'null'.\n      return 'null';\n    }\n    return String(value);\n  }\n\n  if (type === 'boolean') {\n    return String(value);\n  }\n\n  if (type === 'function' || type === 'undefined' || type === 'symbol') {\n    return undefined; // Not the string 'undefined'.\n  }\n\n  if (type === 'string') {\n    // Wrap in double quotes/\n    return \\`\"\\${(value as string).replace(QUOTE_ESCAPE, '\\\\\\\\\"')}\"\\`;\n  }\n\n  // At this point \\`value\\` is either an array, a plain object,\n  // or other unsupported object types such as \\`Map\\` and \\`Set\\`.\n  if (typeof (value as any).toJSON === 'function') {\n    // If value has user-provided \\`toJSON\\` method, we use that instead.\n    return jsonStringify((value as any).toJSON());\n  }\n\n  if (Array.isArray(value)) {\n    const arrayValues = value.map((item) => jsonStringify(item));\n    return \\`[\\${arrayValues.join(',')}]\\`;\n  }\n\n  // \\`value\\` is a plain object.\n  const objectEntries = Object.entries(value as Object)\n    .map(([key, value]) => {\n      const shouldIgnoreEntry =\n        typeof key === 'symbol' ||\n        value === undefined ||\n        typeof value === 'function' ||\n        typeof value === 'symbol';\n\n      if (shouldIgnoreEntry) {\n        return;\n      }\n\n      return \\`\"\\${key}\":\\${jsonStringify(value)}\\`;\n    })\n    .filter((value) => value !== undefined);\n\n  return \\`{\\${objectEntries.join(',')}}\\`;\n}\n`;function f(t){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",h3:\"h3\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This is a hard problem, not necessarily because the logic or the algorithm is hard to understand (although there are certain complexities), but more because you have to be very familiar with the \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" API and know all the intricacies when data types that are not supported by JSON are passed to the function (e.g. functions, \",(0,n.jsx)(e.code,{children:\"regex\"}),\", and \",(0,n.jsx)(e.code,{children:\"Date\"}),\" object). It's extremely unlikely to be asked to implement a solution that handles that many data types during interviews.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Handling data types\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"When passed directly with unsupported type \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\", and \",(0,n.jsx)(e.code,{children:\"Function\"}),\", JSON.stringify outputs \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" (not the string \",(0,n.jsx)(e.code,{children:\"'undefined'\"}),\"):\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`JSON.stringify(undefined); // undefined\nJSON.stringify(Symbol('foo')); // undefined\nJSON.stringify(() => {}); // undefined\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For other built-in object types (except for \",(0,n.jsx)(e.code,{children:\"Function\"}),\" and \",(0,n.jsx)(e.code,{children:\"Date\"}),\") such as \",(0,n.jsx)(e.code,{children:\"Map\"}),\", \",(0,n.jsx)(e.code,{children:\"Set\"}),\", \",(0,n.jsx)(e.code,{children:\"WeakMap\"}),\", \",(0,n.jsx)(e.code,{children:\"WeakSet\"}),\", \",(0,n.jsx)(e.code,{children:\"Regex\"}),\", etc., \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" will return a string of an empty object literal, i.e. \",(0,n.jsx)(e.code,{children:\"{}\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`JSON.stringify(/foo/); // '{}'\nJSON.stringify(new Map()); // '{}'\nJSON.stringify(new Set()); //'{}'\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"NaN\"}),\" and \",(0,n.jsx)(e.code,{children:\"Infinity\"}),\" are converted into \",(0,n.jsx)(e.code,{children:\"null\"}),\", and \",(0,n.jsx)(e.code,{children:\"Date\"}),\" objects are encoded into ISO strings by \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" because of \",(0,n.jsx)(e.code,{children:\"Date.prototype.toJSON\"}),\". And yes, we will have to take care of a custom \",(0,n.jsx)(e.code,{children:\"toJSON\"}),\" method present in the input value.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Cyclic references\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Finally, \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" can detect a cyclic object i.e. objects with circular references and bail out from the stringification by throwing an error. We will have to account for that as well.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const foo = {};\nfoo.a = foo;\n\nJSON.stringify(foo); // \\u274C Uncaught TypeError: Converting circular structure to JSON\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"To detect circular references in an object, we can use a \",(0,n.jsx)(e.code,{children:\"Set\"}),\" to keep track of property values we have visited while traversing the object. As soon as we find a value that exists in the set already, we know the object has circular references.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Here is how we would write it:\"}),`\n`,(0,n.jsx)(c,{languages:{jsx:d,tsx:h}}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"There are still uncovered edge cases with the current implementation. Check out \",(0,n.jsx)(e.a,{href:\"https://262.ecma-international.org/5.1/#sec-15.12.3\",children:\"the spec\"}),\" if you are interested in learning more about it.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"In particular, special characters like \",(0,n.jsx)(e.code,{children:\"\\\\n\"}),\", \",(0,n.jsx)(e.code,{children:\"\\\\t\"}),\" need to be converted into \",(0,n.jsx)(e.code,{children:\"\\\\\\\\n\"}),\", \",(0,n.jsx)(e.code,{children:\"\\\\\\\\t\"}),\" respectively.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"One possible follow-up question could be to make it faster. The current implementation involves frequent runtime type checks due to the dynamic typing nature of the JavaScript language. One way we can make the above implementation of \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\" faster is to have the user provide a schema of the object (e.g. using \",(0,n.jsx)(e.a,{href:\"https://json-schema.org/\",children:\"JSON Schema\"}),\") so we know the object structure before serialization. This can save us a ton of guesswork. In fact, many \",(0,n.jsx)(e.code,{children:\"JSON.stringify\"}),\"-alternative libraries are implemented this way to make serialization faster. One example would be \",(0,n.jsx)(e.a,{href:\"https://github.com/fastify/fast-json-stringify\",children:\"fast-json-stringify\"}),\".\"]}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var J=k;return w(E);})();\n;return Component;",
  "workspace": {
    "main": "/src/json-stringify-ii.ts",
    "run": "/src/json-stringify-ii.run.test.ts",
    "submit": "/src/json-stringify-ii.submit.test.ts"
  }
}