{
  "description": "var Component=(()=>{var h=Object.create;var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var f=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),x=(o,e)=>{for(var t in e)l(o,t,{get:e[t],enumerable:!0})},c=(o,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of g(e))!m.call(o,s)&&s!==t&&l(o,s,{get:()=>e[s],enumerable:!(a=u(e,s))||a.enumerable});return o};var y=(o,e,t)=>(t=o!=null?h(p(o)):{},c(e||!o||!o.__esModule?l(t,\"default\",{value:o,enumerable:!0}):t,o)),b=o=>c(l({},\"__esModule\",{value:!0}),o);var r=f((_,i)=>{i.exports=_jsx_runtime});var k={};x(k,{default:()=>v,frontmatter:()=>j});var n=y(r()),j={title:\"Sleep\",excerpt:\"Implement a function that pauses for a specified duration before resuming execution\"};function d(o){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",strong:\"strong\",h2:\"h2\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"In JavaScript, the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" function can be used to execute callbacks after a delay. However, it introduces a layer of nesting in the code which may not be desired. It'd be nice to use \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" in this fashion:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Note: the following code contains invalid syntax and doesn't work.\nconsole.log('Hello!');\nsetTimeout(1000);\nconsole.log('Bye.');\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In languages like Java and Python, a \",(0,n.jsx)(e.code,{children:\"sleep\"}),\" function is available to suspend execution of the calling thread. However, unlike other languages, JavaScript is single-threaded and blocking the main thread is not a good idea. Hence lets implement an \",(0,n.jsx)(e.strong,{children:\"asynchronous\"}),\" version of the \",(0,n.jsx)(e.code,{children:\"sleep\"}),\" function that works similarly but does not block the main thread.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function greeting() {\n  console.log('Hello!');\n  await sleep(2000);\n  console.log('Bye.'); // Only logs after 2000 milliseconds (2 seconds)\n}\n\ngreeting();\n// t = 0: Hello!\n// t = 2000: Bye.\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"sleep\"}),\" function should also be able to be used without \",(0,n.jsx)(e.code,{children:\"await\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`console.log('Hello!');\nsleep(2000).then(() => {\n  console.log('Bye.'); // Only logs after 2000 milliseconds (2 seconds)\n});\n`})})]})}function w(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(d,o)})):d(o)}var v=w;return b(k);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/sleep\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/sleep.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/sleep.run.test.ts": "import sleep from './sleep';\n\ndescribe('sleep', () => {\n  test('returns a promise', () => {\n    const sleepPromise = sleep(1);\n    expect(sleepPromise instanceof Promise).toBe(true);\n  });\n\n  test('executes after delay', async () => {\n    expect.assertions(4);\n    let i = 0;\n    expect(i).toBe(0);\n    let now = Date.now();\n    await sleep(50);\n    expect(i).toBe(0);\n    i++;\n    expect(i).toBe(1);\n    expect(Date.now() - now).toBeGreaterThan(25);\n  });\n\n  test('does not block other async operations', (done) => {\n    expect.assertions(4);\n    let i = 0;\n    expect(i).toBe(0);\n    sleep(50).then(() => {\n      i++;\n      expect(i).toBe(3);\n      done();\n    });\n    setTimeout(() => {\n      i++;\n      expect(i).toBe(2);\n    }, 25);\n    i++;\n    expect(i).toBe(1);\n  });\n});\n",
    "/src/sleep.submit.test.ts": "import sleep from './sleep';\n\ndescribe('sleep', () => {\n  test('returns a promise', () => {\n    const sleepPromise = sleep(1);\n    expect(sleepPromise instanceof Promise).toBe(true);\n  });\n\n  describe('executes after delay', () => {\n    test('with await', async () => {\n      expect.assertions(4);\n      let i = 0;\n      expect(i).toBe(0);\n      let now = Date.now();\n      await sleep(50);\n      expect(i).toBe(0);\n      i++;\n      expect(i).toBe(1);\n      expect(Date.now() - now).toBeGreaterThan(25);\n    });\n\n    test('delay of 0', (done) => {\n      expect.assertions(3);\n      let i = 0;\n      expect(i).toBe(0);\n      sleep(0).then(() => {\n        i++;\n        expect(i).toBe(2);\n        done();\n      });\n      i++;\n      expect(i).toBe(1);\n    });\n\n    test('delay bigger than 0', (done) => {\n      expect.assertions(3);\n      let i = 0;\n      expect(i).toBe(0);\n      sleep(50).then(() => {\n        i++;\n        expect(i).toBe(2);\n        done();\n      });\n      i++;\n      expect(i).toBe(1);\n    });\n\n    test('does not block other async operations', (done) => {\n      expect.assertions(4);\n      let i = 0;\n      expect(i).toBe(0);\n      sleep(50).then(() => {\n        i++;\n        expect(i).toBe(3);\n        done();\n      });\n      setTimeout(() => {\n        i++;\n        expect(i).toBe(2);\n      }, 25);\n      i++;\n      expect(i).toBe(1);\n    });\n  });\n});\n",
    "/src/sleep.ts": "export default async function sleep(duration: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1683331200,
    "difficulty": "easy",
    "duration": 5,
    "excerpt": "Implement a function that pauses for a specified duration before resuming execution",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/sleep",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "sleep",
    "subtitle": null,
    "title": "Sleep",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {number} duration\n * @return {Promise<void>}\n */\nexport default async function sleep(duration) {\n  throw 'Not implemented';\n}",
    "ts": "export default async function sleep(duration: number): Promise<void> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var c=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var k=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var x=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),T=(i,e)=>{for(var o in e)c(i,o,{get:e[o],enumerable:!0})},l=(i,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of f(e))!w.call(i,t)&&t!==o&&c(i,t,{get:()=>e[t],enumerable:!(r=g(e,t))||r.enumerable});return i};var y=(i,e,o)=>(o=i!=null?m(k(i)):{},l(e||!i||!i.__esModule?c(o,\"default\",{value:i,enumerable:!0}):o,i)),v=i=>l(c({},\"__esModule\",{value:!0}),i);var d=x((_,s)=>{s.exports=_jsx_runtime});var D={};T(D,{default:()=>B});var n=y(d());var a=MDXCodeBlock;var h=`/**\n * @param {number} duration\n * @return {Promise<void>}\n */\nexport default async function sleep(duration) {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n`;var u=`export default async function sleep(duration: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n`;function p(i){let e=Object.assign({h2:\"h2\",h3:\"h3\",code:\"code\",ol:\"ol\",li:\"li\",p:\"p\",pre:\"pre\",ul:\"ul\",a:\"a\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Approach 1: Non-blocking using \",(0,n.jsx)(e.code,{children:\"setTimeout\"})]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The sleep function takes a \",(0,n.jsx)(e.code,{children:\"duration\"}),\" parameter representing the time in milliseconds for which the execution should be paused.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"It returns a \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" that will resolve after the specified \",(0,n.jsx)(e.code,{children:\"duration\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Inside the \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" constructor, use \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" to delay the execution of the \",(0,n.jsx)(e.code,{children:\"resolve\"}),\" function, effectively pausing the execution for the specified time.\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{languages:{jsx:h,tsx:u}}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Approach 2: Blocking version of \",(0,n.jsx)(e.code,{children:\"sleep()\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A synchronous, blocking function of \",(0,n.jsx)(e.code,{children:\"sleep\"}),\" can be implemented as such, where the CPU does nothing except repeatedly check if \",(0,n.jsx)(e.code,{children:\"duration\"}),\" has passed since the function started running. Hence, it will pause all execution on the main thread and is usually not desired.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function sleep(duration) {\n  let now = new Date().getTime();\n  while (new Date().getTime() < now + duration) {\n    // Do nothing.\n  }\n  // Proceed when \\`duration\\` has passed since \\`now\\`.\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here's an example to illustrate the difference between the two versions of \",(0,n.jsx)(e.code,{children:\"sleep\"}),\":\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Asynchronous \",(0,n.jsx)(e.code,{children:\"sleep\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function greeting() {\n  console.log('Hello!');\n  await sleep(2000);\n  console.log('Bye.');\n}\n\nsetInterval(() => {\n  console.log('Tick');\n}, 500);\n\ngreeting();\n// t = 0: Hello!\n// t = 500: Tick\n// t = 1000: Tick\n// t = 1500: Tick\n// t = 2000: Tick\n// t = 2000: Bye.\n// t = 2500: Tick\n// t = 3000: Tick\n// ...\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Synchronous/blocking \",(0,n.jsx)(e.code,{children:\"sleep\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function greeting() {\n  console.log('Hello!');\n  sleep(2000);\n  console.log('Bye.');\n}\n\nsetInterval(() => {\n  console.log('Tick');\n}, 500);\n\ngreeting();\n// t = 0: Hello!\n// t = 2000: Bye.\n// t = 2000: Tick\n// t = 2500: Tick\n// t = 3000: Tick\n// ...\n`})}),`\n`,(0,n.jsxs)(e.p,{children:['Note that in this example, the first \"Tick\" is only printed because the ',(0,n.jsx)(e.code,{children:\"sleep()\"}),\" function was executing the entire time (checking the \",(0,n.jsx)(e.code,{children:\"while\"}),\" condition for the full duration).\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://builtin.com/software-engineering-perspectives/javascript-sleep\",children:\"How to Make JavaScript Sleep or Wait\"})}),`\n`]})]})}function P(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(p,i)})):p(i)}var B=P;return v(D);})();\n;return Component;",
  "workspace": {
    "main": "/src/sleep.ts",
    "run": "/src/sleep.run.test.ts",
    "submit": "/src/sleep.submit.test.ts"
  }
}