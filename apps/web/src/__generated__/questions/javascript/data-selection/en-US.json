{
  "description": "var Component=(()=>{var c=Object.create;var r=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),q=(i,e)=>{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},o=(i,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of m(e))!b.call(i,s)&&s!==t&&r(i,s,{get:()=>e[s],enumerable:!(l=h(e,s))||l.enumerable});return i};var g=(i,e,t)=>(t=i!=null?c(p(i)):{},o(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),k=i=>o(r({},\"__esModule\",{value:!0}),i);var d=f((I,u)=>{u.exports=_jsx_runtime});var w={};q(w,{default:()=>x,frontmatter:()=>D});var n=g(d()),D={title:\"Data Selection\",excerpt:\"Implement a function to filter rows of data matching a specified requirement\"};function a(i){let e=Object.assign({p:\"p\",pre:\"pre\",code:\"code\",ul:\"ul\",li:\"li\",strong:\"strong\",h2:\"h2\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"A data set of gym sessions looks like this:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`[\n  { user: 8, duration: 50, equipment: ['bench'] },\n  { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n  { user: 1, duration: 10, equipment: ['barbell'] },\n  { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n  { user: 7, duration: 200, equipment: ['bike'] },\n  { user: 2, duration: 200, equipment: ['treadmill'] },\n  { user: 2, duration: 200, equipment: ['bike'] },\n];\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Each session has the following fields:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"user\"}),\": User ID of the session's user.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"duration\"}),\": Duration of the session, in minutes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"equipment\"}),\": Array of equipment used during the sessions, in alphabetical order. There are only 5 different equipments.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a method \",(0,n.jsx)(e.code,{children:\"selectData\"}),\", which is used to return sessions from the data. It has the interface \",(0,n.jsx)(e.code,{children:\"selectData(sessions [, options])\"}),\". The options available should include:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"user\"}),\": Select only sessions with this \",(0,n.jsx)(e.code,{children:\"id\"}),\". If not specified, include all users (subject to other filters).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"minDuration\"}),\": Select only sessions with \",(0,n.jsx)(e.code,{children:\"duration\"}),\" equal to or greater than this value. If not specified, include all sessions regardless of duration (subject to other filters).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"equipment\"}),\": Select only sessions where at least one of the specified equipments were used. If not specified, include all sessions regardless of equipment used (subject to other filters).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"merge\"}),\": If set to \",(0,n.jsx)(e.code,{children:\"true\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sessions from the same \",(0,n.jsx)(e.code,{children:\"user\"}),\" should be merged into one object. When merging:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sum up the \",(0,n.jsx)(e.code,{children:\"duration\"}),\" fields.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Combine all the \",(0,n.jsx)(e.code,{children:\"equipment\"}),\" used, de-duplicating the values and sorting alphabetically.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"The other filter options should be applied to the merged data.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The order of the results should always remain unchanged from the original set, and in the case of merging user sessions, the row should take the place of the \",(0,n.jsx)(e.strong,{children:\"latest\"}),\" occurrence of that \",(0,n.jsx)(e.code,{children:\"user\"}),\". The input objects should not be modified.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.p,{children:\"The following examples use the data set above:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`selectData(sessions);\n// [\n//   { user: 8, duration: 50, equipment: ['bench'] },\n//   { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n//   { user: 1, duration: 10, equipment: ['barbell'] },\n//   { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n//   { user: 7, duration: 200, equipment: ['bike'] },\n//   { user: 2, duration: 200, equipment: ['treadmill'] },\n//   { user: 2, duration: 200, equipment: ['bike'] },\n// ];\n\nselectData(sessions, { user: 2 });\n// [\n//   { user: 2, duration: 200, equipment: ['treadmill'] },\n//   { user: 2, duration: 200, equipment: ['bike'] },\n// ];\n\nselectData(sessions, { minDuration: 200 });\n// [\n//   { user: 7, duration: 200, equipment: ['bike'] },\n//   { user: 2, duration: 200, equipment: ['treadmill'] },\n//   { user: 2, duration: 200, equipment: ['bike'] },\n// ];\n\nselectData(sessions, { minDuration: 400 });\n// [];\n\nselectData(sessions, { equipment: ['bike', 'dumbbell'] });\n// [\n//   { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n//   { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n//   { user: 7, duration: 200, equipment: ['bike'] },\n//   { user: 2, duration: 200, equipment: ['bike'] },\n// ];\n\nselectData(sessions, { merge: true });\n// [\n//   { user: 8, duration: 50, equipment: ['bench'] },\n//   { user: 1, duration: 10, equipment: ['barbell'] },\n//   { user: 7, duration: 450, equipment: ['bike', 'dumbbell', 'kettlebell'] },\n//   { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n// ];\n\nselectData(sessions, { merge: true, minDuration: 400 });\n// [\n//   { user: 7, duration: 450, equipment: ['bike', 'dumbbell', 'kettlebell'] },\n//   { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n// ];\n`})})]})}function j(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(a,i)})):a(i)}var x=j;return k(w);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/data-selection\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/data-selection.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/data-selection.run.test.ts": "import selectData from './data-selection';\n\nfunction getDataSmall() {\n  return [\n    { user: 8, duration: 50, equipment: ['bench'] },\n    { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n    { user: 1, duration: 10, equipment: ['barbell'] },\n    { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n    { user: 7, duration: 200, equipment: ['bike'] },\n    { user: 2, duration: 200, equipment: ['treadmill'] },\n    { user: 2, duration: 200, equipment: ['bike'] },\n  ];\n}\n\ndescribe('selectData', () => {\n  test('empty data', () => {\n    expect(selectData([])).toEqual([]);\n  });\n\n  test('minDuration', () => {\n    const dataSmall = getDataSmall();\n    expect(selectData(dataSmall, { minDuration: 150 })).toEqual([\n      { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n      { user: 7, duration: 200, equipment: ['bike'] },\n      { user: 2, duration: 200, equipment: ['treadmill'] },\n      { user: 2, duration: 200, equipment: ['bike'] },\n    ]);\n  });\n\n  test('one equipment specified', () => {\n    const dataSmall = getDataSmall();\n    expect(selectData(dataSmall, { equipment: ['bike'] })).toEqual([\n      { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n      { user: 7, duration: 200, equipment: ['bike'] },\n      { user: 2, duration: 200, equipment: ['bike'] },\n    ]);\n  });\n\n  test('merging', () => {\n    const dataSmall = getDataSmall();\n    expect(\n      selectData(dataSmall, {\n        merge: true,\n        minDuration: 400,\n        equipment: ['treadmill', 'bench', 'barbell', 'dumbbell', 'bike'],\n      }),\n    ).toEqual([\n      {\n        user: 7,\n        duration: 450,\n        equipment: ['bike', 'dumbbell', 'kettlebell'],\n      },\n      { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n    ]);\n  });\n});\n",
    "/src/data-selection.submit.test.ts": "import selectData from './data-selection';\n\nfunction getDataSmall() {\n  return [\n    { user: 8, duration: 50, equipment: ['bench'] },\n    { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n    { user: 1, duration: 10, equipment: ['barbell'] },\n    { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n    { user: 7, duration: 200, equipment: ['bike'] },\n    { user: 2, duration: 200, equipment: ['treadmill'] },\n    { user: 2, duration: 200, equipment: ['bike'] },\n  ];\n}\n\ndescribe('selectData', () => {\n  test('empty data', () => {\n    expect(selectData([])).toEqual([]);\n    expect(selectData([], { user: 2 })).toEqual([]);\n    expect(selectData([], { merge: true })).toEqual([]);\n  });\n\n  test('does not mutate data', () => {\n    const dataSmall = getDataSmall();\n    selectData(dataSmall, { user: 1 });\n    selectData(dataSmall, { minDuration: 150 });\n    selectData(dataSmall, {\n      merge: true,\n      equipment: ['treadmill', 'bench', 'barbell', 'dumbbell', 'bike'],\n    });\n\n    const originalDataSmall = getDataSmall();\n    expect(dataSmall).toEqual(originalDataSmall);\n  });\n\n  test('no options', () => {\n    const dataSmall = getDataSmall();\n    const originalDataSmall = getDataSmall();\n    expect(selectData(dataSmall)).toEqual(originalDataSmall);\n  });\n\n  describe('user option', () => {\n    test('user with single session', () => {\n      const dataSmall = getDataSmall();\n      expect(selectData(dataSmall, { user: 1 })).toEqual([\n        { user: 1, duration: 10, equipment: ['barbell'] },\n      ]);\n    });\n\n    test('user with multiple sessions', () => {\n      const dataSmall = getDataSmall();\n      expect(selectData(dataSmall, { user: 2 })).toEqual([\n        { user: 2, duration: 200, equipment: ['treadmill'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n    });\n\n    test('non-existing user', () => {\n      const dataSmall = getDataSmall();\n      expect(selectData(dataSmall, { user: 99 })).toEqual([]);\n    });\n  });\n\n  describe('minDuration option', () => {\n    test('low minDuration', () => {\n      const dataSmallTest1 = getDataSmall();\n      expect(selectData(dataSmallTest1, { minDuration: 150 })).toEqual([\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['treadmill'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n\n      const dataSmallTest2 = getDataSmall();\n      expect(selectData(dataSmallTest2, { minDuration: 151 })).toEqual([\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['treadmill'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n\n      const dataSmallTest3 = getDataSmall();\n      expect(selectData(dataSmallTest3, { minDuration: 200 })).toEqual([\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['treadmill'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n    });\n\n    test('high minDuration', () => {\n      const dataSmall = getDataSmall();\n      expect(selectData(dataSmall, { minDuration: 400 })).toEqual([]);\n    });\n  });\n\n  describe('equipment option', () => {\n    test('no matching equipment', () => {\n      const dataSmall = getDataSmall();\n      expect(selectData(dataSmall, { equipment: ['nah'] })).toEqual([]);\n    });\n\n    test('one equipment specified', () => {\n      const dataSmall = getDataSmall();\n      expect(selectData(dataSmall, { equipment: ['bike'] })).toEqual([\n        { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n    });\n\n    test('multiple equipments specified', () => {\n      const dataSmallTest1 = getDataSmall();\n      expect(\n        selectData(dataSmallTest1, { equipment: ['bike', 'dumbbell'] }),\n      ).toEqual([\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n\n      const dataSmallTest2 = getDataSmall();\n      expect(\n        selectData(dataSmallTest2, {\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        }),\n      ).toEqual([\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n        { user: 7, duration: 200, equipment: ['bike'] },\n        { user: 2, duration: 200, equipment: ['bike'] },\n      ]);\n    });\n  });\n\n  describe('merge option', () => {\n    test('without other options', () => {\n      const dataSmall = getDataSmall();\n      expect(selectData(dataSmall, { merge: true })).toEqual([\n        { user: 8, duration: 50, equipment: ['bench'] },\n        { user: 1, duration: 10, equipment: ['barbell'] },\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n    });\n\n    test('with user', () => {\n      const dataSmallTest1 = getDataSmall();\n      expect(selectData(dataSmallTest1, { merge: true, user: 1 })).toEqual([\n        { user: 1, duration: 10, equipment: ['barbell'] },\n      ]);\n\n      const dataSmallTest2 = getDataSmall();\n      expect(selectData(dataSmallTest2, { merge: true, user: 2 })).toEqual([\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n\n      const dataSmallTest3 = getDataSmall();\n      expect(selectData(dataSmallTest3, { merge: true, user: 7 })).toEqual([\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n      ]);\n    });\n\n    test('with minDuration', () => {\n      const dataSmallTest1 = getDataSmall();\n      expect(\n        selectData(dataSmallTest1, { merge: true, minDuration: 1000 }),\n      ).toEqual([]);\n\n      const dataSmallTest2 = getDataSmall();\n      expect(\n        selectData(dataSmallTest2, { merge: true, minDuration: 400 }),\n      ).toEqual([\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n    });\n\n    test('with equipment', () => {\n      const dataSmallTest1 = getDataSmall();\n      expect(\n        selectData(dataSmallTest1, { merge: true, equipment: ['bike'] }),\n      ).toEqual([\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n\n      const dataSmallTest2 = getDataSmall();\n      expect(\n        selectData(dataSmallTest2, { merge: true, equipment: ['treadmill'] }),\n      ).toEqual([{ user: 2, duration: 400, equipment: ['bike', 'treadmill'] }]);\n\n      const dataSmallTest3 = getDataSmall();\n      expect(\n        selectData(dataSmallTest3, {\n          merge: true,\n          equipment: ['treadmill', 'bench', 'barbell', 'dumbbell', 'bike'],\n        }),\n      ).toEqual([\n        { user: 8, duration: 50, equipment: ['bench'] },\n        { user: 1, duration: 10, equipment: ['barbell'] },\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n    });\n\n    test('with multiple options', () => {\n      const dataSmallTest1 = getDataSmall();\n      expect(\n        selectData(dataSmallTest1, {\n          merge: true,\n          minDuration: 400,\n          equipment: ['treadmill', 'bench', 'barbell', 'dumbbell', 'bike'],\n        }),\n      ).toEqual([\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n\n      const dataSmallTest2 = getDataSmall();\n      expect(\n        selectData(dataSmallTest2, {\n          merge: true,\n          minDuration: 400,\n          equipment: ['treadmill'],\n        }),\n      ).toEqual([{ user: 2, duration: 400, equipment: ['bike', 'treadmill'] }]);\n    });\n  });\n});\n",
    "/src/data-selection.ts": "function setHasOverlap<T>(setA: Set<T>, setB: Set<T>) {\n  // Bundler doesn't transpile properly when doing for-of for sets.\n  for (const val of Array.from(setA)) {\n    if (setB.has(val)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\ntype Session = { user: number; duration: number; equipment: Array<string> };\ntype Options = {\n  user?: number;\n  minDuration?: number;\n  equipment?: Array<string>;\n  merge?: boolean;\n};\n\nexport default function selectData(\n  sessions: Array<Session>,\n  options?: Options,\n): Array<Session> {\n  const reversedSessions = sessions.slice().reverse(); // Make a copy and reverse.\n  const sessionsForUser = new Map();\n  const sessionsProcessed: Array<{\n    user: number;\n    duration: number;\n    equipment: Set<string>;\n  }> = [];\n\n  reversedSessions.forEach((session) => {\n    if (options?.merge && sessionsForUser.has(session.user)) {\n      const userSession = sessionsForUser.get(session.user);\n      userSession.duration += session.duration;\n      session.equipment.forEach((equipment) => {\n        userSession.equipment.add(equipment);\n      });\n    } else {\n      const clonedSession = {\n        ...session,\n        equipment: new Set(session.equipment),\n      };\n\n      if (options?.merge) {\n        sessionsForUser.set(session.user, clonedSession);\n      }\n\n      sessionsProcessed.push(clonedSession);\n    }\n  });\n\n  sessionsProcessed.reverse();\n\n  const results: Array<Session> = [];\n  const optionEquipments = new Set(options?.equipment);\n  sessionsProcessed.forEach((session) => {\n    if (\n      (options?.user != null && options?.user !== session.user) ||\n      (optionEquipments.size > 0 &&\n        !setHasOverlap(optionEquipments, session.equipment)) ||\n      (options?.minDuration != null && options?.minDuration > session.duration)\n    ) {\n      return;\n    }\n\n    results.push({\n      ...session,\n      equipment: Array.from(session.equipment).sort(),\n    });\n  });\n\n  return results;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [
      "soundcloud"
    ],
    "created": 1655596800,
    "difficulty": "hard",
    "duration": 30,
    "excerpt": "Implement a function to filter rows of data matching a specified requirement",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/data-selection",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "unique-array"
    ],
    "slug": "data-selection",
    "subtitle": null,
    "title": "Data Selection",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Array<{user: number, duration: number, equipment: Array<string>}>} sessions\n * @param {{user?: number, minDuration?: number, equipment?: Array<string>, merge?: boolean}} [options]\n * @return {Array}\n */\nexport default function selectData(sessions, options) {\n  throw 'Not implemented!';\n}",
    "ts": "type Session = { user: number; duration: number; equipment: Array<string> };\ntype Options = {\n  user?: number;\n  minDuration?: number;\n  equipment?: Array<string>;\n  merge?: boolean;\n};\n\nexport default function selectData(\n  sessions: Array<Session>,\n  options?: Options,\n): Array<Session> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var t=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var q=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),y=(n,e)=>{for(var o in e)t(n,o,{get:e[o],enumerable:!0})},a=(n,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!b.call(n,i)&&i!==o&&t(n,i,{get:()=>e[i],enumerable:!(r=f(e,i))||r.enumerable});return n};var v=(n,e,o)=>(o=n!=null?m(w(n)):{},a(e||!n||!n.__esModule?t(o,\"default\",{value:n,enumerable:!0}):o,n)),S=n=>a(t({},\"__esModule\",{value:!0}),n);var u=q((M,c)=>{c.exports=_jsx_runtime});var x={};y(x,{default:()=>F});var s=v(u());var d=MDXCodeBlock;var h=`function setHasOverlap(setA, setB) {\n  // Bundler doesn't transpile properly when doing for-of for sets.\n  for (const val of Array.from(setA)) {\n    if (setB.has(val)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * @param {Array<{user: number, duration: number, equipment: Array<string>}>} sessions\n * @param {{user?: number, minDuration?: number, equipment?: Array<string>, merge?: boolean}} [options]\n * @return {Array}\n */\nexport default function selectData(sessions, options = {}) {\n  const reversedSessions = sessions.slice().reverse(); // Make a copy and reverse.\n  const sessionsForUser = new Map();\n  const sessionsProcessed = [];\n\n  reversedSessions.forEach((session) => {\n    if (options.merge && sessionsForUser.has(session.user)) {\n      const userSession = sessionsForUser.get(session.user);\n      userSession.duration += session.duration;\n      session.equipment.forEach((equipment) => {\n        userSession.equipment.add(equipment);\n      });\n    } else {\n      const clonedSession = {\n        ...session,\n        equipment: new Set(session.equipment),\n      };\n\n      if (options.merge) {\n        sessionsForUser.set(session.user, clonedSession);\n      }\n\n      sessionsProcessed.push(clonedSession);\n    }\n  });\n\n  sessionsProcessed.reverse();\n\n  const results = [];\n  const optionEquipments = new Set(options.equipment);\n  sessionsProcessed.forEach((session) => {\n    if (\n      (options.user != null && options.user !== session.user) ||\n      (optionEquipments.size > 0 &&\n        !setHasOverlap(optionEquipments, session.equipment)) ||\n      (options.minDuration != null && options.minDuration > session.duration)\n    ) {\n      return;\n    }\n\n    results.push({\n      ...session,\n      equipment: Array.from(session.equipment).sort(),\n    });\n  });\n\n  return results;\n}\n`;var l=`function setHasOverlap<T>(setA: Set<T>, setB: Set<T>) {\n  // Bundler doesn't transpile properly when doing for-of for sets.\n  for (const val of Array.from(setA)) {\n    if (setB.has(val)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\ntype Session = { user: number; duration: number; equipment: Array<string> };\ntype Options = {\n  user?: number;\n  minDuration?: number;\n  equipment?: Array<string>;\n  merge?: boolean;\n};\n\nexport default function selectData(\n  sessions: Array<Session>,\n  options?: Options,\n): Array<Session> {\n  const reversedSessions = sessions.slice().reverse(); // Make a copy and reverse.\n  const sessionsForUser = new Map();\n  const sessionsProcessed: Array<{\n    user: number;\n    duration: number;\n    equipment: Set<string>;\n  }> = [];\n\n  reversedSessions.forEach((session) => {\n    if (options?.merge && sessionsForUser.has(session.user)) {\n      const userSession = sessionsForUser.get(session.user);\n      userSession.duration += session.duration;\n      session.equipment.forEach((equipment) => {\n        userSession.equipment.add(equipment);\n      });\n    } else {\n      const clonedSession = {\n        ...session,\n        equipment: new Set(session.equipment),\n      };\n\n      if (options?.merge) {\n        sessionsForUser.set(session.user, clonedSession);\n      }\n\n      sessionsProcessed.push(clonedSession);\n    }\n  });\n\n  sessionsProcessed.reverse();\n\n  const results: Array<Session> = [];\n  const optionEquipments = new Set(options?.equipment);\n  sessionsProcessed.forEach((session) => {\n    if (\n      (options?.user != null && options?.user !== session.user) ||\n      (optionEquipments.size > 0 &&\n        !setHasOverlap(optionEquipments, session.equipment)) ||\n      (options?.minDuration != null && options?.minDuration > session.duration)\n    ) {\n      return;\n    }\n\n    results.push({\n      ...session,\n      equipment: Array.from(session.equipment).sort(),\n    });\n  });\n\n  return results;\n}\n`;function p(n){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\",h3:\"h3\",blockquote:\"blockquote\"},n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:\"This question assesses one's familiarity with JavaScript language.\"}),`\n`,(0,s.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,s.jsxs)(e.ul,{children:[`\n`,(0,s.jsxs)(e.li,{children:[\"What is the expected behavior if \",(0,s.jsx)(e.code,{children:\"options\"}),\" contains \",(0,s.jsx)(e.code,{children:\"equipment: []\"}),\"?\",`\n`,(0,s.jsxs)(e.ul,{children:[`\n`,(0,s.jsxs)(e.li,{children:[\"It should treat it as \",(0,s.jsx)(e.code,{children:\"equipment\"}),\" is not specified at all, but we won't test that case.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,s.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,s.jsx)(e.p,{children:\"Let's break the question down into two parts:\"}),`\n`,(0,s.jsxs)(e.ol,{children:[`\n`,(0,s.jsx)(e.li,{children:\"Filtering the sessions according to the options.\"}),`\n`,(0,s.jsxs)(e.li,{children:[\"Merging the sessions by the \",(0,s.jsx)(e.code,{children:\"user\"}),\" field if \",(0,s.jsx)(e.code,{children:\"merge: true\"}),\" is present in the \",(0,s.jsx)(e.code,{children:\"options\"}),\".\"]}),`\n`]}),`\n`,(0,s.jsx)(e.h3,{children:\"Filtering the sessions according to the options\"}),`\n`,(0,s.jsxs)(e.p,{children:[\"Filtering according to the \",(0,s.jsx)(e.code,{children:\"user\"}),\" and \",(0,s.jsx)(e.code,{children:\"minDuration\"}),\" is pretty straightforward. We can use basic operators to check if the \",(0,s.jsx)(e.code,{children:\"user\"}),\" fields match and whether \",(0,s.jsx)(e.code,{children:\"duration > minDuration\"}),\".\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"To match the equipments, we have to determine if the \",(0,s.jsx)(e.code,{children:\"equipment\"}),\" between the \",(0,s.jsx)(e.code,{children:\"options\"}),\" and each session has overlaps. One way is to convert both \",(0,s.jsx)(e.code,{children:\"equipment\"}),\" fields into \",(0,s.jsx)(e.code,{children:\"Set\"}),\"s so that we can perform lookup in O(1) time. We implement a \",(0,s.jsx)(e.code,{children:\"setHasOverlap\"}),\" function to achieve that.\"]}),`\n`,(0,s.jsxs)(e.h3,{children:[\"Merging the sessions by \",(0,s.jsx)(e.code,{children:\"user\"}),\" field\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"This is the tricky part of the question. We have to merge the data for sessions with the same \",(0,s.jsx)(e.code,{children:\"user\"}),\" field and also preserve the order. Note the requirement that:\"]}),`\n`,(0,s.jsxs)(e.blockquote,{children:[`\n`,(0,s.jsx)(e.p,{children:\"in the case of merging sessions with duplicate users, the row should take the place of the latest occurrence of that user. The input objects should not be modified.\"}),`\n`]}),`\n`,(0,s.jsxs)(e.p,{children:[\"It would be easier if the question asked for first occurrence of that user as we can push the session into the array and the position will be the correct final position. If we encounter sessions for the same user again, we can update that earlier session without changing its position in the array. Thankfully, an elegant trick would be to reverse the input array first as \",(0,s.jsx)(e.code,{children:\"reversedSessions\"}),\" and we can treat it as if the question asked to maintain the order of first occurrence of the user.\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"We use a new array \",(0,s.jsx)(e.code,{children:\"sessionsProcessed\"}),\", which will eventually contain sessions in the correct order and the merged user sessions. The array will be be the one we operate on when filtering according to the options.\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"As we iterate through \",(0,s.jsx)(e.code,{children:\"reversedSessions\"}),\", for each session, we see if the \",(0,s.jsx)(e.code,{children:\"user\"}),\" has been encountered before. If it is the first time, we add a new entry to \",(0,s.jsx)(e.code,{children:\"sessionsProcessed\"}),\". Otherwise, we update the combined session with the current session data.\"]}),`\n`,(0,s.jsxs)(e.p,{children:[\"To modify the combined session for a user, we create a \",(0,s.jsx)(e.code,{children:\"Map\"}),\" (\",(0,s.jsx)(e.code,{children:\"sessionsForUser\"}),\") with the key being the user ID and value being the combined session object. Modifying the combined session object can be done through looking up \",(0,s.jsx)(e.code,{children:\"sessionsForUser\"}),\" with the user ID and modifying the value if it exists. The object within \",(0,s.jsx)(e.code,{children:\"sessionsProcessed\"}),\" will be updated as well because they are the same object.\"]}),`\n`,(0,s.jsx)(d,{languages:{jsx:h,tsx:l}}),`\n`,(0,s.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,s.jsxs)(e.ul,{children:[`\n`,(0,s.jsxs)(e.li,{children:[\"Familiarity with JavaScript data structures like \",(0,s.jsx)(e.code,{children:\"Array\"}),\"s and \",(0,s.jsx)(e.code,{children:\"Set\"}),\"s.\"]}),`\n`]})]})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(p,n)})):p(n)}var F=D;return S(x);})();\n;return Component;",
  "workspace": {
    "main": "/src/data-selection.ts",
    "run": "/src/data-selection.run.test.ts",
    "submit": "/src/data-selection.submit.test.ts"
  }
}