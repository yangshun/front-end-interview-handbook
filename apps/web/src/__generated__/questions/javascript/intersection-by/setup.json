{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/intersection-by\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/intersection-by.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/intersection-by.run.test.ts": "import intersectionBy from './intersection-by';\n\ndescribe('intersectionBy', () => {\n  test('intersection of arrays based on iteratee function', () => {\n    const arr1 = [2.1, 1.2];\n    const arr2 = [2.3, 3.4];\n    const arr3 = [4.5, 2.6];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([2.1]);\n  });\n\n  test('no intersection', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [4, 5, 6];\n    const arr3 = [7, 8, 9];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('multiple intersections', () => {\n    const arr1 = [1.2, 2.3, 3.4];\n    const arr2 = [2.1, 1.2, 4.5];\n    const arr3 = [1.2, 4.5, 2.3, 3.4];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([1.2, 2.3]);\n  });\n});\n",
    "/src/intersection-by.submit.test.ts": "import intersectionBy from './intersection-by';\n\ndescribe('intersectionBy', () => {\n  test('empty arrays', () => {\n    const arr1: Array<number> = [];\n    const arr2: Array<number> = [1, 2, 3];\n    const arr3: Array<number> = [];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('intersection of arrays based on iteratee function', () => {\n    const arr1 = [2.1, 1.2];\n    const arr2 = [2.3, 3.4];\n    const arr3 = [4.5, 2.6];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([2.1]);\n  });\n\n  test('no intersection', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [4, 5, 6];\n    const arr3 = [7, 8, 9];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('single array', () => {\n    const arr1 = [1, 2.5, 3, 7.8];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1)).toEqual([1, 2.5, 3, 7.8]);\n  });\n\n  test('multiple intersections', () => {\n    const arr1 = [1.2, 2.3, 3.4];\n    const arr2 = [2.1, 1.2, 4.5];\n    const arr3 = [1.2, 4.5, 2.3, 3.4];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([1.2, 2.3]);\n  });\n\n  test('non-primitive values', () => {\n    const arr1 = [{ id: 1 }, { id: 2 }];\n    const arr2 = [{ id: 2 }, { id: 3 }];\n    const iteratee = (obj: { id: number }) => obj.id;\n\n    expect(intersectionBy(iteratee, arr1, arr2)).toEqual([{ id: 2 }]);\n  });\n\n  test('different iteratee values', () => {\n    const arr1 = ['apple', 'banana', 'pear'];\n    const arr2 = ['orange', 'kiwi', 'banana'];\n    const arr3 = ['grape', 'pear', 'watermelon'];\n    const iteratee = (value: string) => value.length;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual(['pear']);\n  });\n\n  test('same iteratee values in one array', () => {\n    expect(\n      intersectionBy(\n        (str) => str.toLowerCase(),\n        ['apple', 'banana', 'ORANGE', 'orange'],\n        ['Apple', 'Banana', 'Orange'],\n      ),\n    ).toEqual(['apple', 'banana', 'ORANGE']);\n  });\n});\n",
    "/src/intersection-by.ts": "export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  if (arrays.length == 0) {\n    return [];\n  }\n\n  if (arrays.length === 1) {\n    const uniqueSet = new Set<R>();\n    const result = [];\n    for (const value of arrays[0]) {\n      const transformedValue = iteratee(value);\n\n      if (!uniqueSet.has(transformedValue)) {\n        uniqueSet.add(transformedValue);\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  // If any array is empty, the intersection is empty\n  if (arrays.some((arr) => arr.length === 0)) {\n    return [];\n  }\n\n  // Create Sets of transformed values for arrays 2 onwards for O(1) lookup\n  const subsequentSets = arrays\n    .slice(1)\n    .map((array) => new Set(array.map(iteratee)));\n\n  const result = [];\n  const includedTransformedValues = new Set<R>();\n\n  // Check elements from the first array against the sets.\n  for (const value of arrays[0]) {\n    const transformedValue = iteratee(value);\n\n    if (\n      !includedTransformedValues.has(transformedValue) &&\n      subsequentSets.every((set) => set.has(transformedValue))\n    ) {\n      result.push(value); // Add the original value.\n      includedTransformedValues.add(transformedValue); // Mark transformed value as included.\n    }\n  }\n\n  return result;\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Function} iteratee - The iteratee function to apply to each value.\n * @param {Array[]} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the unique values present in all given arrays.\n */\nexport default function intersectionBy(iteratee, ...arrays) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/intersection-by.ts",
    "run": "/src/intersection-by.run.test.ts",
    "submit": "/src/intersection-by.submit.test.ts"
  }
}