{
  "description": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var t in e)i(r,t,{get:e[t],enumerable:!0})},s=(r,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!f.call(r,a)&&a!==t&&i(r,a,{get:()=>e[a],enumerable:!(o=u(e,a))||o.enumerable});return r};var v=(r,e,t)=>(t=r!=null?d(p(r)):{},s(e||!r||!r.__esModule?i(t,\"default\",{value:r,enumerable:!0}):t,r)),b=r=>s(i({},\"__esModule\",{value:!0}),r);var c=y((_,l)=>{l.exports=_jsx_runtime});var w={};g(w,{default:()=>j,frontmatter:()=>x});var n=v(c()),x={title:\"Intersection By\",excerpt:\"Implement a function that returns an array of unique values that are included in all given arrays based on a provided iteratee function\"};function h(r){let e=Object.assign({p:\"p\",code:\"code\",em:\"em\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"intersectionBy\"}),\" function takes an \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" function and multiple arrays as arguments. It first applies the \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" function to transform the values in all arrays. Then, it identifies the set of transformed values that are common across all arrays. Finally, it returns an array containing the original values from the first array which correspond to these common transformed values.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note: The comparison to find common elements uses the values \",(0,n.jsx)(e.em,{children:\"after\"}),\" the iteratee is applied, but the final returned array contains the original values from the first array (\",(0,n.jsx)(e.em,{children:\"before\"}),\" the iteratee was applied).\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`intersectionBy(iteratee, ...arrays);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The iteratee function is invoked with one argument: \",(0,n.jsx)(e.code,{children:\"value\"}),\", where value is the current value being iterated.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"iteratee\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The iteratee invoked per element.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"arrays\"}),\" \",(0,n.jsx)(e.em,{children:\"(Array)\"}),\": The arrays to inspect.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:\"(Array)\"}),\": Returns the new array of intersecting values.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Get the intersection based on the floor value of each number\nconst result = intersectionBy(Math.floor, [1.2, 2.4], [2.5, 3.6]);\n// Compares floored values ([1, 2] vs [2, 3]). Common floor value is 2.\n// Original value from the first array that floors to 2 is 2.4.\n// => [2.4]\n\n// Get the intersection based on the lowercase value of each string\nconst result2 = intersectionBy(\n  (str) => str.toLowerCase(),\n  ['apple', 'banana', 'ORANGE', 'orange'],\n  ['Apple', 'Banana', 'Orange'],\n);\n// Common lowercase results are 'apple', 'banana', 'orange'.\n// Returns corresponding first-occurrence originals from the first array: 'apple', 'banana', 'ORANGE'.\n// => ['apple', 'banana', 'ORANGE']\n\n// Single array case\nintersectionBy(Math.floor, [1, 2.5, 3]); // => [1, 2.5, 3]\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The input arrays may contain any type of values.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The input arrays may have varying lengths.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The input arrays may be empty.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The function should not modify the original arrays.\"}),`\n`,(0,n.jsx)(e.li,{children:\"0 <= number of arrays <= 20\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionBy\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.intersectionBy\"})]})}),`\n`,(0,n.jsxs)(e.li,{children:[\"In Lodash, \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" is optional and is the last parameter, but in this question it is a required parameter for simplicity.\"]}),`\n`]})]})}function T(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var j=T;return b(w);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/intersection-by\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/intersection-by.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/intersection-by.run.test.ts": "import intersectionBy from './intersection-by';\n\ndescribe('intersectionBy', () => {\n  test('intersection of arrays based on iteratee function', () => {\n    const arr1 = [2.1, 1.2];\n    const arr2 = [2.3, 3.4];\n    const arr3 = [4.5, 2.6];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([2.1]);\n  });\n\n  test('no intersection', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [4, 5, 6];\n    const arr3 = [7, 8, 9];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('multiple intersections', () => {\n    const arr1 = [1.2, 2.3, 3.4];\n    const arr2 = [2.1, 1.2, 4.5];\n    const arr3 = [1.2, 4.5, 2.3, 3.4];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([1.2, 2.3]);\n  });\n});\n",
    "/src/intersection-by.submit.test.ts": "import intersectionBy from './intersection-by';\n\ndescribe('intersectionBy', () => {\n  test('empty arrays', () => {\n    const arr1: Array<number> = [];\n    const arr2: Array<number> = [1, 2, 3];\n    const arr3: Array<number> = [];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('intersection of arrays based on iteratee function', () => {\n    const arr1 = [2.1, 1.2];\n    const arr2 = [2.3, 3.4];\n    const arr3 = [4.5, 2.6];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([2.1]);\n  });\n\n  test('no intersection', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [4, 5, 6];\n    const arr3 = [7, 8, 9];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('single array', () => {\n    const arr1 = [1, 2.5, 3, 7.8];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1)).toEqual([1, 2.5, 3, 7.8]);\n  });\n\n  test('multiple intersections', () => {\n    const arr1 = [1.2, 2.3, 3.4];\n    const arr2 = [2.1, 1.2, 4.5];\n    const arr3 = [1.2, 4.5, 2.3, 3.4];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([1.2, 2.3]);\n  });\n\n  test('non-primitive values', () => {\n    const arr1 = [{ id: 1 }, { id: 2 }];\n    const arr2 = [{ id: 2 }, { id: 3 }];\n    const iteratee = (obj: { id: number }) => obj.id;\n\n    expect(intersectionBy(iteratee, arr1, arr2)).toEqual([{ id: 2 }]);\n  });\n\n  test('different iteratee values', () => {\n    const arr1 = ['apple', 'banana', 'pear'];\n    const arr2 = ['orange', 'kiwi', 'banana'];\n    const arr3 = ['grape', 'pear', 'watermelon'];\n    const iteratee = (value: string) => value.length;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual(['pear']);\n  });\n\n  test('same iteratee values in one array', () => {\n    expect(\n      intersectionBy(\n        (str) => str.toLowerCase(),\n        ['apple', 'banana', 'ORANGE', 'orange'],\n        ['Apple', 'Banana', 'Orange'],\n      ),\n    ).toEqual(['apple', 'banana', 'ORANGE']);\n  });\n});\n",
    "/src/intersection-by.ts": "export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  if (arrays.length == 0) {\n    return [];\n  }\n\n  if (arrays.length === 1) {\n    const uniqueSet = new Set<R>();\n    const result = [];\n    for (const value of arrays[0]) {\n      const transformedValue = iteratee(value);\n\n      if (!uniqueSet.has(transformedValue)) {\n        uniqueSet.add(transformedValue);\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  // If any array is empty, the intersection is empty\n  if (arrays.some((arr) => arr.length === 0)) {\n    return [];\n  }\n\n  // Create Sets of transformed values for arrays 2 onwards for O(1) lookup\n  const subsequentSets = arrays\n    .slice(1)\n    .map((array) => new Set(array.map(iteratee)));\n\n  const result = [];\n  const includedTransformedValues = new Set<R>();\n\n  // Check elements from the first array against the sets.\n  for (const value of arrays[0]) {\n    const transformedValue = iteratee(value);\n\n    if (\n      !includedTransformedValues.has(transformedValue) &&\n      subsequentSets.every((set) => set.has(transformedValue))\n    ) {\n      result.push(value); // Add the original value.\n      includedTransformedValues.add(transformedValue); // Mark transformed value as included.\n    }\n  }\n\n  return result;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1687651200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that returns an array of unique values that are included in all given arrays based on a provided iteratee function",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/intersection-by",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "intersection",
      "intersection-with"
    ],
    "slug": "intersection-by",
    "subtitle": null,
    "title": "Intersection By",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Function} iteratee - The iteratee function to apply to each value.\n * @param {Array[]} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the unique values present in all given arrays.\n */\nexport default function intersectionBy(iteratee, ...arrays) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var n=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var S=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),V=(r,e)=>{for(var a in e)n(r,a,{get:e[a],enumerable:!0})},u=(r,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of p(e))!g.call(r,s)&&s!==a&&n(r,s,{get:()=>e[s],enumerable:!(o=y(e,s))||o.enumerable});return r};var T=(r,e,a)=>(a=r!=null?m(v(r)):{},u(e||!r||!r.__esModule?n(a,\"default\",{value:r,enumerable:!0}):a,r)),x=r=>u(n({},\"__esModule\",{value:!0}),r);var l=S((C,i)=>{i.exports=_jsx_runtime});var A={};V(A,{default:()=>j});var t=T(l());var c=MDXCodeBlock;var d=`/**\n * @param {Function} iteratee - The iteratee function to apply to each value.\n * @param {Array[]} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the unique values present in all given arrays.\n */\nexport default function intersectionBy(iteratee, ...arrays) {\n  if (arrays.length == 0) {\n    return [];\n  }\n\n  if (arrays.length === 1) {\n    const uniqueSet = new Set();\n    const result = [];\n    for (const value of arrays[0]) {\n      const transformedValue = iteratee(value);\n\n      if (!uniqueSet.has(transformedValue)) {\n        uniqueSet.add(transformedValue);\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  // If any array is empty, the intersection is empty\n  if (arrays.some((arr) => arr.length === 0)) {\n    return [];\n  }\n\n  // Create Sets of transformed values for arrays 2 onwards for O(1) lookup\n  const subsequentSets = arrays\n    .slice(1)\n    .map((array) => new Set(array.map(iteratee)));\n\n  const result = [];\n  const includedTransformedValues = new Set();\n\n  // Check elements from the first array against the sets.\n  for (const value of arrays[0]) {\n    const transformedValue = iteratee(value);\n\n    if (\n      !includedTransformedValues.has(transformedValue) &&\n      subsequentSets.every((set) => set.has(transformedValue))\n    ) {\n      result.push(value); // Add the original value.\n      includedTransformedValues.add(transformedValue); // Mark transformed value as included.\n    }\n  }\n\n  return result;\n}\n`;var f=`export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  if (arrays.length == 0) {\n    return [];\n  }\n\n  if (arrays.length === 1) {\n    const uniqueSet = new Set<R>();\n    const result = [];\n    for (const value of arrays[0]) {\n      const transformedValue = iteratee(value);\n\n      if (!uniqueSet.has(transformedValue)) {\n        uniqueSet.add(transformedValue);\n        result.push(value);\n      }\n    }\n    return result;\n  }\n\n  // If any array is empty, the intersection is empty\n  if (arrays.some((arr) => arr.length === 0)) {\n    return [];\n  }\n\n  // Create Sets of transformed values for arrays 2 onwards for O(1) lookup\n  const subsequentSets = arrays\n    .slice(1)\n    .map((array) => new Set(array.map(iteratee)));\n\n  const result = [];\n  const includedTransformedValues = new Set<R>();\n\n  // Check elements from the first array against the sets.\n  for (const value of arrays[0]) {\n    const transformedValue = iteratee(value);\n\n    if (\n      !includedTransformedValues.has(transformedValue) &&\n      subsequentSets.every((set) => set.has(transformedValue))\n    ) {\n      result.push(value); // Add the original value.\n      includedTransformedValues.add(transformedValue); // Mark transformed value as included.\n    }\n  }\n\n  return result;\n}\n`;function h(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",a:\"a\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(c,{languages:{jsx:d,tsx:f}}),`\n`,(0,t.jsxs)(e.p,{children:[\"The solution first creates Sets of transformed values from arrays 2 onwards using the iteratee for efficient lookups. It then filters the first array by checking if each element's transformed value is present in all these Sets via \",(0,t.jsx)(e.code,{children:\"has()\"}),\". Finally, it collects the corresponding original values from the first array that satisfy the condition.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionBy\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.intersectionBy\"})]})}),`\n`]})]})}function k(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(h,r)})):h(r)}var j=k;return x(A);})();\n;return Component;",
  "workspace": {
    "main": "/src/intersection-by.ts",
    "run": "/src/intersection-by.run.test.ts",
    "submit": "/src/intersection-by.submit.test.ts"
  }
}