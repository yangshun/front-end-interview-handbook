{
  "description": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var t in e)i(r,t,{get:e[t],enumerable:!0})},c=(r,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!f.call(r,a)&&a!==t&&i(r,a,{get:()=>e[a],enumerable:!(l=u(e,a))||l.enumerable});return r};var v=(r,e,t)=>(t=r!=null?d(m(r)):{},c(e||!r||!r.__esModule?i(t,\"default\",{value:r,enumerable:!0}):t,r)),b=r=>c(i({},\"__esModule\",{value:!0}),r);var s=y((A,o)=>{o.exports=_jsx_runtime});var B={};g(B,{default:()=>w,frontmatter:()=>x});var n=v(s()),x={title:\"Intersection By\",excerpt:\"Implement a function that returns an array of unique values that are included in all given arrays based on a provided iteratee function\"};function h(r){let e=Object.assign({p:\"p\",code:\"code\",em:\"em\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"intersectionBy\"}),\" function takes an \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" function and multiple arrays as arguments. It creates an array of unique values that are included in all given arrays based on the result of applying the \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" function to each value. The order and references of result values are determined by the first array. Note that the values returned are the values \",(0,n.jsx)(e.em,{children:\"before\"}),\" the \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" function is applied, while the comparison is based on the values \",(0,n.jsx)(e.em,{children:\"after\"}),\" the \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" function is applied.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The iteratee function is invoked with one argument: \",(0,n.jsx)(e.code,{children:\"value\"}),\", where value is the current value being iterated.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`intersectionBy(iteratee, ...arrays);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"iteratee\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The iteratee invoked per element.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"arrays\"}),\" \",(0,n.jsx)(e.em,{children:\"(Array)\"}),\": The arrays to inspect.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:\"(Array)\"}),\": Returns the new array of intersecting values.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Get the intersection based on the floor value of each number\nconst result = intersectionBy(Math.floor, [1.2, 2.4], [2.5, 3.6]); // => [2.4]\n\n// Get the intersection based on the lowercase value of each string\nconst result2 = intersectionBy(\n  (str) => str.toLowerCase(),\n  ['apple', 'banana', 'ORANGE', 'orange'],\n  ['Apple', 'Banana', 'Orange'],\n);\n// => ['apple', 'banana', 'ORANGE']\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"In Lodash, \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\" is optional and is the last parameter, but in this question it is a required parameter for simplicity.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"If no arrays are provided, the function will return an empty array.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If any of the arrays are empty, the function will return an empty array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionBy\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.intersectionBy\"})]})}),`\n`]})]})}function j(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var w=j;return b(B);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/intersection-by\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/intersection-by.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/intersection-by.run.test.ts": "import intersectionBy from './intersection-by';\n\ndescribe('intersectionBy', () => {\n  test('intersection of arrays based on iteratee function', () => {\n    const arr1 = [2.1, 1.2];\n    const arr2 = [2.3, 3.4];\n    const arr3 = [4.5, 2.6];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([2.1]);\n  });\n\n  test('no intersection', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [4, 5, 6];\n    const arr3 = [7, 8, 9];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('multiple intersections', () => {\n    const arr1 = [1.2, 2.3, 3.4];\n    const arr2 = [2.1, 1.2, 4.5];\n    const arr3 = [1.2, 4.5, 2.3, 3.4];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([1.2, 2.3]);\n  });\n});\n",
    "/src/intersection-by.submit.test.ts": "import intersectionBy from './intersection-by';\n\ndescribe('intersectionBy', () => {\n  test('empty arrays', () => {\n    const arr1: Array<number> = [];\n    const arr2: Array<number> = [1, 2, 3];\n    const arr3: Array<number> = [];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('intersection of arrays based on iteratee function', () => {\n    const arr1 = [2.1, 1.2];\n    const arr2 = [2.3, 3.4];\n    const arr3 = [4.5, 2.6];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([2.1]);\n  });\n\n  test('no intersection', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [4, 5, 6];\n    const arr3 = [7, 8, 9];\n    const iteratee = String;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([]);\n  });\n\n  test('multiple intersections', () => {\n    const arr1 = [1.2, 2.3, 3.4];\n    const arr2 = [2.1, 1.2, 4.5];\n    const arr3 = [1.2, 4.5, 2.3, 3.4];\n    const iteratee = Math.floor;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual([1.2, 2.3]);\n  });\n\n  test('non-primitive values', () => {\n    const arr1 = [{ id: 1 }, { id: 2 }];\n    const arr2 = [{ id: 2 }, { id: 3 }];\n    const iteratee = (obj: { id: number }) => obj.id;\n\n    expect(intersectionBy(iteratee, arr1, arr2)).toEqual([{ id: 2 }]);\n  });\n\n  test('different iteratee values', () => {\n    const arr1 = ['apple', 'banana', 'pear'];\n    const arr2 = ['orange', 'kiwi', 'banana'];\n    const arr3 = ['grape', 'pear', 'watermelon'];\n    const iteratee = (value: string) => value.length;\n\n    expect(intersectionBy(iteratee, arr1, arr2, arr3)).toEqual(['pear']);\n  });\n\n  test('same iteratee values in one array', () => {\n    expect(\n      intersectionBy(\n        (str) => str.toLowerCase(),\n        ['apple', 'banana', 'ORANGE', 'orange'],\n        ['Apple', 'Banana', 'Orange'],\n      ),\n    ).toEqual(['apple', 'banana', 'ORANGE']);\n  });\n});\n",
    "/src/intersection-by.ts": "export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const mappedArrays = arrays.map((array) => array.map(iteratee));\n  let intersectedValues = mappedArrays[0].filter((value) => {\n    return mappedArrays.every((mappedArray) => mappedArray.includes(value));\n  });\n\n  intersectedValues = intersectedValues.filter((value, index, self) => {\n    return self.indexOf(value) === index;\n  });\n\n  return intersectedValues.map((value) => {\n    const index = mappedArrays[0].indexOf(value);\n    return arrays[0][index];\n  });\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1687651200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that returns an array of unique values that are included in all given arrays based on a provided iteratee function",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/intersection-by",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "intersection",
      "intersection-with"
    ],
    "slug": "intersection-by",
    "subtitle": null,
    "title": "Intersection By",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Function} iteratee - The iteratee function to apply to each value.\n * @param {Array[]} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the unique values present in all given arrays.\n */\nexport default function intersectionBy(iteratee, ...arrays) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var A=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var t in e)s(r,t,{get:e[t],enumerable:!0})},l=(r,e,t,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of h(e))!v.call(r,n)&&n!==t&&s(r,n,{get:()=>e[n],enumerable:!(i=f(e,n))||i.enumerable});return r};var T=(r,e,t)=>(t=r!=null?m(x(r)):{},l(e||!r||!r.__esModule?s(t,\"default\",{value:r,enumerable:!0}):t,r)),j=r=>l(s({},\"__esModule\",{value:!0}),r);var u=A((D,o)=>{o.exports=_jsx_runtime});var M={};g(M,{default:()=>O});var a=T(u());var d=MDXCodeBlock;var c=`/**\n * @param {Function} iteratee - The iteratee function to apply to each value.\n * @param {Array[]} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the unique values present in all given arrays.\n */\nexport default function intersectionBy(iteratee, ...arrays) {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const mappedArrays = arrays.map((array) => array.map(iteratee));\n  let intersectedValues = mappedArrays[0].filter((value) => {\n    return mappedArrays.every((mappedArray) => mappedArray.includes(value));\n  });\n\n  intersectedValues = intersectedValues.filter((value, index, self) => {\n    return self.indexOf(value) === index;\n  });\n\n  return intersectedValues.map((value) => {\n    const index = mappedArrays[0].indexOf(value);\n    return arrays[0][index];\n  });\n}\n`;var p=`export default function intersectionBy<T, R>(\n  iteratee: (value: T) => R,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  if (arrays.length === 0) {\n    return [];\n  }\n\n  const mappedArrays = arrays.map((array) => array.map(iteratee));\n  let intersectedValues = mappedArrays[0].filter((value) => {\n    return mappedArrays.every((mappedArray) => mappedArray.includes(value));\n  });\n\n  intersectedValues = intersectedValues.filter((value, index, self) => {\n    return self.indexOf(value) === index;\n  });\n\n  return intersectedValues.map((value) => {\n    const index = mappedArrays[0].indexOf(value);\n    return arrays[0][index];\n  });\n}\n`;function y(r){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",a:\"a\",code:\"code\"},r.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,a.jsx)(d,{languages:{jsx:c,tsx:p}}),`\n`,(0,a.jsx)(e.p,{children:\"The solution first maps each array using the iteratee function to transform the values. Then, it filters the values from the first mapped array that are present in all the other mapped arrays. Finally, it maps the intersected values back to the original values from the first array.\"}),`\n`,(0,a.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,a.jsxs)(e.ul,{children:[`\n`,(0,a.jsx)(e.li,{children:(0,a.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionBy\",children:[\"Lodash \",(0,a.jsx)(e.code,{children:\"_.intersectionBy\"})]})}),`\n`]})]})}function _(r={}){let{wrapper:e}=r.components||{};return e?(0,a.jsx)(e,Object.assign({},r,{children:(0,a.jsx)(y,r)})):y(r)}var O=_;return j(M);})();\n;return Component;",
  "workspace": {
    "main": "/src/intersection-by.ts",
    "run": "/src/intersection-by.run.test.ts",
    "submit": "/src/intersection-by.submit.test.ts"
  }
}