{
  "description": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),I=(a,e)=>{for(var l in e)c(a,l,{get:e[l],enumerable:!0})},s=(a,e,l,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of u(e))!b.call(a,t)&&t!==l&&c(a,t,{get:()=>e[t],enumerable:!(r=m(e,t))||r.enumerable});return a};var f=(a,e,l)=>(l=a!=null?h(p(a)):{},s(e||!a||!a.__esModule?c(l,\"default\",{value:a,enumerable:!0}):l,a)),g=a=>s(c({},\"__esModule\",{value:!0}),a);var o=v((y,i)=>{i.exports=_jsx_runtime});var k={};I(k,{default:()=>j,frontmatter:()=>x});var n=f(o()),x={title:\"Cancellable Interval\",excerpt:\"Implement a function that acts like setInterval but returns a function to cancel the interval\"};function d(a){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",a:\"a\",h2:\"h2\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"setCancellableInterval\"}),\", that acts like \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" but instead of returning a timer ID, it returns a function that when called, cancels the interval. The \",(0,n.jsx)(e.code,{children:\"setCancellableInterval\"}),\" function should have the exact same signature as \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`setCancellableInterval(callback);\nsetCancellableInterval(callback, delay);\nsetCancellableInterval(callback, delay, param1);\nsetCancellableInterval(callback, delay, param1, param2);\nsetCancellableInterval(callback, delay, param1, param2, /* \\u2026 ,*/ paramN);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You are recommended to read up on for \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" on \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval\",children:\"MDN Docs\"}),\" if you are unfamiliar.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\n// t = 0:\nconst cancel = setCancellableInterval(() => {\n  i++;\n}, 10);\n// t = 10: i is 1\n// t = 20: i is 2\ncancel(); // Called at t = 25\n// t = 30: i is still 2 because cancel() was called and the interval callback has stopped running.\n`})})]})}function C(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var j=C;return g(k);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/cancellable-interval\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/cancellable-interval.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/cancellable-interval.run.test.ts": "import setCancellableInterval from './cancellable-interval';\n\ndescribe('setCancellableInterval', () => {\n  test('returns a function', () => {\n    expect(typeof setCancellableInterval(() => {})).toBe('function');\n  });\n\n  test('cancelled immediately', (done) => {\n    expect.assertions(2);\n    let i = 0;\n\n    setInterval(() => {\n      // Ensure setInterval callback is never called.\n      expect(i).toBe(0);\n      done();\n    });\n    const cancel = setCancellableInterval(() => {\n      i++;\n    }, 10);\n    cancel();\n    expect(i).toBe(0);\n  });\n\n  test('after running once', (done) => {\n    let i = 0;\n\n    const cancel = setCancellableInterval(() => {\n      i++;\n    }, 10);\n\n    setTimeout(() => {\n      expect(i).toBe(1);\n      cancel();\n      done();\n    }, 15);\n\n    expect(i).toBe(0);\n  });\n});\n",
    "/src/cancellable-interval.submit.test.ts": "import setCancellableInterval from './cancellable-interval';\n\ndescribe('setCancellableInterval', () => {\n  test('returns a function', () => {\n    expect(typeof setCancellableInterval(() => {})).toBe('function');\n  });\n\n  describe('cancelled', () => {\n    test('immediately', (done) => {\n      expect.assertions(2);\n      let i = 0;\n\n      setInterval(() => {\n        // Ensure setInterval callback is never called.\n        expect(i).toBe(0);\n        done();\n      });\n      const cancel = setCancellableInterval(() => {\n        i++;\n      }, 10);\n      cancel();\n      expect(i).toBe(0);\n    });\n\n    test('after running once', (done) => {\n      let i = 0;\n\n      const cancel = setCancellableInterval(() => {\n        i++;\n      }, 10);\n\n      setTimeout(() => {\n        expect(i).toBe(1);\n        cancel();\n        done();\n      }, 15);\n\n      expect(i).toBe(0);\n    });\n\n    test('after running twice', (done) => {\n      let i = 0;\n\n      const cancel = setCancellableInterval(() => {\n        i++;\n\n        if (i === 2) {\n          cancel();\n          done();\n        }\n      }, 10);\n\n      expect(i).toBe(0);\n    });\n  });\n\n  test('uses parameters', (done) => {\n    let i = 1;\n    let count = 0;\n\n    const cancel = setCancellableInterval(\n      (foo: number, bar: number) => {\n        count++;\n        i += foo;\n        i *= bar;\n\n        if (count === 1) {\n          expect(i).toBe(21);\n        }\n\n        if (count === 2) {\n          expect(i).toBe(161);\n          cancel();\n          done();\n        }\n      },\n      10,\n      2,\n      7,\n    );\n\n    expect(i).toBe(1);\n  });\n});\n",
    "/src/cancellable-interval.ts": "export default function setCancellableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): () => void {\n  const timerId = setInterval(callback, delay, ...args);\n\n  return () => {\n    clearInterval(timerId);\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1689552000,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement a function that acts like setInterval but returns a function to cancel the interval",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/cancellable-interval",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "cancellable-timeout"
    ],
    "slug": "cancellable-interval",
    "subtitle": null,
    "title": "Cancellable Interval",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {Function}\n */\nexport default function setCancellableInterval(callback, delay, ...args) {\n  throw 'Not implemented';\n}",
    "ts": "export default function setCancellableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): () => void {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var b=Object.create;var l=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var I=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),k=(n,e)=>{for(var t in e)l(n,t,{get:e[t],enumerable:!0})},i=(n,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of I(e))!g.call(n,r)&&r!==t&&l(n,r,{get:()=>e[r],enumerable:!(o=v(e,r))||o.enumerable});return n};var w=(n,e,t)=>(t=n!=null?b(y(n)):{},i(e||!n||!n.__esModule?l(t,\"default\",{value:n,enumerable:!0}):t,n)),A=n=>i(l({},\"__esModule\",{value:!0}),n);var s=x((R,d)=>{d.exports=_jsx_runtime});var W={};k(W,{default:()=>D});var a=w(s());var c=MDXCodeBlock;var h=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {Function}\n */\nexport default function setCancellableInterval(callback, delay, ...args) {\n  const timerId = setInterval(callback, delay, ...args);\n\n  return () => {\n    clearInterval(timerId);\n  };\n}\n`;var u=`export default function setCancellableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): () => void {\n  const timerId = setInterval(callback, delay, ...args);\n\n  return () => {\n    clearInterval(timerId);\n  };\n}\n`;var m=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {Function}\n */\nexport default function setCancellableInterval(...args) {\n  const timerId = setInterval(...args);\n\n  return () => {\n    clearInterval(timerId);\n  };\n}\n`;var p=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {Function}\n */\nexport default function setCancellableInterval(callback, delay, ...args) {\n  let cancelled = false;\n  setInterval(() => {\n    if (cancelled) {\n      return;\n    }\n\n    callback(...args);\n  }, delay);\n\n  return () => {\n    cancelled = true;\n  };\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",a:\"a\",ul:\"ul\",li:\"li\"},n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,a.jsxs)(e.p,{children:[\"The benefit of returning a cancel function as opposed to a \",(0,a.jsx)(e.code,{children:\"timerId\"}),\" is that the interval mechanism is abstracted away, and can be swapped for something else. Realistically though, there aren't many other good ways to achieved interval execution in JavaScript and that's why you probably don't see this outside of interviews.\"]}),`\n`,(0,a.jsxs)(e.h3,{children:[\"Approach 1: Return a function that calls \",(0,a.jsx)(e.code,{children:\"clearInterval\"})]}),`\n`,(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.code,{children:\"setInterval\"}),\" returns a timer ID. To cancel the timer, we can call \",(0,a.jsx)(e.code,{children:\"clearInterval(timerId)\"}),\". One simple way to solve this question is to return a function that does exactly that. We can forward all the parameters to \",(0,a.jsx)(e.code,{children:\"setInterval\"}),\".\"]}),`\n`,(0,a.jsx)(c,{languages:{jsx:h,tsx:u}}),`\n`,(0,a.jsxs)(e.p,{children:[\"We can simplify the code a little and forward all the parameters to \",(0,a.jsx)(e.code,{children:\"setInterval\"}),\".\"]}),`\n`,(0,a.jsx)(c,{children:m}),`\n`,(0,a.jsxs)(e.p,{children:[\"We don't have to worry about \",(0,a.jsx)(e.code,{children:\"this\"}),\" within the callback function because there's no option to pass a \",(0,a.jsx)(e.code,{children:\"thisArg\"}),\" to \",(0,a.jsx)(e.code,{children:\"setInterval\"}),\" unlike \",(0,a.jsx)(e.code,{children:\"Array.prototype.forEach()\"}),\"/\",(0,a.jsx)(e.code,{children:\"Array.prototype.reduce()\"}),\". Read more about \",(0,a.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval#the_this_problem\",children:\"this on MDN\"}),\".\"]}),`\n`,(0,a.jsxs)(e.h3,{children:[\"Approach 2: Maintain a \",(0,a.jsx)(e.code,{children:\"cancelled\"}),\" flag (non-optimal)\"]}),`\n`,(0,a.jsxs)(e.p,{children:[\"Another way is to maintain a \",(0,a.jsx)(e.code,{children:\"cancelled\"}),\" flag that the returned function will set to \",(0,a.jsx)(e.code,{children:\"true\"}),\" when called. Before the \",(0,a.jsx)(e.code,{children:\"setInterval\"}),\" callback is called, check the value of \",(0,a.jsx)(e.code,{children:\"cancelled\"}),\" before executing the \",(0,a.jsx)(e.code,{children:\"callback\"}),\". This is non-optimal because the \",(0,a.jsx)(e.code,{children:\"setInterval\"}),\" callback will run forever without doing nothing!\"]}),`\n`,(0,a.jsx)(c,{children:p}),`\n`,(0,a.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,a.jsxs)(e.ul,{children:[`\n`,(0,a.jsx)(e.li,{children:(0,a.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval\",children:[(0,a.jsx)(e.code,{children:\"setInterval()\"}),\" | MDN\"]})}),`\n`]})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(f,n)})):f(n)}var D=M;return A(W);})();\n;return Component;",
  "workspace": {
    "main": "/src/cancellable-interval.ts",
    "run": "/src/cancellable-interval.run.test.ts",
    "submit": "/src/cancellable-interval.submit.test.ts"
  }
}