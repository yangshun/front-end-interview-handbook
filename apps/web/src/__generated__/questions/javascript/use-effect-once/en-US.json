{
  "description": "var Component=(()=>{var f=Object.create;var r=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var c in e)r(n,c,{get:e[c],enumerable:!0})},s=(n,e,c,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of d(e))!p.call(n,o)&&o!==c&&r(n,o,{get:()=>e[o],enumerable:!(l=h(e,o))||l.enumerable});return n};var j=(n,e,c)=>(c=n!=null?f(m(n)):{},s(e||!n||!n.__esModule?r(c,\"default\",{value:n,enumerable:!0}):c,n)),_=n=>s(r({},\"__esModule\",{value:!0}),n);var i=g((C,u)=>{u.exports=_jsx_runtime});var k={};x(k,{default:()=>b,frontmatter:()=>E});var t=j(i()),E={title:\"useEffectOnce\",excerpt:\"Implement a hook that runs an effect only once\"};function a(n){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a \",(0,t.jsx)(e.code,{children:\"useEffectOnce\"}),\" hook that runs an effect only once.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`export default function Component() {\n  useEffectOnce(() => {\n    console.log('Running effect once on mount');\n\n    return () => {\n      console.log('Running clean-up of effect on unmount');\n    };\n  });\n\n  return null;\n}\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"effect\"}),\": The function that will be executed once. This function has the same parameters and behavior as the first argument of \",(0,t.jsx)(e.code,{children:\"useEffect\"})]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Nothing, just like \",(0,t.jsx)(e.code,{children:\"useEffect\"}),\".\"]})]})}function O(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(a,n)})):a(n)}var b=O;return _(k);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-effect-once\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-effect-once.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/src/use-effect-once.run.test.ts": "import { renderHook } from '@testing-library/react';\n\nimport useEffectOnce from './use-effect-once';\nimport { StrictMode } from 'react';\n\ndescribe('useEffectOnce', () => {\n  test('returns nothing', () => {\n    const { result } = renderHook(() => useEffectOnce(() => {}));\n\n    expect(result.current).toBe(undefined);\n  });\n\n  test('calls the effect once', () => {\n    let counter = 0;\n\n    const { rerender } = renderHook(() =>\n      useEffectOnce(() => {\n        counter += 1;\n      }),\n    );\n\n    expect(counter).toBe(1);\n\n    rerender();\n\n    expect(counter).toBe(1);\n  });\n});\n",
    "/src/use-effect-once.submit.test.ts": "import { renderHook } from '@testing-library/react';\n\nimport useEffectOnce from './use-effect-once';\nimport { StrictMode } from 'react';\n\ndescribe('useEffectOnce', () => {\n  test('returns nothing', () => {\n    const { result } = renderHook(() => useEffectOnce(() => {}));\n\n    expect(result.current).toBe(undefined);\n  });\n\n  test('calls the effect once', () => {\n    let counter = 0;\n\n    const { rerender } = renderHook(() =>\n      useEffectOnce(() => {\n        counter += 1;\n      }),\n    );\n\n    expect(counter).toBe(1);\n\n    rerender();\n\n    expect(counter).toBe(1);\n  });\n\n  test('cleanup function works', () => {\n    let counter = 0;\n\n    const { unmount } = renderHook(() =>\n      useEffectOnce(() => {\n        counter += 1;\n\n        return () => {\n          counter += 1;\n        };\n      }),\n    );\n\n    expect(counter).toBe(1);\n\n    unmount();\n\n    expect(counter).toBe(2);\n  });\n\n  test('calls the effect once across unmounts', () => {\n    let counter = 0;\n\n    const { rerender } = renderHook(\n      () =>\n        useEffectOnce(() => {\n          counter += 1;\n        }),\n      // We could have used `configure({ reactStrictMode: true })` in @testing-library/react@14.2.0+\n      { wrapper: StrictMode },\n    );\n\n    expect(counter).toBe(1);\n\n    rerender();\n\n    expect(counter).toBe(1);\n  });\n});\n",
    "/src/use-effect-once.ts": "import { EffectCallback, useEffect, useRef } from 'react';\n\nexport default function useEffectOnce(effect: EffectCallback) {\n  const ref = useRef<boolean>(false);\n\n  useEffect(() => {\n    if (ref.current) {\n      return;\n    }\n\n    ref.current = true;\n    return effect();\n  }, []);\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "phillmont",
    "companies": [],
    "created": 1742169600,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement a hook that runs an effect only once",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/use-effect-once",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "use-effect-once",
    "subtitle": null,
    "title": "useEffectOnce",
    "topics": []
  },
  "skeleton": {
    "js": "export default function useEffectOnce(effect) {\n  throw 'Not implemented';\n}",
    "ts": "import { EffectCallback } from 'react';\n\nexport default function useEffectOnce(effect: EffectCallback) {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),E=(n,e)=>{for(var c in e)o(n,c,{get:e[c],enumerable:!0})},i=(n,e,c,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!b.call(n,r)&&r!==c&&o(n,r,{get:()=>e[r],enumerable:!(a=m(e,r))||a.enumerable});return n};var y=(n,e,c)=>(c=n!=null?u(w(n)):{},i(e||!n||!n.__esModule?o(c,\"default\",{value:n,enumerable:!0}):c,n)),k=n=>i(o({},\"__esModule\",{value:!0}),n);var f=g((O,s)=>{s.exports=_jsx_runtime});var C={};E(C,{default:()=>j});var t=y(f());var d=MDXCodeBlock;var h=`import { EffectCallback, useEffect, useRef } from 'react';\n\nexport default function useEffectOnce(effect: EffectCallback) {\n  const ref = useRef<boolean>(false);\n\n  useEffect(() => {\n    if (ref.current) {\n      return;\n    }\n\n    ref.current = true;\n    return effect();\n  }, []);\n}\n`;function l(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\",a:\"a\",em:\"em\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"useEffectOnce\"}),\" hook can be implemented with \",(0,t.jsx)(e.code,{children:\"useRef\"}),\" to keep track of whether the effect has been run or not. If this ref's value has changed, it means the effect has been run once, and we shouldn't run it again. We're using \",(0,t.jsx)(e.code,{children:\"useRef\"}),\" here because it doesn't trigger a re-render when its value changes, and is stable across renders.\"]}),`\n`,(0,t.jsx)(d,{children:h}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"You might be tempted to implement \",(0,t.jsx)(e.code,{children:\"useEffectOnce\"}),\" with just \",(0,t.jsx)(e.code,{children:\"useEffect\"}),\" with an empty dependency array.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-tsx\",children:`import { EffectCallback, useEffect, useRef } from 'react';\n\nexport default function useEffectOnce(effect: EffectCallback) {\n  useEffect(effect, []);\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"This implementation will work for most cases, but will cause trouble in development mode with \",(0,t.jsx)(e.a,{href:\"https://react.dev/reference/react/StrictMode\",children:(0,t.jsx)(e.code,{children:\"<StrictMode>\"})}),\", which is the default in every React project. This implementation will only run the effect once across re-renders, but not across \",(0,t.jsx)(e.em,{children:\"unmounts\"}),\". This means that if the component is unmounted and mounted again, the effect will run again. \",(0,t.jsx)(e.code,{children:\"<StrictMode>\"}),\" is supposed to catch these kinds of bugs, and with this implementation, the effect will be run at least twice in development mode; it will be run only once in production mode.\"]}),`\n`,(0,t.jsxs)(e.p,{children:['When the hook says \"once\", it should mean ',(0,t.jsx)(e.em,{children:\"actually\"}),\" once, and never again, throughout the lifetime of the app, unless the browser is refreshed. If the developer wants to instead have the effect run once per mount, they would have already used \",(0,t.jsx)(e.code,{children:\"useEffect\"}),\" with an empty dependency array.\"]})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var j=v;return k(C);})();\n;return Component;",
  "workspace": {
    "main": "/src/use-effect-once.ts",
    "run": "/src/use-effect-once.run.test.ts",
    "submit": "/src/use-effect-once.submit.test.ts"
  }
}