{
  "description": "var Component=(()=>{var l=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var u=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),w=(a,e)=>{for(var t in e)i(a,t,{get:e[t],enumerable:!0})},s=(a,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!m.call(a,r)&&r!==t&&i(a,r,{get:()=>e[r],enumerable:!(c=g(e,r))||c.enumerable});return a};var x=(a,e,t)=>(t=a!=null?l(b(a)):{},s(e||!a||!a.__esModule?i(t,\"default\",{value:a,enumerable:!0}):t,a)),f=a=>s(i({},\"__esModule\",{value:!0}),a);var o=u((_,h)=>{h.exports=_jsx_runtime});var v={};w(v,{default:()=>j,frontmatter:()=>k});var n=x(o()),k={title:\"Text Search\",excerpt:\"Implement a function to highlight text if a searched term appears within it\"};function d(a){let e=Object.assign({p:\"p\",strong:\"strong\",code:\"code\",h2:\"h2\",pre:\"pre\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"In browsers, we are able to find specific words or phrases within a webpage by using \",(0,n.jsx)(\"kbd\",{children:\"Ctrl\"}),\" + \",(0,n.jsx)(\"kbd\",{children:\"F\"}),\" (Windows, Linux) or \",(0,n.jsx)(\"kbd\",{children:\"\\u2318\"}),\" + \",(0,n.jsx)(\"kbd\",{children:\"F\"}),\" (Mac) and entering the search term. Matches which appear will be highlighted in yellow.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's implement a simple version of a browser's in-webpage search with the difference being we're given a string (as opposed to HTML) and search matches appear \",(0,n.jsx)(e.strong,{children:\"bolded\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Given a content string and a query string, implement a function \",(0,n.jsx)(e.code,{children:\"textSearch\"}),\" that finds all case-insensitive matches with the \",(0,n.jsx)(e.code,{children:\"query\"}),\" string, wrapping the matches in \",(0,n.jsx)(e.code,{children:\"<b>...</b>\"}),\" tags.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', 'fox');\n// 'The Quick Brown <b>Fox</b> Jumps Over The Lazy Dog'\ntextSearch('The hardworking Dog overtakes the lazy dog', 'dog');\n// 'The hardworking <b>Dog</b> overtakes the lazy <b>dog</b>'\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"A character will not match the same query more than once, with letters appearing earlier taking priority.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`textSearch('aaa', 'aa');\n// '<b>aa</b>a'\n// This is because the second character cannot be used as a match again.\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Consecutive matches should be combined into a single \",(0,n.jsx)(e.code,{children:\"<b>\"}),\" tag.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`textSearch('aaaa', 'aa');\n// Correct: '<b>aaaa</b>'\n// Wrong: '<b>aa</b><b>aa</b>'\n`})})]})}function y(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var j=y;return f(v);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/text-search\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/text-search.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/text-search.run.test.ts": "import textSearch from './text-search';\n\ndescribe('textSearch', () => {\n  test('empty query', () => {\n    expect(textSearch('', '')).toBe('');\n  });\n\n  test('no matches', () => {\n    expect(textSearch('The quick brown fox jumps over the lazy dog', '')).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n  });\n\n  test('exact match', () => {\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', 'quick'),\n    ).toBe('The <b>quick</b> brown fox jumps over the lazy dog');\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', 'jumps'),\n    ).toBe('The quick brown fox <b>jumps</b> over the lazy dog');\n  });\n\n  test('partial match', () => {\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', 'jump'),\n    ).toBe('The quick brown fox <b>jump</b>s over the lazy dog');\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', 'he'),\n    ).toBe('T<b>he</b> quick brown fox jumps over t<b>he</b> lazy dog');\n  });\n});\n",
    "/src/text-search.submit.test.ts": "import textSearch from './text-search';\n\ndescribe('textSearch', () => {\n  test('empty string', () => {\n    expect(textSearch('', '')).toBe('');\n    expect(textSearch('', 'xyz')).toBe('');\n  });\n\n  test('empty query', () => {\n    expect(textSearch('', '')).toBe('');\n    expect(textSearch('The quick brown fox jumps over the lazy dog', '')).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n  });\n\n  test('no matches', () => {\n    expect(textSearch('The quick brown fox jumps over the lazy dog', '')).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', 'aaa'),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', 'abc'),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', 'dogo'),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n  });\n\n  describe('matches', () => {\n    test('exact match', () => {\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', 'quick'),\n      ).toBe('The <b>quick</b> brown fox jumps over the lazy dog');\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', 'jumps'),\n      ).toBe('The quick brown fox <b>jumps</b> over the lazy dog');\n    });\n\n    test('case-insensitive match', () => {\n      expect(\n        textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', 'fox'),\n      ).toBe('The Quick Brown <b>Fox</b> Jumps Over The Lazy Dog');\n      expect(\n        textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', 'QUICK'),\n      ).toBe('The <b>Quick</b> Brown Fox Jumps Over The Lazy Dog');\n    });\n\n    test('partial match', () => {\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', 'jump'),\n      ).toBe('The quick brown fox <b>jump</b>s over the lazy dog');\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', 'he'),\n      ).toBe('T<b>he</b> quick brown fox jumps over t<b>he</b> lazy dog');\n    });\n\n    test('characters do not match the same word more than once', () => {\n      expect(textSearch('aaabbcc', 'aa')).toBe('<b>aa</b>abbcc');\n    });\n\n    test('consecutive matches have combined tags', () => {\n      expect(textSearch('aabbcc', 'a')).toBe('<b>aa</b>bbcc');\n      expect(textSearch('aabbbbcc', 'bb')).toBe('aa<b>bbbb</b>cc');\n    });\n  });\n});\n",
    "/src/text-search.ts": "export default function textSearch(text: string, query: string): string {\n  if (text.trim() === '' || query.trim() === '') {\n    return text;\n  }\n\n  const boldChars = Array.from({ length: text.length }, () => 0);\n\n  for (let i = 0; i < text.length; ) {\n    const substr = text.slice(i, i + query.length);\n    if (substr.toLowerCase() === query.toLowerCase()) {\n      boldChars.fill(1, i, i + query.length);\n      // Start from next character if there's a match since one\n      // character cannot match the same query more than once.\n      i = i + query.length;\n    } else {\n      i++;\n    }\n  }\n\n  let highlightedString = '';\n  for (let i = 0; i < text.length; i++) {\n    // When the current character should be bolded\n    // and the previous character should not be bolded,\n    // append an opening tag to the final string.\n    const shouldAddOpeningTag = boldChars[i] === 1 && boldChars[i - 1] !== 1;\n    // When the current character should be bolded\n    // and the next character should not be bolded,\n    // append a closing tag to the final string.\n    const shouldAddClosingTag = boldChars[i] === 1 && boldChars[i + 1] !== 1;\n    let char = text[i];\n\n    if (shouldAddOpeningTag) {\n      char = '<b>' + char;\n    }\n\n    if (shouldAddClosingTag) {\n      char = char + '</b>';\n    }\n    highlightedString += char;\n  }\n\n  return highlightedString;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "zhenghao",
    "companies": [],
    "created": 1656288000,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function to highlight text if a searched term appears within it",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/text-search",
    "importance": "medium",
    "languages": [
      "html",
      "js",
      "ts"
    ],
    "nextQuestions": [
      "flatten",
      "promise-all",
      "todo-list"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "text-search-ii"
    ],
    "slug": "text-search",
    "subtitle": null,
    "title": "Text Search",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {string} text\n * @param {string} query\n * @return {string}\n */\nexport default function textSearch(text, query) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function textSearch(text: string, query: string): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var b=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),w=(n,e)=>{for(var r in e)i(n,r,{get:e[r],enumerable:!0})},o=(n,e,r,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!y.call(n,a)&&a!==r&&i(n,a,{get:()=>e[a],enumerable:!(h=f(e,a))||h.enumerable});return n};var C=(n,e,r)=>(r=n!=null?b(m(n)):{},o(e||!n||!n.__esModule?i(r,\"default\",{value:n,enumerable:!0}):r,n)),q=n=>o(i({},\"__esModule\",{value:!0}),n);var s=x((W,c)=>{c.exports=_jsx_runtime});var k={};w(k,{default:()=>A});var t=C(s());var l=MDXCodeBlock;var d=`/**\n * @param {string} text\n * @param {string} query\n * @return {string}\n */\n\nexport default function textSearch(text, query) {\n  if (text.trim() === '' || query.trim() === '') {\n    return text;\n  }\n\n  const boldChars = Array.from({ length: text.length }, () => 0);\n\n  for (let i = 0; i < text.length; ) {\n    const substr = text.slice(i, i + query.length);\n    if (substr.toLowerCase() === query.toLowerCase()) {\n      boldChars.fill(1, i, i + query.length);\n      // Start from next character if there's a match since one\n      // character cannot match the same query more than once.\n      i = i + query.length;\n    } else {\n      i++;\n    }\n  }\n\n  let highlightedString = '';\n  for (let i = 0; i < text.length; i++) {\n    // When the current character should be bolded\n    // and the previous character should not be bolded,\n    // append an opening tag to the final string.\n    const shouldAddOpeningTag = boldChars[i] === 1 && boldChars[i - 1] !== 1;\n    // When the current character should be bolded\n    // and the next character should not be bolded,\n    // append a closing tag to the final string.\n    const shouldAddClosingTag = boldChars[i] === 1 && boldChars[i + 1] !== 1;\n    let char = text[i];\n\n    if (shouldAddOpeningTag) {\n      char = '<b>' + char;\n    }\n\n    if (shouldAddClosingTag) {\n      char = char + '</b>';\n    }\n    highlightedString += char;\n  }\n\n  return highlightedString;\n}\n`;var u=`export default function textSearch(text: string, query: string): string {\n  if (text.trim() === '' || query.trim() === '') {\n    return text;\n  }\n\n  const boldChars = Array.from({ length: text.length }, () => 0);\n\n  for (let i = 0; i < text.length; ) {\n    const substr = text.slice(i, i + query.length);\n    if (substr.toLowerCase() === query.toLowerCase()) {\n      boldChars.fill(1, i, i + query.length);\n      // Start from next character if there's a match since one\n      // character cannot match the same query more than once.\n      i = i + query.length;\n    } else {\n      i++;\n    }\n  }\n\n  let highlightedString = '';\n  for (let i = 0; i < text.length; i++) {\n    // When the current character should be bolded\n    // and the previous character should not be bolded,\n    // append an opening tag to the final string.\n    const shouldAddOpeningTag = boldChars[i] === 1 && boldChars[i - 1] !== 1;\n    // When the current character should be bolded\n    // and the next character should not be bolded,\n    // append a closing tag to the final string.\n    const shouldAddClosingTag = boldChars[i] === 1 && boldChars[i + 1] !== 1;\n    let char = text[i];\n\n    if (shouldAddOpeningTag) {\n      char = '<b>' + char;\n    }\n\n    if (shouldAddClosingTag) {\n      char = char + '</b>';\n    }\n    highlightedString += char;\n  }\n\n  return highlightedString;\n}\n`;function g(n){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",pre:\"pre\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"This question evaluates one's ability to manipulate arrays and strings in JavaScript, which is certainly an essential skill for Front End development.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,t.jsx)(e.p,{children:\"Your interviewer might not necessarily spell out all the requirements for you upfront. Ideally you start by thinking about all the possible situations and edge cases.\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"What if the \",(0,t.jsx)(e.code,{children:\"query\"}),\" string is an empty string or the input string \",(0,t.jsx)(e.code,{children:\"text\"}),\" is an empty string?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Return the string as-is.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"One might think of leveraging regular expressions (regex), via \",(0,t.jsx)(e.code,{children:\"RegExp\"}),\". Regex is not easy to use here because we need to combine the tags for consecutive matches.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let's try to think backwards from the desired output: we want to output a string with the substrings that exist in the \",(0,t.jsx)(e.code,{children:\"query\"}),\" string wrapped in \",(0,t.jsx)(e.code,{children:\"<b>\"}),\" tags. Therefore we need to know where exactly to insert the opening \",(0,t.jsx)(e.code,{children:\"<b>\"}),\" tags and closing \",(0,t.jsx)(e.code,{children:\"</b>\"}),\" tags. We can create a boolean array of same length as the \",(0,t.jsx)(e.code,{children:\"text\"}),\" with every value defaulting to \",(0,t.jsx)(e.code,{children:\"false\"}),\". The value of \",(0,t.jsx)(e.code,{children:\"boldChars[index]\"}),\" indicates whether the character at that index in the original string needs to be bold.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`// #1: Basic case.\n// text: \"aaabcaa\", query: 'abc'\n// boldChars: [false, false, true, true, true, false, false]\n// result: \"aa<b>abc</b>aa\"\n\n// #2: Multiple matches case.\n// text: \"aaabcaabc\", query: 'abc'\n// boldChars: [false, false, true, true, true, false, true, true, true]\n// result: \"aa<b>abc</b>a<b>abc</b>\"\n\n// #2: Consecutive case.\n// text: \"aababcac\", query: 'ab'\n// boldChars: [false, true, true, true, true, false, false, false]\n// result: \"a<b>abab</b>cac\"\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The beginning of a span of consecutive chunks of \",(0,t.jsx)(e.code,{children:\"true\"}),\" is where we insert the opening tag \",(0,t.jsx)(e.code,{children:\"<b>\"}),\" and the end is where we add a closing \",(0,t.jsx)(e.code,{children:\"</b>\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To identify which characters need to be bold, we do a naive substring match at each character in \",(0,t.jsx)(e.code,{children:\"text\"}),\" for each query. Flipping the boolean value at each matching character's index to \",(0,t.jsx)(e.code,{children:\"true\"}),'. However, because of the \"one character can only match the same query once\" condition, we have to increment ',(0,t.jsx)(e.code,{children:\"i\"}),\" to go past the current query when there's a match. Be careful of off-by-one errors here.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Because we separate out the function into two steps: (1) identification of bold characters, (2) rendering of the \",(0,t.jsx)(e.code,{children:\"<b>\"}),\" tags, we will not run into the issue of combining the tags for consecutive matches.\"]}),`\n`,(0,t.jsx)(l,{languages:{jsx:d,tsx:u}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Empty string\"}),`\n`,(0,t.jsx)(e.li,{children:\"Empty query\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"We use \",(0,t.jsx)(e.code,{children:\"Array.prototype.fill()\"}),\" to mutate the boolean array conveniently when we find a substring match. The method \",(0,t.jsx)(e.code,{children:\"fill\"}),\" is one of the few methods that mutate arrays. As of writing, there are 9 methods in total that mutates arrays: \",(0,t.jsx)(e.code,{children:\"pop\"}),\", \",(0,t.jsx)(e.code,{children:\"push\"}),\", \",(0,t.jsx)(e.code,{children:\"reverse\"}),\", \",(0,t.jsx)(e.code,{children:\"shift\"}),\", \",(0,t.jsx)(e.code,{children:\"sort\"}),\", \",(0,t.jsx)(e.code,{children:\"splice\"}),\", \",(0,t.jsx)(e.code,{children:\"unshift\"}),\", \",(0,t.jsx)(e.code,{children:\"copyWithin\"}),\" and \",(0,t.jsx)(e.code,{children:\"fill\"}),\". Check out \",(0,t.jsx)(e.a,{href:\"https://doesitmutate.xyz\",children:\"Does it mutate\"}),\" where there is a nice list of mutating array methods with more details.\"]}),`\n`]})]})}function S(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(g,n)})):g(n)}var A=S;return q(k);})();\n;return Component;",
  "workspace": {
    "main": "/src/text-search.ts",
    "run": "/src/text-search.run.test.ts",
    "submit": "/src/text-search.submit.test.ts"
  }
}