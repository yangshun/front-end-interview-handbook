{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-idle\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-idle.ts\",\n  \"dependencies\": {\n    \"@sinonjs/fake-timers\": \"14.0.0\",\n    \"@testing-library/react\": \"14.0.0\",\n    \"@testing-library/user-event\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/use-idle.run.test.ts": "import { act, renderHook } from '@testing-library/react';\nimport FakeTimers from '@sinonjs/fake-timers';\n\nimport useIdle from './use-idle';\n\nlet clock: FakeTimers.InstalledClock;\n\ndescribe('useIdle', () => {\n  beforeEach(() => {\n    clock = FakeTimers.withGlobal(globalThis).install();\n  });\n\n  afterEach(() => {\n    clock.uninstall();\n  });\n\n  test('return values', () => {\n    const { result } = renderHook(() => useIdle());\n\n    expect(result.current).toBe(false);\n  });\n\n  test('idle after timeout', () => {\n    const { result } = renderHook(() => useIdle());\n\n    act(() => clock.tick(60_000));\n\n    expect(result.current).toBe(true);\n  });\n});\n",
    "/src/use-idle.submit.test.ts": "import { act, fireEvent, renderHook } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport FakeTimers from '@sinonjs/fake-timers';\n\nimport useIdle from './use-idle';\n\nlet clock: FakeTimers.InstalledClock;\n\ndescribe('useIdle', () => {\n  beforeEach(() => {\n    clock = FakeTimers.withGlobal(globalThis).install();\n  });\n\n  afterEach(() => {\n    clock.uninstall();\n  });\n\n  test('return values', () => {\n    const { result } = renderHook(() => useIdle());\n\n    expect(result.current).toBe(false);\n  });\n\n  test('idle after timeout', () => {\n    const { result } = renderHook(() => useIdle());\n\n    act(() => clock.tick(60_000));\n\n    expect(result.current).toBe(true);\n  });\n\n  test('not idle after click', () => {\n    const user = userEvent.setup();\n    const { result } = renderHook(() => useIdle());\n\n    act(() => {\n      clock.tick(30_000);\n      user.click(document.body);\n      clock.tick(30_000);\n    });\n\n    expect(result.current).toBe(false);\n  });\n\n  test('not idle after key press', () => {\n    const user = userEvent.setup();\n    const { result } = renderHook(() => useIdle());\n\n    act(() => {\n      clock.tick(30_000);\n      user.keyboard('a');\n      clock.tick(30_000);\n    });\n\n    expect(result.current).toBe(false);\n  });\n\n  test('not idle after hover', () => {\n    const user = userEvent.setup();\n    const { result } = renderHook(() => useIdle());\n\n    act(() => {\n      clock.tick(30_000);\n      user.hover(document.body);\n      clock.tick(30_000);\n    });\n\n    expect(result.current).toBe(false);\n  });\n\n  test('not idle after resize', () => {\n    const { result } = renderHook(() => useIdle());\n\n    act(() => {\n      clock.tick(30_000);\n      fireEvent.resize(window);\n      clock.tick(30_000);\n    });\n\n    expect(result.current).toBe(false);\n  });\n\n  test('document visibility change', () => {\n    const { result } = renderHook(() => useIdle());\n\n    act(() => {\n      Object.defineProperties(document, {\n        hidden: { value: true, writable: true },\n        visibilityState: { value: 'hidden', writable: true },\n      });\n\n      fireEvent(document, new Event('visibilitychange'));\n      clock.tick(60_000);\n    });\n\n    expect(result.current).toBe(true);\n\n    act(() => {\n      Object.defineProperties(document, {\n        hidden: { value: false, writable: true },\n        visibilityState: { value: 'visible', writable: true },\n      });\n\n      fireEvent(document, new Event('visibilitychange'));\n    });\n\n    expect(result.current).toBe(false);\n  });\n\n  test('remove event listeners on unmount', () => {\n    const { result, unmount } = renderHook(() => useIdle());\n\n    expect(result.current).toBe(false);\n\n    unmount();\n    act(() => clock.tick(60_000));\n\n    expect(result.current).toBe(false);\n  });\n});\n",
    "/src/use-idle.ts": "import { useEffect, useState } from 'react';\n\nconst DEFAULT_EVENTS: (keyof WindowEventMap)[] = [\n  'mousemove',\n  'mousedown',\n  'resize',\n  'keydown',\n  'touchstart',\n  'wheel',\n];\n\nexport default function useIdle(\n  ms = 60_000,\n  initialState = false,\n  events: (keyof WindowEventMap)[] = DEFAULT_EVENTS,\n): boolean {\n  const [idle, setIdle] = useState<boolean>(initialState);\n\n  useEffect(() => {\n    let timeoutId: number;\n\n    function handleTimeout() {\n      setIdle(true);\n    }\n\n    function handleEvent() {\n      setIdle(false);\n\n      clearTimeout(timeoutId);\n      timeoutId = window.setTimeout(handleTimeout, ms);\n    }\n\n    function handleVisibilityChange() {\n      if (document.hidden) {\n        return;\n      }\n\n      handleEvent();\n    }\n\n    timeoutId = setTimeout(handleTimeout, ms);\n\n    events.forEach((event) => window.addEventListener(event, handleEvent));\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    return () => {\n      clearTimeout(timeoutId);\n\n      events.forEach((event) => window.removeEventListener(event, handleEvent));\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  });\n\n  return idle;\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @type {(keyof WindowEventMap)[]}\n */\nconst DEFAULT_EVENTS = [\n  'mousemove',\n  'mousedown',\n  'resize',\n  'keydown',\n  'touchstart',\n  'wheel',\n];\n\n/**\n *\n * @param {number} ms\n * @param {boolean} initialState\n * @param {(keyof WindowEventMap)[]} events\n * @returns {boolean}\n */\nexport default function useIdle(\n  ms = 60_000,\n  initialState = false,\n  events = DEFAULT_EVENTS,\n) {\n  throw 'Not implemented';\n}",
    "ts": "const DEFAULT_EVENTS: (keyof WindowEventMap)[] = [\n  'mousemove',\n  'mousedown',\n  'resize',\n  'keydown',\n  'touchstart',\n  'wheel',\n];\n\nexport default function useIdle(\n  ms = 60_000,\n  initialState = false,\n  events: (keyof WindowEventMap)[] = DEFAULT_EVENTS,\n): boolean {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/use-idle.ts",
    "run": "/src/use-idle.run.test.ts",
    "submit": "/src/use-idle.submit.test.ts"
  }
}