{
  "description": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,h=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var a in e)l(n,a,{get:e[a],enumerable:!0})},c=(n,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!h.call(n,r)&&r!==a&&l(n,r,{get:()=>e[r],enumerable:!(s=m(e,r))||s.enumerable});return n};var y=(n,e,a)=>(a=n!=null?f(p(n)):{},c(e||!n||!n.__esModule?l(a,\"default\",{value:n,enumerable:!0}):a,n)),j=n=>c(l({},\"__esModule\",{value:!0}),n);var o=x((I,i)=>{i.exports=_jsx_runtime});var b={};g(b,{default:()=>F,frontmatter:()=>v});var t=y(o()),v={title:\"Flatten\",excerpt:\"Implement a function that recursively flattens an array into a single level deep\"};function d(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a function \",(0,t.jsx)(e.code,{children:\"flatten\"}),\" that returns a newly-created array with all sub-array elements concatenated recursively into a single level.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`// Single-level arrays are unaffected.\nflatten([1, 2, 3]); // [1, 2, 3]\n\n// Inner arrays are flattened into a single level.\nflatten([1, [2, 3]]); // [1, 2, 3]\nflatten([\n  [1, 2],\n  [3, 4],\n]); // [1, 2, 3, 4]\n\n// Flattens recursively.\nflatten([1, [2, [3, [4, [5]]]]]); // [1, 2, 3, 4, 5]\n`})})]})}function _(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var F=_;return j(b);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/flatten\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/flatten.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/flatten.run.test.ts": "import flatten from './flatten';\n\ndescribe('flatten array', () => {\n  test('empty array', () => {\n    expect(flatten([])).toEqual([]);\n  });\n\n  test('nested array', () => {\n    expect(flatten([1, [2]])).toEqual([1, 2]);\n  });\n\n  test('multiple levels of nesting', () => {\n    expect(flatten([1, [2, [3]]])).toEqual([1, 2, 3]);\n  });\n});\n",
    "/src/flatten.submit.test.ts": "import flatten from './flatten';\n\ndescribe('flatten array', () => {\n  test('empty array', () => {\n    expect(flatten([])).toEqual([]);\n    expect(flatten([[], [[]], [[], [[[]]]]])).toEqual([]);\n  });\n\n  test('single-element array', () => {\n    expect(flatten([1])).toEqual([1]);\n    expect(flatten(['foo'])).toEqual(['foo']);\n    expect(flatten([undefined])).toEqual([undefined]);\n  });\n\n  test('array with only one level', () => {\n    expect(flatten([1, 2, 3])).toEqual([1, 2, 3]);\n    expect(flatten(['foo', 'bar'])).toEqual(['foo', 'bar']);\n    expect(flatten([null, true, undefined])).toEqual([null, true, undefined]);\n  });\n\n  test('array with multiple levels of nesting', () => {\n    expect(flatten([0, 1, 2, [3, 4]])).toEqual([0, 1, 2, 3, 4]);\n    expect(flatten([1, [2, [3]]])).toEqual([1, 2, 3]);\n    expect(\n      flatten([\n        [1, 2],\n        [3, 4],\n      ]),\n    ).toEqual([1, 2, 3, 4]);\n    expect(flatten(['foo', ['bar']])).toEqual(['foo', 'bar']);\n    expect(flatten([[null, [true]], undefined])).toEqual([\n      null,\n      true,\n      undefined,\n    ]);\n  });\n\n  test('list-style array', () => {\n    expect(flatten([1, [2, [3, [4, [5]]]]])).toEqual([1, 2, 3, 4, 5]);\n    expect(flatten([[[[[1], 2], 3], 4], 5])).toEqual([1, 2, 3, 4, 5]);\n  });\n\n  test('deeply-nested single-element array', () => {\n    expect(flatten([[[[1]]]])).toEqual([1]);\n  });\n});\n",
    "/src/flatten.ts": "type ArrayValue = any | Array<ArrayValue>;\n\nexport default function flatten(value: Array<ArrayValue>): Array<any> {\n  return value.reduce(\n    (acc, curr) => acc.concat(Array.isArray(curr) ? flatten(curr) : curr),\n    [],\n  );\n}\n"
  },
  "metadata": {
    "access": "free",
    "author": "zhenghao",
    "companies": [
      "amazon",
      "apple",
      "lyft",
      "meta",
      "rippling",
      "salesforce"
    ],
    "created": 1649894400,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that recursively flattens an array into a single level deep",
    "featured": true,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/flatten",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "todo-list",
      "holy-grail",
      "deep-equal"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "squash-object",
      "get"
    ],
    "slug": "flatten",
    "subtitle": null,
    "title": "Flatten",
    "topics": [
      "recursion"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Array<*|Array>} value\n * @return {Array}\n */\nexport default function flatten(value) {\n  throw 'Not implemented!';\n}",
    "ts": "type ArrayValue = any | Array<ArrayValue>;\n\nexport default function flatten(value: Array<ArrayValue>): Array<any> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var w=Object.create;var o=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var S=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var V=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),O=(a,e)=>{for(var t in e)o(a,t,{get:e[t],enumerable:!0})},c=(a,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of S(e))!k.call(a,i)&&i!==t&&o(a,i,{get:()=>e[i],enumerable:!(l=b(e,i))||l.enumerable});return a};var I=(a,e,t)=>(t=a!=null?w(x(a)):{},c(e||!a||!a.__esModule?o(t,\"default\",{value:a,enumerable:!0}):t,a)),j=a=>c(o({},\"__esModule\",{value:!0}),a);var h=V((D,s)=>{s.exports=_jsx_runtime});var R={};O(R,{default:()=>H});var r=I(h());var n=MDXCodeBlock;var u=`/**\n * @param {Array<*|Array>} value\n * @return {Array}\n */\nexport default function flatten(value) {\n  return value.reduce(\n    (acc, curr) => acc.concat(Array.isArray(curr) ? flatten(curr) : curr),\n    [],\n  );\n}\n`;var d=`type ArrayValue = any | Array<ArrayValue>;\n\nexport default function flatten(value: Array<ArrayValue>): Array<any> {\n  return value.reduce(\n    (acc, curr) => acc.concat(Array.isArray(curr) ? flatten(curr) : curr),\n    [],\n  );\n}\n`;var y=`type ArrayValue = any | Array<ArrayValue>;\n\nexport default function flatten(value: Array<ArrayValue>): Array<any> {\n  return Array.isArray(value) ? value.flatMap((item) => flatten(item)) : value;\n}\n`;var p=`/**\n * @param {Array<*|Array>} value\n * @return {Array}\n */\nexport default function* flatten(value: Array<any>): Array<any> {\n  for (const item of value) {\n    if (Array.isArray(item)) {\n      yield* flatten(item);\n    } else {\n      yield item;\n    }\n  }\n}\n`;var f=`type ArrayValue = any | Array<ArrayValue>;\n\nexport default function flatten(value: Array<ArrayValue>): Array<any> {\n  for (let i = 0; i < value.length; ) {\n    if (Array.isArray(value[i])) {\n      value.splice(i, 1, ...value[i]);\n    } else {\n      i++;\n    }\n  }\n\n  return value;\n}\n`;var m=`type ArrayValue = any | Array<ArrayValue>;\n\nexport default function flatten(value: Array<ArrayValue>): Array<any> {\n  const res = [];\n  const copy = value.slice();\n\n  while (copy.length) {\n    const item = copy.shift();\n    if (Array.isArray(item)) {\n      copy.unshift(...item);\n    } else {\n      res.push(item);\n    }\n  }\n\n  return res;\n}\n`;var g=`type ArrayValue = any | Array<ArrayValue>;\n\nexport default function flatten(value: Array<ArrayValue>): Array<any> {\n  while (value.some(Array.isArray)) {\n    value = [].concat(...value);\n  }\n\n  return value;\n}\n`;var v=`type ArrayValue = any | Array<ArrayValue>;\n\nexport default function flatten(value: Array<ArrayValue>): Array<any> {\n  return JSON.parse('[' + JSON.stringify(value).replace(/(\\\\[|\\\\])/g, '') + ']');\n}\n`;function A(a){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",h3:\"h3\",a:\"a\",em:\"em\",hr:\"hr\",pre:\"pre\"},a.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"This is a common JavaScript interview question. It tests one's knowledge about checking for the array type, looping through an array, various native methods such as \",(0,r.jsx)(e.code,{children:\"Array.prototype.concat\"}),\", and recursion.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsx)(e.li,{children:\"What type of data does the array contain? Some approach only applies to certain data types.\"}),`\n`,(0,r.jsx)(e.li,{children:\"How many levels of nesting can this array have? If there are thousands-of-levels of nesting, recursion might not be a good idea given its big upfront memory footprint.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Should we return a new array or we mutate the existing array?\"}),`\n`,(0,r.jsx)(e.li,{children:`Can we assume valid input, i.e. an array. Normally the answer is \"yes\", so you don't have to waste your time doing defensive programming.`}),`\n`,(0,r.jsx)(e.li,{children:\"Does the environment the code runs on has ES6+ support? The environment determines what methods/native APIs you have access to.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solutions\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Solution 1: Iterative Solution\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"First let's think through how we should check if a given value is an array or not. We can use \",(0,r.jsx)(e.code,{children:\"Array.isArray\"}),\" or \",(0,r.jsx)(e.code,{children:\"instanceof Array\"}),\" to achieve that. There are some nuances between these two. If you are interested you can check out \",(0,r.jsx)(e.a,{href:\"https://jakearchibald.com/2017/arrays-symbols-realms/\",children:\"this article\"}),\" by Jake Archibald.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"Then, we don't want to mutate the original input array, which is a good practice in general, so we will make a copy of the input array and return a new array with all the items extracted from the input array.\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Here is the solution. We loop through the array with a while loop and we take out an item from the array one at a time to check to see if that item is an array. If the item is not an array, we put it into the \",(0,r.jsx)(e.code,{children:\"res\"}),\" array. If it is an array, we use a spread operator \",(0,r.jsx)(e.code,{children:\"...\"}),\" to get all the items out of it and put them back to the array.\"]}),`\n`,(0,r.jsx)(n,{children:m}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Solution 2: Iterative Solution with \",(0,r.jsx)(e.code,{children:\"Array.prototype.some\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"A more concise approach, compared to the previous one, is to use \",(0,r.jsx)(e.code,{children:\"Array.prototype.some\"}),\".\"]}),`\n`,(0,r.jsx)(n,{children:g}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Solution 3: Recursive approach with \",(0,r.jsx)(e.code,{children:\"Array.prototype.reduce\"})]}),`\n`,(0,r.jsx)(e.p,{children:\"A recursion approach fits well here given the recursive and nesting nature of this question. And it will simplify our code a lot.\"}),`\n`,(0,r.jsx)(n,{languages:{jsx:u,tsx:d}}),`\n`,(0,r.jsxs)(e.p,{children:[\"Although a recursive approach always has the risk overflowing the call stack, as of this writing, in chrome, the number of recursive calls you can make is around 10 thousands and in Firefox it is 50 thousands, so this shouldn't be a problem in practice. However, when the cost of recursion becomes a concern, we can use a \",(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator\",children:\"generator\"}),\" to lazily extract the flattened items from the array. We will see that solution later.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Solution 4: Flatten the array in-place\"}),`\n`,(0,r.jsx)(e.p,{children:\"All the solutions we have seen so far are returning a new flattened array without mutating the original input array. Again, this is normally what you want.\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"However, the interviewer might ask you to implement an in-place solution that doesn't allocate extra memory. That is, a solution with a constant \",(0,r.jsx)(e.code,{children:\"O(1)\"}),\" space complexity.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"In this case, you will need to leverage array methods that \",(0,r.jsx)(e.em,{children:\"mutate\"}),\". There are 9 methods in total that mutate arrays: \",(0,r.jsx)(e.code,{children:\"pop\"}),\", \",(0,r.jsx)(e.code,{children:\"push\"}),\", \",(0,r.jsx)(e.code,{children:\"reverse\"}),\", \",(0,r.jsx)(e.code,{children:\"shift\"}),\", \",(0,r.jsx)(e.code,{children:\"sort\"}),\", \",(0,r.jsx)(e.code,{children:\"splice\"}),\", \",(0,r.jsx)(e.code,{children:\"unshift\"}),\", \",(0,r.jsx)(e.code,{children:\"copyWithin\"}),\" and \",(0,r.jsx)(e.code,{children:\"fill\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Here is one possible solution that uses \",(0,r.jsx)(e.code,{children:\"splice\"}),\" to mutate the input array:\"]}),`\n`,(0,r.jsx)(n,{children:f}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Solution 5: Recursive approaching using \",(0,r.jsx)(e.code,{children:\"flatMap\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"The \",(0,r.jsx)(e.code,{children:\"flatMap\"}),\" function method returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level. By calling it recursively, we can flatten the entire array until it is only one level deep.\"]}),`\n`,(0,r.jsx)(n,{children:y}),`\n`,(0,r.jsx)(e.h3,{children:\"Solution 6: Generator\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"As we have discussed earlier, if the array has a thousands-of-levels nesting, a recursive approach might cause a stack overflow. We can utilize generators to yield array item individually. As generators are \",(0,r.jsx)(e.em,{children:\"lazy\"}),\" in nature, this wouldn't have as big of an upfront cost as our recursive approach does.\"]}),`\n`,(0,r.jsx)(n,{children:p}),`\n`,(0,r.jsx)(e.hr,{}),`\n`,(0,r.jsx)(e.h2,{children:\"Bonus Solutions\"}),`\n`,(0,r.jsx)(e.p,{children:\"The following solutions only work under certain circumstances so they should not be used during interviews.\"}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Bonus Solution 1: Regex and \",(0,r.jsx)(e.code,{children:\"JSON.stringify\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Here is a solution that might be considered unorthodox: we first encode the array into a JSON string via \",(0,r.jsx)(e.code,{children:\"JSON.stringify\"}),\", and filter out brackets using regex \",(0,r.jsx)(e.code,{children:\"/(\\\\[|\\\\])/g\"}),\", and we decode it back to an array using \",(0,r.jsx)(e.code,{children:\"JSON.parse\"}),\". Because all the brackets are stripped off with the regex, we end up with an array with only one level of depth.\"]}),`\n`,(0,r.jsx)(n,{children:v}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Bonus Solution 2: \",(0,r.jsx)(e.code,{children:\"toString\"}),\" when the array contains only numbers\"]}),`\n`,(0,r.jsx)(e.p,{children:\"Recall that we asked about the data types as one of the clarification questions? If the array contains only numbers, here is a very simple solution:\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`function flattenOnlyNumbers(array) {\n  return array\n    .toString()\n    .split(',')\n    .map((numStr) => Number(numStr));\n}\n`})}),`\n`,(0,r.jsxs)(e.p,{children:[\"Note that this only applies when the array only contains numbers, and this usage of \",(0,r.jsx)(e.code,{children:\"toString\"}),' might be thought of as \"obscure\".']}),`\n`,(0,r.jsxs)(e.h2,{children:[\"One-liner Solution with \",(0,r.jsx)(e.code,{children:\"Array.prototype.flat\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"There is a new \",(0,r.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat\",children:[(0,r.jsx)(e.code,{children:\"flat\"}),\" array method\"]}),\" added recently to the JavaScript language. Obviously you cannot use this during interviews but it's still good to know that a native flatten function is available in the language.\"]}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`export default function flatten(arr) {\n  return arr.flat(Infinity);\n}\n`})})]})}function F(a={}){let{wrapper:e}=a.components||{};return e?(0,r.jsx)(e,Object.assign({},a,{children:(0,r.jsx)(A,a)})):A(a)}var H=F;return j(R);})();\n;return Component;",
  "workspace": {
    "main": "/src/flatten.ts",
    "run": "/src/flatten.run.test.ts",
    "submit": "/src/flatten.submit.test.ts"
  }
}