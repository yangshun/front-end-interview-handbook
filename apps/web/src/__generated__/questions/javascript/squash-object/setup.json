{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/squash-object\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/squash-object.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/squash-object.run.test.ts": "import squashObject from './squash-object';\n\ndescribe('squashObject', () => {\n  test('empty', () => {\n    expect(squashObject({})).toEqual({});\n  });\n\n  test('no nesting', () => {\n    expect(squashObject({ a: '1', b: 'b' })).toEqual({ a: '1', b: 'b' });\n  });\n\n  test('one level of nesting', () => {\n    expect(\n      squashObject({\n        a: 5,\n        c: {\n          f: 9,\n        },\n      }),\n    ).toEqual({ a: 5, 'c.f': 9 });\n  });\n});\n",
    "/src/squash-object.submit.test.ts": "import squashObject from './squash-object';\n\ndescribe('squashObject', () => {\n  test('empty', () => {\n    expect(squashObject({})).toEqual({});\n  });\n\n  test('no nesting', () => {\n    expect(squashObject({ a: '1', b: 'b' })).toEqual({ a: '1', b: 'b' });\n  });\n\n  test('one level of nesting', () => {\n    expect(\n      squashObject({\n        a: 5,\n        c: {\n          f: 9,\n        },\n      }),\n    ).toEqual({ a: 5, 'c.f': 9 });\n  });\n\n  test('multiple levels of nesting', () => {\n    expect(\n      squashObject({\n        a: 5,\n        b: 6,\n        c: {\n          f: 9,\n          g: {\n            m: 17,\n            n: 3,\n          },\n        },\n      }),\n    ).toEqual({ a: 5, b: 6, 'c.f': 9, 'c.g.m': 17, 'c.g.n': 3 });\n  });\n\n  test('arrays', () => {\n    expect(\n      squashObject({\n        a: ['hi', 'bye'],\n      }),\n    ).toEqual({\n      'a.0': 'hi',\n      'a.1': 'bye',\n    });\n  });\n\n  test('null-ish values', () => {\n    expect(\n      squashObject({\n        a: {\n          a: 0,\n          b: null,\n          c: false,\n          d: undefined,\n        },\n      }),\n    ).toEqual({\n      'a.a': 0,\n      'a.b': null,\n      'a.c': false,\n      'a.d': undefined,\n    });\n  });\n\n  describe('empty keys', () => {\n    test('single layer of empty key', () => {\n      expect(\n        squashObject({\n          foo: {\n            '': 0,\n            a: 1,\n          },\n        }),\n      ).toEqual({\n        foo: 0,\n        'foo.a': 1,\n      });\n    });\n\n    test('nested empty keys', () => {\n      expect(\n        squashObject({\n          foo: {\n            '': {\n              '': 1,\n              bar: 2,\n            },\n            a: 1,\n          },\n        }),\n      ).toEqual({\n        foo: 1,\n        'foo.bar': 2,\n        'foo.a': 1,\n      });\n    });\n  });\n\n  test('everything', () => {\n    expect(\n      squashObject({\n        a: 'hi',\n        b: {\n          a: null,\n          b: ['foo', '', null, 'bar'],\n          d: 'hello',\n          e: {\n            a: 'yo',\n            b: undefined,\n            c: 'sup',\n            d: 0,\n            f: [\n              { foo: 123, bar: 123 },\n              { foo: 465, bar: 456 },\n            ],\n          },\n        },\n        c: 'world',\n      }),\n    ).toEqual({\n      a: 'hi',\n      'b.a': null,\n      'b.b.0': 'foo',\n      'b.b.1': '',\n      'b.b.2': null,\n      'b.b.3': 'bar',\n      'b.d': 'hello',\n      'b.e.a': 'yo',\n      'b.e.b': undefined,\n      'b.e.c': 'sup',\n      'b.e.d': 0,\n      'b.e.f.0.foo': 123,\n      'b.e.f.0.bar': 123,\n      'b.e.f.1.foo': 465,\n      'b.e.f.1.bar': 456,\n      c: 'world',\n    });\n  });\n});\n",
    "/src/squash-object.ts": "export default function squashObject(obj: Object): Object {\n  function squashImpl(\n    obj_: Object,\n    path: Array<string>,\n    output: Record<string, any>,\n  ) {\n    for (const [key, value] of Object.entries(obj_)) {\n      if (typeof value !== 'object' || value === null) {\n        output[path.concat(key).filter(Boolean).join('.')] = value;\n      } else {\n        squashImpl(value, path.concat(key), output);\n      }\n    }\n  }\n\n  const out = {};\n  squashImpl(obj, [], out);\n  return out;\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Object} obj\n * @return {Object}\n */\nexport default function squashObject(obj) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function squashObject(obj: Object): Object {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/squash-object.ts",
    "run": "/src/squash-object.run.test.ts",
    "submit": "/src/squash-object.submit.test.ts"
  }
}