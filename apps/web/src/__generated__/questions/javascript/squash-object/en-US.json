{
  "description": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),m=(n,e)=>{for(var c in e)s(n,c,{get:e[c],enumerable:!0})},r=(n,e,c,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of b(e))!p.call(n,a)&&a!==c&&s(n,a,{get:()=>e[a],enumerable:!(o=u(e,a))||o.enumerable});return n};var g=(n,e,c)=>(c=n!=null?h(j(n)):{},r(e||!n||!n.__esModule?s(c,\"default\",{value:n,enumerable:!0}):c,n)),x=n=>r(s({},\"__esModule\",{value:!0}),n);var i=f((v,l)=>{l.exports=_jsx_runtime});var O={};m(O,{default:()=>y,frontmatter:()=>q});var t=g(i()),q={title:\"Squash Object\",excerpt:\"Implement a function that returns a new object after squashing the input object into a single level of depth\"};function d(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:['Implement a function that returns a new object after squashing the input object into a single level of depth where nested keys are \"squashed\" together with a period delimiter (',(0,t.jsx)(e.code,{children:\".\"}),\").\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const object = {\n  a: 5,\n  b: 6,\n  c: {\n    f: 9,\n    g: {\n      m: 17,\n      n: 3,\n    },\n  },\n};\n\nsquashObject(object); // { a: 5, b: 6, 'c.f': 9, 'c.g.m': 17, 'c.g.n': 3 }\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Any keys with null-ish values (\",(0,t.jsx)(e.code,{children:\"null\"}),\" and \",(0,t.jsx)(e.code,{children:\"undefined\"}),\") are still included in the returned object.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const object = {\n  a: { b: null, c: undefined },\n};\nsquashObject(object); // { 'a.b': null, 'a.c': undefined }\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"It should also work with properties that have arrays as the value:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const object = { a: { b: [1, 2, 3], c: ['foo'] } };\nsquashObject(object); // { 'a.b.0': 1, 'a.b.1': 2, 'a.b.2': 3, 'a.c.0': 'foo' }\n`})}),`\n`,(0,t.jsx)(e.p,{children:`Empty keys should be treated as if that \"layer\" doesn't exist.`}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const object = {\n  foo: {\n    '': { '': 1, bar: 2 },\n  },\n};\nsquashObject(object); // { foo: 1, 'foo.bar': 2 }\n`})})]})}function w(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var y=w;return x(O);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/squash-object\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/squash-object.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/squash-object.run.test.ts": "import squashObject from './squash-object';\n\ndescribe('squashObject', () => {\n  test('empty', () => {\n    expect(squashObject({})).toEqual({});\n  });\n\n  test('no nesting', () => {\n    expect(squashObject({ a: '1', b: 'b' })).toEqual({ a: '1', b: 'b' });\n  });\n\n  test('one level of nesting', () => {\n    expect(\n      squashObject({\n        a: 5,\n        c: {\n          f: 9,\n        },\n      }),\n    ).toEqual({ a: 5, 'c.f': 9 });\n  });\n});\n",
    "/src/squash-object.submit.test.ts": "import squashObject from './squash-object';\n\ndescribe('squashObject', () => {\n  test('empty', () => {\n    expect(squashObject({})).toEqual({});\n  });\n\n  test('no nesting', () => {\n    expect(squashObject({ a: '1', b: 'b' })).toEqual({ a: '1', b: 'b' });\n  });\n\n  test('one level of nesting', () => {\n    expect(\n      squashObject({\n        a: 5,\n        c: {\n          f: 9,\n        },\n      }),\n    ).toEqual({ a: 5, 'c.f': 9 });\n  });\n\n  test('multiple levels of nesting', () => {\n    expect(\n      squashObject({\n        a: 5,\n        b: 6,\n        c: {\n          f: 9,\n          g: {\n            m: 17,\n            n: 3,\n          },\n        },\n      }),\n    ).toEqual({ a: 5, b: 6, 'c.f': 9, 'c.g.m': 17, 'c.g.n': 3 });\n  });\n\n  test('arrays', () => {\n    expect(\n      squashObject({\n        a: ['hi', 'bye'],\n      }),\n    ).toEqual({\n      'a.0': 'hi',\n      'a.1': 'bye',\n    });\n  });\n\n  test('null-ish values', () => {\n    expect(\n      squashObject({\n        a: {\n          a: 0,\n          b: null,\n          c: false,\n          d: undefined,\n        },\n      }),\n    ).toEqual({\n      'a.a': 0,\n      'a.b': null,\n      'a.c': false,\n      'a.d': undefined,\n    });\n  });\n\n  describe('empty keys', () => {\n    test('single layer of empty key', () => {\n      expect(\n        squashObject({\n          foo: {\n            '': 0,\n            a: 1,\n          },\n        }),\n      ).toEqual({\n        foo: 0,\n        'foo.a': 1,\n      });\n    });\n\n    test('nested empty keys', () => {\n      expect(\n        squashObject({\n          foo: {\n            '': {\n              '': 1,\n              bar: 2,\n            },\n            a: 1,\n          },\n        }),\n      ).toEqual({\n        foo: 1,\n        'foo.bar': 2,\n        'foo.a': 1,\n      });\n    });\n  });\n\n  test('everything', () => {\n    expect(\n      squashObject({\n        a: 'hi',\n        b: {\n          a: null,\n          b: ['foo', '', null, 'bar'],\n          d: 'hello',\n          e: {\n            a: 'yo',\n            b: undefined,\n            c: 'sup',\n            d: 0,\n            f: [\n              { foo: 123, bar: 123 },\n              { foo: 465, bar: 456 },\n            ],\n          },\n        },\n        c: 'world',\n      }),\n    ).toEqual({\n      a: 'hi',\n      'b.a': null,\n      'b.b.0': 'foo',\n      'b.b.1': '',\n      'b.b.2': null,\n      'b.b.3': 'bar',\n      'b.d': 'hello',\n      'b.e.a': 'yo',\n      'b.e.b': undefined,\n      'b.e.c': 'sup',\n      'b.e.d': 0,\n      'b.e.f.0.foo': 123,\n      'b.e.f.0.bar': 123,\n      'b.e.f.1.foo': 465,\n      'b.e.f.1.bar': 456,\n      c: 'world',\n    });\n  });\n});\n",
    "/src/squash-object.ts": "export default function squashObject(obj: Object): Object {\n  function squashImpl(\n    obj_: Object,\n    path: Array<string>,\n    output: Record<string, any>,\n  ) {\n    for (const [key, value] of Object.entries(obj_)) {\n      if (typeof value !== 'object' || value === null) {\n        output[path.concat(key).filter(Boolean).join('.')] = value;\n      } else {\n        squashImpl(value, path.concat(key), output);\n      }\n    }\n  }\n\n  const out = {};\n  squashImpl(obj, [], out);\n  return out;\n}\n"
  },
  "format": "javascript",
  "metadata": {
    "access": "standard",
    "author": "zhenghao",
    "companies": [],
    "created": 1654992000,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that returns a new object after squashing the input object into a single level of depth",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/squash-object",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "flatten",
      "get"
    ],
    "slug": "squash-object",
    "subtitle": null,
    "title": "Squash Object",
    "topics": [
      "recursion"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Object} obj\n * @return {Object}\n */\nexport default function squashObject(obj) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function squashObject(obj: Object): Object {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var b=Object.create;var a=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var w=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var o in e)a(n,o,{get:e[o],enumerable:!0})},c=(n,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!m.call(n,r)&&r!==o&&a(n,r,{get:()=>e[r],enumerable:!(i=j(e,r))||i.enumerable});return n};var g=(n,e,o)=>(o=n!=null?b(f(n)):{},c(e||!n||!n.__esModule?a(o,\"default\",{value:n,enumerable:!0}):o,n)),k=n=>c(a({},\"__esModule\",{value:!0}),n);var h=w((C,s)=>{s.exports=_jsx_runtime});var T={};v(T,{default:()=>_});var t=g(h());var l=MDXCodeBlock;var u=`/**\n * @param {Object} obj\n * @return {Object}\n */\nexport default function squashObject(obj) {\n  function squashImpl(obj_, path, output) {\n    for (const [key, value] of Object.entries(obj_)) {\n      if (typeof value !== 'object' || value === null) {\n        output[path.concat(key).filter(Boolean).join('.')] = value;\n      } else {\n        squashImpl(value, path.concat(key), output);\n      }\n    }\n  }\n\n  const out = {};\n  squashImpl(obj, [], out);\n  return out;\n}\n`;var d=`export default function squashObject(obj: Object): Object {\n  function squashImpl(\n    obj_: Object,\n    path: Array<string>,\n    output: Record<string, any>,\n  ) {\n    for (const [key, value] of Object.entries(obj_)) {\n      if (typeof value !== 'object' || value === null) {\n        output[path.concat(key).filter(Boolean).join('.')] = value;\n      } else {\n        squashImpl(value, path.concat(key), output);\n      }\n    }\n  }\n\n  const out = {};\n  squashImpl(obj, [], out);\n  return out;\n}\n`;function p(n){let e=Object.assign({p:\"p\",ol:\"ol\",li:\"li\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"This is a pretty tricky question, because not only do we need to traverse the object using recursion, but we also have to change the shape of the object, i.e. glueing all keys of a given path when we reach a primitive value. This also requires we keep track of the keys while traversing down the tree (the object).\"}),`\n`,(0,t.jsx)(e.p,{children:\"There are generally two ways we can explore an object:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Loop through the keys with the old school \",(0,t.jsx)(e.code,{children:\"for ... in\"}),\" statement.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Converting the object into an array of keys with \",(0,t.jsx)(e.code,{children:\"Object.keys()\"}),\", or an array of a key-value tuple with \",(0,t.jsx)(e.code,{children:\"Object.entries()\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"With the \",(0,t.jsx)(e.code,{children:\"for ... in\"}),\" statement, inherited enumerable properties are be processed as well. So normally you'd add a \",(0,t.jsx)(e.code,{children:\"Object.hasOwn()\"}),\" check to make sure the property is not inherited from its prototype. On the other hand, \",(0,t.jsx)(e.code,{children:\"Object.keys()\"}),\" and \",(0,t.jsx)(e.code,{children:\"Object.entries()\"}),\" only care about the properties directly defined on the object, and this is usually what we want.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Here is how we would go about visiting each property. When the value of a given property is an object, we would have to repeat the process with recursion.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function squashObject(object) {\n  for (const [key, value] of Object.entries(object)) {\n    if (typeof value !== 'object' || value !== null) {\n      // Add props with glued/squashed keys.\n    } else {\n      // Recursion by calling squashObject.\n    }\n  }\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We also need to keep track of the keys that are on the path to the current value so that we can squash them to form the new keys of the output object. To do that, we need to pass the keys down to the recursion call. We add a new parameter call \",(0,t.jsx)(e.code,{children:\"path\"}),\" that is an array of strings that stores the key explored on a given path. When the current value is a primitive value, i.e. we are the end of the object, we join \",(0,t.jsx)(e.code,{children:\"path\"}),\" together to form the key and assign the value to it.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Here is the solution that defines an inner recursive helper function that accepts the \",(0,t.jsx)(e.code,{children:\"path\"}),\" and \",(0,t.jsx)(e.code,{children:\"output\"}),\" parameters.\"]}),`\n`,(0,t.jsx)(l,{languages:{jsx:u,tsx:d}}),`\n`,(0,t.jsx)(e.p,{children:\"If this still looks confusing to you, no worries because most people find recursion to be hard to follow and comprehend. The thinking involves holding in your head multiple levels of the call stack at the same time and it takes time and practice to get used to.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Alternative Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This question is interesting in the sense that it asks you to make a new object based on the current object with a different shape. In the previous solution, we achieved that by recursively passing down the \",(0,t.jsx)(e.code,{children:\"output\"}),\" object and assigning the new key directly to the output \",(0,t.jsx)(e.code,{children:\"object\"}),\" when the value is a primitive.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Another technique we can use to process objects is to convert the objects into an array of key-value tuples with \",(0,t.jsx)(e.code,{children:\"Object.entries\"}),\" and transform those tuples with array methods such as \",(0,t.jsx)(e.code,{children:\"Array.prototype.map\"}),\" and then convert it back to an object by \",(0,t.jsx)(e.code,{children:\"Object.fromEntries\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Let's say we have the following object:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const object = {\n  a: 5,\n  c: {\n    f: 9,\n  },\n};\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"Object.entries(object)\"}),\" would give us \",(0,t.jsx)(e.code,{children:\"[['a', 5], ['c', { f: 9 }]]\"}),\". To get the object with the squashed keys, i.e. \",(0,t.jsx)(e.code,{children:\"{ a: 5, 'c.f': 9 }\"}),\", we need to transform array \",(0,t.jsx)(e.code,{children:\"[['a', 5], ['c', { f: 9 }]]\"}),\" into \",(0,t.jsx)(e.code,{children:\"[['a', 5], ['c.f', 9]]\"}),\" and pass it to \",(0,t.jsx)(e.code,{children:\"Object.fromEntries\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Here is the second solution and you might find it easier to understand than the previous solution.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function chunk(array, size = 2) {\n  // Helper function that groups two adjacent items in an array into one subarray.\n  const chunkedArray = [];\n  while (array.length) {\n    chunkedArray.push(array.splice(0, size));\n  }\n  return chunkedArray;\n}\n\nfunction traverse(object, path = []) {\n  if (typeof object !== 'object' || object === null) {\n    return [path.join('.'), object];\n  }\n\n  return Object.entries(object).flatMap(([key, value]) => {\n    const newPath = key === '' ? [...path] : [...path, key];\n    return traverse(value, newPath);\n  });\n}\n\nexport default function squashObject(object) {\n  const flattened = traverse(object);\n  return Object.fromEntries(chunk(flattened));\n}\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The input has to be an object, not a primitive value.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Symbol-keyed properties and non-enumerable properties are ignored.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Cyclic objects are not handled properly.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Conflicting keys with different values. JavaScript keys can contain \",(0,t.jsx)(e.code,{children:\".\"}),\" too, and existing keys which contain \",(0,t.jsx)(e.code,{children:\".\"}),\" may conflict with a resulting key. E.g. \",(0,t.jsx)(e.code,{children:\"{ a: { b: 1 }, 'a.b': 2 }\"}),\".\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"You should point this case out during interviews but probably won't have to handle it.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Keys which are empty strings.\"}),`\n`]})]})}function x(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var _=x;return k(T);})();\n;return Component;",
  "workspace": {
    "main": "/src/squash-object.ts",
    "run": "/src/squash-object.run.test.ts",
    "submit": "/src/squash-object.submit.test.ts"
  }
}