{
  "description": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var b=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),T=(t,n)=>{for(var i in n)o(t,i,{get:n[i],enumerable:!0})},r=(t,n,i,s)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let c of m(n))!p.call(t,c)&&c!==i&&o(t,c,{get:()=>n[c],enumerable:!(s=d(n,c))||s.enumerable});return t};var x=(t,n,i)=>(i=t!=null?u(f(t)):{},r(n||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),y=t=>r(o({},\"__esModule\",{value:!0}),t);var l=b((_,a)=>{a.exports=_jsx_runtime});var v={};T(v,{default:()=>j,frontmatter:()=>M});var e=x(l()),M={title:\"Limit\",excerpt:\"Implement a function that accepts a callback and restricts its invocation to at most N times\"};function h(t){let n=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"Implement a function that accepts a callback and a number \",(0,e.jsx)(n.code,{children:\"n\"}),\", which restricts invocation of the callback to at most \",(0,e.jsx)(n.code,{children:\"n\"}),\" times. Subsequent calls of the created function will return the result of the last invocation of the callback function. The callback function is invoked with the \",(0,e.jsx)(n.code,{children:\"this\"}),\" binding and arguments of the created function.\"]}),`\n`,(0,e.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`let i = 1;\n\nfunction incrementBy(value) {\n  i += value;\n  return i;\n}\n\nconst incrementByAtMostThrice = limit(incrementBy, 3);\nincrementByAtMostThrice(2); // i is now 3; The function returns 3.\nincrementByAtMostThrice(3); // i is now 6; The function returns 6.\nincrementByAtMostThrice(4); // i is now 10; The function returns 10.\nincrementByAtMostThrice(5); // i is still 10 as this is the 4th invocation; The function returns 10 as it's the result of the last invocation.\ni = 4;\nincrementByAtMostThrice(2); // i is still 4 as it is not modified. The function still returns 10.\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"Resources\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:(0,e.jsxs)(n.a,{href:\"https://lodash.com/docs/4.17.15#before\",children:[\"Lodash \",(0,e.jsx)(n.code,{children:\"_.before\"})]})}),`\n`]})]})}function g(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(h,t)})):h(t)}var j=g;return y(v);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/limit\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/limit.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/limit.run.test.ts": "import limit from './limit';\n\ndescribe('limit', () => {\n  test('returns function', () => {\n    const limited = limit(() => {}, 1);\n    expect(limited).toBeInstanceOf(Function);\n  });\n\n  test('once', () => {\n    let i = 0;\n    const limited = limit(() => ++i, 1);\n\n    limited();\n    limited();\n    expect(i).toBe(1);\n  });\n\n  test('twice', () => {\n    let i = 0;\n    const limited = limit(() => ++i, 2);\n\n    limited();\n    expect(i).toBe(1);\n    limited();\n    expect(i).toBe(2);\n    limited();\n    expect(i).toBe(2);\n    limited();\n    expect(i).toBe(2);\n  });\n});\n",
    "/src/limit.submit.test.ts": "import limit from './limit';\n\ndescribe('limit', () => {\n  test('returns function', () => {\n    const limited = limit(() => {}, 1);\n    expect(limited).toBeInstanceOf(Function);\n  });\n\n  describe('only run a limited number of times', () => {\n    test('once', () => {\n      let i = 0;\n      const limited = limit(() => ++i, 1);\n\n      limited();\n      limited();\n      expect(i).toBe(1);\n    });\n\n    test('twice', () => {\n      let i = 0;\n      const limited = limit(() => ++i, 2);\n\n      limited();\n      expect(i).toBe(1);\n      limited();\n      expect(i).toBe(2);\n      limited();\n      expect(i).toBe(2);\n      limited();\n      expect(i).toBe(2);\n    });\n\n    test('thrice', () => {\n      let i = 0;\n      const limited = limit(() => ++i, 3);\n\n      limited();\n      expect(i).toBe(1);\n      limited();\n      expect(i).toBe(2);\n      limited();\n      expect(i).toBe(3);\n      limited();\n      expect(i).toBe(3);\n      limited();\n      expect(i).toBe(3);\n    });\n  });\n\n  describe('returns the value of the last real invocation', () => {\n    test('once', () => {\n      let i = 0;\n      const limited = limit(() => ++i, 1);\n      expect(limited()).toBe(1);\n      expect(limited()).toBe(1);\n      expect(i).toBe(1);\n\n      i = 99;\n      expect(limited()).toBe(1);\n      expect(i).toBe(99);\n    });\n\n    test('twice', () => {\n      let i = 0;\n      const limited = limit(() => ++i, 2);\n      expect(limited()).toBe(1);\n      expect(limited()).toBe(2);\n      expect(i).toBe(2);\n\n      i = 99;\n      expect(limited()).toBe(2);\n      expect(i).toBe(99);\n    });\n  });\n\n  describe('accepts arguments', () => {\n    test('single arguments', () => {\n      const limited = limit((a) => a * 2, 2);\n\n      expect(limited(2)).toBe(4);\n      expect(limited(6)).toBe(12);\n      expect(limited(100)).toBe(12);\n    });\n\n    test('two arguments', () => {\n      const limited = limit((a, b) => a + b, 3);\n\n      expect(limited(2, 3)).toBe(5);\n      expect(limited(6, 7)).toBe(13);\n      expect(limited(13, 7)).toBe(20);\n      expect(limited(15, 13)).toBe(20);\n    });\n  });\n\n  test('can access this', () => {\n    const limited = limit(function (this: any, val: number) {\n      return this.multiplier * val;\n    }, 3);\n\n    const obj = { multiplier: 5, mul: limited };\n    expect(obj.mul(7)).toBe(35);\n    expect(obj.mul(10)).toBe(50);\n    expect(obj.mul(13)).toBe(65);\n    expect(obj.mul(0)).toBe(65);\n  });\n});\n",
    "/src/limit.ts": "// Function signature for callback argument.\ntype Func<TParams extends any[], TResult> = (...args: TParams) => TResult;\n\nexport default function limit<TParams extends any[], TResult>(\n  func: Func<TParams, TResult>,\n  n: number,\n): Func<TParams, TResult> {\n  let count = 0;\n  let value: TResult;\n\n  return function (this: any, ...args: TParams): TResult {\n    if (count < n) {\n      value = func.apply(this, args);\n      count++;\n    }\n\n    return value;\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [],
    "created": 1670803200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that accepts a callback and restricts its invocation to at most N times",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/limit",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "once"
    ],
    "slug": "limit",
    "subtitle": null,
    "title": "Limit",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @callback func\n * @param {number} n\n * @return {Function}\n */\nexport default function limit(func, n) {\n  throw 'Not implemented!';\n}",
    "ts": "// Function signature for callback argument.\ntype Func<TParams extends any[], TResult> = (...args: TParams) => TResult;\n\nexport default function limit<TParams extends any[], TResult>(\n  func: Func<TParams, TResult>,\n  n: number,\n): Func<TParams, TResult> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var T=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var c in e)o(t,c,{get:e[c],enumerable:!0})},l=(t,e,c,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of b(e))!v.call(t,i)&&i!==c&&o(t,i,{get:()=>e[i],enumerable:!(r=p(e,i))||r.enumerable});return t};var k=(t,e,c)=>(c=t!=null?m(g(t)):{},l(e||!t||!t.__esModule?o(c,\"default\",{value:t,enumerable:!0}):c,t)),w=t=>l(o({},\"__esModule\",{value:!0}),t);var u=T((C,a)=>{a.exports=_jsx_runtime});var _={};x(_,{default:()=>R});var n=k(u());var s=MDXCodeBlock;var d=`/**\n * @callback func\n * @param {number} n\n * @return {Function}\n */\nexport default function limit(func, n) {\n  let count = 0;\n  let value;\n\n  return function (...args) {\n    if (count < n) {\n      value = func.apply(this, args);\n      count++;\n    }\n\n    return value;\n  };\n}\n`;var h=`// Function signature for callback argument.\ntype Func<TParams extends any[], TResult> = (...args: TParams) => TResult;\n\nexport default function limit<TParams extends any[], TResult>(\n  func: Func<TParams, TResult>,\n  n: number,\n): Func<TParams, TResult> {\n  let count = 0;\n  let value: TResult;\n\n  return function (this: any, ...args: TParams): TResult {\n    if (count < n) {\n      value = func.apply(this, args);\n      count++;\n    }\n\n    return value;\n  };\n}\n`;function f(t){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"We can use closures to capture state required by the returned function. The returned function's closure has access to the following variables:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"func\"}),\": The first argument to \",(0,n.jsx)(e.code,{children:\"limit()\"}),\", the callback function to be invoked.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"n\"}),\": The second argument to \",(0,n.jsx)(e.code,{children:\"limit()\"}),\", the maximum number of times the callback function can be invoked.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"count\"}),\": A boolean variable indicating the number of times the function has been invoked before. \",(0,n.jsx)(e.code,{children:\"func\"}),\" will only be invoked if \",(0,n.jsx)(e.code,{children:\"count < n\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"value\"}),\": Since we need to return the value of the last invocation for subsequent invocations exceeding \",(0,n.jsx)(e.code,{children:\"n\"}),\", we have to save the result of the last invocation and return it directly for those situation.\"]}),`\n`]}),`\n`,(0,n.jsx)(s,{languages:{jsx:d,tsx:h}}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that the callback function is invoked with the \",(0,n.jsx)(e.code,{children:\"this\"}),\" binding and arguments of the created function, hence we cannot return an arrow function if we want the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" to refer to the object calling the created function.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Functions which access \",(0,n.jsx)(e.code,{children:\"this\"})]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Closures\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"How \",(0,n.jsx)(e.code,{children:\"this\"}),\" works\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Invoking functions via \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"})]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/4.17.15#before\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.before\"})]})}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var R=j;return w(_);})();\n;return Component;",
  "workspace": {
    "main": "/src/limit.ts",
    "run": "/src/limit.run.test.ts",
    "submit": "/src/limit.submit.test.ts"
  }
}