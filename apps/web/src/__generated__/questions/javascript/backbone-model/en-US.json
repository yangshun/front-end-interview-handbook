{
  "description": "var Component=(()=>{var s=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var m=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var i in e)c(t,i,{get:e[i],enumerable:!0})},l=(t,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!g.call(t,r)&&r!==i&&c(t,r,{get:()=>e[r],enumerable:!(d=u(e,r))||d.enumerable});return t};var v=(t,e,i)=>(i=t!=null?s(p(t)):{},l(e||!t||!t.__esModule?c(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>l(c({},\"__esModule\",{value:!0}),t);var a=m((B,h)=>{h.exports=_jsx_runtime});var x={};f(x,{default:()=>T,frontmatter:()=>w});var n=v(a()),w={title:\"Backbone Model\",excerpt:\"Implement a class resembling Backbone.Model which allows storing of attributes/values and responding to changes in specific attribute values\"};function o(t){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",h2:\"h2\",h3:\"h3\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",pre:\"pre\",ul:\"ul\",li:\"li\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Before modern UI libraries like React, Angular, and Vue, Backbone.js was the popular library used for building web applications. Backbone.js is a lightweight JavaScript library that provides the structure for developing web applications by offering models, views, collections, and routers. It follows the principles of the Model-View-Controller (MVC) architectural pattern, helping developers organize their code in a modular and maintainable way.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this question, we will focus on implementing a subset of functionality of \",(0,n.jsx)(e.a,{href:\"https://backbonejs.org/#Model\",children:(0,n.jsx)(e.code,{children:\"Backbone.Model\"})}),\" class functionality, which allows storing of attributes/values and responding to changes in specific attribute values.\"]}),`\n`,(0,n.jsxs)(e.h2,{children:[(0,n.jsx)(e.code,{children:\"BackboneModel\"}),\" API\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement the following APIs on the \",(0,n.jsx)(e.code,{children:\"BackboneModel\"}),\":\"]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"new BackboneModel([initialValues])\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Creates an instance of the \",(0,n.jsx)(e.code,{children:\"BackboneModel\"}),\" class which accepts an optional object of attribute/value pairs. Attributes and event callbacks are isolated within the \",(0,n.jsx)(e.code,{children:\"BackboneModel\"}),\" instances they're added to, aka callbacks shouldn't react to changes in other \",(0,n.jsx)(e.code,{children:\"BackboneModel\"}),\" instances.\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Parameter\"}),(0,n.jsx)(e.th,{children:\"Type\"}),(0,n.jsx)(e.th,{children:\"Description\"})]})}),(0,n.jsx)(e.tbody,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"initialValues\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"Object\"})}),(0,n.jsx)(e.td,{children:\"Initial values for the model attributes. Defaults to an empty object.\"})]})})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const person1 = new BackboneModel();\nconst person2 = new BackboneModel({ name: 'John', age: 32 });\n`})}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"model.get(attribute)\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Get the value of a specific attribute.\"}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Parameter\"}),(0,n.jsx)(e.th,{children:\"Type\"}),(0,n.jsx)(e.th,{children:\"Description\"})]})}),(0,n.jsx)(e.tbody,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"attribute\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"string\"})}),(0,n.jsx)(e.td,{children:\"The attribute name.\"})]})})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Returns the value of the specified attribute or \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" if the attribute is not set.\"]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"model.set(attribute, value)\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Set the value of a specific attribute. Fires the \",(0,n.jsx)(e.code,{children:'\"change\"'}),\" event for the attribute.\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Parameter\"}),(0,n.jsx)(e.th,{children:\"Type\"}),(0,n.jsx)(e.th,{children:\"Description\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"attribute\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"string\"})}),(0,n.jsx)(e.td,{children:\"The attribute name.\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"value\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"unknown\"})}),(0,n.jsx)(e.td,{children:\"The value to set for the attribute.\"})]})]})]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"model.has(attribute)\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Check if the model contains a specific attribute.\"}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Parameter\"}),(0,n.jsx)(e.th,{children:\"Type\"}),(0,n.jsx)(e.th,{children:\"Description\"})]})}),(0,n.jsx)(e.tbody,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"attribute\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"string\"})}),(0,n.jsx)(e.td,{children:\"The attribute name.\"})]})})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the model has the specified attribute, otherwise \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"model.unset(attribute)\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Removes the attribute from the model. Fires the \",(0,n.jsx)(e.code,{children:'\"unset\"'}),\" event for the attribute.\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Parameter\"}),(0,n.jsx)(e.th,{children:\"Type\"}),(0,n.jsx)(e.th,{children:\"Description\"})]})}),(0,n.jsx)(e.tbody,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"attribute\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"string\"})}),(0,n.jsx)(e.td,{children:\"The attribute name to unset.\"})]})})]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"model.on(event, attribute, callback, context)\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Register an event listener for changes to a specific attribute.\"}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Parameter\"}),(0,n.jsx)(e.th,{children:\"Type\"}),(0,n.jsx)(e.th,{children:\"Description\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"event\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"string\"})}),(0,n.jsxs)(e.td,{children:[\"The event name, either \",(0,n.jsx)(e.code,{children:\"'change'\"}),\" or \",(0,n.jsx)(e.code,{children:\"'unset'\"}),\".\"]})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"attribute\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"string\"})}),(0,n.jsx)(e.td,{children:\"The attribute name to listen for changes.\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"callback\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"Function\"})}),(0,n.jsx)(e.td,{children:\"The callback function to be executed on the event.\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"context\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"any\"})}),(0,n.jsx)(e.td,{children:\"(Optional) The context in which to execute the callback.\"})]})]})]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Each event \",(0,n.jsx)(e.code,{children:\"callback\"}),\" is invoked with different parameters depending on the event:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"change\"}),\": Fired when the value of an attribute changes (via \",(0,n.jsx)(e.code,{children:\"model.set()\"}),\"). The callback is invoked with attribute name, new value, and old value, in that order.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"unset\"}),\": Fired when an attribute is unset (via \",(0,n.jsx)(e.code,{children:\"model.unset()\"}),\"). The callback is invoked with the attribute name.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"context\"}),\" parameter is optional and is used to specify the context (\",(0,n.jsx)(e.code,{children:\"this\"}),\" value) in which the callback function should be executed.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"model.off(event, attribute, callback)\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Remove an event listener for changes to a specific attribute.\"}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Parameter\"}),(0,n.jsx)(e.th,{children:\"Type\"}),(0,n.jsx)(e.th,{children:\"Description\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"event\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"string\"})}),(0,n.jsxs)(e.td,{children:[\"The event name, either \",(0,n.jsx)(e.code,{children:\"'change'\"}),\" or \",(0,n.jsx)(e.code,{children:\"'unset'\"}),\".\"]})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"attribute\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"string\"})}),(0,n.jsx)(e.td,{children:\"The attribute name to stop listening for changes.\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"callback\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"Function\"})}),(0,n.jsx)(e.td,{children:\"The callback function to remove.\"})]})]})]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Instantiate the BackboneModel.\nconst person = new BackboneModel({ name: 'John', age: 30 });\n\n// Log initial values.\nconsole.log(person.get('name')); // \"John\"\nconsole.log(person.get('age')); // 30\n\n// Set new values.\nperson.set('name', 'Jane');\nperson.set('age', 25);\n\n// Log updated values.\nconsole.log(person.get('name')); // \"Jane\"\nconsole.log(person.get('age')); // 25\n\n// Check if the model has a specific attribute.\nconsole.log(person.has('name')); // true\nconsole.log(person.has('gender')); // false\n\n// Unset an attribute.\nperson.unset('age');\nconsole.log(person.get('age')); // undefined\n\nfunction nameChangeCallback(attribute, newName, oldName) {\n  console.log(\\`'\\${attribute}' changed from '\\${newName}' to '\\${oldName}'\\`);\n}\n// Register an event listener for a change in the \\`name\\` field.\nperson.on('change', 'name', nameChangeCallback);\n\n// Trigger the 'change' event for the 'name' attribute.\nperson.set('name', 'Bob');\n// > \"'name' changed from 'Jane' to 'Bob'\"\n\n// Remove an event listener for the 'name' attribute.\nperson.off('name', nameChangeCallback);\n\n// Trigger the 'change' event again.\nperson.set('name', 'Alice');\n// No output because the listener was removed.\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Changelog\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"2024/06/08\"}),\": Changed \",(0,n.jsx)(e.code,{children:\"on\"}),\" callback parameter order to be \",(0,n.jsx)(e.code,{children:\"(attribute, newValue, oldValue)\"}),\".\"]}),`\n`]})]})}function y(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(o,t)})):o(t)}var T=y;return k(x);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/backbone-model\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/backbone-model.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/backbone-model.run.test.ts": "import BackboneModel from './backbone-model';\n\ndescribe('BackboneModel', () => {\n  test('constructor', () => {\n    const person = new BackboneModel();\n    expect(person).toBeInstanceOf(BackboneModel);\n  });\n\n  test('get', () => {\n    const person = new BackboneModel({ name: 'John', age: 30 });\n    expect(person.get('name')).toBe('John');\n    expect(person.get('age')).toBe(30);\n  });\n\n  test('set', () => {\n    const person = new BackboneModel();\n    person.set('name', 'Carol');\n\n    expect(person.get('name')).toBe('Carol');\n  });\n\n  test('has', () => {\n    const person = new BackboneModel({ name: 'John' });\n    expect(person.has('name')).toBe(true);\n  });\n\n  test('unset', () => {\n    const person = new BackboneModel({ name: 'John', age: 30 });\n    expect(person.has('name')).toBe(true);\n    person.unset('name');\n\n    expect(person.has('name')).toBe(false);\n  });\n\n  describe('on', () => {\n    test('change', () => {\n      let fired = false;\n      const person = new BackboneModel({ name: 'John' });\n      person.on('change', 'name', () => {\n        fired = true;\n      });\n      person.set('name', 'Johnny');\n\n      expect(person.get('name')).toBe('Johnny');\n      expect(fired).toBe(true);\n    });\n\n    test('unset', () => {\n      let fired = false;\n      const person = new BackboneModel({ name: 'John' });\n      person.on('unset', 'name', () => {\n        fired = true;\n      });\n      person.unset('name');\n\n      expect(fired).toBe(true);\n      expect(person.get('name')).toBeUndefined();\n    });\n  });\n\n  test('off', () => {\n    let times = 0;\n    function callback() {\n      times++;\n    }\n\n    const person = new BackboneModel({ name: 'John' });\n    person.on('change', 'name', callback);\n\n    person.set('name', 'Johnny');\n    expect(person.get('name')).toBe('Johnny');\n    expect(times).toEqual(1);\n\n    person.set('name', 'Carol');\n    expect(person.get('name')).toBe('Carol');\n    expect(times).toEqual(2);\n\n    person.off('change', 'name', callback);\n    person.set('name', 'Caroline');\n    expect(person.get('name')).toBe('Caroline');\n    expect(times).toEqual(2);\n  });\n});\n",
    "/src/backbone-model.submit.test.ts": "import BackboneModel from './backbone-model';\n\ndescribe('BackboneModel', () => {\n  describe('constructor', () => {\n    test('without default data', () => {\n      const person = new BackboneModel();\n      expect(person).toBeInstanceOf(BackboneModel);\n    });\n\n    test('with default data', () => {\n      const person = new BackboneModel({ name: 'John', age: 30 });\n      expect(person).toBeInstanceOf(BackboneModel);\n    });\n  });\n\n  describe('get', () => {\n    test('existing field', () => {\n      const person = new BackboneModel({ name: 'John', age: 30 });\n      expect(person.get('name')).toBe('John');\n      expect(person.get('age')).toBe(30);\n    });\n\n    test('non-existing field', () => {\n      const person = new BackboneModel();\n      expect(person.get('name')).toBeUndefined();\n    });\n  });\n\n  describe('set', () => {\n    test('new field', () => {\n      const person = new BackboneModel();\n      person.set('name', 'Carol');\n\n      expect(person.get('name')).toBe('Carol');\n    });\n\n    test('existing field', () => {\n      const person = new BackboneModel({ name: 'John', age: 30 });\n      expect(person.get('name')).toBe('John');\n\n      person.set('name', 'Carol');\n      expect(person.get('name')).toBe('Carol');\n    });\n  });\n\n  describe('has', () => {\n    test('existing field', () => {\n      const person = new BackboneModel({ name: 'John' });\n      expect(person.has('name')).toBe(true);\n    });\n\n    test('non-existing field', () => {\n      const person = new BackboneModel({ name: 'John' });\n      expect(person.has('age')).toBe(false);\n    });\n  });\n\n  describe('unset', () => {\n    test('existing field', () => {\n      const person = new BackboneModel({ name: 'John', age: 30 });\n      expect(person.has('name')).toBe(true);\n      person.unset('name');\n\n      expect(person.has('name')).toBe(false);\n    });\n\n    test('non-existing field', () => {\n      const person = new BackboneModel({ name: 'John' });\n      person.unset('age');\n\n      expect(person.has('age')).toBe(false);\n    });\n  });\n\n  describe('on', () => {\n    describe('change event', () => {\n      test('callback invoked when attribute changes', () => {\n        let fired = false;\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', () => {\n          fired = true;\n        });\n        person.set('name', 'Johnny');\n\n        expect(person.get('name')).toBe('Johnny');\n        expect(fired).toBe(true);\n      });\n\n      test('callback invoked with correct arguments', () => {\n        let args: Array<any> = [];\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', (...args_: Array<any>) => {\n          args = args_;\n        });\n        person.set('name', 'Johnny');\n\n        expect(person.get('name')).toBe('Johnny');\n        expect(args).toEqual(['name', 'Johnny', 'John']);\n      });\n\n      test('callback invoked with `this`', () => {\n        let user = { name: 'Boo' };\n        const person = new BackboneModel({ name: 'John' });\n        person.on(\n          'change',\n          'name',\n          function (\n            this: any,\n            attribute: string,\n            newValue: any,\n            _oldValue: any,\n          ) {\n            this[attribute] = newValue;\n          },\n          user,\n        );\n        expect(user.name).toBe('Boo');\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(user.name).toEqual('Johnny');\n      });\n\n      test('works for multiple changes', () => {\n        let args: Array<any> = [];\n\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', (...args_: Array<any>) => {\n          args = args_;\n        });\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(args).toEqual(['name', 'Johnny', 'John']);\n\n        person.set('name', 'Carol');\n        expect(person.get('name')).toBe('Carol');\n        expect(args).toEqual(['name', 'Carol', 'Johnny']);\n      });\n\n      test('does not fire when no change', () => {\n        let times = 0;\n        function callback() {\n          times++;\n        }\n\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', callback);\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(times).toEqual(1);\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(times).toEqual(1);\n      });\n\n      test('removed when unset', () => {\n        let times = 0;\n\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', () => {\n          times++;\n        });\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(times).toBe(1);\n\n        person.unset('name');\n        person.set('name', 'Carol');\n        person.set('name', 'Caroline');\n        expect(times).toBe(1);\n      });\n    });\n\n    describe('unset event', () => {\n      test('callback invoked when attribute unset', () => {\n        let fired = false;\n        const person = new BackboneModel({ name: 'John' });\n        person.on('unset', 'name', () => {\n          fired = true;\n        });\n        person.unset('name');\n\n        expect(fired).toBe(true);\n        expect(person.get('name')).toBeUndefined();\n      });\n\n      test('callback invoked with correct arguments', () => {\n        let args: Array<any> = [];\n        const person = new BackboneModel({ name: 'John' });\n        person.on('unset', 'name', (...args_: Array<any>) => {\n          args = args_;\n        });\n        person.unset('name');\n\n        expect(args).toEqual(['name']);\n        expect(person.get('name')).toBeUndefined();\n      });\n\n      test('callback invoked with `this`', () => {\n        let unsetAttribute = { name: null };\n        const person = new BackboneModel({ name: 'John' });\n        person.on(\n          'unset',\n          'name',\n          function (this: any, attribute: string) {\n            this.name = attribute;\n          },\n          unsetAttribute,\n        );\n        expect(unsetAttribute.name).toBeNull();\n        person.unset('name');\n\n        expect(person.get('name')).toBeUndefined();\n        expect(unsetAttribute.name).toEqual('name');\n      });\n    });\n\n    test('non-existing attribute does not error', () => {\n      const person = new BackboneModel();\n      expect(() => {\n        person.on('change', 'boo', () => {});\n      }).not.toThrow();\n    });\n\n    test('not called after the attribute is set', () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n      const person = new BackboneModel();\n      person.on('change', 'name', callback);\n\n      person.set('name', 'John');\n      expect(times).toBe(0);\n\n      person.set('name', 'Johnny');\n      expect(times).toBe(0);\n    });\n\n    describe('multiple callbacks', () => {\n      test('same callback can be added multiple times for the same attribute and event', () => {\n        let times = 0;\n        function callback() {\n          times++;\n        }\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', callback);\n        person.on('change', 'name', callback);\n\n        person.set('name', 'Johnny');\n        expect(times).toBe(2);\n      });\n\n      test('different callbacks for the same attribute and event', () => {\n        let foo = 0;\n        let bar = 0;\n        function fooIncrement() {\n          foo++;\n        }\n        function barIncrement() {\n          bar++;\n        }\n\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', fooIncrement);\n        person.on('change', 'name', barIncrement);\n\n        person.set('name', 'Johnny');\n        expect(foo).toBe(1);\n        expect(bar).toBe(1);\n      });\n    });\n\n    test('event callbacks are isolated within instances', () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const john = new BackboneModel({ name: 'John', age: 32 });\n      const _carol = new BackboneModel({ name: 'Carol', age: 36 });\n\n      john.on('change', 'age', callback);\n      john.set('age', 33);\n      expect(john.get('age')).toBe(33);\n      expect(times).toEqual(1);\n    });\n  });\n\n  describe('off', () => {\n    test('works for `change`', () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const person = new BackboneModel({ name: 'John' });\n      person.on('change', 'name', callback);\n\n      person.set('name', 'Johnny');\n      expect(person.get('name')).toBe('Johnny');\n      expect(times).toEqual(1);\n\n      person.set('name', 'Carol');\n      expect(person.get('name')).toBe('Carol');\n      expect(times).toEqual(2);\n\n      person.off('change', 'name', callback);\n      person.set('name', 'Caroline');\n      expect(person.get('name')).toBe('Caroline');\n      expect(times).toEqual(2);\n    });\n\n    test('works for `unset`', () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const person = new BackboneModel({ name: 'John' });\n      person.on('unset', 'name', callback);\n\n      person.set('name', 'Johnny');\n      expect(person.get('name')).toBe('Johnny');\n\n      person.off('unset', 'name', callback);\n      person.unset('name');\n      expect(person.get('name')).toBeUndefined();\n      expect(times).toEqual(0);\n    });\n\n    test('callbacks can be removed individually', () => {\n      let foo = 0;\n      let bar = 0;\n      function fooIncrement() {\n        foo++;\n      }\n      function barIncrement() {\n        bar++;\n      }\n\n      const person = new BackboneModel({ name: 'John' });\n      person.on('change', 'name', fooIncrement);\n      person.on('change', 'name', barIncrement);\n\n      person.set('name', 'Johnny');\n      expect(foo).toBe(1);\n      expect(bar).toBe(1);\n\n      person.off('change', 'name', fooIncrement);\n\n      person.set('name', 'Carol');\n      expect(foo).toBe(1);\n      expect(bar).toBe(2);\n    });\n  });\n\n  test('integration', () => {\n    let times = 0;\n    function callback() {\n      times++;\n    }\n\n    const person = new BackboneModel({ name: 'John', age: 32 });\n    expect(person.has('name')).toBe(true);\n    expect(person.has('age')).toBe(true);\n\n    person.on('change', 'name', callback);\n    person.on('change', 'age', callback);\n    person.on('unset', 'name', callback);\n\n    person.set('name', 'Johnny');\n    expect(person.get('name')).toBe('Johnny');\n    expect(times).toEqual(1);\n\n    person.set('name', 'Johnny');\n    expect(person.get('name')).toBe('Johnny');\n    expect(times).toEqual(1);\n\n    person.unset('name');\n    expect(times).toEqual(2);\n    expect(person.has('name')).toBe(false);\n\n    person.set('age', 33);\n    expect(person.get('age')).toBe(33);\n    expect(times).toEqual(3);\n\n    person.off('change', 'age', callback);\n    expect(person.set('age', 34));\n    expect(times).toEqual(3);\n  });\n});\n",
    "/src/backbone-model.ts": "type EventName = 'change' | 'unset';\n\ninterface IBackboneModel {\n  get(attribute: string): unknown | undefined;\n  set(attribute: string, value: unknown): void;\n  has(attribute: string): boolean;\n  unset(attribute: string): void;\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void;\n  off(eventName: EventName, attribute: string, callback: Function): void;\n}\n\ntype CallbackData = { fn: Function; context: any };\ntype AttributeData = {\n  value: unknown;\n  events: {\n    change: Array<CallbackData>;\n    unset: Array<CallbackData>;\n  };\n};\n\n// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel implements IBackboneModel {\n  _attributes: Map<string, AttributeData>;\n\n  constructor(initialValues: Record<string, unknown> = {}) {\n    this._attributes = new Map();\n    Object.entries(initialValues).forEach(([attribute, value]) => {\n      this._attributes.set(attribute, {\n        value,\n        events: {\n          change: [],\n          unset: [],\n        },\n      });\n    });\n  }\n\n  get(attribute: string): unknown | undefined {\n    return this._attributes.get(attribute)?.value;\n  }\n\n  set(attribute: string, value: unknown): void {\n    const attributeData: AttributeData = this.has(attribute)\n      ? this._attributes.get(attribute)!\n      : {\n          value,\n          events: {\n            change: [],\n            unset: [],\n          },\n        };\n\n    // Only invoke callbacks if there's a change in the values.\n    if (attributeData.value !== value) {\n      // Invoke callbacks listening for the `change` event.\n      attributeData.events.change.forEach((callback) => {\n        callback.fn.call(\n          callback.context ?? null,\n          attribute,\n          value,\n          attributeData.value,\n        );\n      });\n    }\n\n    attributeData.value = value;\n    this._attributes.set(attribute, attributeData);\n  }\n\n  has(attribute: string): boolean {\n    return this._attributes.has(attribute);\n  }\n\n  unset(attribute: string): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Invoke callbacks listening for the `unset` event.\n    attributeData.events.unset.forEach((callback) => {\n      callback.fn.call(callback.context ?? null, attribute);\n    });\n    // Remove the attribute entirely.\n    this._attributes.delete(attribute);\n  }\n\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Add to the list of callbacks.\n    attributeData.events[eventName].push({\n      fn: callback,\n      context,\n    });\n  }\n\n  off(eventName: EventName, attribute: string, callback: Function): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Remove from the added list of callbacks.\n    attributeData.events[eventName] = attributeData.events[eventName].filter(\n      ({ fn }) => fn !== callback,\n    );\n  }\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [
      "airbnb"
    ],
    "created": 1699660800,
    "difficulty": "hard",
    "duration": 30,
    "excerpt": "Implement a class resembling Backbone.Model which allows storing of attributes/values and responding to changes in specific attribute values",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/backbone-model",
    "importance": "medium",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "event-emitter",
      "event-emitter-ii"
    ],
    "slug": "backbone-model",
    "subtitle": null,
    "title": "Backbone Model",
    "topics": [
      "oop"
    ]
  },
  "skeleton": {
    "js": "// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel {\n  /**\n   * @param {Object} initialValues\n   * @returns BackboneModel\n   */\n  constructor(initialValues) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the value of a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @returns {any | undefined} The value of the attribute.\n   */\n  get(attribute) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Set the value of a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @param {any} value - The value to set for the attribute.\n   */\n  set(attribute, value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Check if the model has a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @returns {boolean} `true` if the model has the attribute, `false` otherwise.\n   */\n  has(attribute) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Unset a specific attribute.\n   * @param {string} attribute - The attribute name to unset.\n   */\n  unset(attribute) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Register an event listener for changes to a specific attribute.\n   * @param {string} eventName - The event name.\n   * @param {string} attribute - The attribute name to listen for changes.\n   * @param {Function} callback - The callback function to be executed on the event.\n   * @param {any} [context] - The context in which to execute the callback.\n   */\n  on(eventName, attribute, callback, context) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Remove an event listener for changes to a specific attribute.\n   * @param {string} eventName - The event name.\n   * @param {string} attribute - The attribute name to stop listening for changes.\n   * @param {Function} callback - The callback function to remove.\n   */\n  off(eventName, attribute, callback) {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "type EventName = 'change' | 'unset';\n\ninterface IBackboneModel {\n  get(attribute: string): unknown | undefined;\n  set(attribute: string, value: unknown): void;\n  has(attribute: string): boolean;\n  unset(attribute: string): void;\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void;\n  off(event: EventName, attribute: string, callback: Function): void;\n}\n\n// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel implements IBackboneModel {\n  constructor(initialValues: Record<string, unknown> = {}) {\n    throw 'Not implemented!';\n  }\n\n  get(attribute: string): unknown | undefined {\n    throw 'Not implemented!';\n  }\n\n  set(attribute: string, value: unknown): void {\n    throw 'Not implemented!';\n  }\n\n  has(attribute: string): boolean {\n    throw 'Not implemented!';\n  }\n\n  unset(attribute: string): void {\n    throw 'Not implemented!';\n  }\n\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void {\n    throw 'Not implemented!';\n  }\n\n  off(eventName: EventName, attribute: string, callback: Function): void {\n    throw 'Not implemented!';\n  }\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var r=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var k=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var a in e)r(n,a,{get:e[a],enumerable:!0})},c=(n,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!p.call(n,i)&&i!==a&&r(n,i,{get:()=>e[i],enumerable:!(l=v(e,i))||l.enumerable});return n};var D=(n,e,a)=>(a=n!=null?f(g(n)):{},c(e||!n||!n.__esModule?r(a,\"default\",{value:n,enumerable:!0}):a,n)),w=n=>c(r({},\"__esModule\",{value:!0}),n);var s=k((I,o)=>{o.exports=_jsx_runtime});var M={};x(M,{default:()=>N});var t=D(s());var h=MDXCodeBlock;var u=`// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel {\n  /**\n   * @param {Object} initialValues\n   * @returns BackboneModel\n   */\n  constructor(initialValues = {}) {\n    this._attributes = new Map();\n    Object.entries(initialValues).forEach(([attribute, value]) => {\n      this._attributes.set(attribute, {\n        value,\n        events: {\n          change: [],\n          unset: [],\n        },\n      });\n    });\n  }\n\n  /**\n   * Get the value of a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @returns {any | undefined} The value of the attribute.\n   */\n  get(attribute) {\n    return this._attributes.get(attribute)?.value;\n  }\n\n  /**\n   * Set the value of a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @param {any} value - The value to set for the attribute.\n   */\n  set(attribute, value) {\n    const attributeData = this.has(attribute)\n      ? this._attributes.get(attribute)\n      : {\n          value,\n          events: {\n            change: [],\n            unset: [],\n          },\n        };\n\n    // Only invoke callbacks if there's a change in the values.\n    if (attributeData.value !== value) {\n      // Invoke callbacks listening for the \\`change\\` event.\n      attributeData.events.change.forEach((callback) => {\n        callback.fn.call(\n          callback.context ?? null,\n          attribute,\n          value,\n          attributeData.value,\n        );\n      });\n    }\n\n    attributeData.value = value;\n    this._attributes.set(attribute, attributeData);\n  }\n\n  /**\n   * Check if the model has a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @returns {boolean} \\`true\\` if the model has the attribute, \\`false\\` otherwise.\n   */\n  has(attribute) {\n    return this._attributes.has(attribute);\n  }\n\n  /**\n   * Unset a specific attribute.\n   * @param {string} attribute - The attribute name to unset.\n   */\n  unset(attribute) {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Invoke callbacks listening for the \\`unset\\` event.\n    attributeData.events.unset.forEach((callback) => {\n      callback.fn.call(callback.context ?? null, attribute);\n    });\n    // Remove the attribute entirely.\n    this._attributes.delete(attribute);\n  }\n\n  /**\n   * Register an event listener for changes to a specific attribute.\n   * @param {string} eventName - The event name.\n   * @param {string} attribute - The attribute name to listen for changes.\n   * @param {Function} callback - The callback function to be executed on the event.\n   * @param {any} [context] - The context in which to execute the callback.\n   */\n  on(eventName, attribute, callback, context) {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Add to the list of callbacks.\n    attributeData.events[eventName].push({\n      fn: callback,\n      context,\n    });\n  }\n\n  /**\n   * Remove an event listener for changes to a specific attribute.\n   * @param {string} eventName - The event name.\n   * @param {string} attribute - The attribute name to stop listening for changes.\n   * @param {Function} callback - The callback function to remove.\n   */\n  off(eventName, attribute, callback) {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Remove from the added list of callbacks.\n    attributeData.events[eventName] = attributeData.events[eventName].filter(\n      ({ fn }) => fn !== callback,\n    );\n  }\n}\n`;var d=`type EventName = 'change' | 'unset';\n\ninterface IBackboneModel {\n  get(attribute: string): unknown | undefined;\n  set(attribute: string, value: unknown): void;\n  has(attribute: string): boolean;\n  unset(attribute: string): void;\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void;\n  off(eventName: EventName, attribute: string, callback: Function): void;\n}\n\ntype CallbackData = { fn: Function; context: any };\ntype AttributeData = {\n  value: unknown;\n  events: {\n    change: Array<CallbackData>;\n    unset: Array<CallbackData>;\n  };\n};\n\n// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel implements IBackboneModel {\n  _attributes: Map<string, AttributeData>;\n\n  constructor(initialValues: Record<string, unknown> = {}) {\n    this._attributes = new Map();\n    Object.entries(initialValues).forEach(([attribute, value]) => {\n      this._attributes.set(attribute, {\n        value,\n        events: {\n          change: [],\n          unset: [],\n        },\n      });\n    });\n  }\n\n  get(attribute: string): unknown | undefined {\n    return this._attributes.get(attribute)?.value;\n  }\n\n  set(attribute: string, value: unknown): void {\n    const attributeData: AttributeData = this.has(attribute)\n      ? this._attributes.get(attribute)!\n      : {\n          value,\n          events: {\n            change: [],\n            unset: [],\n          },\n        };\n\n    // Only invoke callbacks if there's a change in the values.\n    if (attributeData.value !== value) {\n      // Invoke callbacks listening for the \\`change\\` event.\n      attributeData.events.change.forEach((callback) => {\n        callback.fn.call(\n          callback.context ?? null,\n          attribute,\n          value,\n          attributeData.value,\n        );\n      });\n    }\n\n    attributeData.value = value;\n    this._attributes.set(attribute, attributeData);\n  }\n\n  has(attribute: string): boolean {\n    return this._attributes.has(attribute);\n  }\n\n  unset(attribute: string): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Invoke callbacks listening for the \\`unset\\` event.\n    attributeData.events.unset.forEach((callback) => {\n      callback.fn.call(callback.context ?? null, attribute);\n    });\n    // Remove the attribute entirely.\n    this._attributes.delete(attribute);\n  }\n\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Add to the list of callbacks.\n    attributeData.events[eventName].push({\n      fn: callback,\n      context,\n    });\n  }\n\n  off(eventName: EventName, attribute: string, callback: Function): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Remove from the added list of callbacks.\n    attributeData.events[eventName] = attributeData.events[eventName].filter(\n      ({ fn }) => fn !== callback,\n    );\n  }\n}\n`;function b(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",h3:\"h3\",pre:\"pre\",h4:\"h4\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" This question is an extension of \",(0,t.jsx)(e.a,{href:\"/questions/javascript/event-emitter-ii\",children:\"Event Emitter II\"}),\", you are recommended to complete that question first.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,t.jsx)(e.p,{children:\"The following are good questions to ask the interviewer to demonstrate your thoughtfulness. Depending on their response, you might need to adjust the implementation accordingly.\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"How should values be compared for the \",(0,t.jsx)(e.code,{children:\"'change'\"}),\" event?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Strict equality can be used.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Can the same callback be added multiple times for the same attribute and event?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Yes, it can be. It will be called once for each time it is added when the event is emitted, in the order the callbacks were added.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Can non-existent events be emitted?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Yes, but nothing should happen and the code should not error or crash.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"What should the \",(0,t.jsx)(e.code,{children:\"this\"}),\" value of the callbacks be if it's not specified?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"It can be \",(0,t.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Can \",(0,t.jsx)(e.code,{children:\"model.off()\"}),\" be called more than once?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Yes it can be, it should ignore callbacks that aren't added.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Can callbacks contain code that invoke methods on the emitter instance?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Yes, but we can ignore that scenario for this question.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"What if the added callbacks throw an error when an event is fired?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The error should be caught and not halt the rest of the execution. However, we will not test for this case.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"We will handle all the above cases except for the last two cases.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Data structure\"}),`\n`,(0,t.jsx)(e.p,{children:\"Firstly, we have to decide on the data structure to store the events and the callbacks.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"There's a few hierarchy of attribute > event (\",(0,t.jsx)(e.code,{children:\"'change'\"}),\", \",(0,t.jsx)(e.code,{children:\"'unset'\"}),\") > callback here, and the shape of our data can reflect this hierarchy. The tradeoffs between data structures for event callbacks have been discussed in \",(0,t.jsx)(e.a,{href:\"/questions/javascript/event-emitter-ii\",children:\"Event Emitter II\"}),\" and one plausible choice is to have a \",(0,t.jsx)(e.code,{children:\"Map\"}),\" of attribute strings to objects where the key is the event name and value is array of callbacks and contexts.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ts\",children:`type CallbackData = { fn: Function; context: any };\ntype AttributeData = {\n  value: unknown;\n  events: {\n    change: Array<CallbackData>;\n    unset: Array<CallbackData>;\n  };\n};\n\nexport default class BackboneModel {\n  _attributes: Map<string, AttributeData>;\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"A concrete example:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`Map(2) {\n  name: {\n    change: [\n      { fn: Function1, context: Object },\n      { fn: Function2, context: Object },\n    ],\n    unset: [\n      { fn: Function3, context: Object },\n    ],\n  },\n  age: {\n    change: [],\n    unset: [{ fn: Function4, context: Object }]\n  },\n};\n`})}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Pros:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Fast lookup of callbacks given an attribute and the event.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Cons:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Cannot remove specific callbacks for an event if the callback was added multiple times. However, this is not a requirement of the question.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Implementation\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Here's an explanation for the constructor and each method of the \",(0,t.jsx)(e.code,{children:\"BackboneModel\"}),\" class:\"]}),`\n`,(0,t.jsx)(e.h4,{children:\"Constructor\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The constructor initializes a new instance of the \",(0,t.jsx)(e.code,{children:\"BackboneModel\"}),\" class. It takes an optional \",(0,t.jsx)(e.code,{children:\"initialValues\"}),\" parameter, which is a record of initial attribute values for the model. The constructor sets up the internal \",(0,t.jsx)(e.code,{children:\"_attributes\"}),\" map, where each attribute is associated with an object containing its current value and event callbacks for 'change' and 'unset' events. If \",(0,t.jsx)(e.code,{children:\"initialValues\"}),\" is provided, it iterates through each entry and sets up the initial attribute values.\"]}),`\n`,(0,t.jsx)(e.h4,{children:(0,t.jsx)(e.code,{children:\"model.get()\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"get\"}),\" method retrieves the current value of the specified attribute. If the attribute exists in the model, it returns its current value; otherwise, it returns \",(0,t.jsx)(e.code,{children:\"undefined\"}),\".\"]}),`\n`,(0,t.jsx)(e.h4,{children:(0,t.jsx)(e.code,{children:\"model.set()\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"set\"}),\" method sets the value of the specified attribute. It checks if the attribute already exists in the model. If it does, it triggers \",(0,t.jsx)(e.code,{children:\"'change'\"}),\" callbacks only if the new value is different from the current one. It then updates the attribute's value and stores it in the internal \",(0,t.jsx)(e.code,{children:\"_attributes\"}),\" map.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The callbacks should be invoked with the respective \",(0,t.jsx)(e.code,{children:\"this\"}),\", if it was specified during \",(0,t.jsx)(e.code,{children:\"model.on('change', ...)\"}),\".\"]}),`\n`,(0,t.jsx)(e.h4,{children:(0,t.jsx)(e.code,{children:\"model.has()\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"has\"}),\" method checks if the model has a specific attribute. It returns \",(0,t.jsx)(e.code,{children:\"true\"}),\" if the attribute exists in the model, and \",(0,t.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,t.jsx)(e.h4,{children:(0,t.jsx)(e.code,{children:\"model.unset()\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"unset\"}),\" method removes a specific attribute from the model. It triggers 'unset' callbacks and then removes the attribute from the internal \",(0,t.jsx)(e.code,{children:\"_attributes\"}),\" map.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The callbacks should be invoked with the respective \",(0,t.jsx)(e.code,{children:\"this\"}),\", if it was specified during \",(0,t.jsx)(e.code,{children:\"model.on('unset', ...)\"}),\".\"]}),`\n`,(0,t.jsx)(e.h4,{children:(0,t.jsx)(e.code,{children:\"model.on()\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"on\"}),\" method adds a callback function to the list of callbacks for a specific event (\",(0,t.jsx)(e.code,{children:\"'change'\"}),\" or \",(0,t.jsx)(e.code,{children:\"'unset'\"}),\") on a given attribute. If the attribute does not exist, the method does nothing.\"]}),`\n`,(0,t.jsx)(e.h4,{children:(0,t.jsx)(e.code,{children:\"model.off()\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"off\"}),\" method removes a callback function from the list of callbacks for a specific event (\",(0,t.jsx)(e.code,{children:\"'change'\"}),\" or \",(0,t.jsx)(e.code,{children:\"'unset'\"}),\") on a given attribute. If the attribute does not exist, the method does nothing.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Class-based solution\"}),`\n`,(0,t.jsx)(h,{languages:{jsx:u,tsx:d}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The same callback function can be added more than once for the same event. Calling \",(0,t.jsx)(e.code,{children:\"model.off()\"}),\" should remove all matching callbacks from that attribute's event callbacks.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Methods called with non-existing attributes should be no-op.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Object-oriented programming\"}),`\n`,(0,t.jsx)(e.li,{children:\"Using the right data structures\"}),`\n`,(0,t.jsx)(e.li,{children:\"Closures\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://backbonejs.org/#Model\",children:\"Backbone.Model\"})}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(b,n)})):b(n)}var N=T;return w(M);})();\n;return Component;",
  "workspace": {
    "main": "/src/backbone-model.ts",
    "run": "/src/backbone-model.run.test.ts",
    "submit": "/src/backbone-model.submit.test.ts"
  }
}