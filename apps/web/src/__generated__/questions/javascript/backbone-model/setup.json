{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/backbone-model\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/backbone-model.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/backbone-model.run.test.ts": "import BackboneModel from './backbone-model';\n\ndescribe('BackboneModel', () => {\n  test('constructor', () => {\n    const person = new BackboneModel();\n    expect(person).toBeInstanceOf(BackboneModel);\n  });\n\n  test('get', () => {\n    const person = new BackboneModel({ name: 'John', age: 30 });\n    expect(person.get('name')).toBe('John');\n    expect(person.get('age')).toBe(30);\n  });\n\n  test('set', () => {\n    const person = new BackboneModel();\n    person.set('name', 'Carol');\n\n    expect(person.get('name')).toBe('Carol');\n  });\n\n  test('has', () => {\n    const person = new BackboneModel({ name: 'John' });\n    expect(person.has('name')).toBe(true);\n  });\n\n  test('unset', () => {\n    const person = new BackboneModel({ name: 'John', age: 30 });\n    expect(person.has('name')).toBe(true);\n    person.unset('name');\n\n    expect(person.has('name')).toBe(false);\n  });\n\n  describe('on', () => {\n    test('change', () => {\n      let fired = false;\n      const person = new BackboneModel({ name: 'John' });\n      person.on('change', 'name', () => {\n        fired = true;\n      });\n      person.set('name', 'Johnny');\n\n      expect(person.get('name')).toBe('Johnny');\n      expect(fired).toBe(true);\n    });\n\n    test('unset', () => {\n      let fired = false;\n      const person = new BackboneModel({ name: 'John' });\n      person.on('unset', 'name', () => {\n        fired = true;\n      });\n      person.unset('name');\n\n      expect(fired).toBe(true);\n      expect(person.get('name')).toBeUndefined();\n    });\n  });\n\n  test('off', () => {\n    let times = 0;\n    function callback() {\n      times++;\n    }\n\n    const person = new BackboneModel({ name: 'John' });\n    person.on('change', 'name', callback);\n\n    person.set('name', 'Johnny');\n    expect(person.get('name')).toBe('Johnny');\n    expect(times).toEqual(1);\n\n    person.set('name', 'Carol');\n    expect(person.get('name')).toBe('Carol');\n    expect(times).toEqual(2);\n\n    person.off('change', 'name', callback);\n    person.set('name', 'Caroline');\n    expect(person.get('name')).toBe('Caroline');\n    expect(times).toEqual(2);\n  });\n});\n",
    "/src/backbone-model.submit.test.ts": "import BackboneModel from './backbone-model';\n\ndescribe('BackboneModel', () => {\n  describe('constructor', () => {\n    test('without default data', () => {\n      const person = new BackboneModel();\n      expect(person).toBeInstanceOf(BackboneModel);\n    });\n\n    test('with default data', () => {\n      const person = new BackboneModel({ name: 'John', age: 30 });\n      expect(person).toBeInstanceOf(BackboneModel);\n    });\n  });\n\n  describe('get', () => {\n    test('existing field', () => {\n      const person = new BackboneModel({ name: 'John', age: 30 });\n      expect(person.get('name')).toBe('John');\n      expect(person.get('age')).toBe(30);\n    });\n\n    test('non-existing field', () => {\n      const person = new BackboneModel();\n      expect(person.get('name')).toBeUndefined();\n    });\n  });\n\n  describe('set', () => {\n    test('new field', () => {\n      const person = new BackboneModel();\n      person.set('name', 'Carol');\n\n      expect(person.get('name')).toBe('Carol');\n    });\n\n    test('existing field', () => {\n      const person = new BackboneModel({ name: 'John', age: 30 });\n      expect(person.get('name')).toBe('John');\n\n      person.set('name', 'Carol');\n      expect(person.get('name')).toBe('Carol');\n    });\n  });\n\n  describe('has', () => {\n    test('existing field', () => {\n      const person = new BackboneModel({ name: 'John' });\n      expect(person.has('name')).toBe(true);\n    });\n\n    test('non-existing field', () => {\n      const person = new BackboneModel({ name: 'John' });\n      expect(person.has('age')).toBe(false);\n    });\n  });\n\n  describe('unset', () => {\n    test('existing field', () => {\n      const person = new BackboneModel({ name: 'John', age: 30 });\n      expect(person.has('name')).toBe(true);\n      person.unset('name');\n\n      expect(person.has('name')).toBe(false);\n    });\n\n    test('non-existing field', () => {\n      const person = new BackboneModel({ name: 'John' });\n      person.unset('age');\n\n      expect(person.has('age')).toBe(false);\n    });\n  });\n\n  describe('on', () => {\n    describe('change event', () => {\n      test('callback invoked when attribute changes', () => {\n        let fired = false;\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', () => {\n          fired = true;\n        });\n        person.set('name', 'Johnny');\n\n        expect(person.get('name')).toBe('Johnny');\n        expect(fired).toBe(true);\n      });\n\n      test('callback invoked with correct arguments', () => {\n        let args: Array<any> = [];\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', (...args_: Array<any>) => {\n          args = args_;\n        });\n        person.set('name', 'Johnny');\n\n        expect(person.get('name')).toBe('Johnny');\n        expect(args).toEqual(['name', 'Johnny', 'John']);\n      });\n\n      test('callback invoked with `this`', () => {\n        let user = { name: 'Boo' };\n        const person = new BackboneModel({ name: 'John' });\n        person.on(\n          'change',\n          'name',\n          function (\n            this: any,\n            attribute: string,\n            newValue: any,\n            _oldValue: any,\n          ) {\n            this[attribute] = newValue;\n          },\n          user,\n        );\n        expect(user.name).toBe('Boo');\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(user.name).toEqual('Johnny');\n      });\n\n      test('works for multiple changes', () => {\n        let args: Array<any> = [];\n\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', (...args_: Array<any>) => {\n          args = args_;\n        });\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(args).toEqual(['name', 'Johnny', 'John']);\n\n        person.set('name', 'Carol');\n        expect(person.get('name')).toBe('Carol');\n        expect(args).toEqual(['name', 'Carol', 'Johnny']);\n      });\n\n      test('does not fire when no change', () => {\n        let times = 0;\n        function callback() {\n          times++;\n        }\n\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', callback);\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(times).toEqual(1);\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(times).toEqual(1);\n      });\n\n      test('removed when unset', () => {\n        let times = 0;\n\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', () => {\n          times++;\n        });\n\n        person.set('name', 'Johnny');\n        expect(person.get('name')).toBe('Johnny');\n        expect(times).toBe(1);\n\n        person.unset('name');\n        person.set('name', 'Carol');\n        person.set('name', 'Caroline');\n        expect(times).toBe(1);\n      });\n    });\n\n    describe('unset event', () => {\n      test('callback invoked when attribute unset', () => {\n        let fired = false;\n        const person = new BackboneModel({ name: 'John' });\n        person.on('unset', 'name', () => {\n          fired = true;\n        });\n        person.unset('name');\n\n        expect(fired).toBe(true);\n        expect(person.get('name')).toBeUndefined();\n      });\n\n      test('callback invoked with correct arguments', () => {\n        let args: Array<any> = [];\n        const person = new BackboneModel({ name: 'John' });\n        person.on('unset', 'name', (...args_: Array<any>) => {\n          args = args_;\n        });\n        person.unset('name');\n\n        expect(args).toEqual(['name']);\n        expect(person.get('name')).toBeUndefined();\n      });\n\n      test('callback invoked with `this`', () => {\n        let unsetAttribute = { name: null };\n        const person = new BackboneModel({ name: 'John' });\n        person.on(\n          'unset',\n          'name',\n          function (this: any, attribute: string) {\n            this.name = attribute;\n          },\n          unsetAttribute,\n        );\n        expect(unsetAttribute.name).toBeNull();\n        person.unset('name');\n\n        expect(person.get('name')).toBeUndefined();\n        expect(unsetAttribute.name).toEqual('name');\n      });\n    });\n\n    test('non-existing attribute does not error', () => {\n      const person = new BackboneModel();\n      expect(() => {\n        person.on('change', 'boo', () => {});\n      }).not.toThrow();\n    });\n\n    test('not called after the attribute is initially set', () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n      const person = new BackboneModel();\n      person.on('change', 'name', callback);\n\n      person.set('name', 'John');\n      expect(times).toBe(0);\n    });\n\n    describe('multiple callbacks', () => {\n      test('same callback can be added multiple times for the same attribute and event', () => {\n        let times = 0;\n        function callback() {\n          times++;\n        }\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', callback);\n        person.on('change', 'name', callback);\n\n        person.set('name', 'Johnny');\n        expect(times).toBe(2);\n      });\n\n      test('different callbacks for the same attribute and event', () => {\n        let foo = 0;\n        let bar = 0;\n        function fooIncrement() {\n          foo++;\n        }\n        function barIncrement() {\n          bar++;\n        }\n\n        const person = new BackboneModel({ name: 'John' });\n        person.on('change', 'name', fooIncrement);\n        person.on('change', 'name', barIncrement);\n\n        person.set('name', 'Johnny');\n        expect(foo).toBe(1);\n        expect(bar).toBe(1);\n      });\n    });\n\n    test('event callbacks are isolated within instances', () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const john = new BackboneModel({ name: 'John', age: 32 });\n      const _carol = new BackboneModel({ name: 'Carol', age: 36 });\n\n      john.on('change', 'age', callback);\n      john.set('age', 33);\n      expect(john.get('age')).toBe(33);\n      expect(times).toEqual(1);\n    });\n  });\n\n  describe('off', () => {\n    test('works for `change`', () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const person = new BackboneModel({ name: 'John' });\n      person.on('change', 'name', callback);\n\n      person.set('name', 'Johnny');\n      expect(person.get('name')).toBe('Johnny');\n      expect(times).toEqual(1);\n\n      person.set('name', 'Carol');\n      expect(person.get('name')).toBe('Carol');\n      expect(times).toEqual(2);\n\n      person.off('change', 'name', callback);\n      person.set('name', 'Caroline');\n      expect(person.get('name')).toBe('Caroline');\n      expect(times).toEqual(2);\n    });\n\n    test('works for `unset`', () => {\n      let times = 0;\n      function callback() {\n        times++;\n      }\n\n      const person = new BackboneModel({ name: 'John' });\n      person.on('unset', 'name', callback);\n\n      person.set('name', 'Johnny');\n      expect(person.get('name')).toBe('Johnny');\n\n      person.off('unset', 'name', callback);\n      person.unset('name');\n      expect(person.get('name')).toBeUndefined();\n      expect(times).toEqual(0);\n    });\n\n    test('callbacks can be removed individually', () => {\n      let foo = 0;\n      let bar = 0;\n      function fooIncrement() {\n        foo++;\n      }\n      function barIncrement() {\n        bar++;\n      }\n\n      const person = new BackboneModel({ name: 'John' });\n      person.on('change', 'name', fooIncrement);\n      person.on('change', 'name', barIncrement);\n\n      person.set('name', 'Johnny');\n      expect(foo).toBe(1);\n      expect(bar).toBe(1);\n\n      person.off('change', 'name', fooIncrement);\n\n      person.set('name', 'Carol');\n      expect(foo).toBe(1);\n      expect(bar).toBe(2);\n    });\n  });\n\n  test('integration', () => {\n    let times = 0;\n    function callback() {\n      times++;\n    }\n\n    const person = new BackboneModel({ name: 'John', age: 32 });\n    expect(person.has('name')).toBe(true);\n    expect(person.has('age')).toBe(true);\n\n    person.on('change', 'name', callback);\n    person.on('change', 'age', callback);\n    person.on('unset', 'name', callback);\n\n    person.set('name', 'Johnny');\n    expect(person.get('name')).toBe('Johnny');\n    expect(times).toEqual(1);\n\n    person.set('name', 'Johnny');\n    expect(person.get('name')).toBe('Johnny');\n    expect(times).toEqual(1);\n\n    person.unset('name');\n    expect(times).toEqual(2);\n    expect(person.has('name')).toBe(false);\n\n    person.set('age', 33);\n    expect(person.get('age')).toBe(33);\n    expect(times).toEqual(3);\n\n    person.off('change', 'age', callback);\n    expect(person.set('age', 34));\n    expect(times).toEqual(3);\n  });\n});\n",
    "/src/backbone-model.ts": "type EventName = 'change' | 'unset';\n\ninterface IBackboneModel {\n  get(attribute: string): unknown | undefined;\n  set(attribute: string, value: unknown): void;\n  has(attribute: string): boolean;\n  unset(attribute: string): void;\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void;\n  off(eventName: EventName, attribute: string, callback: Function): void;\n}\n\ntype CallbackData = { fn: Function; context: any };\ntype AttributeData = {\n  value: unknown;\n  events: {\n    change: Array<CallbackData>;\n    unset: Array<CallbackData>;\n  };\n};\n\n// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel implements IBackboneModel {\n  _attributes: Map<string, AttributeData>;\n\n  constructor(initialValues: Record<string, unknown> = {}) {\n    this._attributes = new Map();\n    Object.entries(initialValues).forEach(([attribute, value]) => {\n      this._attributes.set(attribute, {\n        value,\n        events: {\n          change: [],\n          unset: [],\n        },\n      });\n    });\n  }\n\n  get(attribute: string): unknown | undefined {\n    return this._attributes.get(attribute)?.value;\n  }\n\n  set(attribute: string, value: unknown): void {\n    const attributeData: AttributeData = this.has(attribute)\n      ? this._attributes.get(attribute)!\n      : {\n          value,\n          events: {\n            change: [],\n            unset: [],\n          },\n        };\n\n    // Only invoke callbacks if there's a change in the values.\n    if (attributeData.value !== value) {\n      // Invoke callbacks listening for the `change` event.\n      attributeData.events.change.forEach((callback) => {\n        callback.fn.call(\n          callback.context ?? null,\n          attribute,\n          value,\n          attributeData.value,\n        );\n      });\n    }\n\n    attributeData.value = value;\n    this._attributes.set(attribute, attributeData);\n  }\n\n  has(attribute: string): boolean {\n    return this._attributes.has(attribute);\n  }\n\n  unset(attribute: string): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Invoke callbacks listening for the `unset` event.\n    attributeData.events.unset.forEach((callback) => {\n      callback.fn.call(callback.context ?? null, attribute);\n    });\n    // Remove the attribute entirely.\n    this._attributes.delete(attribute);\n  }\n\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Add to the list of callbacks.\n    attributeData.events[eventName].push({\n      fn: callback,\n      context,\n    });\n  }\n\n  off(eventName: EventName, attribute: string, callback: Function): void {\n    const attributeData = this._attributes.get(attribute);\n    // No-op for non-existent attributes.\n    if (attributeData == null) {\n      return;\n    }\n\n    // Remove from the added list of callbacks.\n    attributeData.events[eventName] = attributeData.events[eventName].filter(\n      ({ fn }) => fn !== callback,\n    );\n  }\n}\n"
  },
  "skeleton": {
    "js": "// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel {\n  /**\n   * @param {Object} initialValues\n   * @returns BackboneModel\n   */\n  constructor(initialValues) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the value of a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @returns {any | undefined} The value of the attribute.\n   */\n  get(attribute) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Set the value of a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @param {any} value - The value to set for the attribute.\n   */\n  set(attribute, value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Check if the model has a specific attribute.\n   * @param {string} attribute - The attribute name.\n   * @returns {boolean} `true` if the model has the attribute, `false` otherwise.\n   */\n  has(attribute) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Unset a specific attribute.\n   * @param {string} attribute - The attribute name to unset.\n   */\n  unset(attribute) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Register an event listener for changes to a specific attribute.\n   * @param {string} eventName - The event name.\n   * @param {string} attribute - The attribute name to listen for changes.\n   * @param {Function} callback - The callback function to be executed on the event.\n   * @param {any} [context] - The context in which to execute the callback.\n   */\n  on(eventName, attribute, callback, context) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Remove an event listener for changes to a specific attribute.\n   * @param {string} eventName - The event name.\n   * @param {string} attribute - The attribute name to stop listening for changes.\n   * @param {Function} callback - The callback function to remove.\n   */\n  off(eventName, attribute, callback) {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "type EventName = 'change' | 'unset';\n\ninterface IBackboneModel {\n  get(attribute: string): unknown | undefined;\n  set(attribute: string, value: unknown): void;\n  has(attribute: string): boolean;\n  unset(attribute: string): void;\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void;\n  off(event: EventName, attribute: string, callback: Function): void;\n}\n\n// You are free to use alternative approaches of\n// defining BackboneModel as long as the\n// default export can be instantiated.\nexport default class BackboneModel implements IBackboneModel {\n  constructor(initialValues: Record<string, unknown> = {}) {\n    throw 'Not implemented!';\n  }\n\n  get(attribute: string): unknown | undefined {\n    throw 'Not implemented!';\n  }\n\n  set(attribute: string, value: unknown): void {\n    throw 'Not implemented!';\n  }\n\n  has(attribute: string): boolean {\n    throw 'Not implemented!';\n  }\n\n  unset(attribute: string): void {\n    throw 'Not implemented!';\n  }\n\n  on(\n    eventName: EventName,\n    attribute: string,\n    callback: Function,\n    context?: any,\n  ): void {\n    throw 'Not implemented!';\n  }\n\n  off(eventName: EventName, attribute: string, callback: Function): void {\n    throw 'Not implemented!';\n  }\n}"
  },
  "workspace": {
    "main": "/src/backbone-model.ts",
    "run": "/src/backbone-model.run.test.ts",
    "submit": "/src/backbone-model.submit.test.ts"
  }
}