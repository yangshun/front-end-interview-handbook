{
  "description": "var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var l in e)r(t,l,{get:e[l],enumerable:!0})},s=(t,e,l,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!g.call(t,o)&&o!==l&&r(t,o,{get:()=>e[o],enumerable:!(i=m(e,o))||i.enumerable});return t};var x=(t,e,l)=>(l=t!=null?h(u(t)):{},s(e||!t||!t.__esModule?r(l,\"default\",{value:t,enumerable:!0}):l,t)),b=t=>s(r({},\"__esModule\",{value:!0}),t);var c=y((j,d)=>{d.exports=_jsx_runtime});var C={};f(C,{default:()=>E,frontmatter:()=>w});var n=x(c()),w={title:\"getElementsByStyle\",excerpt:\"Implement a function to get all DOM elements that are rendered using the specified style\"};function a(t){let e=Object.assign({p:\"p\",code:\"code\",a:\"a\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a method \",(0,n.jsx)(e.code,{children:\"getElementsByStyle()\"}),\" that finds DOM elements that are rendered by the browser using the specified style. It is similar to \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName\",children:(0,n.jsx)(e.code,{children:\"Element.getElementsByClassName()\"})}),\" but with some differences:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"It is a pure function which takes in an element, a property string, and a value string representing the style's property/value pair to be matched on the elements descendants. E.g. \",(0,n.jsx)(e.code,{children:\"getElementsByStyle(document.body, 'font-size', '12px')\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Similar to \",(0,n.jsx)(e.code,{children:\"Element.getElementsByClassName()\"}),\", only descendants of the element argument are searched, not the element itself.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return an array of \",(0,n.jsx)(e.code,{children:\"Element\"}),\"s, instead of an \",(0,n.jsx)(e.code,{children:\"HTMLCollection\"}),\" of \",(0,n.jsx)(e.code,{children:\"Element\"}),\"s.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Do not use \",(0,n.jsx)(e.code,{children:\"document.querySelectorAll()\"}),\" which will make the problem trivial otherwise. You will not be allowed to use it during real interviews.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const doc = new DOMParser().parseFromString(\n  \\`<div>\n    <span style=\"font-size: 12px\">Span</span>\n    <p style=\"font-size: 12px\">Paragraph</p>\n    <blockquote style=\"font-size: 14px\">Blockquote</blockquote>\n  </div>\\`,\n  'text/html',\n);\n\ngetElementsByStyle(doc.body, 'font-size', '12px');\n// [span, p] <-- This is an array of elements.\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Hint\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"You might find the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle\",children:(0,n.jsx)(e.code,{children:\"Window.getComputedStyle()\"})}),\" method helpful.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle\",children:\"Window: getComputedStyle() method - Web APIs | MDN\"})}),`\n`]})]})}function S(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(a,t)})):a(t)}var E=S;return b(C);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/get-elements-by-style\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/get-elements-by-style.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/get-elements-by-style.run.test.ts": "import getElementsByStyle from './get-elements-by-style';\n\nfunction checkResults(\n  expected: HTMLCollectionOf<Element>,\n  received: Array<Element>,\n) {\n  expect(received.length).toBe(expected.length);\n  // Inefficient O(n^2) check so that order doesn't matter.\n  for (let i = 0; i < expected.length; i++) {\n    expect(received.some((node) => node.isEqualNode(expected[i]))).toBe(true);\n  }\n}\nfunction createElementFromHtmlString(htmlString: string) {\n  // Use `document.createElement()` because jsdom@16 has some issues with `getComputedStyle()`\n  // with elements created using `DOMParser().parseFromString()`.\n  const body = document.createElement('body');\n  body.innerHTML = htmlString.trim(); // Trimming to avoid any leading whitespace nodes.\n  return body;\n}\n\ndescribe('getElementsByStyle()', () => {\n  test('empty tree', () => {\n    const bodyEl = createElementFromHtmlString(``);\n    const els = getElementsByStyle(bodyEl, 'font-size', '12px');\n    const expected = bodyEl.getElementsByTagName('');\n\n    checkResults(expected, els);\n  });\n\n  test('matching span', () => {\n    const bodyEl = createElementFromHtmlString(`\n      <div>\n        <span style=\"font-size: 12px\">Span</span>\n        <p>Paragraph</p>\n        <div></div>\n      </div>`);\n\n    const els = getElementsByStyle(bodyEl, 'font-size', '12px');\n    const expected = bodyEl.getElementsByTagName('span');\n\n    checkResults(expected, els);\n  });\n\n  test('multiple matching elements', () => {\n    const bodyEl = createElementFromHtmlString(`\n      <div>\n        <span style=\"font-size: 12px\">Span</span>\n        <p>Paragraph</p>\n        <div></div>\n      </div>`);\n\n    const els = getElementsByStyle(bodyEl, 'font-size', '12px');\n    const expected = bodyEl.getElementsByTagName('span');\n\n    checkResults(expected, els);\n  });\n});\n",
    "/src/get-elements-by-style.submit.test.ts": "import getElementsByStyle from './get-elements-by-style';\n\nfunction checkResults(\n  expected: HTMLCollectionOf<Element>,\n  received: Array<Element>,\n) {\n  expect(received.length).toBe(expected.length);\n  // Inefficient O(n^2) check so that order doesn't matter.\n  for (let i = 0; i < expected.length; i++) {\n    expect(received.some((node) => node.isEqualNode(expected[i]))).toBe(true);\n  }\n}\n\nfunction createElementFromHtmlString(htmlString: string) {\n  // Use `document.createElement()` because jsdom@16 has some issues with `getComputedStyle()`\n  // with elements created using `DOMParser().parseFromString()`.\n  const div = document.createElement('div');\n  div.innerHTML = htmlString.trim(); // Trimming to avoid any leading whitespace nodes.\n  return div;\n}\n\ndescribe('getElementsByStyle()', () => {\n  test('empty tree', () => {\n    const containerEl = createElementFromHtmlString(``);\n    const els = getElementsByStyle(containerEl, 'font-size', '12px');\n    const expected = containerEl.getElementsByTagName('');\n\n    checkResults(expected, els);\n  });\n\n  test('no matches', () => {\n    const containerEl = createElementFromHtmlString(\n      `<div>\n        <span>Span</span>\n        <p>Paragraph</p>\n        <div></div>\n      </div>`,\n    );\n\n    const els = getElementsByStyle(containerEl, 'font-size', '120px');\n    const expected = containerEl.getElementsByTagName('');\n    checkResults(expected, els);\n  });\n\n  describe('matches', () => {\n    test('matching span', () => {\n      const containerEl = createElementFromHtmlString(\n        `<div>\n          <span style=\"font-size: 12px\">Span</span>\n          <p>Paragraph</p>\n          <div></div>\n        </div>`,\n      );\n\n      const els = getElementsByStyle(containerEl, 'font-size', '12px');\n      const expected = containerEl.getElementsByTagName('span');\n      checkResults(expected, els);\n    });\n\n    test('multiple matching elements', () => {\n      const containerEl = createElementFromHtmlString(\n        `<div>\n          <span style=\"font-size: 12px\">Span</span>\n          <p>Paragraph</p>\n          <div></div>\n          <span style=\"font-size: 12px\">Span 2</span>\n        </div>`,\n      );\n\n      const els = getElementsByStyle(containerEl, 'font-size', '12px');\n      const expected = containerEl.getElementsByTagName('span');\n      checkResults(expected, els);\n    });\n\n    test('matches one level of children', () => {\n      const containerEl = createElementFromHtmlString(\n        `<div id=\"root\">\n          <span class=\"match\" style=\"color: rgb(255, 255, 255)\">\n            Span\n            <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n          </span>\n          <p>Paragraph</p>\n          <div>\n            <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n          </div>\n        </div>`,\n      );\n\n      const els = getElementsByStyle(\n        containerEl.querySelector('#root')!,\n        'color',\n        'rgb(255, 255, 255)',\n      );\n      const expected = containerEl.getElementsByClassName('match');\n      checkResults(expected, els);\n    });\n\n    test('matches two levels of children', () => {\n      const containerEl = createElementFromHtmlString(\n        `<div id=\"root\">\n          <span class=\"match\" style=\"color: rgb(255, 255, 255)\">\n            Span\n            <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n          </span>\n          <div>\n            <p>\n              <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n            </p>\n          </div>\n          <div>\n            <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n          </div>\n        </div>`,\n      );\n\n      const els = getElementsByStyle(\n        containerEl.querySelector('#root')!,\n        'color',\n        'rgb(255, 255, 255)',\n      );\n      const expected = containerEl.getElementsByClassName('match');\n      checkResults(expected, els);\n    });\n\n    test('ignores comment nodes', () => {\n      const containerEl = createElementFromHtmlString(\n        `<div id=\"root\">\n          <span class=\"match\" style=\"color: rgb(255, 255, 255)\">\n            <!-- Here's a comment -->\n            Span\n            <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n          </span>\n          <p>Paragraph</p>\n          <div>\n            <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n          </div>\n        </div>`,\n      );\n\n      const els = getElementsByStyle(\n        containerEl.querySelector('#root')!,\n        'color',\n        'rgb(255, 255, 255)',\n      );\n      const expected = containerEl.getElementsByClassName('match');\n      checkResults(expected, els);\n    });\n\n    test(\"doesn't include itself\", () => {\n      const containerEl = createElementFromHtmlString(\n        `<div id=\"root\" style=\"color: rgb(255, 255, 255)\">\n          <span class=\"match\" style=\"color: rgb(255, 255, 255)\">\n            <!-- Here's a comment -->\n            Span\n            <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n          </span>\n          <p>Paragraph</p>\n          <div>\n            <span class=\"match\" style=\"color: rgb(255, 255, 255)\">Span</span>\n          </div>\n        </div>`,\n      );\n\n      const els = getElementsByStyle(\n        containerEl.querySelector('#root')!,\n        'color',\n        'rgb(255, 255, 255)',\n      );\n      const expected = containerEl.getElementsByClassName('match');\n      checkResults(expected, els);\n    });\n  });\n});\n",
    "/src/get-elements-by-style.ts": "export default function getElementsByStyle(\n  element: Element,\n  property: string,\n  value: string,\n): Array<Element> {\n  const elements: Array<Element> = [];\n\n  function traverse(el: Element) {\n    if (el == null) {\n      return;\n    }\n\n    const computedStyles = getComputedStyle(el);\n    if (computedStyles.getPropertyValue(property) === value) {\n      elements.push(el);\n    }\n\n    for (const child of el.children) {\n      traverse(child);\n    }\n  }\n\n  for (const child of element.children) {\n    traverse(child);\n  }\n\n  return elements;\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": "yangshun",
    "companies": [
      "amazon"
    ],
    "created": 1723766400,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function to get all DOM elements that are rendered using the specified style",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/get-elements-by-style",
    "importance": "medium",
    "languages": [
      "html",
      "css",
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "get-elements-by-tag-name",
      "get-elements-by-class-name"
    ],
    "slug": "get-elements-by-style",
    "subtitle": null,
    "title": "getElementsByStyle",
    "topics": [
      "web-api"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Element} element\n * @param {string} property\n * @param {string} value\n * @return {Array<Element>}\n */\nexport default function getElementsByStyle(element, property, value) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function getElementsByStyle(\n  element: Element,\n  property: string,\n  value: string,\n): Array<Element> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var S=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var l in e)i(t,l,{get:e[l],enumerable:!0})},s=(t,e,l,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of g(e))!v.call(t,r)&&r!==l&&i(t,r,{get:()=>e[r],enumerable:!(o=y(e,r))||o.enumerable});return t};var w=(t,e,l)=>(l=t!=null?p(f(t)):{},s(e||!t||!t.__esModule?i(l,\"default\",{value:t,enumerable:!0}):l,t)),C=t=>s(i({},\"__esModule\",{value:!0}),t);var d=S((A,c)=>{c.exports=_jsx_runtime});var T={};b(T,{default:()=>P});var n=w(d());var a=MDXCodeBlock;var h=`/**\n * @param {Element} element\n * @param {string} property\n * @param {string} value\n * @return {Array<Element>}\n */\nexport default function getElementsByStyle(element, property, value) {\n  const elements = [];\n\n  function traverse(el) {\n    if (el == null) {\n      return;\n    }\n\n    const computedStyles = getComputedStyle(el);\n    if (computedStyles.getPropertyValue(property) === value) {\n      elements.push(el);\n    }\n\n    for (const child of el.children) {\n      traverse(child);\n    }\n  }\n\n  for (const child of element.children) {\n    traverse(child);\n  }\n\n  return elements;\n}\n`;var u=`export default function getElementsByStyle(\n  element: Element,\n  property: string,\n  value: string,\n): Array<Element> {\n  const elements: Array<Element> = [];\n\n  function traverse(el: Element) {\n    if (el == null) {\n      return;\n    }\n\n    const computedStyles = getComputedStyle(el);\n    if (computedStyles.getPropertyValue(property) === value) {\n      elements.push(el);\n    }\n\n    for (const child of el.children) {\n      traverse(child);\n    }\n  }\n\n  for (const child of element.children) {\n    traverse(child);\n  }\n\n  return elements;\n}\n`;function m(t){let e=Object.assign({p:\"p\",code:\"code\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\",pre:\"pre\",strong:\"strong\",ol:\"ol\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This question assesses you on the basic DOM traversal APIs, recursion, knowledge of CSS, and use of the \",(0,n.jsx)(e.code,{children:\"Window.getComputedStyle()\"}),\" API. The general approach to solve this question is similar to \",(0,n.jsx)(e.a,{href:\"/questions/javascript/get-elements-by-tag-name\",children:\"getElementsByTagName\"}),\" where we recursively traverse the element tree and collect the elements that matches a specific criteria. In this case the criteria is matching styles.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"Firstly, we should know the following APIs and what they do:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle\",children:(0,n.jsx)(e.code,{children:\"Window.getComputedStyle()\"})}),\" which returns an object containing the values of all CSS properties of an element, after applying active stylesheets and resolving any basic computation those values may contain.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/children\",children:(0,n.jsx)(e.code,{children:\"Element.children\"})}),\" which returns a live \",(0,n.jsx)(e.code,{children:\"HTMLCollection\"}),\" of the child elements. We use this over \",(0,n.jsx)(e.code,{children:\"Node.childNodes\"}),\" which returns a live \",(0,n.jsx)(e.code,{children:\"NodeList\"}),\" of child \",(0,n.jsx)(e.code,{children:\"Node\"}),\"s because \",(0,n.jsx)(e.code,{children:\"childNodes\"}),\" will include non-element nodes like text and comment nodes, which are not relevant in this question.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"However \",(0,n.jsx)(e.code,{children:\"HTMLCollection\"}),\" does not have \",(0,n.jsx)(e.code,{children:\".forEach\"}),\", so we have to iterate through it using traditional \",(0,n.jsx)(e.code,{children:\"for\"}),\" loops.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.h2,{children:[(0,n.jsx)(e.code,{children:\"Window.getComputedStyle()\"}),\" vs \",(0,n.jsx)(e.code,{children:\"Element.style\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"While both APIs return \",(0,n.jsx)(e.code,{children:\"CSSStyleDeclaration\"}),\"s, \",(0,n.jsx)(e.code,{children:\"getComputedStyle()\"}),\" returns an object that represents the final resolved styles of an element after all styles have been applied, including styles from CSS files, inline styles, and browser defaults. The \",(0,n.jsx)(e.code,{children:\"style\"}),\" property on elements allows you to access and modify inline styles directly on the element. If an element is not styled using inline styles, the values of all the keys on the \",(0,n.jsx)(e.code,{children:\"style\"}),\" property is empty.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since the function is meant to match the style rendered by the browser, \",(0,n.jsx)(e.code,{children:\"getComputedStyle()\"}),\" should be used instead of \",(0,n.jsx)(e.code,{children:\"element.style\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Assuming a typical <body> element with no inline styles specified.\n\nconsole.log(document.body.style.fontSize); // '' (empty string)\nconsole.log(getComputedStyle(document.body).getPropertyValue('font-size')); // 16px;\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"What are computed styles and why are they important?\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's take a closer look at \",(0,n.jsx)(e.code,{children:\"Window.getComputedStyle()\"}),\". According to MDN, it returns the property values \",(0,n.jsx)(e.strong,{children:\"after applying active stylesheets and resolving any basic computation those values may contain\"}),\". Obtaining resolved styles is important because:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Styling can be done in many ways\"}),\": There are many ways to style an element on a webpage:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Inline\"}),\": Directly within the HTML tag.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Internal\"}),\": With a \",(0,n.jsx)(e.code,{children:\"<style>\"}),\" tag.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"External\"}),\": Linking to a separate CSS file.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Styles follow cascading and inheritance rules\"}),\": CSS works by cascading styles \\u2013 rules from different sources combine and potentially override each other. Elements can also inherit styles from their parent elements.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Multiple ways of defining styles properties\"}),\": Other than using the raw final values when styling elements:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Many value types\"}),\": Some properties like colors can be done in different ways. e.g. \",(0,n.jsx)(e.code,{children:\"color: white\"}),\", \",(0,n.jsx)(e.code,{children:\"color: #fff\"}),\", \",(0,n.jsx)(e.code,{children:\"color: rgb(255, 255, 255)\"}),\" are all valid ways to render white text color.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Shorthands\"}),\": Properties can be defined using shorthands, e.g. \",(0,n.jsx)(e.code,{children:\"margin: 10px\"}),\" results in \",(0,n.jsx)(e.code,{children:\"margin-top: 10px\"}),\" as well as for the other directions.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"CSS variables\"}),\": Properties can also be written using CSS variables or more officially known as CSS custom properties, e.g. \",(0,n.jsx)(e.code,{children:\"color: var(--text-color)\"}),\". The final color value is not known until the browser resolves the value of the \",(0,n.jsx)(e.code,{children:\"--text-color\"}),\" variable.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Styles have to be resolved\"}),\": The \",(0,n.jsx)(e.code,{children:\"getComputedStyle()\"}),\" API gives you a snapshot of the final, calculated styles applied to an element after all the cascading and inheritance rules have been applied. This is incredibly valuable because it reflects how the element is actually rendered in the browser.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The implication of using \",(0,n.jsx)(e.code,{children:\"Window.getComputedStyle()\"}),\" is that we can only match based on the element's resolved values. Font sizes, paddings, margins, can be defined using \",(0,n.jsx)(e.code,{children:\"px\"}),\", \",(0,n.jsx)(e.code,{children:\"rem\"}),\", \",(0,n.jsx)(e.code,{children:\"em\"}),\", etc but the resolved value unit for these properties obtained from \",(0,n.jsx)(e.code,{children:\"getComputedStyle()\"}),\" is \",(0,n.jsx)(e.code,{children:\"px\"}),\". Colors can be defined using \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value\",children:\"named colors, HSL, RGB (and more) formats\"}),\" but the resolved style format for colors is RGB hexadecimal. This is a limitation that you should mention during your interviews if you have the opportunity.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`element.style.color = 'white';\nconsole.log(getComputedStyle(element).getPropertyValue('color')); // 'rgb(255, 255, 255)'\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"While it is possible to write your own conversion/resolution logic within your \",(0,n.jsx)(e.code,{children:\"getElementsByStyle()\"}),\" function so that the value argument is resolved before comparing against the element's resolved styles, it is only achievable for certain properties that do not rely on properties of other elements. Properties like \",(0,n.jsx)(e.code,{children:\"inherit\"}),\", \",(0,n.jsx)(e.code,{children:\"rem\"}),\" which rely on properties of other elements due to CSS cascading cannot be matched easily and accurately.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Recursive traversal\"}),`\n`,(0,n.jsx)(e.p,{children:\"Both depth-first traversal and breadth-first traversals can be used but it's easier to write depth-first traversals using recursions. When visiting each element:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Call \",(0,n.jsx)(e.code,{children:\"getComputedStyle(element)\"}),\" to get a \",(0,n.jsx)(e.code,{children:\"CSSStyleDeclaration\"}),\" object containing the resolved styles of the specified element. \",(0,n.jsx)(e.code,{children:\"getPropertyValue(property)\"}),\" is used to retrieve the value of a specific CSS property such as \",(0,n.jsx)(e.code,{children:\"color\"}),\", \",(0,n.jsx)(e.code,{children:\"font-size\"}),\", \",(0,n.jsx)(e.code,{children:\"margin\"}),\", etc. Then check against the property and value arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Recursively traverse the element's children via \",(0,n.jsx)(e.code,{children:\"element.children\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Maintain an \",(0,n.jsx)(e.code,{children:\"elements\"}),\" array to collect the matching elements while recursively traversing starting from the root element. Remember that the root element argument itself is not included in the results and it should not be added to the \",(0,n.jsx)(e.code,{children:\"elements\"}),\" array.\"]}),`\n`,(0,n.jsx)(a,{languages:{jsx:h,tsx:u}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Element argument is not included in the results even if it matches the specified style.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Value arguments have to be in the format of the resolved styles, e.g. colors have to be in \",(0,n.jsx)(e.code,{children:\"rgb()\"}),\"/\",(0,n.jsx)(e.code,{children:\"rgba()\"}),\" format in order to match.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Recursion\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"DOM APIs\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"How to get an \",(0,n.jsx)(e.code,{children:\"Element\"}),\"'s computed style\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"How to traverse an \",(0,n.jsx)(e.code,{children:\"Element\"}),\"'s children\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle\",children:\"Window: getComputedStyle() method - Web APIs | MDN\"})}),`\n`]})]})}function W(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var P=W;return C(T);})();\n;return Component;",
  "workspace": {
    "main": "/src/get-elements-by-style.ts",
    "run": "/src/get-elements-by-style.run.test.ts",
    "submit": "/src/get-elements-by-style.submit.test.ts"
  }
}