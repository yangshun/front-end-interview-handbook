{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/is-match\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/is-match.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/is-match.run.test.ts": "import isMatch from './is-match';\n\ndescribe('isMatch', () => {\n  test('empty source object', () => {\n    expect(isMatch({}, {})).toEqual(true);\n  });\n\n  test('single property match', () => {\n    expect(isMatch({ b: 2 }, { b: 2 })).toEqual(true);\n    expect(isMatch({ b: 2 }, { b: 3 })).toEqual(false);\n  });\n\n  test('multiple properties with partial match', () => {\n    expect(isMatch({ a: 1, b: 2 }, { b: 2 })).toEqual(true);\n    expect(isMatch({ a: 1, b: 2 }, { b: 3 })).toEqual(false);\n  });\n});\n",
    "/src/is-match.submit.test.ts": "import isMatch from './is-match';\n\ndescribe('isMatch', () => {\n  test('basic functionality', () => {\n    const source = { a: 1 };\n    expect(isMatch({ a: 1, b: 2 }, source)).toEqual(true);\n    expect(isMatch({ a: 2 }, source)).toEqual(false);\n  });\n\n  test('matching with undefined and null values', () => {\n    const source = { a: undefined, b: null };\n    expect(isMatch({ a: undefined, b: null }, source)).toEqual(true);\n    expect(isMatch({ a: null, b: undefined }, source)).toEqual(false);\n  });\n\n  test('handling primitive data types', () => {\n    const source = { a: 'hello', b: 100 };\n    expect(isMatch({ a: 'hello', b: 100, c: false }, source)).toEqual(true);\n    expect(isMatch({ a: 'world', b: 100 }, source)).toEqual(false);\n  });\n\n  test('handling boolean values', () => {\n    const source = { a: true, b: false };\n    expect(isMatch({ a: true, b: false, c: 'extra' }, source)).toEqual(true);\n    expect(isMatch({ a: false, b: true }, source)).toEqual(false);\n  });\n\n  test('strict equality checks', () => {\n    const source = { a: 0, b: '0' };\n    expect(isMatch({ a: 0, b: '0', c: null }, source)).toEqual(true);\n    expect(isMatch({ a: '0', b: 0 }, source)).toEqual(false);\n  });\n\n  test('values with different types', () => {\n    const source = { a: '5', b: 5 };\n    expect(isMatch({ a: '5', b: 5 }, source)).toEqual(true);\n    expect(isMatch({ a: 5, b: '5' }, source)).toEqual(false);\n  });\n\n  test('nested objects', () => {\n    const source = { a: { b: { c: 1 } } };\n    expect(isMatch({ a: { b: { c: 1, d: 2 } }, e: 3 }, source)).toEqual(true);\n    expect(isMatch({ a: { b: { c: 2 } } }, source)).toEqual(false);\n  });\n\n  test('nested arrays', () => {\n    const source = { a: [1, 2, [3, 4]] };\n    expect(isMatch({ a: [1, 2, [3, 4]], b: 5 }, source)).toEqual(true);\n    expect(isMatch({ a: [1, 2, [4, 3]] }, source)).toEqual(false);\n  });\n\n  test('complex nesting', () => {\n    const source = { a: [{ b: { c: [1, { d: 2 }] } }] };\n    expect(\n      isMatch({ a: [{ b: { c: [1, { d: 2, e: 3 }] } }], f: 4 }, source),\n    ).toEqual(true);\n    expect(isMatch({ a: [{ b: { c: [1, { d: 3 }] } }] }, source)).toEqual(\n      false,\n    );\n  });\n});\n",
    "/src/is-match.ts": "export default function isMatch(\n  object: Record<string, any>,\n  source: Record<string, any>,\n): boolean {\n  for (const key in source) {\n    // Check if both values are objects (including arrays, but not null).\n    if (\n      typeof object[key] === 'object' &&\n      typeof source[key] === 'object' &&\n      object[key] !== null &&\n      source[key] !== null\n    ) {\n      // Recursively call isMatch for nested objects or arrays.\n      if (!isMatch(object[key], source[key])) {\n        return false;\n      }\n    } else if (object[key] !== source[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property to match.\n * @returns {boolean} Returns true if object is a match, else false.\n */\nexport default function isMatch(object, source) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function isMatch(\n  object: Record<string, any>,\n  source: Record<string, any>,\n): boolean {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/is-match.ts",
    "run": "/src/is-match.run.test.ts",
    "submit": "/src/is-match.submit.test.ts"
  }
}