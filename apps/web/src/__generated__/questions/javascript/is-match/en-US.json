{
  "description": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var j=(c,e)=>()=>(e||c((e={exports:{}}).exports,e),e.exports),f=(c,e)=>{for(var t in e)a(c,t,{get:e[t],enumerable:!0})},i=(c,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!b.call(c,r)&&r!==t&&a(c,r,{get:()=>e[r],enumerable:!(o=u(e,r))||o.enumerable});return c};var y=(c,e,t)=>(t=c!=null?d(p(c)):{},i(e||!c||!c.__esModule?a(t,\"default\",{value:c,enumerable:!0}):t,c)),g=c=>i(a({},\"__esModule\",{value:!0}),c);var l=j((w,s)=>{s.exports=_jsx_runtime});var _={};f(_,{default:()=>v,frontmatter:()=>x});var n=y(l()),x={title:\"Is Match\",excerpt:\"Implement a function that compares object and source to determine if they contain equivalent property values\"};function h(c){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",ul:\"ul\",a:\"a\"},c.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"isMatch(object, source)\"}),\" that performs a partial deep comparison between object and source to determine if object contains equivalent property values.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`isMatch(object, source);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"object\"}),\" \",(0,n.jsx)(e.em,{children:\"(Object)\"}),\": The object to inspect.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"source\"}),\" \",(0,n.jsx)(e.em,{children:\"(Object)\"}),\": The object of property to match.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:(0,n.jsx)(e.code,{children:\"(boolean)\"})}),\": Returns true if object is a match, else false.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`isMatch({ a: 1, b: 2 }, { b: 2 });\n// => true\n\nisMatch({ a: 1, b: 2 }, { b: 1 });\n// => false\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Partial comparisons will match empty array and empty object source values against any array or object value, respectively.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const object = { a: 1, b: ['x', 'y'], c: { key: 'value' } };\n\nisMatch(object, { b: [] }); // => true\n\nisMatch(object, { c: {} }); // => true\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#isMatch\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.isMatch\"})]})}),`\n`]})]})}function M(c={}){let{wrapper:e}=c.components||{};return e?(0,n.jsx)(e,Object.assign({},c,{children:(0,n.jsx)(h,c)})):h(c)}var v=M;return g(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/is-match\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/is-match.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/is-match.run.test.ts": "import isMatch from './is-match';\n\ndescribe('isMatch', () => {\n  test('empty source object', () => {\n    expect(isMatch({}, {})).toEqual(true);\n  });\n\n  test('single property match', () => {\n    expect(isMatch({ b: 2 }, { b: 2 })).toEqual(true);\n    expect(isMatch({ b: 2 }, { b: 3 })).toEqual(false);\n  });\n\n  test('multiple properties with partial match', () => {\n    expect(isMatch({ a: 1, b: 2 }, { b: 2 })).toEqual(true);\n    expect(isMatch({ a: 1, b: 2 }, { b: 3 })).toEqual(false);\n  });\n});\n",
    "/src/is-match.submit.test.ts": "import isMatch from './is-match';\n\ndescribe('isMatch', () => {\n  test('basic functionality', () => {\n    const source = { a: 1 };\n    expect(isMatch({ a: 1, b: 2 }, source)).toEqual(true);\n    expect(isMatch({ a: 2 }, source)).toEqual(false);\n  });\n\n  test('matching with undefined and null values', () => {\n    const source = { a: undefined, b: null };\n    expect(isMatch({ a: undefined, b: null }, source)).toEqual(true);\n    expect(isMatch({ a: null, b: undefined }, source)).toEqual(false);\n  });\n\n  test('handling primitive data types', () => {\n    const source = { a: 'hello', b: 100 };\n    expect(isMatch({ a: 'hello', b: 100, c: false }, source)).toEqual(true);\n    expect(isMatch({ a: 'world', b: 100 }, source)).toEqual(false);\n  });\n\n  test('handling boolean values', () => {\n    const source = { a: true, b: false };\n    expect(isMatch({ a: true, b: false, c: 'extra' }, source)).toEqual(true);\n    expect(isMatch({ a: false, b: true }, source)).toEqual(false);\n  });\n\n  test('strict equality checks', () => {\n    const source = { a: 0, b: '0' };\n    expect(isMatch({ a: 0, b: '0', c: null }, source)).toEqual(true);\n    expect(isMatch({ a: '0', b: 0 }, source)).toEqual(false);\n  });\n\n  test('values with different types', () => {\n    const source = { a: '5', b: 5 };\n    expect(isMatch({ a: '5', b: 5 }, source)).toEqual(true);\n    expect(isMatch({ a: 5, b: '5' }, source)).toEqual(false);\n  });\n\n  test('nested objects', () => {\n    const source = { a: { b: { c: 1 } } };\n    expect(isMatch({ a: { b: { c: 1, d: 2 } }, e: 3 }, source)).toEqual(true);\n    expect(isMatch({ a: { b: { c: 2 } } }, source)).toEqual(false);\n  });\n\n  test('nested arrays', () => {\n    const source = { a: [1, 2, [3, 4]] };\n    expect(isMatch({ a: [1, 2, [3, 4]], b: 5 }, source)).toEqual(true);\n    expect(isMatch({ a: [1, 2, [4, 3]] }, source)).toEqual(false);\n  });\n\n  test('complex nesting', () => {\n    const source = { a: [{ b: { c: [1, { d: 2 }] } }] };\n    expect(\n      isMatch({ a: [{ b: { c: [1, { d: 2, e: 3 }] } }], f: 4 }, source),\n    ).toEqual(true);\n    expect(isMatch({ a: [{ b: { c: [1, { d: 3 }] } }] }, source)).toEqual(\n      false,\n    );\n  });\n});\n",
    "/src/is-match.ts": "export default function isMatch(\n  object: Record<string, any>,\n  source: Record<string, any>,\n): boolean {\n  for (const key in source) {\n    // Check if both values are objects (including arrays, but not null).\n    if (\n      typeof object[key] === 'object' &&\n      typeof source[key] === 'object' &&\n      object[key] !== null &&\n      source[key] !== null\n    ) {\n      // Recursively call isMatch for nested objects or arrays.\n      if (!isMatch(object[key], source[key])) {\n        return false;\n      }\n    } else if (object[key] !== source[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1712102400,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that compares object and source to determine if they contain equivalent property values",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/is-match",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": false,
    "ranking": 100,
    "similarQuestions": [
      "conforms-to"
    ],
    "slug": "is-match",
    "subtitle": null,
    "title": "Is Match",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property to match.\n * @returns {boolean} Returns true if object is a match, else false.\n */\nexport default function isMatch(object, source) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function isMatch(\n  object: Record<string, any>,\n  source: Record<string, any>,\n): boolean {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var j=Object.create;var n=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,M=Object.prototype.hasOwnProperty;var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var o in e)n(r,o,{get:e[o],enumerable:!0})},a=(r,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of k(e))!M.call(r,c)&&c!==o&&n(r,c,{get:()=>e[c],enumerable:!(i=p(e,c))||i.enumerable});return r};var x=(r,e,o)=>(o=r!=null?j(m(r)):{},a(e||!r||!r.__esModule?n(o,\"default\",{value:r,enumerable:!0}):o,r)),R=r=>a(n({},\"__esModule\",{value:!0}),r);var u=v((B,l)=>{l.exports=_jsx_runtime});var A={};g(A,{default:()=>w});var t=x(u());var s=MDXCodeBlock;var h=`/**\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property to match.\n * @returns {boolean} Returns true if object is a match, else false.\n */\nexport default function isMatch(object, source) {\n  for (const key in source) {\n    // Check if both values are objects (including arrays, but not null).\n    if (\n      typeof object[key] === 'object' &&\n      typeof source[key] === 'object' &&\n      object[key] !== null &&\n      source[key] !== null\n    ) {\n      // Recursively call isMatch for nested objects or arrays.\n      if (!isMatch(object[key], source[key])) {\n        return false;\n      }\n    } else if (object[key] !== source[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n`;var d=`export default function isMatch(\n  object: Record<string, any>,\n  source: Record<string, any>,\n): boolean {\n  for (const key in source) {\n    // Check if both values are objects (including arrays, but not null).\n    if (\n      typeof object[key] === 'object' &&\n      typeof source[key] === 'object' &&\n      object[key] !== null &&\n      source[key] !== null\n    ) {\n      // Recursively call isMatch for nested objects or arrays.\n      if (!isMatch(object[key], source[key])) {\n        return false;\n      }\n    } else if (object[key] !== source[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n`;var y=`/**\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property to match.\n * @returns {boolean} Returns true if object is a match, else false.\n */\nexport default function isMatch(object, source) {\n  // .every() ensures that all predicate must return \\`true\\` for \\`isMatch\\` to return \\`true\\`.\n  return Object.keys(source).every((key) => {\n    if (\n      typeof object[key] === 'object' &&\n      typeof source[key] === 'object' &&\n      object[key] !== null &&\n      source[key] !== null\n    ) {\n      // Recursively call isMatch for nested objects or arrays.\n      return isMatch(object[key], source[key]);\n    }\n    // Direct comparison for non-object types or if one value is null.\n    return object[key] === source[key];\n  });\n}\n`;var f=`export default function isMatch(\n  object: Record<string, any>,\n  source: Record<string, any>,\n): boolean {\n  // .every() ensures that all predicate must return \\`true\\` for \\`isMatch\\` to return \\`true\\`.\n  return Object.keys(source).every((key) => {\n    if (\n      typeof object[key] === 'object' &&\n      typeof source[key] === 'object' &&\n      object[key] !== null &&\n      source[key] !== null\n    ) {\n      // Recursively call isMatch for nested objects or arrays.\n      return isMatch(object[key], source[key]);\n    }\n    // Direct comparison for non-object types or if one value is null.\n    return object[key] === source[key];\n  });\n}\n`;function b(r){let e=Object.assign({h2:\"h2\",h3:\"h3\",code:\"code\",ol:\"ol\",li:\"li\",p:\"p\",ul:\"ul\",a:\"a\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 1: Iterate through \",(0,t.jsx)(e.code,{children:\"source\"}),\" and return \",(0,t.jsx)(e.code,{children:\"false\"}),\" once any part of it is not fulfilled\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Iterates over the keys in \",(0,t.jsx)(e.code,{children:\"source\"}),\" object and compare with the corresponding value in \",(0,t.jsx)(e.code,{children:\"object\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"source\"}),\" is a nested array/object, do a deep comparison recursively by calling \",(0,t.jsx)(e.code,{children:\"isMatch()\"}),\" again to match specific keys in \",(0,t.jsx)(e.code,{children:\"source\"}),\" and \",(0,t.jsx)(e.code,{children:\"object\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Returns \",(0,t.jsx)(e.code,{children:\"false\"}),\" if it does not match, and only returns \",(0,t.jsx)(e.code,{children:\"true\"}),\" after all are checked to match.\"]}),`\n`]}),`\n`,(0,t.jsx)(s,{languages:{jsx:h,tsx:d}}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 2: Uses \",(0,t.jsx)(e.code,{children:\".every()\"}),\" to ensure all keys in \",(0,t.jsx)(e.code,{children:\"source\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"By using \",(0,t.jsx)(e.code,{children:\"Object.keys(source).every(...)\"}),\", it ensures that to return \",(0,t.jsx)(e.code,{children:\"true\"}),\", every key in \",(0,t.jsx)(e.code,{children:\"source\"}),\" must match with \",(0,t.jsx)(e.code,{children:\"object\"}),\".\"]}),`\n`,(0,t.jsx)(s,{languages:{jsx:y,tsx:f}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"When \",(0,t.jsx)(e.code,{children:\"object\"}),\" or \",(0,t.jsx)(e.code,{children:\"source\"}),\" has circular references, it can cause infinite loops in due to the recursive nature. To solve this, we can keep track of visited objects using a data structure like \",(0,t.jsx)(e.code,{children:\"WeakMap\"}),\" during the recursion, and if an object is encountered that has already been visited, you can either stop the recursion or handle it appropriately to prevent infinite loops.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#isMatch\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.isMatch\"})]})}),`\n`]})]})}function D(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(b,r)})):b(r)}var w=D;return R(A);})();\n;return Component;",
  "workspace": {
    "main": "/src/is-match.ts",
    "run": "/src/is-match.run.test.ts",
    "submit": "/src/is-match.submit.test.ts"
  }
}