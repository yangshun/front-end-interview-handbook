{
  "description": "var Component=(()=>{var h=Object.create;var d=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var T=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var r in e)d(n,r,{get:e[r],enumerable:!0})},l=(n,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!f.call(n,o)&&o!==r&&d(n,o,{get:()=>e[o],enumerable:!(i=m(e,o))||i.enumerable});return n};var D=(n,e,r)=>(r=n!=null?h(u(n)):{},l(e||!n||!n.__esModule?d(r,\"default\",{value:n,enumerable:!0}):r,n)),M=n=>l(d({},\"__esModule\",{value:!0}),n);var a=T((w,s)=>{s.exports=_jsx_runtime});var j={};x(j,{default:()=>g,frontmatter:()=>v});var t=D(a()),v={title:\"Identical DOM Trees\",excerpt:\"Implement a function to determine if two DOM trees are the same\"};function c(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a function \",(0,t.jsx)(e.code,{children:\"identicalDOMTrees\"}),\" that checks if two DOM trees are identical or not. The function takes two DOM nodes as the root nodes of two DOM trees and returns a boolean result.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Two DOM trees are considered identical if they are structurally similar, and the DOM nodes on one tree have the exact same attributes as the nodes on the same relative position on the other tree.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.p,{children:\"Tree A and Tree B are considered the same.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-html\",children:`<!-- Tree A -->\n<div>Hello World</div>\n\n<!-- Tree B -->\n<div>Hello World</div>\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"Tree C and Tree D are considered the different.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-html\",children:`<!-- Tree C -->\n<div class=\"header\">Hello World</div>\n\n<!-- Tree D -->\n<div id=\"foo\">Hello World</div>\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The only types of \",(0,t.jsx)(e.code,{children:\"Node\"}),\"s present in the tree are \",(0,t.jsx)(e.code,{children:\"Element\"}),\" nodes and \",(0,t.jsx)(e.code,{children:\"Text\"}),\" nodes.\"]}),`\n`]})]})}function O(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(c,n)})):c(n)}var g=O;return M(j);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/identical-dom-trees\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/identical-dom-trees.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/identical-dom-trees.run.test.ts": "import identicalDOMTrees from './identical-dom-trees';\n\ndescribe('identicalDOMTrees', () => {\n  test('single nodes', () => {\n    const treeA = document.createElement('div');\n    const treeB = document.createElement('div');\n    expect(identicalDOMTrees(treeA, treeB)).toBe(true);\n  });\n\n  test('nodes with same children', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div><span>Foo</span><p>Para</p></div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div><span>Foo</span><p>Para</p></div>`,\n      'text/html',\n    );\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(true);\n  });\n\n  test('nodes with different children', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div><span>Foo</span><p>Para</p></div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div><span>Bar</span><p>Para</p></div>`,\n      'text/html',\n    );\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(false);\n  });\n});\n",
    "/src/identical-dom-trees.submit.test.ts": "import identicalDOMTrees from './identical-dom-trees';\n\ndescribe('identicalDOMTrees', () => {\n  test('single nodes', () => {\n    const treeA = document.createElement('div');\n    const treeB = document.createElement('div');\n    expect(identicalDOMTrees(treeA, treeB)).toBe(true);\n  });\n\n  test('nodes with same children', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div><span>Foo</span><p>Para</p></div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div><span>Foo</span><p>Para</p></div>`,\n      'text/html',\n    );\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(true);\n  });\n\n  test('nodes with different children', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div><span>Foo</span><p>Para</p></div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div><span>Bar</span><p>Para</p></div>`,\n      'text/html',\n    );\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(false);\n  });\n\n  test('nodes with different tagnames', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div>Foo</div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(`<p>Foo</p>`, 'text/html');\n\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(false);\n  });\n\n  test('nodes with same attributes', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div class=\"foo\" data-id=\"123\">hello</div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div class=\"foo\" data-id=\"123\">hello</div>`,\n      'text/html',\n    );\n\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(true);\n  });\n\n  test('nodes with different attributes', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div class=\"foo\">hello</div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div class=\"bar\">hello</div>`,\n      'text/html',\n    );\n\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(false);\n  });\n\n  test('nodes with different styles', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div style=\"color: red;\">hello</div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div style=\"color: blue;\">hello</div>`,\n      'text/html',\n    );\n\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(false);\n  });\n\n  test('nodes with different comment and text nodes', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div><span>Foo</span><!-- comment --></div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div><span>Foo</span>text node</div>`,\n      'text/html',\n    );\n\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(false);\n  });\n\n  test('nodes with different numbers of children', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div>\n        <span>Foo</span>\n        <p>Para</p>\n      </div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div>\n        <span>Foo</span>\n        <p>Para</p>\n        <div></div>\n      </div>`,\n      'text/html',\n    );\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(false);\n  });\n\n  test('nodes with nested elements', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div>\n        <span>Foo</span>\n        <p>Para</p>\n        <div>\n          <span>Bar</span>\n          <p>Para</p>\n        </div>\n      </div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div>\n        <span>Foo</span>\n        <p>Para</p>\n        <div>\n          <span>Bar</span>\n          <p>Para</p>\n        </div>\n      </div>`,\n      'text/html',\n    );\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(true);\n  });\n\n  test('nodes with nested elements in different order', () => {\n    const treeA = new DOMParser().parseFromString(\n      `<div>\n        <span>Foo</span>\n        <p>Para</p>\n        <div>\n          <span>Bar</span>\n          <p>Para</p>\n        </div>\n      </div>`,\n      'text/html',\n    );\n    const treeB = new DOMParser().parseFromString(\n      `<div>\n        <div>\n          <p>Para</p>\n          <span>Bar</span>\n        </div>\n        <span>Foo</span>\n        <p>Para</p>\n      </div>`,\n      'text/html',\n    );\n    expect(identicalDOMTrees(treeA.body, treeB.body)).toBe(false);\n  });\n});\n",
    "/src/identical-dom-trees.ts": "export default function identicalDOMTrees(nodeA: Node, nodeB: Node): boolean {\n  if (nodeA.nodeType !== nodeB.nodeType) {\n    return false;\n  }\n\n  if (nodeA.nodeType === Node.TEXT_NODE) {\n    return nodeA.textContent === nodeB.textContent;\n  }\n\n  const elA = nodeA as Element;\n  const elB = nodeB as Element;\n\n  // We can assume it's an element node from here on.\n  if (elA.tagName !== elB.tagName) {\n    return false;\n  }\n\n  if (elA.childNodes.length !== elB.childNodes.length) {\n    return false;\n  }\n\n  if (elA.attributes.length !== elB.attributes.length) {\n    return false;\n  }\n\n  const hasSameAttributes = elA\n    .getAttributeNames()\n    .every(\n      (attrName) => elA.getAttribute(attrName) === elB.getAttribute(attrName),\n    );\n\n  if (!hasSameAttributes) {\n    return false;\n  }\n\n  return Array.prototype.every.call(elA.childNodes, (childA, index) =>\n    identicalDOMTrees(childA, elB.childNodes[index]),\n  );\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "zhenghao",
    "companies": [],
    "created": 1649894400,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function to determine if two DOM trees are the same",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/identical-dom-trees",
    "importance": "low",
    "languages": [
      "html",
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "deep-equal"
    ],
    "slug": "identical-dom-trees",
    "subtitle": null,
    "title": "Identical DOM Trees",
    "topics": [
      "recursion",
      "tree",
      "web-api"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @return {boolean}\n */\nexport default function identicalDOMTrees(nodeA, nodeB) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function identicalDOMTrees(nodeA: Node, nodeB: Node): boolean {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,N=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var o in e)i(n,o,{get:e[o],enumerable:!0})},a=(n,e,o,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!N.call(n,r)&&r!==o&&i(n,r,{get:()=>e[r],enumerable:!(d=f(e,r))||d.enumerable});return n};var v=(n,e,o)=>(o=n!=null?p(A(n)):{},a(e||!n||!n.__esModule?i(o,\"default\",{value:n,enumerable:!0}):o,n)),w=n=>a(i({},\"__esModule\",{value:!0}),n);var s=g((j,l)=>{l.exports=_jsx_runtime});var B={};b(B,{default:()=>D});var t=v(s());var c=MDXCodeBlock;var h=`/**\n * @param {Node} nodeA\n * @param {Node} nodeB\n * @return {boolean}\n */\nexport default function identicalDOMTrees(nodeA, nodeB) {\n  if (nodeA.nodeType !== nodeB.nodeType) {\n    return false;\n  }\n\n  if (nodeA.nodeType === Node.TEXT_NODE) {\n    return nodeA.textContent === nodeB.textContent;\n  }\n\n  // We can assume it's an element node from here on.\n  if (nodeA.tagName !== nodeB.tagName) {\n    return false;\n  }\n\n  if (nodeA.childNodes.length !== nodeB.childNodes.length) {\n    return false;\n  }\n\n  if (nodeA.attributes.length !== nodeB.attributes.length) {\n    return false;\n  }\n\n  const hasSameAttributes = nodeA\n    .getAttributeNames()\n    .every(\n      (attrName) =>\n        nodeA.getAttribute(attrName) === nodeB.getAttribute(attrName),\n    );\n\n  if (!hasSameAttributes) {\n    return false;\n  }\n\n  return Array.prototype.every.call(nodeA.childNodes, (childA, index) =>\n    identicalDOMTrees(childA, nodeB.childNodes[index]),\n  );\n}\n`;var u=`export default function identicalDOMTrees(nodeA: Node, nodeB: Node): boolean {\n  if (nodeA.nodeType !== nodeB.nodeType) {\n    return false;\n  }\n\n  if (nodeA.nodeType === Node.TEXT_NODE) {\n    return nodeA.textContent === nodeB.textContent;\n  }\n\n  const elA = nodeA as Element;\n  const elB = nodeB as Element;\n\n  // We can assume it's an element node from here on.\n  if (elA.tagName !== elB.tagName) {\n    return false;\n  }\n\n  if (elA.childNodes.length !== elB.childNodes.length) {\n    return false;\n  }\n\n  if (elA.attributes.length !== elB.attributes.length) {\n    return false;\n  }\n\n  const hasSameAttributes = elA\n    .getAttributeNames()\n    .every(\n      (attrName) => elA.getAttribute(attrName) === elB.getAttribute(attrName),\n    );\n\n  if (!hasSameAttributes) {\n    return false;\n  }\n\n  return Array.prototype.every.call(elA.childNodes, (childA, index) =>\n    identicalDOMTrees(childA, elB.childNodes[index]),\n  );\n}\n`;function m(n){let e=Object.assign({p:\"p\",a:\"a\",pre:\"pre\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"This question is the front end version of the \",(0,t.jsx)(e.a,{href:\"https://leetcode.com/problems/same-tree/\",children:\"Same Tree\"}),\" question on LeetCode. It tests your knowledge of recursion / tree traversals and the Document Object Model (DOM).\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Let's look at a minimal example of a DOM tree.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-html\",children:`<span>foo</span>\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the DOM, every HTML tag is an object. Nested tags or texts are children of the enclosing tag. In this example, the text \",(0,t.jsx)(e.code,{children:\"foo\"}),\" is the child of the \",(0,t.jsx)(e.code,{children:\"span\"}),\" tag, which can be accessed by the \",(0,t.jsx)(e.code,{children:\"childNodes\"}),\" property.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"Our function needs to determine if two trees are identical. We can achieve this by traversing two root nodes at the same time and compare them to see if they are the same, recurse into their children nodes and repeat this process until we have found a mismatch or we have visited all of the nodes in either one of the two trees.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Therefore, our tasks can be divided into two subtasks:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Traverse the DOM trees.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Compare the current DOM nodes.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If you have worked on the \",(0,t.jsx)(e.a,{href:\"/questions/javascript/deep-equal\",children:\"deep equal\"}),\" question, you would realize that the approach described above is exactly the one we used for the \",(0,t.jsx)(e.a,{href:\"/questions/javascript/deep-equal\",children:\"deep equal\"}),\" question as well. In fact, it is a common technique across most of the object/tree-related questions:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"We want to efficiently visit an object (a tree).\"}),`\n`,(0,t.jsx)(e.li,{children:\"We need to do something when we process each property of that object (a node in a tree).\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Here is the solution:\"}),`\n`,(0,t.jsx)(c,{languages:{jsx:h,tsx:u}}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes on native DOM APIs\"}),`\n`,(0,t.jsx)(e.p,{children:\"There are quite a bit of DOM-specific APIs you will have to use to implement such a function. And it is ok if you are not familiar with them. In practice, you usually do not need to write low-level DOM manipulation code anymore.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Here are the DOM APIs we have covered in this solution:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"We use \",(0,t.jsx)(e.code,{children:\"nodeType\"}),\" when checking the types of nodes. There is a similar API called \",(0,t.jsx)(e.code,{children:\"tagName\"}),\" that only works for HTML elements, not for text nodes and comment nodes. Check out \",(0,t.jsx)(e.a,{href:\"https://javascript.info/basic-dom-node-properties#summary\",children:\"this tutorial\"}),\" if you want to learn more about their differences.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"We use the \",(0,t.jsx)(e.code,{children:\"childNodes\"}),\" property - as opposed to the \",(0,t.jsx)(e.code,{children:\"children\"}),\" property - to get the list of children nodes. The reason is, again, \",(0,t.jsx)(e.code,{children:\"children\"}),\" only returns elements while \",(0,t.jsx)(e.code,{children:\"childNodes\"}),\" returns all nodes, including text nodes and comment nodes. Check out \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes\",children:\"this MDN page\"}),\" if you want to learn more about their differences.\"]}),`\n`,(0,t.jsxs)(e.li,{children:['We \"borrowed\" the ',(0,t.jsx)(e.code,{children:\"every\"}),\" method from \",(0,t.jsx)(e.code,{children:\"Array.prototype\"}),\" via \",(0,t.jsx)(e.code,{children:\"Array.prototype.every.call(treeA.childNodes)\"}),\" as opposed to just calling \",(0,t.jsx)(e.code,{children:\"every\"}),\" on \",(0,t.jsx)(e.code,{children:\"childNodes\"}),\". This is because what \",(0,t.jsx)(e.code,{children:\"childNodes\"}),\" returns is not a JavaScript array, rather an array-like data structure called \",(0,t.jsx)(e.code,{children:\"NodeList\"}),\", which doesn't come with all the array methods right out of box. Calling array methods such as \",(0,t.jsx)(e.code,{children:\"every\"}),\" on it would throw an error. The other way to use array methods on a \",(0,t.jsx)(e.code,{children:\"NodeList\"}),\" is to convert it to an array first via \",(0,t.jsx)(e.code,{children:\"Array.from\"}),\". i.e. \",(0,t.jsx)(e.code,{children:\"Array.from(treeA.childNodes).every(...)\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"One-liner solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"There is a new API called \",(0,t.jsx)(e.code,{children:\"isEqualNode\"}),\" that tests whether two nodes are equal. Check out \",(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Node/isEqualNode\",children:[(0,t.jsx)(e.code,{children:\"Node.isEqualNode()\"}),\" API on MDN\"]}),\".\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function identicalDOMTrees(treeA, treeB) {\n  return treeA.isEqualNode(treeB);\n}\n`})})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var D=M;return w(B);})();\n;return Component;",
  "workspace": {
    "main": "/src/identical-dom-trees.ts",
    "run": "/src/identical-dom-trees.run.test.ts",
    "submit": "/src/identical-dom-trees.submit.test.ts"
  }
}