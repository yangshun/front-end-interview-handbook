{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-input-control\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-input-control.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"@testing-library/user-event\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/use-input-control.run.test.tsx": "import { act, renderHook } from '@testing-library/react';\n\nimport useInputControl from './use-input-control';\n\ndescribe('useInputControl', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useInputControl(''));\n\n    expect(typeof result.current.value).toBe('string');\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(false);\n    expect(typeof result.current.handleChange).toBe('function');\n    expect(typeof result.current.handleBlur).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n  });\n\n  describe('value', () => {\n    test('initial value', () => {\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      expect(result.current.value).toBe('initial value');\n    });\n\n    test('value can be different', () => {\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.value).toBe(value);\n    });\n  });\n\n  test('different', () => {\n    const value = 'new value';\n    const { result } = renderHook(() => useInputControl('initial value'));\n\n    act(() =>\n      result.current.handleChange({\n        target: { value },\n        currentTarget: { value },\n      } as any),\n    );\n\n    expect(result.current.different).toBe(true);\n  });\n\n  test('dirty', () => {\n    const value = 'new value';\n    const { result } = renderHook(() => useInputControl('initial value'));\n\n    act(() =>\n      result.current.handleChange({\n        target: { value },\n        currentTarget: { value },\n      } as any),\n    );\n\n    expect(result.current.dirty).toBe(true);\n  });\n\n  test('touched', () => {\n    const { result } = renderHook(() => useInputControl('initial value'));\n\n    expect(result.current.touched).toBe(false);\n\n    act(() => result.current.handleBlur());\n\n    expect(result.current.touched).toBe(true);\n  });\n\n  test('reset', () => {\n    const initialValue = 'initial value';\n    const newValue = 'new value';\n    const { result } = renderHook(() => useInputControl(initialValue));\n\n    act(() => {\n      result.current.handleChange({\n        target: { value: newValue },\n        currentTarget: { value: newValue },\n      } as any);\n      result.current.handleBlur();\n    });\n\n    expect(result.current.value).toBe(newValue);\n    expect(result.current.different).toBe(true);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(true);\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.different).toBe(false);\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n  });\n});\n",
    "/src/use-input-control.submit.test.tsx": "import React from 'react';\nimport { act, render, renderHook } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\nimport useInputControl from './use-input-control';\n\ndescribe('useInputControl', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useInputControl(''));\n\n    expect(typeof result.current.value).toBe('string');\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(false);\n    expect(typeof result.current.handleChange).toBe('function');\n    expect(typeof result.current.handleBlur).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n  });\n\n  describe('value', () => {\n    test('initial value', () => {\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      expect(result.current.value).toBe('initial value');\n    });\n\n    test('value can be changed', () => {\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.value).toBe(value);\n    });\n  });\n\n  describe('different', () => {\n    test('different value', () => {\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.different).toBe(true);\n    });\n\n    test('back to initial value', () => {\n      const initialValue = 'initial value';\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl(initialValue));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.different).toBe(true);\n\n      act(() =>\n        result.current.handleChange({\n          target: { value: initialValue },\n          currentTarget: { value: initialValue },\n        } as any),\n      );\n\n      expect(result.current.different).toBe(false);\n    });\n\n    test('does not rely on initial argument', () => {\n      const initialValue = 'initial value';\n      const newValue = 'new value';\n      const { result, rerender } = renderHook(\n        ({ initialValue }) => useInputControl(initialValue),\n        {\n          initialProps: { initialValue },\n        },\n      );\n\n      act(() =>\n        result.current.handleChange({\n          target: { value: newValue },\n          currentTarget: { value: newValue },\n        } as any),\n      );\n\n      expect(result.current.different).toBe(true);\n\n      rerender({ initialValue: newValue });\n\n      expect(result.current.different).toBe(true);\n    });\n  });\n\n  describe('dirty', () => {\n    test('different value', () => {\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.dirty).toBe(true);\n    });\n\n    test('back to initial value', () => {\n      const initialValue = 'initial value';\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl(initialValue));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.dirty).toBe(true);\n\n      act(() =>\n        result.current.handleChange({\n          target: { value: initialValue },\n          currentTarget: { value: initialValue },\n        } as any),\n      );\n\n      expect(result.current.dirty).toBe(true);\n    });\n  });\n\n  describe('touched', () => {\n    test('initial', () => {\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      expect(result.current.touched).toBe(false);\n    });\n\n    test('handleBlur', () => {\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      expect(result.current.touched).toBe(false);\n\n      act(() => result.current.handleBlur());\n\n      expect(result.current.touched).toBe(true);\n    });\n  });\n\n  test('reset', () => {\n    const initialValue = 'initial value';\n    const newValue = 'new value';\n    const { result } = renderHook(() => useInputControl(initialValue));\n\n    act(() => {\n      result.current.handleChange({\n        target: { value: newValue },\n        currentTarget: { value: newValue },\n      } as any);\n      result.current.handleBlur();\n    });\n\n    expect(result.current.value).toBe(newValue);\n    expect(result.current.different).toBe(true);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(true);\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.different).toBe(false);\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n  });\n\n  test('integration', async () => {\n    const initialValue = 'initial value';\n    const { result } = renderHook(() => useInputControl(initialValue));\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(false);\n\n    const newValue = 'new value';\n\n    act(() => {\n      result.current.handleChange({\n        target: { value: newValue },\n        currentTarget: { value: newValue },\n      } as any);\n    });\n\n    expect(result.current.value).toBe(newValue);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(true);\n\n    act(() => {\n      result.current.handleBlur();\n    });\n\n    expect(result.current.value).toBe(newValue);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(true);\n    expect(result.current.different).toBe(true);\n\n    act(() => {\n      result.current.handleChange({\n        target: { value: initialValue },\n        currentTarget: { value: initialValue },\n      } as any);\n    });\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(true);\n    expect(result.current.different).toBe(false);\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(false);\n  });\n});\n",
    "/src/use-input-control.ts": "import { ChangeEvent, useCallback, useRef, useState } from 'react';\n\ninterface UseInputValueReturn {\n  value: string;\n  dirty: boolean;\n  touched: boolean;\n  different: boolean;\n  handleChange: (event: ChangeEvent<HTMLInputElement>) => void;\n  handleBlur: () => void;\n  reset: () => void;\n}\n\nconst defaultDirty = false;\nconst defaultTouched = false;\n\nexport default function useInputControl(\n  initialValue: string,\n): UseInputValueReturn {\n  const initialValueRef = useRef<string>(initialValue);\n  const [value, setValue] = useState(initialValue);\n  const [dirty, setDirty] = useState(defaultDirty);\n  const [touched, setTouched] = useState(defaultTouched);\n\n  const handleChange: UseInputValueReturn['handleChange'] = useCallback(\n    (event) => {\n      setValue(event.currentTarget.value);\n      setDirty(true);\n    },\n    [],\n  );\n  const handleBlur: UseInputValueReturn['handleBlur'] = useCallback(() => {\n    setTouched(true);\n  }, []);\n  const reset = useCallback(() => {\n    setValue(initialValueRef.current);\n    setDirty(defaultDirty);\n    setTouched(defaultTouched);\n  }, []);\n\n  // Derived from whether the value is different from the initial value\n  const different = initialValueRef.current !== value;\n\n  return {\n    value,\n    dirty,\n    touched,\n    different,\n    handleChange,\n    handleBlur,\n    reset,\n  };\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {string} initialValue\n */\nexport default function useInputControl(initialValue) {\n  throw 'Not implemented';\n}",
    "ts": "import { ChangeEvent } from 'react';\n\ninterface UseInputValueReturn {\n  value: string;\n  onChange: (event: ChangeEvent<HTMLInputElement>) => void;\n}\n\nexport default function useInputControl(\n  initialValue: string,\n): UseInputValueReturn {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/use-input-control.ts",
    "run": "/src/use-input-control.run.test.tsx",
    "submit": "/src/use-input-control.submit.test.tsx"
  }
}