{
  "description": "var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var s=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var r in e)l(t,r,{get:e[r],enumerable:!0})},h=(t,e,r,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!m.call(t,i)&&i!==r&&l(t,i,{get:()=>e[i],enumerable:!(d=s(e,i))||d.enumerable});return t};var g=(t,e,r)=>(r=t!=null?u(f(t)):{},h(e||!t||!t.__esModule?l(r,\"default\",{value:t,enumerable:!0}):r,t)),I=t=>h(l({},\"__esModule\",{value:!0}),t);var a=b((T,o)=>{o.exports=_jsx_runtime});var C={};v(C,{default:()=>k,frontmatter:()=>y});var n=g(a()),y={title:\"useInputControl\",excerpt:\"Implement a hook that manages a controlled input value and tracks its dirty & touched state\"};function c(t){let e=Object.assign({p:\"p\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"useInputControl\"}),\" hook that manages a controlled input value and tracks additional form input states like:\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Property\"}),(0,n.jsx)(e.th,{children:\"Tracks\"}),(0,n.jsxs)(e.th,{children:[\"When it becomes \",(0,n.jsx)(e.code,{children:\"true\"})]}),(0,n.jsxs)(e.th,{children:[\"When it becomes \",(0,n.jsx)(e.code,{children:\"false\"})]})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Touched\"}),(0,n.jsx)(e.td,{children:\"If input has been focused then blurred\"}),(0,n.jsx)(e.td,{children:\"When the user blurs the input (focus -> blur)\"}),(0,n.jsx)(e.td,{children:\"Never resets automatically\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Dirty\"}),(0,n.jsx)(e.td,{children:\"If value has been changed before\"}),(0,n.jsx)(e.td,{children:\"When the user types something Never resets automatically\"}),(0,n.jsx)(e.td,{})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Different\"}),(0,n.jsx)(e.td,{children:\"If value is different from the original\"}),(0,n.jsx)(e.td,{children:\"When the value is different from the initial\"}),(0,n.jsx)(e.td,{children:\"When the value is same as the initial\"})]})]})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"handleX\"}),\" functions returned by the hook are meant to be called on the relevant event handlers of \",(0,n.jsx)(e.code,{children:\"<input>\"}),\" in order for the hook to work as intended.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`export default function Component() {\n  const nameInput = useInputControl('Oliver');\n\n  return (\n    <form>\n      <div>\n        <label htmlFor=\"name\">Name</label>\n        <input\n          id=\"name\"\n          value={nameInput.value}\n          onChange={nameInput.handleChange}\n          onBlur={nameInput.handleBlur}\n        />\n      </div>\n      <p>Touched: {nameInput.touched.toString()}</p>\n      <p>Dirty: {nameInput.dirty.toString()}</p>\n      <p>Different: {nameInput.different.toString()}</p>\n      <button type=\"submit\" disabled={!nameInput.different}>\n        Submit\n      </button>\n      <button type=\"button\" onClick={nameInput.reset}>\n        Reset\n      </button>\n    <form>\n  );\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"initialValue: string\"}),\": The initial value of the input\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsx)(e.p,{children:\"The hook returns an object with the following properties:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"value: string\"}),\": The current value of the input\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"dirty: boolean\"}),\": Whether the user has been modified at least once\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"touched: boolean\"}),\": Whether the input was focused and blurred\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"different: boolean\"}),\": Whether the value is different from the initial value\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"handleChange: (event: React.ChangeEvent<HTMLInputElement>) => void\"}),\": A function that updates the value of the input\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"handleBlur: (event: React.FocusEvent<HTMLInputElement>) => void\"}),\": A function that to be called when the input is blurred\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"reset: () => void\"}),\": A function to reset to the initial value as well as the value of all states\"]}),`\n`]})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(c,t)})):c(t)}var k=x;return I(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a hook that manages a controlled input value and tracks its dirty & touched state",
    "title": "useInputControl"
  },
  "solution": "var Component=(()=>{var f=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),C=(n,e)=>{for(var l in e)r(n,l,{get:e[l],enumerable:!0})},d=(n,e,l,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!m.call(n,i)&&i!==l&&r(n,i,{get:()=>e[i],enumerable:!(a=p(e,i))||a.enumerable});return n};var V=(n,e,l)=>(l=n!=null?f(g(n)):{},d(e||!n||!n.__esModule?r(l,\"default\",{value:n,enumerable:!0}):l,n)),R=n=>d(r({},\"__esModule\",{value:!0}),n);var c=b((x,h)=>{h.exports=_jsx_runtime});var T={};C(T,{default:()=>k});var t=V(c());var o=MDXCodeBlock;var u=`import { ChangeEvent, useCallback, useRef, useState } from 'react';\n\ninterface UseInputValueReturn {\n  value: string;\n  dirty: boolean;\n  touched: boolean;\n  different: boolean;\n  handleChange: (event: ChangeEvent<HTMLInputElement>) => void;\n  handleBlur: () => void;\n  reset: () => void;\n}\n\nconst defaultDirty = false;\nconst defaultTouched = false;\n\nexport default function useInputControl(\n  initialValue: string,\n): UseInputValueReturn {\n  const initialValueRef = useRef<string>(initialValue);\n  const [value, setValue] = useState(initialValue);\n  const [dirty, setDirty] = useState(defaultDirty);\n  const [touched, setTouched] = useState(defaultTouched);\n\n  const handleChange: UseInputValueReturn['handleChange'] = useCallback(\n    (event) => {\n      setValue(event.currentTarget.value);\n      setDirty(true);\n    },\n    [],\n  );\n  const handleBlur: UseInputValueReturn['handleBlur'] = useCallback(() => {\n    setTouched(true);\n  }, []);\n  const reset = useCallback(() => {\n    setValue(initialValueRef.current);\n    setDirty(defaultDirty);\n    setTouched(defaultTouched);\n  }, []);\n\n  // Derived from whether the value is different from the initial value\n  const different = initialValueRef.current !== value;\n\n  return {\n    value,\n    dirty,\n    touched,\n    different,\n    handleChange,\n    handleBlur,\n    reset,\n  };\n}\n`;function s(n){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h3:\"h3\",a:\"a\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"To recap what fields are returned:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"value\"}),\": The current input value\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"touched\"}),\": Whether the input has been focused then blurred\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"dirty\"}),\": Whether the value has been changed before\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"different\"}),\": Whether the value is different from the original\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Let's go through each field and how to implement them:\"}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"value\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"value\"}),\" is a boolean value tracked using React state. An \",(0,t.jsx)(e.code,{children:\"handleChange\"}),\" handler us used to to update the value state from the input's \",(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event\",children:[(0,t.jsx)(e.code,{children:\"change\"}),\" event\"]}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"touched\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"touched\"}),\" is a boolean value tracked using React state. It will be set to \",(0,t.jsx)(e.code,{children:\"true\"}),\" when the input is blurred. As the hook does not know when the \",(0,t.jsx)(e.code,{children:\"<input>\"}),\" element is blurred, we return a \",(0,t.jsx)(e.code,{children:\"handleBlur\"}),\" function that sets the value to \",(0,t.jsx)(e.code,{children:\"true\"}),\" and the user will call the \",(0,t.jsx)(e.code,{children:\"handleBlur\"}),\" function in an \",(0,t.jsx)(e.code,{children:\"onBlur\"}),\" event handler.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"dirty\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"touched\"}),\" is a boolean value tracked using React state. Since it is set to \",(0,t.jsx)(e.code,{children:\"true\"}),\" when it has been changed before, \",(0,t.jsx)(e.code,{children:\"handleChange\"}),\" is a good place to do that.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"different\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"This field does not require a state as it is derived state that can be computed by comparing the initial value and the current \",(0,t.jsx)(e.code,{children:\"value\"}),\". However, the comparison should not be done against the \",(0,t.jsx)(e.code,{children:\"initialValue\"}),\" argument as the value might be different during re-renders!\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Instead, we track the first render's \",(0,t.jsx)(e.code,{children:\"initialValue\"}),\" using \",(0,t.jsx)(e.code,{children:\"useRef\"}),\". Why not state? Because \",(0,t.jsx)(e.code,{children:\"initialValueRef\"}),\" does not ever change after the hook is mounted.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const different = initialValueRef.current !== value;\n`})}),`\n`,(0,t.jsxs)(e.h3,{children:[(0,t.jsx)(e.code,{children:\"reset\"}),\" function\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This function resets all the states within the hook. Simply call the various state setters with their initial values. The initial value to set to can be obtained from \",(0,t.jsx)(e.code,{children:\"initialValueRef\"}),\".\"]}),`\n`,(0,t.jsx)(o,{children:u})]})}function y(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(s,n)})):s(n)}var k=y;return R(T);})();\n;return Component;"
}