{
  "description": "var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var s=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var r in e)l(t,r,{get:e[r],enumerable:!0})},h=(t,e,r,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!m.call(t,i)&&i!==r&&l(t,i,{get:()=>e[i],enumerable:!(d=s(e,i))||d.enumerable});return t};var g=(t,e,r)=>(r=t!=null?u(f(t)):{},h(e||!t||!t.__esModule?l(r,\"default\",{value:t,enumerable:!0}):r,t)),I=t=>h(l({},\"__esModule\",{value:!0}),t);var a=b((T,o)=>{o.exports=_jsx_runtime});var C={};v(C,{default:()=>k,frontmatter:()=>y});var n=g(a()),y={title:\"useInputControl\",excerpt:\"Implement a hook that manages a controlled input value and tracks its dirty & touched state\"};function c(t){let e=Object.assign({p:\"p\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"useInputControl\"}),\" hook that manages a controlled input value and tracks additional form input states like:\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Property\"}),(0,n.jsx)(e.th,{children:\"Tracks\"}),(0,n.jsxs)(e.th,{children:[\"When it becomes \",(0,n.jsx)(e.code,{children:\"true\"})]}),(0,n.jsxs)(e.th,{children:[\"When it becomes \",(0,n.jsx)(e.code,{children:\"false\"})]})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Touched\"}),(0,n.jsx)(e.td,{children:\"If input has been focused then blurred\"}),(0,n.jsx)(e.td,{children:\"When the user blurs the input (focus -> blur)\"}),(0,n.jsx)(e.td,{children:\"Never resets automatically\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Dirty\"}),(0,n.jsx)(e.td,{children:\"If value has been changed before\"}),(0,n.jsx)(e.td,{children:\"When the user types something Never resets automatically\"}),(0,n.jsx)(e.td,{})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Different\"}),(0,n.jsx)(e.td,{children:\"If value is different from the original\"}),(0,n.jsx)(e.td,{children:\"When the value is different from the initial\"}),(0,n.jsx)(e.td,{children:\"When the value is same as the initial\"})]})]})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"handleX\"}),\" functions returned by the hook are meant to be called on the relevant event handlers of \",(0,n.jsx)(e.code,{children:\"<input>\"}),\" in order for the hook to work as intended.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`export default function Component() {\n  const nameInput = useInputControl('Oliver');\n\n  return (\n    <form>\n      <div>\n        <label htmlFor=\"name\">Name</label>\n        <input\n          id=\"name\"\n          value={nameInput.value}\n          onChange={nameInput.handleChange}\n          onBlur={nameInput.handleBlur}\n        />\n      </div>\n      <p>Touched: {nameInput.touched.toString()}</p>\n      <p>Dirty: {nameInput.dirty.toString()}</p>\n      <p>Different: {nameInput.different.toString()}</p>\n      <button type=\"submit\" disabled={!nameInput.different}>\n        Submit\n      </button>\n      <button type=\"button\" onClick={nameInput.reset}>\n        Reset\n      </button>\n    <form>\n  );\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"initialValue: string\"}),\": The initial value of the input\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsx)(e.p,{children:\"The hook returns an object with the following properties:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"value: string\"}),\": The current value of the input\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"dirty: boolean\"}),\": Whether the user has been modified at least once\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"touched: boolean\"}),\": Whether the input was focused and blurred\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"different: boolean\"}),\": Whether the value is different from the initial value\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"handleChange: (event: React.ChangeEvent<HTMLInputElement>) => void\"}),\": A function that updates the value of the input\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"handleBlur: (event: React.FocusEvent<HTMLInputElement>) => void\"}),\": A function that to be called when the input is blurred\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"reset: () => void\"}),\": A function to reset to the initial value as well as the value of all states\"]}),`\n`]})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(c,t)})):c(t)}var k=x;return I(C);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-input-control\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-input-control.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"@testing-library/user-event\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/src/use-input-control.run.test.tsx": "import { act, renderHook } from '@testing-library/react';\n\nimport useInputControl from './use-input-control';\n\ndescribe('useInputControl', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useInputControl(''));\n\n    expect(typeof result.current.value).toBe('string');\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(false);\n    expect(typeof result.current.handleChange).toBe('function');\n    expect(typeof result.current.handleBlur).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n  });\n\n  describe('value', () => {\n    test('initial value', () => {\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      expect(result.current.value).toBe('initial value');\n    });\n\n    test('value can be different', () => {\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.value).toBe(value);\n    });\n  });\n\n  test('different', () => {\n    const value = 'new value';\n    const { result } = renderHook(() => useInputControl('initial value'));\n\n    act(() =>\n      result.current.handleChange({\n        target: { value },\n        currentTarget: { value },\n      } as any),\n    );\n\n    expect(result.current.different).toBe(true);\n  });\n\n  test('dirty', () => {\n    const value = 'new value';\n    const { result } = renderHook(() => useInputControl('initial value'));\n\n    act(() =>\n      result.current.handleChange({\n        target: { value },\n        currentTarget: { value },\n      } as any),\n    );\n\n    expect(result.current.dirty).toBe(true);\n  });\n\n  test('touched', () => {\n    const { result } = renderHook(() => useInputControl('initial value'));\n\n    expect(result.current.touched).toBe(false);\n\n    act(() => result.current.handleBlur());\n\n    expect(result.current.touched).toBe(true);\n  });\n\n  test('reset', () => {\n    const initialValue = 'initial value';\n    const newValue = 'new value';\n    const { result } = renderHook(() => useInputControl(initialValue));\n\n    act(() => {\n      result.current.handleChange({\n        target: { value: newValue },\n        currentTarget: { value: newValue },\n      } as any);\n      result.current.handleBlur();\n    });\n\n    expect(result.current.value).toBe(newValue);\n    expect(result.current.different).toBe(true);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(true);\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.different).toBe(false);\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n  });\n});\n",
    "/src/use-input-control.submit.test.tsx": "import React from 'react';\nimport { act, render, renderHook } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\n\nimport useInputControl from './use-input-control';\n\ndescribe('useInputControl', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useInputControl(''));\n\n    expect(typeof result.current.value).toBe('string');\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(false);\n    expect(typeof result.current.handleChange).toBe('function');\n    expect(typeof result.current.handleBlur).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n  });\n\n  describe('value', () => {\n    test('initial value', () => {\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      expect(result.current.value).toBe('initial value');\n    });\n\n    test('value can be changed', () => {\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.value).toBe(value);\n    });\n  });\n\n  describe('different', () => {\n    test('different value', () => {\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.different).toBe(true);\n    });\n\n    test('back to initial value', () => {\n      const initialValue = 'initial value';\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl(initialValue));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.different).toBe(true);\n\n      act(() =>\n        result.current.handleChange({\n          target: { value: initialValue },\n          currentTarget: { value: initialValue },\n        } as any),\n      );\n\n      expect(result.current.different).toBe(false);\n    });\n\n    test('does not rely on initial argument', () => {\n      const initialValue = 'initial value';\n      const newValue = 'new value';\n      const { result, rerender } = renderHook(\n        ({ initialValue }) => useInputControl(initialValue),\n        {\n          initialProps: { initialValue },\n        },\n      );\n\n      act(() =>\n        result.current.handleChange({\n          target: { value: newValue },\n          currentTarget: { value: newValue },\n        } as any),\n      );\n\n      expect(result.current.different).toBe(true);\n\n      rerender({ initialValue: newValue });\n\n      expect(result.current.different).toBe(true);\n    });\n  });\n\n  describe('dirty', () => {\n    test('different value', () => {\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.dirty).toBe(true);\n    });\n\n    test('back to initial value', () => {\n      const initialValue = 'initial value';\n      const value = 'new value';\n      const { result } = renderHook(() => useInputControl(initialValue));\n\n      act(() =>\n        result.current.handleChange({\n          target: { value },\n          currentTarget: { value },\n        } as any),\n      );\n\n      expect(result.current.dirty).toBe(true);\n\n      act(() =>\n        result.current.handleChange({\n          target: { value: initialValue },\n          currentTarget: { value: initialValue },\n        } as any),\n      );\n\n      expect(result.current.dirty).toBe(true);\n    });\n  });\n\n  describe('touched', () => {\n    test('initial', () => {\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      expect(result.current.touched).toBe(false);\n    });\n\n    test('handleBlur', () => {\n      const { result } = renderHook(() => useInputControl('initial value'));\n\n      expect(result.current.touched).toBe(false);\n\n      act(() => result.current.handleBlur());\n\n      expect(result.current.touched).toBe(true);\n    });\n  });\n\n  test('reset', () => {\n    const initialValue = 'initial value';\n    const newValue = 'new value';\n    const { result } = renderHook(() => useInputControl(initialValue));\n\n    act(() => {\n      result.current.handleChange({\n        target: { value: newValue },\n        currentTarget: { value: newValue },\n      } as any);\n      result.current.handleBlur();\n    });\n\n    expect(result.current.value).toBe(newValue);\n    expect(result.current.different).toBe(true);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(true);\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.different).toBe(false);\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n  });\n\n  test('integration', async () => {\n    const initialValue = 'initial value';\n    const { result } = renderHook(() => useInputControl(initialValue));\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(false);\n\n    const newValue = 'new value';\n\n    act(() => {\n      result.current.handleChange({\n        target: { value: newValue },\n        currentTarget: { value: newValue },\n      } as any);\n    });\n\n    expect(result.current.value).toBe(newValue);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(true);\n\n    act(() => {\n      result.current.handleBlur();\n    });\n\n    expect(result.current.value).toBe(newValue);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(true);\n    expect(result.current.different).toBe(true);\n\n    act(() => {\n      result.current.handleChange({\n        target: { value: initialValue },\n        currentTarget: { value: initialValue },\n      } as any);\n    });\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.dirty).toBe(true);\n    expect(result.current.touched).toBe(true);\n    expect(result.current.different).toBe(false);\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.value).toBe(initialValue);\n    expect(result.current.dirty).toBe(false);\n    expect(result.current.touched).toBe(false);\n    expect(result.current.different).toBe(false);\n  });\n});\n",
    "/src/use-input-control.ts": "import { ChangeEvent, useCallback, useRef, useState } from 'react';\n\ninterface UseInputValueReturn {\n  value: string;\n  dirty: boolean;\n  touched: boolean;\n  different: boolean;\n  handleChange: (event: ChangeEvent<HTMLInputElement>) => void;\n  handleBlur: () => void;\n  reset: () => void;\n}\n\nconst defaultDirty = false;\nconst defaultTouched = false;\n\nexport default function useInputControl(\n  initialValue: string,\n): UseInputValueReturn {\n  const initialValueRef = useRef<string>(initialValue);\n  const [value, setValue] = useState(initialValue);\n  const [dirty, setDirty] = useState(defaultDirty);\n  const [touched, setTouched] = useState(defaultTouched);\n\n  const handleChange: UseInputValueReturn['handleChange'] = useCallback(\n    (event) => {\n      setValue(event.currentTarget.value);\n      setDirty(true);\n    },\n    [],\n  );\n  const handleBlur: UseInputValueReturn['handleBlur'] = useCallback(() => {\n    setTouched(true);\n  }, []);\n  const reset = useCallback(() => {\n    setValue(initialValueRef.current);\n    setDirty(defaultDirty);\n    setTouched(defaultTouched);\n  }, []);\n\n  // Derived from whether the value is different from the initial value\n  const different = initialValueRef.current !== value;\n\n  return {\n    value,\n    dirty,\n    touched,\n    different,\n    handleChange,\n    handleBlur,\n    reset,\n  };\n}\n"
  },
  "metadata": {
    "access": "free",
    "author": "phillmont",
    "companies": [],
    "created": 1742169600,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a hook that manages a controlled input value and tracks its dirty & touched state",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/use-input-control",
    "importance": "medium",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "use-input-control",
    "subtitle": null,
    "title": "useInputControl",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {string} initialValue\n */\nexport default function useInputControl(initialValue) {\n  throw 'Not implemented';\n}",
    "ts": "import { ChangeEvent } from 'react';\n\ninterface UseInputValueReturn {\n  value: string;\n  onChange: (event: ChangeEvent<HTMLInputElement>) => void;\n}\n\nexport default function useInputControl(\n  initialValue: string,\n): UseInputValueReturn {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),C=(n,e)=>{for(var l in e)r(n,l,{get:e[l],enumerable:!0})},d=(n,e,l,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!m.call(n,i)&&i!==l&&r(n,i,{get:()=>e[i],enumerable:!(a=p(e,i))||a.enumerable});return n};var V=(n,e,l)=>(l=n!=null?f(g(n)):{},d(e||!n||!n.__esModule?r(l,\"default\",{value:n,enumerable:!0}):l,n)),R=n=>d(r({},\"__esModule\",{value:!0}),n);var c=b((x,h)=>{h.exports=_jsx_runtime});var T={};C(T,{default:()=>k});var t=V(c());var o=MDXCodeBlock;var u=`import { ChangeEvent, useCallback, useRef, useState } from 'react';\n\ninterface UseInputValueReturn {\n  value: string;\n  dirty: boolean;\n  touched: boolean;\n  different: boolean;\n  handleChange: (event: ChangeEvent<HTMLInputElement>) => void;\n  handleBlur: () => void;\n  reset: () => void;\n}\n\nconst defaultDirty = false;\nconst defaultTouched = false;\n\nexport default function useInputControl(\n  initialValue: string,\n): UseInputValueReturn {\n  const initialValueRef = useRef<string>(initialValue);\n  const [value, setValue] = useState(initialValue);\n  const [dirty, setDirty] = useState(defaultDirty);\n  const [touched, setTouched] = useState(defaultTouched);\n\n  const handleChange: UseInputValueReturn['handleChange'] = useCallback(\n    (event) => {\n      setValue(event.currentTarget.value);\n      setDirty(true);\n    },\n    [],\n  );\n  const handleBlur: UseInputValueReturn['handleBlur'] = useCallback(() => {\n    setTouched(true);\n  }, []);\n  const reset = useCallback(() => {\n    setValue(initialValueRef.current);\n    setDirty(defaultDirty);\n    setTouched(defaultTouched);\n  }, []);\n\n  // Derived from whether the value is different from the initial value\n  const different = initialValueRef.current !== value;\n\n  return {\n    value,\n    dirty,\n    touched,\n    different,\n    handleChange,\n    handleBlur,\n    reset,\n  };\n}\n`;function s(n){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h3:\"h3\",a:\"a\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"To recap what fields are returned:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"value\"}),\": The current input value\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"touched\"}),\": Whether the input has been focused then blurred\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"dirty\"}),\": Whether the value has been changed before\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"different\"}),\": Whether the value is different from the original\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Let's go through each field and how to implement them:\"}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"value\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"value\"}),\" is a boolean value tracked using React state. An \",(0,t.jsx)(e.code,{children:\"handleChange\"}),\" handler us used to to update the value state from the input's \",(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event\",children:[(0,t.jsx)(e.code,{children:\"change\"}),\" event\"]}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"touched\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"touched\"}),\" is a boolean value tracked using React state. It will be set to \",(0,t.jsx)(e.code,{children:\"true\"}),\" when the input is blurred. As the hook does not know when the \",(0,t.jsx)(e.code,{children:\"<input>\"}),\" element is blurred, we return a \",(0,t.jsx)(e.code,{children:\"handleBlur\"}),\" function that sets the value to \",(0,t.jsx)(e.code,{children:\"true\"}),\" and the user will call the \",(0,t.jsx)(e.code,{children:\"handleBlur\"}),\" function in an \",(0,t.jsx)(e.code,{children:\"onBlur\"}),\" event handler.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"dirty\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"touched\"}),\" is a boolean value tracked using React state. Since it is set to \",(0,t.jsx)(e.code,{children:\"true\"}),\" when it has been changed before, \",(0,t.jsx)(e.code,{children:\"handleChange\"}),\" is a good place to do that.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"different\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"This field does not require a state as it is derived state that can be computed by comparing the initial value and the current \",(0,t.jsx)(e.code,{children:\"value\"}),\". However, the comparison should not be done against the \",(0,t.jsx)(e.code,{children:\"initialValue\"}),\" argument as the value might be different during re-renders!\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Instead, we track the first render's \",(0,t.jsx)(e.code,{children:\"initialValue\"}),\" using \",(0,t.jsx)(e.code,{children:\"useRef\"}),\". Why not state? Because \",(0,t.jsx)(e.code,{children:\"initialValueRef\"}),\" does not ever change after the hook is mounted.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const different = initialValueRef.current !== value;\n`})}),`\n`,(0,t.jsxs)(e.h3,{children:[(0,t.jsx)(e.code,{children:\"reset\"}),\" function\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This function resets all the states within the hook. Simply call the various state setters with their initial values. The initial value to set to can be obtained from \",(0,t.jsx)(e.code,{children:\"initialValueRef\"}),\".\"]}),`\n`,(0,t.jsx)(o,{children:u})]})}function y(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(s,n)})):s(n)}var k=y;return R(T);})();\n;return Component;",
  "workspace": {
    "main": "/src/use-input-control.ts",
    "run": "/src/use-input-control.run.test.tsx",
    "submit": "/src/use-input-control.submit.test.tsx"
  }
}