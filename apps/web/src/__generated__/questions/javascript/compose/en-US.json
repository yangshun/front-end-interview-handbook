{
  "description": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var l=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var x=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),g=(e,n)=>{for(var o in n)c(e,o,{get:n[o],enumerable:!0})},i=(e,n,o,a)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let s of d(n))!f.call(e,s)&&s!==o&&c(e,s,{get:()=>n[s],enumerable:!(a=h(n,s))||a.enumerable});return e};var b=(e,n,o)=>(o=e!=null?p(l(e)):{},i(n||!e||!e.__esModule?c(o,\"default\",{value:e,enumerable:!0}):o,e)),j=e=>i(c({},\"__esModule\",{value:!0}),e);var u=x((I,r)=>{r.exports=_jsx_runtime});var y={};g(y,{default:()=>v,frontmatter:()=>_});var t=b(u()),_={title:\"Compose\",excerpt:\"Implement a function that takes multiple functions as arguments and returns a new function that applies those functions in reverse\"};function m(e){let n=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[\"Implement a function \",(0,t.jsx)(n.code,{children:\"compose\"}),\" that takes multiple functions as arguments and returns a new function that applies those functions in reverse order. The output of one function becomes the input of the next function, creating a chain of function compositions.\"]}),`\n`,(0,t.jsxs)(n.p,{children:[\"If there are no functions passed to the \",(0,t.jsx)(n.code,{children:\"compose\"}),\" function, the default behavior is to return a new function that simply returns the input it receives. In other words, the default behavior of \",(0,t.jsx)(n.code,{children:\"compose\"}),\" without any functions results in a simple identity function.\"]}),`\n`,(0,t.jsx)(n.p,{children:\"You may assume that all the functions accept a single parameter.\"}),`\n`,(0,t.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:\"language-js\",children:`const add1 = (num) => num + 1;\nconst double = (num) => num * 2;\nconst subtract10 = (num) => num - 10;\n\nconst composedFn = compose(subtract10, double, add1);\ncomposedFn(3); // (3 + 1) * 2 - 10 => -2\n`})})]})}function w(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(m,e)})):m(e)}var v=w;return j(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/compose\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/compose.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/compose.run.test.ts": "import compose from './compose';\n\nconst identity = <T>(x: T): T => x;\nconst double = (x: number) => x * 2;\nconst square = (x: number) => x * x;\n\ndescribe('compose', () => {\n  test('returns a function', () => {\n    const composed = compose(identity);\n    expect(typeof composed).toBe('function');\n  });\n\n  test('identity', () => {\n    const composed = compose(identity);\n    expect(composed(42)).toBe(42);\n  });\n\n  test('square then double', () => {\n    const composed = compose(square, double);\n    expect(composed(4)).toBe(64);\n  });\n});\n",
    "/src/compose.submit.test.ts": "import compose from './compose';\n\nconst identity = <T>(x: T): T => x;\nconst double = (x: number) => x * 2;\nconst square = (x: number) => x * x;\n\ndescribe('compose', () => {\n  test('returns a function', () => {\n    const composed = compose(identity);\n    expect(typeof composed).toBe('function');\n  });\n\n  test('no functions', () => {\n    const composed = compose();\n    expect(composed(42)).toBe(42);\n  });\n\n  describe('only one function', () => {\n    test('identity', () => {\n      const composed = compose(identity);\n      expect(composed(42)).toBe(42);\n    });\n\n    test('double', () => {\n      const composed = compose(double);\n      expect(composed(42)).toBe(84);\n    });\n  });\n\n  describe('two functions', () => {\n    test('identity', () => {\n      const composed = compose(identity, identity);\n      expect(composed(42)).toBe(42);\n    });\n\n    test('mixture', () => {\n      const composed = compose(square, double);\n      expect(composed(4)).toBe(64);\n    });\n  });\n\n  describe('multiple functions', () => {\n    test('identity', () => {\n      const composed = compose(identity, identity, identity);\n      expect(composed(42)).toBe(42);\n    });\n\n    test('mixture', () => {\n      const composed = compose(square, identity, square, double, identity);\n      expect(composed(3)).toBe(1296);\n    });\n  });\n});\n",
    "/src/compose.ts": "export default function compose(...fns: Array<Function>): Function {\n  return function (x: any): Function {\n    return fns.reduceRight((result, func) => func(result), x);\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1689552000,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement a function that takes multiple functions as arguments and returns a new function that applies those functions in reverse",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/compose",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "middlewares"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "compose",
    "subtitle": null,
    "title": "Compose",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {...Function} args\n * @returns Function\n */\nexport default function compose(...fns) {\n  throw 'Not implemented';\n}",
    "ts": "export default function compose(...fns: Array<Function>): Function {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var g=Object.create;var i=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var F=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var j=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),R=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},u=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of y(e))!v.call(t,o)&&o!==r&&i(t,o,{get:()=>e[o],enumerable:!(s=x(e,o))||s.enumerable});return t};var b=(t,e,r)=>(r=t!=null?g(F(t)):{},u(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),k=t=>u(i({},\"__esModule\",{value:!0}),t);var a=j((X,l)=>{l.exports=_jsx_runtime});var C={};R(C,{default:()=>A});var n=b(a());var c=MDXCodeBlock;var h=`/**\n * @param {...Function} args\n * @returns Function\n */\nexport default function compose(...fns) {\n  return function (x) {\n    return fns.reduceRight((result, func) => func(result), x);\n  };\n}\n`;var f=`export default function compose(...fns: Array<Function>): Function {\n  return function (x: any): Function {\n    return fns.reduceRight((result, func) => func(result), x);\n  };\n}\n`;var d=`/**\n * @param {...Function} args\n * @returns Function\n */\nexport default function compose(...fns) {\n  return function (x) {\n    let result = x;\n\n    for (let i = fns.length - 1; i >= 0; i--) {\n      result = fns[i](result);\n    }\n\n    return result;\n  };\n}\n`;var p=`/**\n * @param {...Function} args\n * @returns Function\n */\nexport default function compose(...fns) {\n  return function (x) {\n    function apply(fn, ...rest) {\n      if (rest.length === 0) {\n        return fn(x);\n      }\n\n      return fn(apply(...rest));\n    }\n\n    return apply(...fns);\n  };\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",h3:\"h3\",code:\"code\",ol:\"ol\",li:\"li\",p:\"p\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Approach 1: Using \",(0,n.jsx)(e.code,{children:\"reduceRight\"})]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"compose\"}),\" function takes multiple functions as arguments using the rest parameter syntax \",(0,n.jsx)(e.code,{children:\"...fns\"}),\". This allows us to pass any number of functions.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"It returns a new function that takes a single argument \",(0,n.jsx)(e.code,{children:\"x\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Inside the returned function, the \",(0,n.jsx)(e.code,{children:\"reduceRight\"}),\" method is used to apply the functions in reverse order.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"reduceRight\"}),\" method starts from the last function in the \",(0,n.jsx)(e.code,{children:\"fns\"}),\" array and iterates over the array from right to left.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"In each iteration, it applies the current function (\",(0,n.jsx)(e.code,{children:\"func\"}),\") to the intermediate result obtained from the previous iteration or the original \",(0,n.jsx)(e.code,{children:\"input\"}),\" in the first iteration.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"The result of each function becomes the input for the next function in the chain, effectively composing the functions in reverse order.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The final result of the composed function is returned.\"}),`\n`]}),`\n`,(0,n.jsx)(c,{languages:{jsx:h,tsx:f}}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Approach 2: Using \",(0,n.jsx)(e.code,{children:\"for\"}),\" loops\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you're not familiar with \",(0,n.jsx)(e.code,{children:\"reduceRight\"}),\", it can also be written as a \",(0,n.jsx)(e.code,{children:\"for\"}),\" loop that traverses the array from the back.\"]}),`\n`,(0,n.jsx)(c,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Approach 3: Recursion\"}),`\n`,(0,n.jsx)(e.p,{children:\"If iteration is not your thing, here's a recursive solution. Note that it's less memory efficient due to the recursion stack using up memory space (potentially even causing a stack overflow).\"}),`\n`,(0,n.jsx)(c,{children:p})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var A=M;return k(C);})();\n;return Component;",
  "workspace": {
    "main": "/src/compose.ts",
    "run": "/src/compose.run.test.ts",
    "submit": "/src/compose.submit.test.ts"
  }
}