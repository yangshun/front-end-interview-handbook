{
  "description": "var Component=(()=>{var h=Object.create;var d=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),x=(r,e)=>{for(var t in e)d(r,t,{get:e[t],enumerable:!0})},o=(r,e,t,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of m(e))!p.call(r,c)&&c!==t&&d(r,c,{get:()=>e[c],enumerable:!(i=u(e,c))||i.enumerable});return r};var b=(r,e,t)=>(t=r!=null?h(g(r)):{},o(e||!r||!r.__esModule?d(t,\"default\",{value:r,enumerable:!0}):t,r)),j=r=>o(d({},\"__esModule\",{value:!0}),r);var l=f((T,a)=>{a.exports=_jsx_runtime});var v={};x(v,{default:()=>N,frontmatter:()=>_});var n=b(l()),_={title:\"Range\",excerpt:\"Implement a function that returns a sequence of numbers in ascending order\"};function s(r){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",pre:\"pre\",ul:\"ul\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"range([start=0], end, [step=1])\"}),\" that creates an array of numbers (positive and/or negative) progressing from \",(0,n.jsx)(e.code,{children:\"start\"}),\" up to, but not including, \",(0,n.jsx)(e.code,{children:\"end\"}),\". A step of \",(0,n.jsx)(e.code,{children:\"-1\"}),\" is used if a negative \",(0,n.jsx)(e.code,{children:\"start\"}),\" is specified without an \",(0,n.jsx)(e.code,{children:\"end\"}),\" or \",(0,n.jsx)(e.code,{children:\"step\"}),\". If \",(0,n.jsx)(e.code,{children:\"end\"}),\" is not specified, it's set to \",(0,n.jsx)(e.code,{children:\"start\"}),\" with \",(0,n.jsx)(e.code,{children:\"start\"}),\" then set to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"start\"}),\" \",(0,n.jsx)(e.em,{children:\"(Number)\"}),\": The start of the range.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"end\"}),\" \",(0,n.jsx)(e.em,{children:\"(Number)\"}),\": The end of the range.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"step\"}),\" \",(0,n.jsx)(e.em,{children:\"(Number)\"}),\": The value to increment or decrement by.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:(0,n.jsx)(e.code,{children:\"(Array)\"})}),\": Returns the range of numbers.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`range(4); // => [0, 1, 2, 3]\n\nrange(-4); // => [0, -1, -2, -3]\n\nrange(1, 5); // => [1, 2, 3, 4]\n\nrange(0, 20, 5); // => [0, 5, 10, 15]\n\nrange(0, -4, -1); // => [0, -1, -2, -3]\n\nrange(1, 4, 0); // => [1, 1, 1]\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The function should return an empty array if \",(0,n.jsx)(e.code,{children:\"start\"}),\" is equal to \",(0,n.jsx)(e.code,{children:\"end\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`range(0); // => []\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#range\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.range\"})]})}),`\n`]})]})}function y(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(s,r)})):s(r)}var N=y;return j(v);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/range\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/range.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/range.run.test.ts": "import range from './range';\n\ndescribe('range', () => {\n  test('start equals to end', () => {\n    expect(range(0)).toEqual([]);\n  });\n\n  test('start specified', () => {\n    expect(range(2, 5)).toEqual([2, 3, 4]);\n  });\n\n  test('start and step specified', () => {\n    expect(range(1, 7, 2)).toEqual([1, 3, 5]);\n  });\n});\n",
    "/src/range.submit.test.ts": "import range from './range';\n\ndescribe('range', () => {\n  test('start equals to end', () => {\n    expect(range(0)).toEqual([]);\n    expect(range(-3, -3)).toEqual([]);\n    expect(range(5, 5)).toEqual([]);\n  });\n\n  test('start specified', () => {\n    expect(range(2, 5)).toEqual([2, 3, 4]);\n    expect(range(-2, 1)).toEqual([-2, -1, 0]);\n    expect(range(-8, -4)).toEqual([-8, -7, -6, -5]);\n  });\n\n  test('start and step specified', () => {\n    expect(range(1, 7, 2)).toEqual([1, 3, 5]);\n    expect(range(-3, 6, 3)).toEqual([-3, 0, 3]);\n    expect(range(1, 8, 9)).toEqual([1]);\n  });\n\n  test('negative end value', () => {\n    expect(range(-4)).toEqual([0, -1, -2, -3]);\n    expect(range(-9, -4, 1)).toEqual([-9, -8, -7, -6, -5]);\n    expect(range(8, -2, -3)).toEqual([8, 5, 2, -1]);\n  });\n\n  test('negative step value', () => {\n    expect(range(8, -2, -3)).toEqual([8, 5, 2, -1]);\n    expect(range(7, 4, -1)).toEqual([7, 6, 5]);\n  });\n\n  test('step value = 0', () => {\n    expect(range(1, 5, 0)).toEqual([1, 1, 1, 1]);\n    expect(range(-4, -2, 0)).toEqual([-4, -4]);\n    expect(range(-2, -4, 0)).toEqual([]);\n  });\n});\n",
    "/src/range.ts": "// Overloaded function declarations\nexport default function range(end: number): Array<number>;\nexport default function range(\n  start: number,\n  end: number,\n  step?: number,\n): Array<number>;\n\nexport default function range(\n  start: number = 0,\n  end?: number,\n  step: number = 1,\n): Array<number> {\n  let result: Array<number> = [];\n\n  // Adjust parameters if only `end` is provided\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n\n  // Adjust `step` for descending sequences\n  if (end < start && step === 1) {\n    step = -1;\n  }\n\n  // Determine the number of elements in `result`\n  const length = (end - start) / (step || 1);\n\n  // Generate the range\n  for (let i = 0; i < length; i++) {\n    result.push(start + i * step);\n  }\n\n  return result;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1710633600,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement a function that returns a sequence of numbers in ascending order",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/range",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "range-right"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "in-range",
      "range-right"
    ],
    "slug": "range",
    "subtitle": null,
    "title": "Range",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Number} start - The first number of the resultant array.\n * @param {Number} end - The value where the resultant array will stop at and not contain it.\n * @param {Number} step - The step / increment value of each number in the array.\n * @return {Array<Number>} Returns the array with the sequence of numbers in the specified range.\n */\nexport default function range(start = 0, end, step = 1) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function range(end: number): Array<number>;\nexport default function range(\n  start: number,\n  end: number,\n  step?: number,\n): Array<number>;\n\nexport default function range(\n  start: number = 0,\n  end?: number,\n  step: number = 1,\n): Array<number> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var j=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},i=(t,e,r,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of g(e))!x.call(t,s)&&s!==r&&a(t,s,{get:()=>e[s],enumerable:!(d=f(e,s))||d.enumerable});return t};var A=(t,e,r)=>(r=t!=null?p(b(t)):{},i(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>i(a({},\"__esModule\",{value:!0}),t);var c=j((C,o)=>{o.exports=_jsx_runtime});var q={};y(q,{default:()=>M});var n=A(c());var u=MDXCodeBlock;var l=`/**\n * @param {number} start - The start of the range.\n * @param {number} end - The end of the range.\n * @param {number} step - The value to increment or decrement by.\n * @returns {Array<number>} An array of numbers in the specified range.\n */\nexport default function range(start, end = undefined, step = 1) {\n  let result = [];\n\n  // Adjust parameters if only \\`end\\` is provided\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n\n  // Adjust \\`step\\` for descending sequences\n  if (end < start && step === 1) {\n    step = -1;\n  }\n\n  // Determine the number of elements in \\`result\\`\n  const length = (end - start) / (step || 1);\n\n  // Generate the range\n  for (let i = 0; i < length; i++) {\n    result.push(start + i * step);\n  }\n\n  return result;\n}\n`;var h=`// Overloaded function declarations\nexport default function range(end: number): Array<number>;\nexport default function range(\n  start: number,\n  end: number,\n  step?: number,\n): Array<number>;\n\nexport default function range(\n  start: number = 0,\n  end?: number,\n  step: number = 1,\n): Array<number> {\n  let result: Array<number> = [];\n\n  // Adjust parameters if only \\`end\\` is provided\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  }\n\n  // Adjust \\`step\\` for descending sequences\n  if (end < start && step === 1) {\n    step = -1;\n  }\n\n  // Determine the number of elements in \\`result\\`\n  const length = (end - start) / (step || 1);\n\n  // Generate the range\n  for (let i = 0; i < length; i++) {\n    result.push(start + i * step);\n  }\n\n  return result;\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here is a solution that generates the range of sequence from \",(0,n.jsx)(e.code,{children:\"start\"}),\" to (but not including) \",(0,n.jsx)(e.code,{children:\"end\"}),\" with \",(0,n.jsx)(e.code,{children:\"step\"}),\" as increment using only basic functions. Overloaded functions are required in TypeScript as \",(0,n.jsx)(e.code,{children:\"start\"}),\" and \",(0,n.jsx)(e.code,{children:\"step\"}),\" are optional.\"]}),`\n`,(0,n.jsx)(u,{languages:{jsx:l,tsx:h}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To handle cases where \",(0,n.jsx)(e.code,{children:\"start\"}),\" and \",(0,n.jsx)(e.code,{children:\"step\"}),\" are not specified but \",(0,n.jsx)(e.code,{children:\"end\"}),\" is negative, we can add an if statement to change the value of \",(0,n.jsx)(e.code,{children:\"step\"}),\" to -1.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#range\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.range\"})]})}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var M=T;return _(q);})();\n;return Component;",
  "workspace": {
    "main": "/src/range.ts",
    "run": "/src/range.run.test.ts",
    "submit": "/src/range.submit.test.ts"
  }
}