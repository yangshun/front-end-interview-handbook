{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-with-resolvers\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-with-resolvers.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promise-with-resolvers.run.test.ts": "import promiseWithResolvers from './promise-with-resolvers';\n\n// TODO: fix tests passing even if resolved value is incorrect.\ndescribe('promiseWithResolvers', () => {\n  test('returns require fields', () => {\n    const { promise, reject, resolve } = promiseWithResolvers();\n\n    expect(promise).toBeInstanceOf(Promise);\n    expect(resolve).toBeInstanceOf(Function);\n    expect(reject).toBeInstanceOf(Function);\n  });\n\n  test('resolves', () => {\n    const { promise, resolve } = promiseWithResolvers();\n    resolve(42);\n\n    return expect(promise).resolves.toBe(42);\n  });\n\n  test('rejects', () => {\n    const { promise, reject } = promiseWithResolvers();\n    reject(42);\n\n    return expect(promise).rejects.toBe(42);\n  });\n});\n",
    "/src/promise-with-resolvers.submit.test.ts": "import promiseWithResolvers from './promise-with-resolvers';\n\ndescribe('promiseWithResolvers', () => {\n  test('returns require fields', () => {\n    const { promise, reject, resolve } = promiseWithResolvers();\n\n    expect(promise).toBeInstanceOf(Promise);\n    expect(resolve).toBeInstanceOf(Function);\n    expect(reject).toBeInstanceOf(Function);\n  });\n\n  describe('promise', () => {\n    test('resolves', () => {\n      const { promise, resolve } = promiseWithResolvers();\n      resolve(42);\n\n      return expect(promise).resolves.toBe(42);\n    });\n\n    test('rejects', () => {\n      const { promise, reject } = promiseWithResolvers();\n      reject(42);\n\n      return expect(promise).rejects.toBe(42);\n    });\n\n    test('then', (done) => {\n      expect.assertions(1);\n      const { promise, resolve } = promiseWithResolvers();\n      resolve(42);\n\n      promise.then((result) => {\n        expect(result).toBe(42);\n        done();\n      });\n    });\n  });\n\n  describe('usage with promise methods', () => {\n    test('Promise.all()', () => {\n      const { promise: p0, resolve } = promiseWithResolvers();\n      const p1 = new Promise((resolve) => {\n        setTimeout(() => {\n          resolve('foo');\n        }, 100);\n      });\n      resolve(3);\n\n      return expect(Promise.all([p0, p1])).resolves.toStrictEqual([3, 'foo']);\n    });\n\n    test('Promise.allSettled()', async () => {\n      const { promise: p0, resolve: resolve0 } = promiseWithResolvers();\n      const { promise: p1, resolve: resolve1 } = promiseWithResolvers();\n\n      resolve0(2);\n      resolve1(3);\n\n      const res = await Promise.allSettled([p0, p1]);\n\n      expect(res).toEqual([\n        {\n          status: 'fulfilled',\n          value: 2,\n        },\n        {\n          status: 'fulfilled',\n          value: 3,\n        },\n      ]);\n    });\n\n    test('Promise.any()', async () => {\n      const { promise: p0, resolve: resolve0 } = promiseWithResolvers();\n      const { promise: p1, reject: reject1 } = promiseWithResolvers();\n\n      resolve0(2);\n      reject1(3);\n\n      const res = await Promise.any([p0, p1]);\n      expect(res).toEqual(2);\n    });\n\n    test('Promise.race()', async () => {\n      const { promise: p0, resolve: resolve0 } = promiseWithResolvers();\n      const { promise: p1, reject: resolve1 } = promiseWithResolvers();\n\n      resolve0(2);\n      resolve1(3);\n\n      const res = await Promise.race([p0, p1]);\n      expect(res).toEqual(2);\n    });\n  });\n});\n",
    "/src/promise-with-resolvers.ts": "export default function promiseWithResolvers<T>(): Readonly<{\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}> {\n  let resolve: (value: T) => void = () => {};\n  let reject: (reason?: any) => void = () => {};\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @returns { promise: Promise, resolve: Function, reject: Function }\n */\nexport default function promiseWithResolvers() {\n  throw 'Not implemented';\n}",
    "ts": "export default function promiseWithResolvers<T>(): Readonly<{\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}> {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/promise-with-resolvers.ts",
    "run": "/src/promise-with-resolvers.run.test.ts",
    "submit": "/src/promise-with-resolvers.submit.test.ts"
  }
}