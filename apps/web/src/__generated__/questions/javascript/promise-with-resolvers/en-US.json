{
  "description": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var o in e)s(n,o,{get:e[o],enumerable:!0})},c=(n,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of u(e))!g.call(n,t)&&t!==o&&s(n,t,{get:()=>e[t],enumerable:!(i=h(e,t))||i.enumerable});return n};var j=(n,e,o)=>(o=n!=null?d(p(n)):{},c(e||!n||!n.__esModule?s(o,\"default\",{value:n,enumerable:!0}):o,n)),w=n=>c(s({},\"__esModule\",{value:!0}),n);var a=v((S,l)=>{l.exports=_jsx_runtime});var x={};f(x,{default:()=>P,frontmatter:()=>R});var r=j(a()),R={title:\"Promise.withResolvers\",excerpt:\"Implement a function that returns an object containing a new `Promise` object and two functions to resolve or reject it\"};function m(n){let e=Object.assign({p:\"p\",code:\"code\",em:\"em\",a:\"a\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"The \",(0,r.jsx)(e.code,{children:\"Promise.withResolvers()\"}),\" static method returns an object containing a new \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" object and two functions to resolve or reject it, corresponding to the two parameters passed to the executor of the \",(0,r.jsx)(e.code,{children:\"Promise()\"}),\" constructor.\"]}),`\n`,(0,r.jsx)(e.p,{children:(0,r.jsxs)(e.em,{children:[\"Source: \",(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\",children:\"Promise.withResolvers() - JavaScript | MDN\"})]})}),`\n`,(0,r.jsxs)(e.p,{children:[\"Such usage can improve code readability and make it easier to manage asynchronous operations, especially when you need to resolve or reject the \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" from different parts of your code.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"Here's an example of how it can be used:\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`function delayedGreeting(name) {\n  const { promise, resolve, reject } = Promise.withResolvers();\n\n  setTimeout(() => {\n    if (name) {\n      resolve(\\`Hello, \\${name}!\\`);\n    } else {\n      reject(new Error('Name is required.'));\n    }\n  }, 1000);\n\n  return promise;\n}\n\ndelayedGreeting('Alice')\n  .then((message) => console.log(message)) // Output: Hello, Alice!\n  .catch((error) => console.error(error));\n\ndelayedGreeting()\n  .then((message) => console.log(message))\n  .catch((error) => console.error(error)); // Output: Error: Name is required.\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Requirement\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Implement the \",(0,r.jsx)(e.code,{children:\"Promise.withResolvers\"}),\" function as \",(0,r.jsx)(e.code,{children:\"promiseWithResolvers\"}),\", a standalone utility function.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,r.jsx)(e.p,{children:\"Success case:\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`const { promise, resolve, reject } = promiseWithResolvers();\n\n// Later in your code\nresolve('Success!');\npromise.then((result) => console.log(result)); // Output: Success!\n`})}),`\n`,(0,r.jsx)(e.p,{children:\"Implementing a timeout:\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`function timeoutPromise(duration) {\n  const { promise, resolve, reject } = promiseWithResolvers();\n\n  setTimeout(() => reject(new Error('Timeout')), duration);\n\n  return promise;\n}\n\ntimeoutPromise(2000).catch((error) => console.error(error.message)); // Output after 2 seconds: Timeout\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\",children:\"Promise.withResolvers() - JavaScript | MDN\"})}),`\n`]})]})}function b(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(m,n)})):m(n)}var P=b;return w(x);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-with-resolvers\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-with-resolvers.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/promise-with-resolvers.run.test.ts": "import promiseWithResolvers from './promise-with-resolvers';\n\n// TODO: fix tests passing even if resolved value is incorrect.\ndescribe('promiseWithResolvers', () => {\n  test('returns require fields', () => {\n    const { promise, reject, resolve } = promiseWithResolvers();\n\n    expect(promise).toBeInstanceOf(Promise);\n    expect(resolve).toBeInstanceOf(Function);\n    expect(reject).toBeInstanceOf(Function);\n  });\n\n  test('resolves', () => {\n    const { promise, resolve } = promiseWithResolvers();\n    resolve(42);\n\n    return expect(promise).resolves.toBe(42);\n  });\n\n  test('rejects', () => {\n    const { promise, reject } = promiseWithResolvers();\n    reject(42);\n\n    return expect(promise).rejects.toBe(42);\n  });\n});\n",
    "/src/promise-with-resolvers.submit.test.ts": "import promiseWithResolvers from './promise-with-resolvers';\n\ndescribe('promiseWithResolvers', () => {\n  test('returns require fields', () => {\n    const { promise, reject, resolve } = promiseWithResolvers();\n\n    expect(promise).toBeInstanceOf(Promise);\n    expect(resolve).toBeInstanceOf(Function);\n    expect(reject).toBeInstanceOf(Function);\n  });\n\n  describe('promise', () => {\n    test('resolves', () => {\n      const { promise, resolve } = promiseWithResolvers();\n      resolve(42);\n\n      return expect(promise).resolves.toBe(42);\n    });\n\n    test('rejects', () => {\n      const { promise, reject } = promiseWithResolvers();\n      reject(42);\n\n      return expect(promise).rejects.toBe(42);\n    });\n\n    test('then', (done) => {\n      expect.assertions(1);\n      const { promise, resolve } = promiseWithResolvers();\n      resolve(42);\n\n      promise.then((result) => {\n        expect(result).toBe(42);\n        done();\n      });\n    });\n  });\n\n  describe('usage with promise methods', () => {\n    test('Promise.all()', () => {\n      const { promise: p0, resolve } = promiseWithResolvers();\n      const p1 = new Promise((resolve) => {\n        setTimeout(() => {\n          resolve('foo');\n        }, 100);\n      });\n      resolve(3);\n\n      return expect(Promise.all([p0, p1])).resolves.toStrictEqual([3, 'foo']);\n    });\n\n    test('Promise.allSettled()', async () => {\n      const { promise: p0, resolve: resolve0 } = promiseWithResolvers();\n      const { promise: p1, resolve: resolve1 } = promiseWithResolvers();\n\n      resolve0(2);\n      resolve1(3);\n\n      const res = await Promise.allSettled([p0, p1]);\n\n      expect(res).toEqual([\n        {\n          status: 'fulfilled',\n          value: 2,\n        },\n        {\n          status: 'fulfilled',\n          value: 3,\n        },\n      ]);\n    });\n\n    test('Promise.any()', async () => {\n      const { promise: p0, resolve: resolve0 } = promiseWithResolvers();\n      const { promise: p1, reject: reject1 } = promiseWithResolvers();\n\n      resolve0(2);\n      reject1(3);\n\n      const res = await Promise.any([p0, p1]);\n      expect(res).toEqual(2);\n    });\n\n    test('Promise.race()', async () => {\n      const { promise: p0, resolve: resolve0 } = promiseWithResolvers();\n      const { promise: p1, reject: resolve1 } = promiseWithResolvers();\n\n      resolve0(2);\n      resolve1(3);\n\n      const res = await Promise.race([p0, p1]);\n      expect(res).toEqual(2);\n    });\n  });\n});\n",
    "/src/promise-with-resolvers.ts": "export default function promiseWithResolvers<T>(): Readonly<{\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}> {\n  let resolve: (value: T) => void = () => {};\n  let reject: (reason?: any) => void = () => {};\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [],
    "created": 1723766400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that returns an object containing a new `Promise` object and two functions to resolve or reject it",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promise-with-resolvers",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "promise-resolve",
      "promise-reject"
    ],
    "slug": "promise-with-resolvers",
    "subtitle": null,
    "title": "Promise.withResolvers",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @returns { promise: Promise, resolve: Function, reject: Function }\n */\nexport default function promiseWithResolvers() {\n  throw 'Not implemented';\n}",
    "ts": "export default function promiseWithResolvers<T>(): Readonly<{\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var s=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var j=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),w=(o,e)=>{for(var t in e)s(o,t,{get:e[t],enumerable:!0})},i=(o,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of j(e))!g.call(o,n)&&n!==t&&s(o,n,{get:()=>e[n],enumerable:!(c=v(e,n))||c.enumerable});return o};var P=(o,e,t)=>(t=o!=null?p(f(o)):{},i(e||!o||!o.__esModule?s(t,\"default\",{value:o,enumerable:!0}):t,o)),R=o=>i(s({},\"__esModule\",{value:!0}),o);var a=x((S,l)=>{l.exports=_jsx_runtime});var M={};w(M,{default:()=>T});var r=P(a());var d=MDXCodeBlock;var h=`/**\n * @returns { promise: Promise, resolve: Function, reject: Function }\n */\nexport default function promiseWithResolvers() {\n  let resolve, reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n`;var m=`export default function promiseWithResolvers<T>(): Readonly<{\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n}> {\n  let resolve: (value: T) => void = () => {};\n  let reject: (reason?: any) => void = () => {};\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise, resolve, reject };\n}\n`;function u(o){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",a:\"a\",pre:\"pre\",ul:\"ul\",li:\"li\"},o.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"For the most part, \",(0,r.jsx)(e.code,{children:\"Promise.withResolvers()\"}),\" is syntactic sugar. The only way to get access to the \",(0,r.jsx)(e.code,{children:\"resolve\"}),\" and \",(0,r.jsx)(e.code,{children:\"reject\"}),\" function is the arguments to the \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" constructor. Hence we can create the \",(0,r.jsx)(e.code,{children:\"resolve\"}),\" and \",(0,r.jsx)(e.code,{children:\"reject\"}),\" functions before creating the \",(0,r.jsx)(e.code,{children:\"Promise\"}),\", then exposing it from within the constructor function.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"The \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" constructor function argument runs synchronously, so we can be sure that the \",(0,r.jsx)(e.code,{children:\"resolve\"}),\" and \",(0,r.jsx)(e.code,{children:\"reject\"}),\" variables are assigned the right values before the \",(0,r.jsx)(e.code,{children:\"return\"}),\" statement.\"]}),`\n`,(0,r.jsx)(d,{languages:{jsx:h,tsx:m}}),`\n`,(0,r.jsxs)(e.p,{children:[\"In fact, MDN even mentions that \",(0,r.jsx)(e.code,{children:\"Promise.withResolvers()\"}),\" is \",(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers#description\",children:\"exactly equivalent to the following code\"}),\":\"]}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`let resolve, reject;\nconst promise = new Promise((res, rej) => {\n  resolve = res;\n  reject = rej;\n});\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\",children:\"Promise.withResolvers() - JavaScript | MDN\"})}),`\n`]})]})}function _(o={}){let{wrapper:e}=o.components||{};return e?(0,r.jsx)(e,Object.assign({},o,{children:(0,r.jsx)(u,o)})):u(o)}var T=_;return R(M);})();\n;return Component;",
  "workspace": {
    "main": "/src/promise-with-resolvers.ts",
    "run": "/src/promise-with-resolvers.run.test.ts",
    "submit": "/src/promise-with-resolvers.submit.test.ts"
  }
}