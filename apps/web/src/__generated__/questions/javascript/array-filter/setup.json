{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/array-filter\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/array-filter.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/array-filter.run.test.ts": "import './array-filter';\n\nconst isEven = (element: any, index: number) => element % 2 === 0;\nconst isOdd = (element: any, index: number) => element % 2 === 1;\n\ndescribe('Array.prototype.myFilter', () => {\n  test('even numbers', () => {\n    expect([1, 10, 4].myFilter(isEven)).toStrictEqual([10, 4]);\n  });\n\n  test('odd numbers', () => {\n    expect([1, 10, 3].myFilter(isOdd)).toStrictEqual([1, 3]);\n  });\n});\n",
    "/src/array-filter.submit.test.ts": "import './array-filter';\n\nconst isEven = (element: any, index: number) => element % 2 === 0;\nconst isOdd = (element: any, index: number) => element % 2 === 1;\nconst isEvenIndex = (_: any, index: number) => index % 2 === 0;\nconst isOddIndex = (_: any, index: number) => index % 2 === 1;\nconst isSquareEven = (_: any, index: number, array: Array<any>) =>\n  (array[index] * array[index]) % 2 === 0;\nconst isSquareOdd = (_: any, index: number, array: Array<any>) =>\n  (array[index] * array[index]) % 2 === 1;\nconst isThisProductEven = function (this: any, element: number) {\n  return (element * this) % 2 === 0;\n};\nconst isThisProductEvenArrowFn = (element: number) =>\n  (element * this!) % 2 === 0;\n\ndescribe('Array.prototype.myFilter', () => {\n  test('empty array', () => {\n    expect([].myFilter(isEven)).toStrictEqual([]);\n    expect([].myFilter(isOdd)).toStrictEqual([]);\n  });\n\n  test('one value', () => {\n    expect([1].myFilter(isEven)).toStrictEqual([]);\n    expect([1].myFilter(isOdd)).toStrictEqual([1]);\n  });\n\n  test('two values', () => {\n    expect([1, 10].myFilter(isEven)).toStrictEqual([10]);\n    expect([1, 10].myFilter(isOdd)).toStrictEqual([1]);\n  });\n\n  test('multiple values', () => {\n    expect([1, 2, 3, 5, 7, 8, 9].myFilter(isEven)).toStrictEqual([2, 8]);\n    expect([1, 2, 3, 5, 7, 8, 9].myFilter(isOdd)).toStrictEqual([\n      1, 3, 5, 7, 9,\n    ]);\n  });\n\n  test('reducer uses index argument when provided', () => {\n    expect([1, 2, 3].myFilter(isEvenIndex)).toStrictEqual([1, 3]);\n    expect([-1, -3, 4, 99].myFilter(isOddIndex)).toStrictEqual([-3, 99]);\n  });\n\n  test('reducer uses array argument when provided', () => {\n    expect([1, 2, 3, 4].myFilter(isSquareEven)).toStrictEqual([2, 4]);\n    expect([-3, 4, 1, 5].myFilter(isSquareOdd)).toStrictEqual([-3, 1, 5]);\n  });\n\n  test('uses this argument', () => {\n    expect([1, 2, 3, 4].myFilter(isThisProductEven)).toStrictEqual([]);\n    expect([1, 2, 3, 4].myFilter(isThisProductEven, 10)).toStrictEqual([\n      1, 2, 3, 4,\n    ]);\n    expect([1, 2, 3, 4].myFilter(isThisProductEven, 9)).toStrictEqual([2, 4]);\n    expect([1, 2, 3, 4].myFilter(isThisProductEvenArrowFn)).toStrictEqual([]);\n    expect([1, 2, 3, 4].myFilter(isThisProductEvenArrowFn, 10)).toStrictEqual(\n      [],\n    );\n    expect([1, 2, 3, 4].myFilter(isThisProductEvenArrowFn, 9)).toStrictEqual(\n      [],\n    );\n  });\n\n  test('sparse arrays', () => {\n    expect([, , ,].myFilter(isEven)).toStrictEqual([]);\n    expect([1, 2, , 4].myFilter(isEven)).toStrictEqual([2, 4]);\n    expect([1, , 2, , 4, 7, 9].myFilter(isOdd)).toStrictEqual([1, 7, 9]);\n  });\n});\n",
    "/src/array-filter.ts": "interface Array<T> {\n  myFilter(\n    callbackFn: (value: T, index: number, array: Array<T>) => boolean,\n    thisArg?: any,\n  ): Array<T>;\n}\n\nArray.prototype.myFilter = function (callbackFn, thisArg) {\n  const len = this.length;\n  const results = [];\n\n  for (let k = 0; k < len; k++) {\n    const kValue = this[k];\n    if (\n      // Ignore index if value is not defined for index (e.g. in sparse arrays).\n      Object.hasOwn(this, k) &&\n      callbackFn.call(thisArg, kValue, k, this)\n    ) {\n      results.push(kValue);\n    }\n  }\n\n  return results;\n};\n"
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param { (value: T, index: number, array: Array<T>) => boolean } callbackFn\n * @param {any} [thisArg]\n * @return {Array<T>}\n */\nArray.prototype.myFilter = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};",
    "ts": "interface Array<T> {\n  myFilter(\n    callbackFn: (value: T, index: number, array: Array<T>) => boolean,\n    thisArg?: any,\n  ): Array<T>;\n}\n\nArray.prototype.myFilter = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};"
  },
  "workspace": {
    "main": "/src/array-filter.ts",
    "run": "/src/array-filter.run.test.ts",
    "submit": "/src/array-filter.submit.test.ts"
  }
}