{
  "description": "var Component=(()=>{var a=Object.create;var c=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var p=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var r in e)c(n,r,{get:e[r],enumerable:!0})},s=(n,e,r,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!f.call(n,i)&&i!==r&&c(n,i,{get:()=>e[i],enumerable:!(h=m(e,i))||h.enumerable});return n};var g=(n,e,r)=>(r=n!=null?a(b(n)):{},s(e||!n||!n.__esModule?c(r,\"default\",{value:n,enumerable:!0}):r,n)),w=n=>s(c({},\"__esModule\",{value:!0}),n);var o=p((k,d)=>{d.exports=_jsx_runtime});var y={};v(y,{default:()=>T,frontmatter:()=>E});var t=g(o()),E={title:\"Event Emitter II\",excerpt:\"Implement a class that can subscribe to and emit events that trigger attached callback functions. Subscription objects are returned and can unsubscribe itself\"};function l(n){let e=Object.assign({p:\"p\",a:\"a\",strong:\"strong\",code:\"code\",h2:\"h2\",h3:\"h3\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.a,{href:\"https://www.patterns.dev/posts/observer-pattern/\",children:(0,t.jsx)(e.strong,{children:\"observer pattern\"})}),\" (also commonly known as the publish-subscribe model), we can observe/subscribe to events emitted by publishers and execute code whenever an event happens.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement an \",(0,t.jsxs)(e.a,{href:\"https://nodejs.org/api/events.html#class-eventemitter\",children:[(0,t.jsx)(e.code,{children:\"EventEmitter\"}),\" class\"]}),\" similar to the one in \",(0,t.jsx)(e.a,{href:\"https://nodejs.org/api/events.html\",children:\"Node.js\"}),\" that follows such an observer pattern. The difference between this question and the first \",(0,t.jsx)(e.a,{href:\"/questions/javascript/event-emitter\",children:\"Event Emitter\"}),\" question is the way listeners are unsubscribed. In this version, there's no \",(0,t.jsx)(e.code,{children:\"emitter.off()\"}),\" method available on the \",(0,t.jsx)(e.code,{children:\"EventEmitter\"}),\" instance. Instead, \",(0,t.jsx)(e.code,{children:\"emitter.on()\"}),\" returns an object that has an \",(0,t.jsx)(e.code,{children:\"off()\"}),\" method.\"]}),`\n`,(0,t.jsxs)(e.h2,{children:[(0,t.jsx)(e.code,{children:\"EventEmitter\"}),\" API\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Implement the following classes and APIs:\"}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"new EventEmitter()\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Creates an instance of the \",(0,t.jsx)(e.code,{children:\"EventEmitter\"}),\" class. Events and listeners are isolated within the \",(0,t.jsx)(e.code,{children:\"EventEmitter\"}),\" instances they're added to, aka listeners shouldn't react to events emitted by other \",(0,t.jsx)(e.code,{children:\"EventEmitter\"}),\" instances.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"emitter.on(eventName, listener)\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Adds a callback function (\",(0,t.jsx)(e.code,{children:\"listener\"}),\") that will be invoked when an event with the name \",(0,t.jsx)(e.code,{children:\"eventName\"}),\" is emitted.\"]}),`\n`,(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Parameter\"}),(0,t.jsx)(e.th,{children:\"Type\"}),(0,t.jsx)(e.th,{children:\"Description\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:\"eventName\"})}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:\"string\"})}),(0,t.jsx)(e.td,{children:\"The name of the event.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:\"listener\"})}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:\"Function\"})}),(0,t.jsx)(e.td,{children:\"The callback function to be invoked when the event occurs.\"})]})]})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Returns a subscription object that has an \",(0,t.jsx)(e.code,{children:\"off()\"}),\" method that unsubscribes this listener from the event. More details below.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"emitter.emit(eventName[, ...args])\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Invokes each of the listeners listening to \",(0,t.jsx)(e.code,{children:\"eventName\"}),\" with the supplied arguments in order.\"]}),`\n`,(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:\"Parameter\"}),(0,t.jsx)(e.th,{children:\"Type\"}),(0,t.jsx)(e.th,{children:\"Description\"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:\"eventName\"})}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:\"string\"})}),(0,t.jsx)(e.td,{children:\"The name of the event.\"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:\"...args\"})}),(0,t.jsx)(e.td,{children:(0,t.jsx)(e.code,{children:\"any\"})}),(0,t.jsx)(e.td,{children:\"Arguments to invoke the list of listener functions with.\"})]})]})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Returns \",(0,t.jsx)(e.code,{children:\"true\"}),\" if the event had listeners, \",(0,t.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"sub.off()\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"This object is returned from \",(0,t.jsx)(e.code,{children:\"emitter.on()\"}),\". Calling \",(0,t.jsx)(e.code,{children:\"sub.off()\"}),\" unsubscribes the respective listener from the event.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const emitter = new EventEmitter();\n\nfunction addTwoNumbers(a, b) {\n  console.log(\\`The sum is \\${a + b}\\`);\n}\n\n// Returns a subscription object that has an .off() method.\nconst sub = emitter.on('foo', addTwoNumbers);\nemitter.emit('foo', 2, 5);\n// > \"The sum is 7\"\n\nemitter.on('foo', (a, b) => {\n  console.log(\\`The product is \\${a * b}\\`);\n});\nemitter.emit('foo', 4, 5);\n// > \"The sum is 9\"\n// > \"The product is 20\"\n\nsub.off(); // This unsubscribes the callback that logs the sum of the numbers.\nemitter.emit('foo', -3, 9);\n// > \"The product is -27\"\n// (Only the multiply callback is triggered, the first one was unsubscribed.)\n`})})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var T=j;return w(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/event-emitter-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/event-emitter-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/event-emitter-ii.run.test.ts": "import EventEmitter from './event-emitter-ii';\n\ndescribe('EventEmitter', () => {\n  test('constructor', () => {\n    const emitter = new EventEmitter();\n    expect(emitter).toBeInstanceOf(EventEmitter);\n  });\n\n  test('emit', () => {\n    const emitter = new EventEmitter();\n    let a = 0;\n    emitter.on('foo', () => {\n      a = 1;\n    });\n    emitter.emit('foo');\n\n    expect(a).toBe(1);\n  });\n\n  test('unsubscribe', () => {\n    const emitter = new EventEmitter();\n\n    let sum = 0;\n    function addTwoNumbers(a: number, b: number) {\n      sum = a + b;\n    }\n    const sub = emitter.on('foo', addTwoNumbers);\n    emitter.emit('foo', 2, 5);\n    expect(sum).toBe(7);\n\n    sub.off();\n    emitter.emit('foo', -3, 9);\n    expect(sum).toBe(7);\n  });\n});\n",
    "/src/event-emitter-ii.submit.test.ts": "import EventEmitter from './event-emitter-ii';\n\ndescribe('EventEmitter', () => {\n  test('constructor', () => {\n    const emitter = new EventEmitter();\n    expect(emitter).toBeInstanceOf(EventEmitter);\n  });\n\n  describe('subscribe', () => {\n    test('returns object with off() method', () => {\n      const emitter = new EventEmitter();\n      const sub = emitter.on('foo', () => {});\n\n      expect(sub).toBeTruthy();\n      expect(sub.off).toBeTruthy();\n    });\n\n    test('single listener', () => {\n      const emitter = new EventEmitter();\n      let a = 0;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.emit('foo');\n\n      expect(a).toBe(1);\n    });\n\n    test('multiple listeners', () => {\n      const emitter = new EventEmitter();\n      let a = 0,\n        b = 1;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.on('foo', () => {\n        b = 3;\n      });\n      emitter.emit('foo');\n\n      expect(a).toBe(1);\n      expect(b).toBe(3);\n    });\n\n    test('multiple events', () => {\n      const emitter = new EventEmitter();\n      let a = 0,\n        b = 1;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.on('bar', () => {\n        b = 3;\n      });\n      emitter.emit('foo');\n      expect(a).toBe(1);\n      expect(b).toBe(1);\n\n      emitter.emit('bar');\n      expect(b).toBe(3);\n    });\n\n    test('same listener added multiple times', () => {\n      const emitter = new EventEmitter();\n\n      let num = 1;\n      function square() {\n        num *= 2;\n      }\n\n      emitter.on('square', square);\n      emitter.emit('square');\n      expect(num).toBe(2);\n\n      emitter.on('square', square);\n      emitter.emit('square');\n      expect(num).toBe(8);\n    });\n  });\n\n  describe('emit', () => {\n    describe('listeners are invoked with arguments', () => {\n      test('single argument', () => {\n        const emitter = new EventEmitter();\n\n        let sum = 0;\n        emitter.on('foo', (a: number) => {\n          sum = a;\n        });\n        emitter.emit('foo', 3);\n        expect(sum).toBe(3);\n\n        emitter.emit('foo', 5);\n        expect(sum).toBe(5);\n      });\n\n      test('two arguments', () => {\n        const emitter = new EventEmitter();\n\n        let sum = 0;\n        emitter.on('foo', (a: number, b: number) => {\n          sum = a + b;\n        });\n        emitter.emit('foo', 3, 5);\n        expect(sum).toBe(8);\n\n        emitter.emit('foo', 4, 13);\n        expect(sum).toBe(17);\n      });\n\n      test('multiple arguments', () => {\n        const emitter = new EventEmitter();\n\n        let product = 0;\n        emitter.on('foo', (a: number, b: number, c: number) => {\n          product = a * b * c;\n        });\n        emitter.emit('foo', 3, 5, 6);\n        expect(product).toBe(90);\n\n        emitter.emit('foo', 4, 13, 9);\n        expect(product).toBe(468);\n      });\n    });\n\n    describe('non-existing event name returns false', () => {\n      test('custom event', () => {\n        const emitter = new EventEmitter();\n\n        expect(emitter.emit('foo')).toBe(false);\n      });\n\n      test('same name as built-in event', () => {\n        const emitter = new EventEmitter();\n\n        expect(emitter.emit('toString')).toBe(false);\n      });\n    });\n  });\n\n  describe('unsubscribe', () => {\n    test('single listener', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const sub = emitter.on('foo', addTwoNumbers);\n      emitter.emit('foo', 2, 5);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(7);\n    });\n\n    test('multiple listeners', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const addSub = emitter.on('foo', addTwoNumbers);\n      emitter.emit('foo', 2, 5);\n      expect(sum).toBe(7);\n\n      let product = 0;\n      function multiplyTwoNumbers(a: number, b: number) {\n        product = a * b;\n      }\n      const mulSub = emitter.on('foo', multiplyTwoNumbers);\n      emitter.emit('foo', 4, 5);\n      expect(sum).toBe(9);\n      expect(product).toBe(20);\n\n      addSub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(9);\n      expect(product).toBe(-27);\n\n      mulSub.off();\n      emitter.emit('foo', 3, 7);\n      expect(sum).toBe(9);\n      expect(product).toBe(-27);\n    });\n\n    test('multiple events', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const fooSub = emitter.on('foo', addTwoNumbers);\n      emitter.emit('foo', 2, 5);\n      expect(sum).toBe(7);\n\n      const barSub = emitter.on('bar', addTwoNumbers);\n      emitter.emit('bar', 3, 7);\n      expect(sum).toBe(10);\n\n      fooSub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(10);\n\n      barSub.off();\n      emitter.emit('bar', -3, 9);\n      expect(sum).toBe(10);\n    });\n\n    test('same listener added multiple times removed correctly', () => {\n      const emitter = new EventEmitter();\n\n      let num = 1;\n      function square() {\n        num *= 2;\n      }\n\n      const sub1 = emitter.on('square', square);\n      emitter.emit('square');\n      expect(num).toBe(2);\n\n      const sub2 = emitter.on('square', square);\n      emitter.emit('square');\n      expect(num).toBe(8);\n\n      sub1.off();\n      emitter.emit('square');\n      expect(num).toBe(16);\n\n      sub2.off();\n      emitter.emit('square');\n      expect(num).toBe(16);\n    });\n\n    test(\"sub.off() called more than once doesn't crash\", () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const sub = emitter.on('foo', addTwoNumbers);\n      emitter.emit('foo', 2, 5);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(7);\n    });\n  });\n});\n",
    "/src/event-emitter-ii.ts": "interface IEventEmitter {\n  on(eventName: string, listener: Function): { off: () => void };\n  emit(eventName: string, ...args: Array<any>): boolean;\n}\n\n// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter implements IEventEmitter {\n  _key: number;\n  _events: Record<string, Record<string, Function>>;\n\n  constructor() {\n    // Avoid creating objects via `{}` to exclude unwanted properties\n    // on the prototype (such as `.toString`).\n    this._events = Object.create(null);\n    // Use an incrementing number to uniquely identify each listener.\n    this._key = 0;\n  }\n\n  on(eventName: string, listener: Function): { off: () => void } {\n    if (!Object.hasOwn(this._events, eventName)) {\n      // It's ok to use `{}` here since the keys will just be numbers.\n      this._events[eventName] = {};\n    }\n\n    const listenerId = this._key;\n    this._events[eventName][listenerId] = listener;\n    this._key++;\n\n    return {\n      // Use arrow function so that `this` is preserved.\n      off: () => {\n        delete this._events[eventName][listenerId];\n      },\n    };\n  }\n\n  emit(eventName: string, ...args: Array<any>): boolean {\n    // Return false for non-existing eventNames or events without listeners.\n    if (\n      !Object.hasOwn(this._events, eventName) ||\n      Object.keys(this._events[eventName]).length === 0\n    ) {\n      return false;\n    }\n\n    // Make a clone of the listeners in case one of the\n    // listeners calls sub.off() and changes the listeners.\n    const listeners = { ...this._events[eventName] };\n    Object.values(listeners).forEach((listener) => {\n      listener.apply(null, args);\n    });\n\n    return true;\n  }\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [
      "google",
      "lyft",
      "tiktok",
      "bytedance",
      "microsoft"
    ],
    "created": 1669939200,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a class that can subscribe to and emit events that trigger attached callback functions. Subscription objects are returned and can unsubscribe itself",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/event-emitter-ii",
    "importance": "medium",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "event-emitter",
      "jquery-class-manipulation",
      "backbone-model"
    ],
    "slug": "event-emitter-ii",
    "subtitle": null,
    "title": "Event Emitter II",
    "topics": [
      "oop"
    ]
  },
  "skeleton": {
    "js": "// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {Function} listener\n   * @returns {{off: Function}}\n   */\n  on(eventName, listener) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {...any} args\n   * @returns boolean\n   */\n  emit(eventName, ...args) {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "interface IEventEmitter {\n  on(eventName: string, listener: Function): { off: () => void };\n  emit(eventName: string, ...args: Array<any>): boolean;\n}\n\n// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter implements IEventEmitter {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  on(eventName: string, listener: Function): { off: () => void } {\n    throw 'Not implemented!';\n  }\n\n  emit(eventName: string, ...args: Array<any>): boolean {\n    throw 'Not implemented!';\n  }\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),N=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of g(e))!y.call(t,r)&&r!==i&&s(t,r,{get:()=>e[r],enumerable:!(l=p(e,r))||l.enumerable});return t};var j=(t,e,i)=>(i=t!=null?f(b(t)):{},c(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>c(s({},\"__esModule\",{value:!0}),t);var h=w((T,a)=>{a.exports=_jsx_runtime});var F={};N(F,{default:()=>I});var n=j(h());var o=MDXCodeBlock;var d=`export default class EventEmitter {\n  constructor() {\n    // Avoid creating objects via \\`{}\\` to exclude unwanted properties\n    // on the prototype (such as \\`.toString\\`).\n    this._events = Object.create(null);\n    // Use an incrementing number to uniquely identify each listener.\n    this._key = 0;\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {Function} listener\n   * @returns {{off: Function}}\n   */\n  on(eventName, listener) {\n    if (!Object.hasOwn(this._events, eventName)) {\n      // It's ok to use \\`{}\\` here since the keys will just be numbers.\n      this._events[eventName] = {};\n    }\n\n    const listenerId = this._key;\n    this._events[eventName][listenerId] = listener;\n    this._key++;\n\n    return {\n      // Use arrow function so that \\`this\\` is preserved.\n      off: () => {\n        delete this._events[eventName][listenerId];\n      },\n    };\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {...any} args\n   * @returns boolean\n   */\n  emit(eventName, ...args) {\n    // Early return for non-existing eventNames or\n    // events without listeners.\n    if (\n      !Object.hasOwn(this._events, eventName) ||\n      Object.keys(this._events[eventName]).length === 0\n    ) {\n      return false;\n    }\n\n    // Make a clone of the listeners in case one of the\n    // listeners calls sub.off() and changes the listeners.\n    const listeners = { ...this._events[eventName] };\n    Object.values(listeners).forEach((listener) => {\n      listener.apply(null, args);\n    });\n\n    return true;\n  }\n}\n`;var u=`interface IEventEmitter {\n  on(eventName: string, listener: Function): { off: () => void };\n  emit(eventName: string, ...args: Array<any>): boolean;\n}\n\n// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter implements IEventEmitter {\n  _key: number;\n  _events: Record<string, Record<string, Function>>;\n\n  constructor() {\n    // Avoid creating objects via \\`{}\\` to exclude unwanted properties\n    // on the prototype (such as \\`.toString\\`).\n    this._events = Object.create(null);\n    // Use an incrementing number to uniquely identify each listener.\n    this._key = 0;\n  }\n\n  on(eventName: string, listener: Function): { off: () => void } {\n    if (!Object.hasOwn(this._events, eventName)) {\n      // It's ok to use \\`{}\\` here since the keys will just be numbers.\n      this._events[eventName] = {};\n    }\n\n    const listenerId = this._key;\n    this._events[eventName][listenerId] = listener;\n    this._key++;\n\n    return {\n      // Use arrow function so that \\`this\\` is preserved.\n      off: () => {\n        delete this._events[eventName][listenerId];\n      },\n    };\n  }\n\n  emit(eventName: string, ...args: Array<any>): boolean {\n    // Return false for non-existing eventNames or events without listeners.\n    if (\n      !Object.hasOwn(this._events, eventName) ||\n      Object.keys(this._events[eventName]).length === 0\n    ) {\n      return false;\n    }\n\n    // Make a clone of the listeners in case one of the\n    // listeners calls sub.off() and changes the listeners.\n    const listeners = { ...this._events[eventName] };\n    Object.values(listeners).forEach((listener) => {\n      listener.apply(null, args);\n    });\n\n    return true;\n  }\n}\n`;var m=`export default function EventEmitter() {\n  // Avoid creating objects via \\`{}\\` to exclude unwanted properties\n  // on the prototype (such as \\`.toString\\`).\n  this._events = Object.create(null);\n  // Use an incrementing number to unique identify each listener.\n  this._key = 0;\n}\n\n/**\n * @param {string} eventName\n * @param {Function} listener\n * @returns {{off: Function}}\n */\nEventEmitter.prototype.on = function (eventName, listener) {\n  if (!Object.hasOwn(this._events, eventName)) {\n    // It's ok to use \\`{}\\` here since the keys will just be numbers.\n    this._events[eventName] = {};\n  }\n\n  const listenerId = this._key;\n  this._events[eventName][listenerId] = listener;\n  this._key++;\n\n  return {\n    // Use arrow function so that \\`this\\` is preserved.\n    off: () => {\n      delete this._events[eventName][listenerId];\n    },\n  };\n};\n\n/**\n * @param {string} eventName\n * @param {...any} args\n * @returns boolean\n */\nEventEmitter.prototype.emit = function (eventName, ...args) {\n  // Early return for non-existing eventNames or events without listeners.\n  if (\n    !Object.hasOwn(this._events, eventName) ||\n    Object.keys(this._events[eventName]).length === 0\n  ) {\n    return false;\n  }\n\n  // Make a clone of the listeners in case one of the listeners\n  // calls sub.off() and changes the listeners.\n  const listeners = { ...this._events[eventName] };\n  Object.values(listeners).forEach((listener) => {\n    listener.apply(null, args);\n  });\n\n  return true;\n};\n`;function v(t){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\",h3:\"h3\",h4:\"h4\",pre:\"pre\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"An event-based interaction model is the most common way of building user interfaces. The DOM is also built around this model with the \",(0,n.jsx)(e.code,{children:\"document.addEventListener()\"}),\" and \",(0,n.jsx)(e.code,{children:\"document.removeEventListener()\"}),\" APIs to allow responding to events like \",(0,n.jsx)(e.code,{children:\"click\"}),\", \",(0,n.jsx)(e.code,{children:\"hover\"}),\", \",(0,n.jsx)(e.code,{children:\"input\"}),\", etc.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,n.jsx)(e.p,{children:\"The following are good questions to ask the interviewer to demonstrate your thoughtfulness. Depending on their response, you might need to adjust the implementation accordingly.\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Can \",(0,n.jsx)(e.code,{children:\"emitter.emit()\"}),\" be called without any arguments besides the \",(0,n.jsx)(e.code,{children:\"eventName\"}),\"?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Yes, it can be.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Can the same listener be added multiple times with the same \",(0,n.jsx)(e.code,{children:\"eventName\"}),\"?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Yes, it can be. It will be called once for each time it is added when \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" is emitted in the order they were added.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Can non-existent events be emitted?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Yes, but nothing should happen and the code should not error or crash.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"What should the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value of the listeners be?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"It can be \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Can \",(0,n.jsx)(e.code,{children:\"sub.off()\"}),\" be called more than once?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Yes it can be, the second call should be a no-op.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Can listeners contain code that invoke methods on the emitter instance?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Yes, but we can ignore that scenario for this question.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"What if the listener callbacks throw an error during \",(0,n.jsx)(e.code,{children:\"emitter.emit()\"}),\"?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The error should be caught and not halt the rest of the execution. However, we will not test for this case.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"We will handle all the above cases except for the last two cases.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Data structure\"}),`\n`,(0,n.jsx)(e.p,{children:\"Firstly, we have to decide on the data structure to store the events and the listeners.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We need to be able to uniquely identify each listener function so that when we call \",(0,n.jsx)(e.code,{children:\"sub.off()\"}),\" we know which listener to remove. This can be achieved by having the \",(0,n.jsx)(e.code,{children:\"EventEmitter\"}),\" instance keep an integer counter which is incremented on every new listener added and each listener is assigned the counter's current value.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We can either use:\"}),`\n`,(0,n.jsxs)(e.h4,{children:[\"1. Map of \",(0,n.jsx)(e.code,{children:\"eventName\"}),\"s of map of listener functions.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`events = {\n  foo: { 1: Function1, 3: Function3 },\n  bar: { 2: Function2 },\n};\n`})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Pros:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Fast lookup of listeners given an \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" and a listener ID.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Cons:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Since \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" is provided by the user, it can be any value and might conflict with existing keys on \",(0,n.jsx)(e.code,{children:\"Object.prototype\"}),\" such as \",(0,n.jsx)(e.code,{children:\".toString\"}),\". We will handle this situation.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.h4,{children:[\"2. A flat array of \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" and listener pairs.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`events = [\n  { eventName: 'foo', listener: Function1, key: 1 },\n  { eventName: 'bar', listener: Function2, key: 2 },\n  { eventName: 'foo', listener: Function3, key: 3 },\n];\n`})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Pros:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Simple, flat structure.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Cons:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Requires O(n) time to find the listeners for an event because you have to look through the entire list of events.\"}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"emit()\"}),\" and \",(0,n.jsx)(e.code,{children:\"sub.off()\"}),\" operations will require iterating through the array, you can't instantly determine if an event exists and ignore emission of non-existent events.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Potentially more space needed to store the data because of the repeated object fields and \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" strings.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Approach #1 is clearly superior, so we will use that. To mitigate the issue of user-provided \",(0,n.jsx)(e.code,{children:\"eventName\"}),\"s conflicting with keys on \",(0,n.jsx)(e.code,{children:\"Object.prototype\"}),\", we can instantiate the \",(0,n.jsx)(e.code,{children:\"_events\"}),\" object with \",(0,n.jsx)(e.code,{children:\"Object.create(null)\"}),\" or use a ES6 \",(0,n.jsx)(e.code,{children:\"Map\"}),\" class.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Implementing \",(0,n.jsx)(e.code,{children:\"emitter.on()\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implementing \",(0,n.jsx)(e.code,{children:\"emitter.on()\"}),\" is pretty straightforward. Firstly check if \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" is present as a key of the \",(0,n.jsx)(e.code,{children:\"_events\"}),\" object and make the value an empty object (for the map of \",(0,n.jsx)(e.code,{children:\"listenerId\"}),\"s to its listeners for that event) if it is the first time this \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" is encountered. Then push the \",(0,n.jsx)(e.code,{children:\"listener\"}),\" into the array.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Implementing \",(0,n.jsx)(e.code,{children:\"sub.off()\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"emitter.on()\"}),\" needs to return an object that has an \",(0,n.jsx)(e.code,{children:\"off()\"}),\" method. It will suffice to use a plain object with an \",(0,n.jsx)(e.code,{children:\"off()\"}),\" method. The \",(0,n.jsx)(e.code,{children:\"off()\"}),\" method contains a reference to the \",(0,n.jsx)(e.code,{children:\"listener\"}),\"'s unique ID (\",(0,n.jsx)(e.code,{children:\"listenerId\"}),\") and \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" thanks to closures. However, for the \",(0,n.jsx)(e.code,{children:\"off()\"}),\" method to have access to the emitter instance's \",(0,n.jsx)(e.code,{children:\"this\"}),\" value, it should be defined using an arrow function or use a separate \",(0,n.jsx)(e.code,{children:\"that\"}),\" variable to retain a reference to \",(0,n.jsx)(e.code,{children:\"this\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To remove the listener from the emitter, simply \",(0,n.jsx)(e.code,{children:\"delete\"}),\" the key from \",(0,n.jsx)(e.code,{children:\"this.events[eventName]\"}),\". This approach also works if called \",(0,n.jsx)(e.code,{children:\"sub.off()\"}),\" is called multiple times because \",(0,n.jsx)(e.code,{children:\"delete\"}),\" on non-existing keys is a no-op.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function on(eventName, listener) {\n  // Rest of the implementation omitted for brevity.\n  return {\n    // Use arrow function so that \\`this\\` is preserved.\n    off: () => {\n      delete this.events[eventName][listenerId];\n    },\n  };\n}\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function on(eventName, listener) {\n  // Rest of the implementation omitted for brevity.\n  // Define a separate \\`that\\` variable to retain a reference to \\`this\\`.\n  const that = this;\n  return {\n    off() {\n      delete that.events[eventName][listenerId];\n    },\n  };\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can create a new class \",(0,n.jsx)(e.code,{children:\"EventSubscription\"}),\" with an \",(0,n.jsx)(e.code,{children:\".off()\"}),\" method to instantiate as the object returned from \",(0,n.jsx)(e.code,{children:\"emitter.off()\"}),\", which has the benefit of sharing the method implementation across instances. However, the memory footprint is negligible and is not really necessary.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Implementing \",(0,n.jsx)(e.code,{children:\"EventEmitter.emit()\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Check if the \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" exists or has any events and we can terminate and return \",(0,n.jsx)(e.code,{children:\"false\"}),\" if the \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" doesn't exist or if there are no listeners for \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" (object is empty).\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To pass the rest of the arguments to each listener, we have to use \",(0,n.jsx)(e.code,{children:\"...args\"}),\" in the method signature to capture all other arguments as the variable \",(0,n.jsx)(e.code,{children:\"args\"}),\". The listeners can be called with \",(0,n.jsx)(e.code,{children:\"args\"}),\" via \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" or \",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\".\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Built-in object properties colliding with user-provided \",(0,n.jsx)(e.code,{children:\"eventName\"}),\"s\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"As mentioned above, if you're using a plain JavaScript object to map \",(0,n.jsx)(e.code,{children:\"eventName\"}),\" to callbacks, one potential issue is using \",(0,n.jsx)(e.code,{children:\"eventName\"}),\"s that clash with properties existing on JavaScript objects such as \",(0,n.jsx)(e.code,{children:\"valueOf\"}),\" and \",(0,n.jsx)(e.code,{children:\"toString\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const emitter = new EventEmitter();\nemitter.emit('toString'); // Might crash because the property does exist on the object.\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Two ways to handle this:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Use a \",(0,n.jsx)(e.code,{children:\"Map\"}),\" instead of an object. This is the modern approach.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Create your plain JavaScript object with \",(0,n.jsx)(e.code,{children:\"Object.create(null)\"}),\" so that the object does not have a prototype and no additional properties.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Class-based solution\"}),`\n`,(0,n.jsx)(o,{languages:{jsx:d,tsx:u}}),`\n`,(0,n.jsx)(e.h3,{children:\"Function prototype-based solution\"}),`\n`,(0,n.jsx)(o,{children:m}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The same listener function can be added more than once for the same event. Calling \",(0,n.jsx)(e.code,{children:\"sub.off()\"}),\" should remove the respective listener because the order of invocation matters.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"emitter.emit()\"}),\" is called without any arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Methods are called with non-existing \",(0,n.jsx)(e.code,{children:\"eventName\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"sub.off()\"}),\" is called multiple times and shouldn't crash.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Object-oriented programming.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Using the right data structures.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Closures.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Handling of variadic arguments.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Node.js' \",(0,n.jsx)(e.code,{children:\"EventEmitter\"}),\"'s implementation allows \",(0,n.jsx)(e.code,{children:\"eventName\"}),\"s to be symbols which we don't allow here.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://nodejs.org/api/events.html#class-eventemitter\",children:\"EventEmitter | Node.js\"})}),`\n`]})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(v,t)})):v(t)}var I=O;return k(F);})();\n;return Component;",
  "workspace": {
    "main": "/src/event-emitter-ii.ts",
    "run": "/src/event-emitter-ii.run.test.ts",
    "submit": "/src/event-emitter-ii.submit.test.ts"
  }
}