{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/event-emitter-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/event-emitter-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/event-emitter-ii.run.test.ts": "import EventEmitter from './event-emitter-ii';\n\ndescribe('EventEmitter', () => {\n  test('constructor', () => {\n    const emitter = new EventEmitter();\n    expect(emitter).toBeInstanceOf(EventEmitter);\n  });\n\n  test('emit', () => {\n    const emitter = new EventEmitter();\n    let a = 0;\n    emitter.on('foo', () => {\n      a = 1;\n    });\n    emitter.emit('foo');\n\n    expect(a).toBe(1);\n  });\n\n  test('unsubscribe', () => {\n    const emitter = new EventEmitter();\n\n    let sum = 0;\n    function addTwoNumbers(a: number, b: number) {\n      sum = a + b;\n    }\n    const sub = emitter.on('foo', addTwoNumbers);\n    emitter.emit('foo', 2, 5);\n    expect(sum).toBe(7);\n\n    sub.off();\n    emitter.emit('foo', -3, 9);\n    expect(sum).toBe(7);\n  });\n});\n",
    "/src/event-emitter-ii.submit.test.ts": "import EventEmitter from './event-emitter-ii';\n\ndescribe('EventEmitter', () => {\n  test('constructor', () => {\n    const emitter = new EventEmitter();\n    expect(emitter).toBeInstanceOf(EventEmitter);\n  });\n\n  describe('subscribe', () => {\n    test('returns object with off() method', () => {\n      const emitter = new EventEmitter();\n      const sub = emitter.on('foo', () => {});\n\n      expect(sub).toBeTruthy();\n      expect(sub.off).toBeTruthy();\n    });\n\n    test('single listener', () => {\n      const emitter = new EventEmitter();\n      let a = 0;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.emit('foo');\n\n      expect(a).toBe(1);\n    });\n\n    test('multiple listeners', () => {\n      const emitter = new EventEmitter();\n      let a = 0,\n        b = 1;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.on('foo', () => {\n        b = 3;\n      });\n      emitter.emit('foo');\n\n      expect(a).toBe(1);\n      expect(b).toBe(3);\n    });\n\n    test('multiple events', () => {\n      const emitter = new EventEmitter();\n      let a = 0,\n        b = 1;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.on('bar', () => {\n        b = 3;\n      });\n      emitter.emit('foo');\n      expect(a).toBe(1);\n      expect(b).toBe(1);\n\n      emitter.emit('bar');\n      expect(b).toBe(3);\n    });\n\n    test('same listener added multiple times', () => {\n      const emitter = new EventEmitter();\n\n      let num = 1;\n      function square() {\n        num *= 2;\n      }\n\n      emitter.on('square', square);\n      emitter.emit('square');\n      expect(num).toBe(2);\n\n      emitter.on('square', square);\n      emitter.emit('square');\n      expect(num).toBe(8);\n    });\n  });\n\n  describe('emit', () => {\n    describe('listeners are invoked with arguments', () => {\n      test('single argument', () => {\n        const emitter = new EventEmitter();\n\n        let sum = 0;\n        emitter.on('foo', (a: number) => {\n          sum = a;\n        });\n        emitter.emit('foo', 3);\n        expect(sum).toBe(3);\n\n        emitter.emit('foo', 5);\n        expect(sum).toBe(5);\n      });\n\n      test('two arguments', () => {\n        const emitter = new EventEmitter();\n\n        let sum = 0;\n        emitter.on('foo', (a: number, b: number) => {\n          sum = a + b;\n        });\n        emitter.emit('foo', 3, 5);\n        expect(sum).toBe(8);\n\n        emitter.emit('foo', 4, 13);\n        expect(sum).toBe(17);\n      });\n\n      test('multiple arguments', () => {\n        const emitter = new EventEmitter();\n\n        let product = 0;\n        emitter.on('foo', (a: number, b: number, c: number) => {\n          product = a * b * c;\n        });\n        emitter.emit('foo', 3, 5, 6);\n        expect(product).toBe(90);\n\n        emitter.emit('foo', 4, 13, 9);\n        expect(product).toBe(468);\n      });\n    });\n\n    describe('non-existing event name returns false', () => {\n      test('custom event', () => {\n        const emitter = new EventEmitter();\n\n        expect(emitter.emit('foo')).toBe(false);\n      });\n\n      test('same name as built-in event', () => {\n        const emitter = new EventEmitter();\n\n        expect(emitter.emit('toString')).toBe(false);\n      });\n    });\n  });\n\n  describe('unsubscribe', () => {\n    test('single listener', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const sub = emitter.on('foo', addTwoNumbers);\n      emitter.emit('foo', 2, 5);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(7);\n    });\n\n    test('multiple listeners', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const addSub = emitter.on('foo', addTwoNumbers);\n      emitter.emit('foo', 2, 5);\n      expect(sum).toBe(7);\n\n      let product = 0;\n      function multiplyTwoNumbers(a: number, b: number) {\n        product = a * b;\n      }\n      const mulSub = emitter.on('foo', multiplyTwoNumbers);\n      emitter.emit('foo', 4, 5);\n      expect(sum).toBe(9);\n      expect(product).toBe(20);\n\n      addSub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(9);\n      expect(product).toBe(-27);\n\n      mulSub.off();\n      emitter.emit('foo', 3, 7);\n      expect(sum).toBe(9);\n      expect(product).toBe(-27);\n    });\n\n    test('multiple events', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const fooSub = emitter.on('foo', addTwoNumbers);\n      emitter.emit('foo', 2, 5);\n      expect(sum).toBe(7);\n\n      const barSub = emitter.on('bar', addTwoNumbers);\n      emitter.emit('bar', 3, 7);\n      expect(sum).toBe(10);\n\n      fooSub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(10);\n\n      barSub.off();\n      emitter.emit('bar', -3, 9);\n      expect(sum).toBe(10);\n    });\n\n    test('same listener added multiple times removed correctly', () => {\n      const emitter = new EventEmitter();\n\n      let num = 1;\n      function square() {\n        num *= 2;\n      }\n\n      const sub1 = emitter.on('square', square);\n      emitter.emit('square');\n      expect(num).toBe(2);\n\n      const sub2 = emitter.on('square', square);\n      emitter.emit('square');\n      expect(num).toBe(8);\n\n      sub1.off();\n      emitter.emit('square');\n      expect(num).toBe(16);\n\n      sub2.off();\n      emitter.emit('square');\n      expect(num).toBe(16);\n    });\n\n    test(\"sub.off() called more than once doesn't crash\", () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      const sub = emitter.on('foo', addTwoNumbers);\n      emitter.emit('foo', 2, 5);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(7);\n\n      sub.off();\n      emitter.emit('foo', -3, 9);\n      expect(sum).toBe(7);\n    });\n  });\n});\n",
    "/src/event-emitter-ii.ts": "interface IEventEmitter {\n  on(eventName: string, listener: Function): { off: () => void };\n  emit(eventName: string, ...args: Array<any>): boolean;\n}\n\n// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter implements IEventEmitter {\n  _key: number;\n  _events: Record<string, Record<string, Function>>;\n\n  constructor() {\n    // Avoid creating objects via `{}` to exclude unwanted properties\n    // on the prototype (such as `.toString`).\n    this._events = Object.create(null);\n    // Use an incrementing number to uniquely identify each listener.\n    this._key = 0;\n  }\n\n  on(eventName: string, listener: Function): { off: () => void } {\n    if (!Object.hasOwn(this._events, eventName)) {\n      // It's ok to use `{}` here since the keys will just be numbers.\n      this._events[eventName] = {};\n    }\n\n    const listenerId = this._key;\n    this._events[eventName][listenerId] = listener;\n    this._key++;\n\n    return {\n      // Use arrow function so that `this` is preserved.\n      off: () => {\n        delete this._events[eventName][listenerId];\n      },\n    };\n  }\n\n  emit(eventName: string, ...args: Array<any>): boolean {\n    // Return false for non-existing eventNames or events without listeners.\n    if (\n      !Object.hasOwn(this._events, eventName) ||\n      Object.keys(this._events[eventName]).length === 0\n    ) {\n      return false;\n    }\n\n    // Make a clone of the listeners in case one of the\n    // listeners calls sub.off() and changes the listeners.\n    const listeners = { ...this._events[eventName] };\n    Object.values(listeners).forEach((listener) => {\n      listener.apply(null, args);\n    });\n\n    return true;\n  }\n}\n"
  },
  "skeleton": {
    "js": "// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {Function} listener\n   * @returns {{off: Function}}\n   */\n  on(eventName, listener) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {...any} args\n   * @returns boolean\n   */\n  emit(eventName, ...args) {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "interface IEventEmitter {\n  on(eventName: string, listener: Function): { off: () => void };\n  emit(eventName: string, ...args: Array<any>): boolean;\n}\n\n// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export is correct.\nexport default class EventEmitter implements IEventEmitter {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  on(eventName: string, listener: Function): { off: () => void } {\n    throw 'Not implemented!';\n  }\n\n  emit(eventName: string, ...args: Array<any>): boolean {\n    throw 'Not implemented!';\n  }\n}"
  },
  "workspace": {
    "main": "/src/event-emitter-ii.ts",
    "run": "/src/event-emitter-ii.run.test.ts",
    "submit": "/src/event-emitter-ii.submit.test.ts"
  }
}