{
  "description": "var Component=(()=>{var l=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var o in e)s(n,o,{get:e[o],enumerable:!0})},a=(n,e,o,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of d(e))!f.call(n,i)&&i!==o&&s(n,i,{get:()=>e[i],enumerable:!(c=h(e,i))||c.enumerable});return n};var v=(n,e,o)=>(o=n!=null?l(p(n)):{},a(e||!n||!n.__esModule?s(o,\"default\",{value:n,enumerable:!0}):o,n)),z=n=>a(s({},\"__esModule\",{value:!0}),n);var u=g((b,r)=>{r.exports=_jsx_runtime});var y={};x(y,{default:()=>w,frontmatter:()=>M});var t=v(u()),M={title:\"Memoize II\",excerpt:\"Implement a function that returns a memoized version of a function which accepts any number of arguments\"};function m(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"A memoize function is a higher-order function that takes in a function and returns a memoized version of it. The memoized function caches the results of expensive function calls and returns the cached result when it receives the same inputs again. This can significantly improve the performance of functions that involve complex processing / significant latency and are called with the same arguments repeatedly.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement a function \",(0,t.jsx)(e.code,{children:\"memoize(func)\"}),\" that takes in a function parameter \",(0,t.jsx)(e.code,{children:\"func\"}),\" and returns a memoized version of the function. You may assume that \",(0,t.jsx)(e.code,{children:\"func\"}),\" only accepts strings or numbers as arguments.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function expensiveMul(a, b) {\n  console.log('Computing...');\n  return a * b;\n}\n\n// Create a memoized version of the function.\nconst memoizedExpensiveMul = memoize(expensiveMul);\n\n// First call (computes and caches the result).\nconsole.log(memoizedExpensiveMul(3, 7)); // Output: Computing... 21\n\n// Second call with the same argument (returns the cached result).\nconsole.log(memoizedExpensiveMul(3, 7)); // Output: 21\n\n// Third call with a different argument (computes and caches the new result).\nconsole.log(memoizedExpensiveMul(5, 8)); // Output: Computing... 40\n\n// Fourth call with the same argument as the third call (returns the cached result).\nconsole.log(memoizedExpensiveMul(5, 8)); // Output: 40\n`})})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var w=j;return z(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/memoize-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/memoize-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/memoize-ii.run.test.ts": "import memoize from './memoize-ii';\n\ndescribe('memoize', () => {\n  test('returns a function', () => {\n    const memoizedFn = memoize(() => {});\n    expect(typeof memoizedFn).toBe('function');\n  });\n\n  test('no arguments', () => {\n    let count = 0;\n    function foo() {\n      count++;\n      return 'booya';\n    }\n    const memoizedFn = memoize(foo);\n    expect(count).toBe(0);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n  });\n\n  test('single argument', () => {\n    let count = 0;\n    function double(x: number): number {\n      count++;\n      return x * 2;\n    }\n    const memoizedFn = memoize(double);\n    expect(count).toBe(0);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(1);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(1);\n    expect(memoizedFn(3)).toBe(6);\n    expect(count).toBe(2);\n    expect(memoizedFn(3)).toBe(6);\n    expect(count).toBe(2);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(2);\n  });\n\n  test('two arguments', () => {\n    let count = 0;\n    function mul(a: number, b: number) {\n      count++;\n      return a * b;\n    }\n    const memoizedFn = memoize(mul);\n    expect(count).toBe(0);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(1);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(1);\n    expect(memoizedFn(3, 7)).toBe(21);\n    expect(count).toBe(2);\n    expect(memoizedFn(3, 7)).toBe(21);\n    expect(count).toBe(2);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(2);\n  });\n});\n",
    "/src/memoize-ii.submit.test.ts": "import memoize from './memoize-ii';\n\ndescribe('memoize', () => {\n  test('returns a function', () => {\n    const memoizedFn = memoize(() => {});\n    expect(typeof memoizedFn).toBe('function');\n  });\n\n  test('no arguments', () => {\n    let count = 0;\n    function foo() {\n      count++;\n      return 'booya';\n    }\n    const memoizedFn = memoize(foo);\n    expect(count).toBe(0);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n  });\n\n  test('single argument', () => {\n    let count = 0;\n    function double(x: number): number {\n      count++;\n      return x * 2;\n    }\n    const memoizedFn = memoize(double);\n    expect(count).toBe(0);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(1);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(1);\n    expect(memoizedFn(3)).toBe(6);\n    expect(count).toBe(2);\n    expect(memoizedFn(3)).toBe(6);\n    expect(count).toBe(2);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(2);\n  });\n\n  test('two arguments', () => {\n    let count = 0;\n    function mul(a: number, b: number) {\n      count++;\n      return a * b;\n    }\n    const memoizedFn = memoize(mul);\n    expect(count).toBe(0);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(1);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(1);\n    expect(memoizedFn(3, 7)).toBe(21);\n    expect(count).toBe(2);\n    expect(memoizedFn(3, 7)).toBe(21);\n    expect(count).toBe(2);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(2);\n  });\n\n  test('strings', () => {\n    let count = 0;\n    function repeat(x: string) {\n      count++;\n      return x + x;\n    }\n    const memoizedFn = memoize(repeat);\n    expect(count).toBe(0);\n    expect(memoizedFn('foo')).toBe('foofoo');\n    expect(count).toBe(1);\n    expect(memoizedFn('foo')).toBe('foofoo');\n    expect(count).toBe(1);\n    expect(memoizedFn('bar')).toBe('barbar');\n    expect(count).toBe(2);\n    expect(memoizedFn('bar')).toBe('barbar');\n    expect(count).toBe(2);\n    expect(memoizedFn('foo')).toBe('foofoo');\n    expect(count).toBe(2);\n  });\n\n  test('differentiates strings and numbers', () => {\n    let count = 0;\n    function identity<T>(x: T): T {\n      count++;\n      return x;\n    }\n    const memoizedFn = memoize(identity);\n    expect(count).toBe(0);\n    expect(memoizedFn('1')).toBe('1');\n    expect(count).toBe(1);\n    expect(memoizedFn('1')).toBe('1');\n    expect(count).toBe(1);\n    expect(memoizedFn(1)).toBe(1);\n    expect(count).toBe(2);\n    expect(memoizedFn(1)).toBe(1);\n    expect(count).toBe(2);\n  });\n\n  describe('variadic arguments', () => {\n    test('arguments of same type', () => {\n      let count = 0;\n      function product(...args: Array<number>) {\n        count++;\n        return args.reduce((acc, num) => acc * num, 1);\n      }\n      const memoizedFn = memoize(product);\n      expect(count).toBe(0);\n      expect(memoizedFn(3, 4, 5)).toBe(60);\n      expect(count).toBe(1);\n      expect(memoizedFn(3, 4, 5)).toBe(60);\n      expect(count).toBe(1);\n      expect(memoizedFn(4, 5, 6, 7)).toBe(840);\n      expect(count).toBe(2);\n      expect(memoizedFn(4, 5, 6, 7)).toBe(840);\n      expect(count).toBe(2);\n      expect(memoizedFn(3, 4, 5)).toBe(60);\n      expect(count).toBe(2);\n    });\n\n    test('arguments of different type', () => {\n      let count = 0;\n      function repeat(str: string, times: number) {\n        count++;\n        return Array(times).fill(str).join('');\n      }\n      const memoizedFn = memoize(repeat);\n      expect(count).toBe(0);\n      expect(memoizedFn('abc', 3)).toBe('abcabcabc');\n      expect(count).toBe(1);\n      expect(memoizedFn('abc', 3)).toBe('abcabcabc');\n      expect(count).toBe(1);\n      expect(memoizedFn('bar', 2)).toBe('barbar');\n      expect(count).toBe(2);\n      expect(memoizedFn('bar', 2)).toBe('barbar');\n      expect(count).toBe(2);\n      expect(memoizedFn('abc', 3)).toBe('abcabcabc');\n      expect(count).toBe(2);\n    });\n  });\n\n  test('can access `this`', () => {\n    let count = 0;\n    function mul(this: any, x: number) {\n      count++;\n      return this.age * x;\n    }\n    const person = {\n      age: 42,\n      mul: memoize(mul),\n    };\n    expect(count).toBe(0);\n    expect(person.mul(2)).toBe(84);\n    expect(count).toBe(1);\n    expect(person.mul(2)).toBe(84);\n    expect(count).toBe(1);\n  });\n});\n",
    "/src/memoize-ii.ts": "type Fn<T> = (this: any, ...args: Array<any>) => T;\n\nexport default function memoize<T>(func: Fn<T>): Fn<T> {\n  const cache = new Map<string, T>();\n\n  return function (this: any, ...args) {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n\n    const result = func.apply(this, args);\n    cache.set(key, result);\n\n    return result;\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [
      "linkedin"
    ],
    "created": 1690848000,
    "difficulty": "medium",
    "duration": 30,
    "excerpt": "Implement a function that returns a memoized version of a function which accepts any number of arguments",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/memoize-ii",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "memoize-ii",
    "subtitle": null,
    "title": "Memoize II",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Function} func\n * @returns Function\n */\nexport default function memoize(func) {\n  throw 'Not implemented';\n}",
    "ts": "type Fn<T> = (this: any, ...args: Array<any>) => T;\n\nexport default function memoize<T>(func: Fn<T>): Fn<T> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,N=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),k=(n,e)=>{for(var r in e)o(n,r,{get:e[r],enumerable:!0})},a=(n,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!N.call(n,i)&&i!==r&&o(n,i,{get:()=>e[i],enumerable:!(c=p(e,i))||c.enumerable});return n};var v=(n,e,r)=>(r=n!=null?m(w(n)):{},a(e||!n||!n.__esModule?o(r,\"default\",{value:n,enumerable:!0}):r,n)),_=n=>a(o({},\"__esModule\",{value:!0}),n);var u=b((O,h)=>{h.exports=_jsx_runtime});var M={};k(M,{default:()=>j});var t=v(u());var s=MDXCodeBlock;var d=`/**\n * @param {Function} func\n * @returns Function\n */\nexport default function memoize(func) {\n  const cache = new Map();\n\n  return function (...args) {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n\n    const result = func.apply(this, args);\n    cache.set(key, result);\n\n    return result;\n  };\n}\n`;var l=`type Fn<T> = (this: any, ...args: Array<any>) => T;\n\nexport default function memoize<T>(func: Fn<T>): Fn<T> {\n  const cache = new Map<string, T>();\n\n  return function (this: any, ...args) {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n\n    const result = func.apply(this, args);\n    cache.set(key, result);\n\n    return result;\n  };\n}\n`;var f=`/**\n * @param {Function} func\n * @returns Function\n */\nexport default function memoize(func) {\n  const cache = new Trie();\n\n  return function (...args) {\n    if (cache.has(args)) {\n      return cache.get(args);\n    }\n\n    const result = func.apply(this, args);\n    cache.set(args, result);\n\n    return result;\n  };\n}\n\nclass TrieNode {\n  constructor(value) {\n    this._value = value;\n    this._nodes = new Map();\n  }\n\n  getValue() {\n    return this._value;\n  }\n\n  setValue(value) {\n    this._value = value;\n  }\n\n  hasKey(nodeKey) {\n    return this._nodes.has(nodeKey);\n  }\n\n  getNode(nodeKey) {\n    return this._nodes.get(nodeKey);\n  }\n\n  addNode(nodeKey) {\n    const newNode = new TrieNode();\n    this._nodes.set(nodeKey, newNode);\n    return newNode;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this._rootNode = new TrieNode();\n    this._hasValueForUndefined = false;\n  }\n\n  set(args, value) {\n    if (args.length === 0) {\n      if (this._hasValueForUndefined) {\n        return this._rootNode.getValue();\n      }\n\n      this._hasValueForUndefined = true;\n      this._rootNode.setValue(value);\n      return;\n    }\n\n    let currNode = this._rootNode;\n    for (const arg of args) {\n      if (currNode.hasKey(arg)) {\n        currNode = currNode.getNode(arg);\n      } else {\n        currNode = currNode.addNode(arg);\n      }\n    }\n\n    currNode.setValue(value);\n  }\n\n  has(args) {\n    if (args.length === 0) {\n      return this._hasValueForUndefined;\n    }\n\n    let currNode = this._rootNode;\n    for (const arg of args) {\n      if (!currNode.hasKey(arg)) {\n        return false;\n      }\n      currNode = currNode.getNode(arg);\n    }\n\n    return true;\n  }\n\n  get(args) {\n    if (args.length === 0) {\n      return this._rootNode.getValue();\n    }\n\n    let currNode = this._rootNode;\n    for (const arg of args) {\n      currNode = currNode.getNode(arg);\n    }\n\n    return currNode.getValue();\n  }\n}\n`;function g(n){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",code:\"code\",h4:\"h4\",ol:\"ol\",li:\"li\",ul:\"ul\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"The key to solving this question is to use a cache that stores the results for an input argument. If a cache entry exists for the input argument, return the cached result. Otherwise, call the function as per normal, put the result into the cache with the input argument as the key so that subsequent calls to the function with the same parameter will be a cache hit and return the value directly without calling the original function.\"}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 1: \",(0,t.jsx)(e.code,{children:\"Map\"}),\"-based cache and serialized arguments as cache key\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This question can be broken down into three parts:\"}),`\n`,(0,t.jsx)(e.h4,{children:\"Determining the cache key\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The cache key is a value that has a one-one relationship with the arguments that \",(0,t.jsx)(e.code,{children:\"func\"}),\" can be called with. Since the input types are strings and numbers, we can construct a unique key by concatenating them together.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A first attempt at constructing a hash function for the arguments could be doing \",(0,t.jsx)(e.code,{children:\"args.join('_')\"}),\" (or some other token) but this has a few issues:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If the string contains \",(0,t.jsx)(e.code,{children:\"_\"}),\", then there's a possibility of non-unique hashes. E.g. both \",(0,t.jsx)(e.code,{children:\"['hello_', 'world']\"}),\" and \",(0,t.jsx)(e.code,{children:\"['hello', '_world']\"}),\" will result in \",(0,t.jsx)(e.code,{children:\"hello_world\"}),\" as the key.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Numbers aren't differentiated from strings. E.g. both \",(0,t.jsx)(e.code,{children:\"['1', 'foo']\"}),\" and \",(0,t.jsx)(e.code,{children:\"[1, 'foo']\"}),\" will result in \",(0,t.jsx)(e.code,{children:\"1_foo\"}),\" as the key.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Hashing is tricky business, and one built-in function we can use is \",(0,t.jsx)(e.code,{children:\"JSON.stringify()\"}),\". It adds double quotes around strings, effectively differentiating numbers and strings, and correctly segments the parameters within the stringified result. Note that we can use \",(0,t.jsx)(e.code,{children:\"JSON.stringify()\"}),\" only because of the restriction on string and number inputs. If there are other types of inputs like \",(0,t.jsx)(e.code,{children:\"Set\"}),\", \",(0,t.jsx)(e.code,{children:\"JSON.stringify()\"}),\" by default turns them into \",(0,t.jsx)(e.code,{children:\"{}\"}),\" regardless of contents and will no longer produce a unique value for unique argument combinations.\"]}),`\n`,(0,t.jsx)(e.h4,{children:\"Deciding on a structure for the cache\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Cache lookups have to be fast, ideally with a O(1) time complexity. In JavaScript, objects and \",(0,t.jsx)(e.code,{children:\"Map\"}),\"s are able to serve the purpose of a fast lookup for a key and a corresponding value. Since the key is a string, we can use both objects and \",(0,t.jsx)(e.code,{children:\"Map\"}),\"s for the cache structure\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The returned function has access to the cache via closures. With closures, each unique memoized function instance will have its own cache.\"}),`\n`,(0,t.jsx)(e.h4,{children:\"Using the cache\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Before invoking the original function \",(0,t.jsx)(e.code,{children:\"func\"}),\", the memoized function first checks if the \",(0,t.jsx)(e.code,{children:\"cache\"}),\" already contains an entry for the current arguments (using the \",(0,t.jsx)(e.code,{children:\"JSON.stringify(args)\"}),\" as the key). This will result in one of the following two scenarios:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The cache contains an entry for \",(0,t.jsx)(e.code,{children:\"key\"}),\". A cached result exists, it means that the function has been called with the same arguments before, and there is no need to recompute the result. In this case, the memoized function simply returns the cached result using \",(0,t.jsx)(e.code,{children:\"cache.get(key)\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The cache does not contain an entry these \",(0,t.jsx)(e.code,{children:\"args\"}),\". If the cache does not contain a result for the current \",(0,t.jsx)(e.code,{children:\"args\"}),\", it means that the function is called with arguments that haven't been seen before. The memoized function then invokes the original function func using \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\". \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" is used to ensure that the context (\",(0,t.jsx)(e.code,{children:\"this\"}),\") of the original function is preserved when called from the memoized function. The arguments are passed to the original function \",(0,t.jsx)(e.code,{children:\"func\"}),\" and after computing the result using the original function, the memoized function stores the result in the cache by associating it with the corresponding key using \",(0,t.jsx)(e.code,{children:\"cache.set(key, result)\"}),\". Finally the memoized function returns the computed result.\"]}),`\n`]}),`\n`,(0,t.jsx)(s,{languages:{jsx:d,tsx:l}}),`\n`,(0,t.jsx)(e.h3,{children:\"Approach 2: Trie-based cache\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Instead of constructing a single string key out of the arguments, we can use individual argument item as nodes within a trie data structure. Here we implement a \",(0,t.jsx)(e.code,{children:\"Trie\"}),\" and \",(0,t.jsx)(e.code,{children:\"TrieNode\"}),\" class with the same relevant \",(0,t.jsx)(e.code,{children:\"set\"}),\", \",(0,t.jsx)(e.code,{children:\"has\"}),\", \",(0,t.jsx)(e.code,{children:\"get\"}),\" APIs as \",(0,t.jsx)(e.code,{children:\"Map\"}),\" and can just change the cache initialization step and have the rest of the code remain the same. The benefit of using a trie as the cache is lesser memory space needed, but lookup time complexity is around the same as the \",(0,t.jsx)(e.code,{children:\"JSON.stringify\"}),\" version.\"]}),`\n`,(0,t.jsx)(s,{children:f}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"In practice, functions can take in arguments of varying types beyond strings and numbers, so the current \",(0,t.jsx)(e.code,{children:\"memoize\"}),\" implementation wouldn't be sufficient for those cases.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"While \",(0,t.jsx)(e.code,{children:\"this\"}),\" can be accessed without issues, the results are memoized solely on the input arguments, the same memoized result is returned for the same input arguments even if the \",(0,t.jsx)(e.code,{children:\"this\"}),\" value is different between calls.\"]}),`\n`]})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(g,n)})):g(n)}var j=F;return _(M);})();\n;return Component;",
  "workspace": {
    "main": "/src/memoize-ii.ts",
    "run": "/src/memoize-ii.run.test.ts",
    "submit": "/src/memoize-ii.submit.test.ts"
  }
}