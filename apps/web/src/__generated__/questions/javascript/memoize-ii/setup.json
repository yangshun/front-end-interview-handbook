{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/memoize-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/memoize-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/memoize-ii.run.test.ts": "import memoize from './memoize-ii';\n\ndescribe('memoize', () => {\n  test('returns a function', () => {\n    const memoizedFn = memoize(() => {});\n    expect(typeof memoizedFn).toBe('function');\n  });\n\n  test('no arguments', () => {\n    let count = 0;\n    function foo() {\n      count++;\n      return 'booya';\n    }\n    const memoizedFn = memoize(foo);\n    expect(count).toBe(0);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n  });\n\n  test('single argument', () => {\n    let count = 0;\n    function double(x: number): number {\n      count++;\n      return x * 2;\n    }\n    const memoizedFn = memoize(double);\n    expect(count).toBe(0);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(1);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(1);\n    expect(memoizedFn(3)).toBe(6);\n    expect(count).toBe(2);\n    expect(memoizedFn(3)).toBe(6);\n    expect(count).toBe(2);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(2);\n  });\n\n  test('two arguments', () => {\n    let count = 0;\n    function mul(a: number, b: number) {\n      count++;\n      return a * b;\n    }\n    const memoizedFn = memoize(mul);\n    expect(count).toBe(0);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(1);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(1);\n    expect(memoizedFn(3, 7)).toBe(21);\n    expect(count).toBe(2);\n    expect(memoizedFn(3, 7)).toBe(21);\n    expect(count).toBe(2);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(2);\n  });\n});\n",
    "/src/memoize-ii.submit.test.ts": "import memoize from './memoize-ii';\n\ndescribe('memoize', () => {\n  test('returns a function', () => {\n    const memoizedFn = memoize(() => {});\n    expect(typeof memoizedFn).toBe('function');\n  });\n\n  test('no arguments', () => {\n    let count = 0;\n    function foo() {\n      count++;\n      return 'booya';\n    }\n    const memoizedFn = memoize(foo);\n    expect(count).toBe(0);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n    expect(memoizedFn()).toBe('booya');\n    expect(count).toBe(1);\n  });\n\n  test('single argument', () => {\n    let count = 0;\n    function double(x: number): number {\n      count++;\n      return x * 2;\n    }\n    const memoizedFn = memoize(double);\n    expect(count).toBe(0);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(1);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(1);\n    expect(memoizedFn(3)).toBe(6);\n    expect(count).toBe(2);\n    expect(memoizedFn(3)).toBe(6);\n    expect(count).toBe(2);\n    expect(memoizedFn(1)).toBe(2);\n    expect(count).toBe(2);\n  });\n\n  test('two arguments', () => {\n    let count = 0;\n    function mul(a: number, b: number) {\n      count++;\n      return a * b;\n    }\n    const memoizedFn = memoize(mul);\n    expect(count).toBe(0);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(1);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(1);\n    expect(memoizedFn(3, 7)).toBe(21);\n    expect(count).toBe(2);\n    expect(memoizedFn(3, 7)).toBe(21);\n    expect(count).toBe(2);\n    expect(memoizedFn(3, 4)).toBe(12);\n    expect(count).toBe(2);\n  });\n\n  test('strings', () => {\n    let count = 0;\n    function repeat(x: string) {\n      count++;\n      return x + x;\n    }\n    const memoizedFn = memoize(repeat);\n    expect(count).toBe(0);\n    expect(memoizedFn('foo')).toBe('foofoo');\n    expect(count).toBe(1);\n    expect(memoizedFn('foo')).toBe('foofoo');\n    expect(count).toBe(1);\n    expect(memoizedFn('bar')).toBe('barbar');\n    expect(count).toBe(2);\n    expect(memoizedFn('bar')).toBe('barbar');\n    expect(count).toBe(2);\n    expect(memoizedFn('foo')).toBe('foofoo');\n    expect(count).toBe(2);\n  });\n\n  test('differentiates strings and numbers', () => {\n    let count = 0;\n    function identity<T>(x: T): T {\n      count++;\n      return x;\n    }\n    const memoizedFn = memoize(identity);\n    expect(count).toBe(0);\n    expect(memoizedFn('1')).toBe('1');\n    expect(count).toBe(1);\n    expect(memoizedFn('1')).toBe('1');\n    expect(count).toBe(1);\n    expect(memoizedFn(1)).toBe(1);\n    expect(count).toBe(2);\n    expect(memoizedFn(1)).toBe(1);\n    expect(count).toBe(2);\n  });\n\n  describe('variadic arguments', () => {\n    test('arguments of same type', () => {\n      let count = 0;\n      function product(...args: Array<number>) {\n        count++;\n        return args.reduce((acc, num) => acc * num, 1);\n      }\n      const memoizedFn = memoize(product);\n      expect(count).toBe(0);\n      expect(memoizedFn(3, 4, 5)).toBe(60);\n      expect(count).toBe(1);\n      expect(memoizedFn(3, 4, 5)).toBe(60);\n      expect(count).toBe(1);\n      expect(memoizedFn(4, 5, 6, 7)).toBe(840);\n      expect(count).toBe(2);\n      expect(memoizedFn(4, 5, 6, 7)).toBe(840);\n      expect(count).toBe(2);\n      expect(memoizedFn(3, 4, 5)).toBe(60);\n      expect(count).toBe(2);\n    });\n\n    test('arguments of different type', () => {\n      let count = 0;\n      function repeat(str: string, times: number) {\n        count++;\n        return Array(times).fill(str).join('');\n      }\n      const memoizedFn = memoize(repeat);\n      expect(count).toBe(0);\n      expect(memoizedFn('abc', 3)).toBe('abcabcabc');\n      expect(count).toBe(1);\n      expect(memoizedFn('abc', 3)).toBe('abcabcabc');\n      expect(count).toBe(1);\n      expect(memoizedFn('bar', 2)).toBe('barbar');\n      expect(count).toBe(2);\n      expect(memoizedFn('bar', 2)).toBe('barbar');\n      expect(count).toBe(2);\n      expect(memoizedFn('abc', 3)).toBe('abcabcabc');\n      expect(count).toBe(2);\n    });\n  });\n\n  test('can access `this`', () => {\n    let count = 0;\n    function mul(this: any, x: number) {\n      count++;\n      return this.age * x;\n    }\n    const person = {\n      age: 42,\n      mul: memoize(mul),\n    };\n    expect(count).toBe(0);\n    expect(person.mul(2)).toBe(84);\n    expect(count).toBe(1);\n    expect(person.mul(2)).toBe(84);\n    expect(count).toBe(1);\n  });\n});\n",
    "/src/memoize-ii.ts": "type Fn<T> = (this: any, ...args: Array<any>) => T;\n\nexport default function memoize<T>(func: Fn<T>): Fn<T> {\n  const cache = new Map<string, T>();\n\n  return function (this: any, ...args) {\n    const key = JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n\n    const result = func.apply(this, args);\n    cache.set(key, result);\n\n    return result;\n  };\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Function} func\n * @returns Function\n */\nexport default function memoize(func) {\n  throw 'Not implemented';\n}",
    "ts": "type Fn<T> = (this: any, ...args: Array<any>) => T;\n\nexport default function memoize<T>(func: Fn<T>): Fn<T> {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/memoize-ii.ts",
    "run": "/src/memoize-ii.run.test.ts",
    "submit": "/src/memoize-ii.submit.test.ts"
  }
}