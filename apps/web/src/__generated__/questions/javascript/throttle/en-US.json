{
  "description": "var Component=(()=>{var s=Object.create;var c=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var i in e)c(n,i,{get:e[i],enumerable:!0})},a=(n,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!p.call(n,o)&&o!==i&&c(n,o,{get:()=>e[o],enumerable:!(l=m(e,o))||l.enumerable});return n};var w=(n,e,i)=>(i=n!=null?s(f(n)):{},a(e||!n||!n.__esModule?c(i,\"default\",{value:n,enumerable:!0}):i,n)),x=n=>a(c({},\"__esModule\",{value:!0}),n);var h=b((k,r)=>{r.exports=_jsx_runtime});var y={};g(y,{default:()=>j,frontmatter:()=>v});var t=w(h()),v={title:\"Throttle\",excerpt:\"Implement a function to control the execution of a function by limiting how many times it can execute over time\"};function d(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Throttling is a technique used to control how many times we allow a function to be executed over time. When a JavaScript function is said to be throttled with a wait time of X milliseconds, it can only be invoked at most once every X milliseconds. The callback is invoked immediately and cannot be invoked again for the rest of the \",(0,t.jsx)(e.code,{children:\"wait\"}),\" duration.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement a \",(0,t.jsx)(e.code,{children:\"throttle\"}),\" function which accepts a callback function and a \",(0,t.jsx)(e.code,{children:\"wait\"}),\" duration. Calling \",(0,t.jsx)(e.code,{children:\"throttle()\"}),\" returns a function which throttled invocations of the callback function following the behavior described above.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\nfunction increment() {\n  i++;\n}\nconst throttledIncrement = throttle(increment, 100);\n\n// t = 0: Call throttledIncrement(). i is now 1.\nthrottledIncrement(); // i = 1\n\n// t = 50: Call throttledIncrement() again.\n//  i is still 1 because 100ms have not passed.\nthrottledIncrement(); // i = 1\n\n// t = 101: Call throttledIncrement() again. i is now 2.\n//  i can be incremented because it has been more than 100ms\n//  since the last throttledIncrement() call at t = 0.\nthrottledIncrement(); // i = 2\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Follow Up\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Throttle with cancel and leading/trailing options.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Reading\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://lodash.com/docs/4.17.15#throttle\",children:\"Throttle on Lodash Documentation\"})}),`\n`]})]})}function I(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var j=I;return x(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/throttle\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/throttle.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/throttle.run.test.ts": "import throttle from './throttle';\n\ndescribe('throttle', () => {\n  test('can be initialized', () => {\n    const increment = throttle(() => {}, 50);\n    expect(increment).toBeInstanceOf(Function);\n  });\n\n  test('invokes callback immediately', () => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 50);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n  });\n\n  test('throttles immediate invocations', () => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 50);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n    increment();\n    expect(i).toBe(1);\n  });\n\n  test('throttles delayed invocations', (done) => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 100);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n\n    setTimeout(() => {\n      increment();\n      expect(i).toBe(1);\n    }, 25);\n\n    setTimeout(() => {\n      increment();\n      expect(i).toBe(1);\n      done();\n    }, 50);\n  });\n});\n",
    "/src/throttle.submit.test.ts": "import throttle from './throttle';\n\ndescribe('throttle', () => {\n  test('can be initialized', () => {\n    const increment = throttle(() => {}, 50);\n    expect(increment).toBeInstanceOf(Function);\n  });\n\n  test('invokes callback immediately', () => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 50);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n  });\n\n  test('throttles immediate invocations', () => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 50);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n    increment();\n    expect(i).toBe(1);\n  });\n\n  test('throttles delayed invocations', (done) => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 100);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n\n    setTimeout(() => {\n      increment();\n      expect(i).toBe(1);\n    }, 25);\n\n    setTimeout(() => {\n      increment();\n      expect(i).toBe(1);\n      done();\n    }, 50);\n  });\n\n  test('uses arguments', () => {\n    let i = 21;\n    const increment = throttle((a, b) => {\n      i += a * b;\n    }, 50);\n\n    expect(i).toBe(21);\n    increment(3, 7);\n    expect(i).toBe(42);\n  });\n\n  test('can be called again after first throttling window', (done) => {\n    let i = 0;\n    const increment = throttle(() => {\n      i++;\n    }, 100);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(1);\n\n    // Should not fire yet.\n    setTimeout(() => {\n      expect(i).toBe(1);\n      increment();\n      expect(i).toBe(1);\n    }, 50);\n\n    setTimeout(() => {\n      expect(i).toBe(1);\n      increment();\n      expect(i).toBe(2);\n    }, 150);\n\n    setTimeout(() => {\n      expect(i).toBe(2);\n      increment();\n      expect(i).toBe(2);\n      done();\n    }, 200);\n  });\n\n  test('callbacks can access `this`', (done) => {\n    const increment = throttle(function (delta) {\n      this.val += delta;\n    }, 50);\n\n    const obj = {\n      val: 2,\n      increment,\n    };\n\n    expect(obj.val).toBe(2);\n    obj.increment(3);\n    expect(obj.val).toBe(5);\n\n    setTimeout(() => {\n      obj.increment(10);\n      expect(obj.val).toBe(15);\n      done();\n    }, 100);\n  });\n});\n",
    "/src/throttle.ts": "type ThrottleFunction<T extends any[]> = (this: any, ...args: T) => any;\n\nexport default function throttle<T extends any[]>(\n  func: ThrottleFunction<T>,\n  wait: number,\n): ThrottleFunction<T> {\n  let shouldThrottle = false;\n\n  return function (...args) {\n    if (shouldThrottle) {\n      return;\n    }\n\n    shouldThrottle = true;\n    setTimeout(function () {\n      shouldThrottle = false;\n    }, wait);\n\n    func.apply(this, args);\n  };\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": "yangshun",
    "companies": [
      "google",
      "tiktok",
      "walmart",
      "yelp",
      "tiktok",
      "atlassian",
      "uber"
    ],
    "created": 1649894400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function to control the execution of a function by limiting how many times it can execute over time",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/throttle",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "debounce"
    ],
    "slug": "throttle",
    "subtitle": null,
    "title": "Throttle",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @callback func\n * @param {number} wait\n * @return {Function}\n */\nexport default function throttle(func, wait) {\n  throw 'Not implemented!';\n}",
    "ts": "type ThrottleFunction<T extends any[]> = (...args: T) => any;\n\nexport default function throttle<T extends any[]>(\n  func: ThrottleFunction<T>,\n  wait: number,\n): ThrottleFunction<T> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var T=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)l(t,i,{get:e[i],enumerable:!0})},r=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!v.call(t,o)&&o!==i&&l(t,o,{get:()=>e[o],enumerable:!(c=m(e,o))||c.enumerable});return t};var y=(t,e,i)=>(i=t!=null?p(w(t)):{},r(e||!t||!t.__esModule?l(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>r(l({},\"__esModule\",{value:!0}),t);var d=T((C,h)=>{h.exports=_jsx_runtime});var I={};b(I,{default:()=>A});var n=y(d());var a=MDXCodeBlock;var s=`/**\n * @callback func\n * @param {number} wait\n * @return {Function}\n */\nexport default function throttle(func, wait = 0) {\n  let shouldThrottle = false;\n\n  return function (...args) {\n    if (shouldThrottle) {\n      return;\n    }\n\n    shouldThrottle = true;\n    setTimeout(function () {\n      shouldThrottle = false;\n    }, wait);\n\n    func.apply(this, args);\n  };\n}\n`;var u=`type ThrottleFunction<T extends any[]> = (this: any, ...args: T) => any;\n\nexport default function throttle<T extends any[]>(\n  func: ThrottleFunction<T>,\n  wait: number,\n): ThrottleFunction<T> {\n  let shouldThrottle = false;\n\n  return function (...args) {\n    if (shouldThrottle) {\n      return;\n    }\n\n    shouldThrottle = true;\n    setTimeout(function () {\n      shouldThrottle = false;\n    }, wait);\n\n    func.apply(this, args);\n  };\n}\n`;function f(t){let e=Object.assign({p:\"p\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\",strong:\"strong\",code:\"code\",h3:\"h3\",ol:\"ol\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Throttle, along with \",(0,n.jsx)(e.a,{href:\"/questions/javascript/debounce\",children:\"debounce\"}),\", are among the most common front end interview questions; it's the front end equivalent of inverting a binary tree. Hence you should make sure that you are very familiar with both questions.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"A throttled function can be in two states: it's either:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Idle\"}),\": The throttled function was not invoked in the last \",(0,n.jsx)(e.code,{children:\"wait\"}),' duration. Calling the throttled function will immediately execute the callback function without any need to throttle. After this happens, the function enters the \"Active\" state.']}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Active\"}),\": The throttled function was invoked within the last \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration. Subsequent calls should not execute the callback function until \",(0,n.jsx)(e.code,{children:\"wait\"}),\" is over.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Given that there's a \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration before the function can be invoked again, we know that we will need a timer, and \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" is the first thing that comes to mind. Since there are only two states, we can use a \",(0,n.jsx)(e.code,{children:\"boolean\"}),\" variable to model the state.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We will also need to return a function which contains logic surrounding when to invoke the \",(0,n.jsx)(e.code,{children:\"func\"}),\". This function needs to do a few things:\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"1. Throttle invocation\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The callback function is invoked immediately and doesn't allow only invocations again until a duration of \",(0,n.jsx)(e.code,{children:\"wait\"}),\" has passed. As mentioned earlier, we can use a boolean variable \",(0,n.jsx)(e.code,{children:\"shouldThrottle\"}),\" to model the states.\"]}),`\n`,(0,n.jsx)(e.p,{children:'When the function is called in the \"Idle\" state, a few things are done:'}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"shouldThrottle\"}),\" is set to \",(0,n.jsx)(e.code,{children:\"true\"}),'. The function is now in the \"Active\" state.']}),`\n`,(0,n.jsxs)(e.li,{children:[\"Invoke \",(0,n.jsx)(e.code,{children:\"func\"}),\" with the appropriate arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" to schedule releasing of the lock (\",(0,n.jsx)(e.code,{children:\"shouldThrottle = false\"}),\") after \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"While the lock is active, calls to the throttled function will not invoke \",(0,n.jsx)(e.code,{children:\"func\"}),\" because of the \",(0,n.jsx)(e.code,{children:\"shouldThrottle\"}),\" check at the top of the function.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"2. Invoke \",(0,n.jsx)(e.code,{children:\"func\"}),\" with the appropriate arguments\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Throttled functions are used like the original functions, so we should forward the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" and function arguments when invoking the original callback functions.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Invoking the original callback function \",(0,n.jsx)(e.code,{children:\"func\"}),\" has to preserve the reference to \",(0,n.jsx)(e.code,{children:\"this\"}),\". Therefore:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Arrow functions cannot be used to declare the inner function due to lexical binding of \",(0,n.jsx)(e.code,{children:\"this\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Invoking the original callback function via \",(0,n.jsx)(e.code,{children:\"func(...args)\"}),\" will not forward the correct \",(0,n.jsx)(e.code,{children:\"this\"}),\" reference and cannot be used.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Hence we have to use \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" which allows us to specify \",(0,n.jsx)(e.code,{children:\"this\"}),\" as the first argument:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"func.apply(thisArg, args)\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"func.call(thisArg, ...args)\"})}),`\n`]}),`\n`,(0,n.jsx)(a,{languages:{jsx:s,tsx:u}}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that there are many variations of \",(0,n.jsx)(e.code,{children:\"throttle\"}),\" and this implementation only covers the most common behavior. Some other variations:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Have \",(0,n.jsx)(e.code,{children:\"leading\"}),\" and \",(0,n.jsx)(e.code,{children:\"trailing\"}),\" options, including methods to \",(0,n.jsx)(e.code,{children:\"flush\"}),\" and \",(0,n.jsx)(e.code,{children:\"cancel\"}),\" delayed \",(0,n.jsx)(e.code,{children:\"func\"}),\" invocations, like \",(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/4.17.15#throttle\",children:[\"Lodash's \",(0,n.jsx)(e.code,{children:\"_.throttle\"})]}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Collect all the throttled invocations and spread them out by executing them at every \",(0,n.jsx)(e.code,{children:\"wait\"}),\" intervals in the future, respecting the rule that there can only be at most one invocation every \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration. In contrast, this current implementation ignores all throttled function invocations when the lock is active.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Closures.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"How \",(0,n.jsx)(e.code,{children:\"this\"}),\" works.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Invoking functions via \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://css-tricks.com/debouncing-throttling-explained-examples/\",children:\"Debouncing and Throttling Explained Through Examples\"})}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var A=j;return k(I);})();\n;return Component;",
  "workspace": {
    "main": "/src/throttle.ts",
    "run": "/src/throttle.run.test.ts",
    "submit": "/src/throttle.submit.test.ts"
  }
}