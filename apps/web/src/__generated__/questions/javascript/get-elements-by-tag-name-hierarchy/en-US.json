{
  "description": "var Component=(()=>{var h=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var l in e)a(t,l,{get:e[l],enumerable:!0})},c=(t,e,l,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!g.call(t,r)&&r!==l&&a(t,r,{get:()=>e[r],enumerable:!(i=m(e,r))||i.enumerable});return t};var b=(t,e,l)=>(l=t!=null?h(u(t)):{},c(e||!t||!t.__esModule?a(l,\"default\",{value:t,enumerable:!0}):l,t)),w=t=>c(a({},\"__esModule\",{value:!0}),t);var d=f((A,o)=>{o.exports=_jsx_runtime});var N={};y(N,{default:()=>v,frontmatter:()=>E});var n=b(d()),E={title:\"getElementsByTagNameHierarchy\",excerpt:\"Implement a function to get all DOM elements that match a tag hierarchy\"};function s(t){let e=Object.assign({p:\"p\",code:\"code\",a:\"a\",ul:\"ul\",li:\"li\",ol:\"ol\",h2:\"h2\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"getElementsByTagName()\"}),\" method exists on the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByTagName\",children:(0,n.jsx)(e.code,{children:\"Document\"})}),\" and \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\",children:(0,n.jsx)(e.code,{children:\"Element\"})}),\" objects and returns an \",(0,n.jsx)(e.code,{children:\"HTMLCollection\"}),\" of descendant elements within the \",(0,n.jsx)(e.code,{children:\"Document\"}),\"/\",(0,n.jsx)(e.code,{children:\"Element\"}),\" given a tag name.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"It will be useful to find tags that follow a certain ancestor hierarchy. This is already possible by using \",(0,n.jsx)(e.code,{children:\"document.querySelectorAll()\"}),\", e.g. \",(0,n.jsx)(e.code,{children:\"document.querySelectorAll('div span')\"}),\" which finds all the \",(0,n.jsx)(e.code,{children:\"<span>\"}),\"s that are descendants (not necessarily direct) of a \",(0,n.jsx)(e.code,{children:\"<div>\"}),\" within the \",(0,n.jsx)(e.code,{children:\"document\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"getElementsByTagNameHierarchy()\"}),\", that with a similar functionality, but with some differences:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"A pure function which takes in two parameters:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"document\"}),\" object to search within.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"A string consisting of a space-delimited list of tags. Note that there can be an arbitrary number of tags. If only one tag is specified, the function behaves like \",(0,n.jsx)(e.code,{children:\"getElementByTagName()\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Returns an array of \",(0,n.jsx)(e.code,{children:\"Element\"}),\"s, instead of an \",(0,n.jsx)(e.code,{children:\"HTMLCollection\"}),\" of \",(0,n.jsx)(e.code,{children:\"Element\"}),\"s.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"E.g. \",(0,n.jsx)(e.code,{children:\"getElementsByTagNameHierarchy(document, 'div span')\"}),\" and returns an array of elements matching that selector within the \",(0,n.jsx)(e.code,{children:\"document\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Do not use \",(0,n.jsx)(e.code,{children:\"document.querySelectorAll()\"}),\" which will otherwise make the problem trivial. You will not be allowed to use it during real interviews.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const doc = new DOMParser().parseFromString(\n  \\`<div>\n    <span id=\"foo\">\n      <span id=\"bar\">Bar</span>\n      Foo\n    </span>\n    <p>Paragraph</p>\n    <span id=\"baz\">Baz</span>\n  </div>\\`,\n  'text/html',\n);\n\ngetElementsByTagNameHierarchy(doc, 'div span');\n// [span#foo, span#bar, span#baz] <-- This is an array of elements.\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\",children:\"Document: querySelectorAll() method - Web APIs | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\",children:\"Element: getElementsByTagName() method - Web APIs | MDN\"})}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(s,t)})):s(t)}var v=T;return w(N);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/get-elements-by-tag-name-hierarchy\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/get-elements-by-tag-name-hierarchy.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"esnext\"\n  }\n}\n",
    "/src/get-elements-by-tag-name-hierarchy.run.test.ts": "import getElementsByTagNameHierarchy from './get-elements-by-tag-name-hierarchy';\n\nfunction checkResults(expected: NodeListOf<Element>, received: Array<Element>) {\n  expect(received.length).toBe(expected.length);\n  // Inefficient O(n^2) check so that order doesn't matter.\n  for (let i = 0; i < expected.length; i++) {\n    expect(received.some((node) => node.isEqualNode(expected[i]))).toBe(true);\n  }\n}\n\ndescribe('getElementsByTagNameHierarchy()', () => {\n  test('empty tree', () => {\n    const doc = new DOMParser().parseFromString(``, 'text/html');\n    const els = getElementsByTagNameHierarchy(doc, 'div');\n    const expected = doc.querySelectorAll('div');\n\n    checkResults(expected, els);\n  });\n\n  test('single element with no nodes', () => {\n    const doc = new DOMParser().parseFromString(`<div></div>`, 'text/html');\n\n    const els = getElementsByTagNameHierarchy(doc, 'div');\n    const expected = doc.querySelectorAll('div');\n\n    checkResults(expected, els);\n  });\n\n  describe('single layer', () => {\n    test('single descendant node', () => {\n      const doc = new DOMParser().parseFromString(\n        `<div><span></span></div>`,\n        'text/html',\n      );\n\n      const els = getElementsByTagNameHierarchy(doc, 'div span');\n      const expected = doc.querySelectorAll('div span');\n\n      checkResults(expected, els);\n    });\n\n    test('multiple matching descendant nodes', () => {\n      const doc = new DOMParser().parseFromString(\n        `<div>\n          <span>Span</span>\n          <p>Paragraph</p>\n          <span>Span 2</span>\n        </div>`,\n        'text/html',\n      );\n\n      const els = getElementsByTagNameHierarchy(doc, 'div span');\n      const expected = doc.querySelectorAll('div span');\n\n      checkResults(expected, els);\n    });\n  });\n\n  test('non-existent tags', () => {\n    const doc = new DOMParser().parseFromString(\n      `<div>\n        <span>Span</span>\n        <p>Paragraph</p>\n        <div></div>\n      </div>`,\n      'text/html',\n    );\n\n    const els = getElementsByTagNameHierarchy(doc, 'img');\n    const expected = doc.querySelectorAll('img');\n\n    checkResults(expected, els);\n  });\n\n  test('ignores comment nodes', () => {\n    const doc = new DOMParser().parseFromString(\n      `<div>\n        <!-- Here's a comment -->\n        <div>Hello</div>\n      </div>`,\n      'text/html',\n    );\n\n    const els = getElementsByTagNameHierarchy(doc, 'div');\n    const expected = doc.querySelectorAll('div');\n\n    checkResults(expected, els);\n  });\n});\n",
    "/src/get-elements-by-tag-name-hierarchy.submit.test.ts": "import getElementsByTagNameHierarchy from './get-elements-by-tag-name-hierarchy';\n\nfunction checkResults(expected: NodeListOf<Element>, received: Array<Element>) {\n  expect(received.length).toBe(expected.length);\n  // Inefficient O(n^2) check so that order doesn't matter.\n  for (let i = 0; i < expected.length; i++) {\n    expect(received.some((node) => node.isEqualNode(expected[i]))).toBe(true);\n  }\n}\n\ndescribe('getElementsByTagNameHierarchy()', () => {\n  test('empty tree', () => {\n    const doc = new DOMParser().parseFromString(``, 'text/html');\n    const els = getElementsByTagNameHierarchy(doc, 'div');\n    const expected = doc.querySelectorAll('div');\n\n    checkResults(expected, els);\n  });\n\n  test('single element with no nodes', () => {\n    const doc = new DOMParser().parseFromString(`<div></div>`, 'text/html');\n\n    const els = getElementsByTagNameHierarchy(doc, 'div');\n    const expected = doc.querySelectorAll('div');\n\n    checkResults(expected, els);\n  });\n\n  describe('varying tag token length', () => {\n    describe('one tag', () => {\n      test('no match', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span></span>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'p');\n        const expected = doc.querySelectorAll('p');\n        checkResults(expected, els);\n      });\n\n      test('one match', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span></span>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'span');\n        const expected = doc.querySelectorAll('span');\n        checkResults(expected, els);\n      });\n\n      test('two matches', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span></span>\n            <p></p>\n            <span></span>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'span');\n        const expected = doc.querySelectorAll('span');\n        checkResults(expected, els);\n      });\n\n      test('inner matches', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span>\n              <span></span>\n            </span>\n            <p></p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'span');\n        const expected = doc.querySelectorAll('span');\n        checkResults(expected, els);\n      });\n\n      test('inner matches deep', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span>\n              <span></span>\n            </span>\n            <p>\n              <span>\n                <span></span>\n              </span>\n            </p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'span');\n        const expected = doc.querySelectorAll('span');\n        checkResults(expected, els);\n      });\n    });\n\n    describe('two tags', () => {\n      test('no match', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span></span>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'span div');\n        const expected = doc.querySelectorAll('span div');\n        checkResults(expected, els);\n      });\n\n      test('one match', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span></span>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'div span');\n        const expected = doc.querySelectorAll('div span');\n        checkResults(expected, els);\n      });\n\n      test('two matches', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span></span>\n            <p></p>\n            <span></span>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'div span');\n        const expected = doc.querySelectorAll('div span');\n        checkResults(expected, els);\n      });\n\n      test('inner matches', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span>\n              <span></span>\n            </span>\n            <p></p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'div span');\n        const expected = doc.querySelectorAll('div span');\n        checkResults(expected, els);\n      });\n\n      test('inner matches deep', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span>\n              <span></span>\n            </span>\n            <p>\n              <span>\n                <span></span>\n              </span>\n            </p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'p span');\n        const expected = doc.querySelectorAll('p span');\n        checkResults(expected, els);\n      });\n\n      test('inner matches deep same tag', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span>\n              <span></span>\n            </span>\n            <p>\n              <span>\n                <span></span>\n              </span>\n            </p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'span span');\n        const expected = doc.querySelectorAll('span span');\n        checkResults(expected, els);\n      });\n    });\n\n    describe('three tags', () => {\n      test('no match', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <p>\n              <span></span>\n            </p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'div span p');\n        const expected = doc.querySelectorAll('div span p');\n        checkResults(expected, els);\n      });\n\n      test('one match', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <p>\n              <span></span>\n            </p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'div p span');\n        const expected = doc.querySelectorAll('div p span');\n        checkResults(expected, els);\n      });\n\n      test('two matches', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <p>\n              <span></span>\n            </p>\n            <p>\n              <span></span>\n            </p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'div p span');\n        const expected = doc.querySelectorAll('div p span');\n        checkResults(expected, els);\n      });\n\n      test('inner matches', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span>\n              <span></span>\n            </span>\n            <p></p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'div span span');\n        const expected = doc.querySelectorAll('div span span');\n        checkResults(expected, els);\n      });\n\n      test('inner matches deep', () => {\n        const doc = new DOMParser().parseFromString(\n          `<div>\n            <span>\n              <span></span>\n            </span>\n            <p>\n              <span>\n                <span></span>\n              </span>\n            </p>\n          </div>`,\n          'text/html',\n        );\n\n        const els = getElementsByTagNameHierarchy(doc, 'div p span');\n        const expected = doc.querySelectorAll('div p span');\n        checkResults(expected, els);\n      });\n    });\n  });\n\n  test('huge DOM tree', () => {\n    const doc = new DOMParser().parseFromString(\n      `<div>\n        <span>Span</span>\n        <p>Paragraph</p>\n        <div>\n          <div>\n            <p>\n              <div>\n                <div>\n                  <span></span>\n                  <div>\n                    <div>\n                    </div>\n                  </div>\n                </div>\n              </div>\n            </p>\n          </div>\n        </div>\n        <div>\n          <div>\n            <div>\n              <p>\n                <div>\n                  <span></span>\n                  <div>\n                    <div>\n                      <div>\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </p>\n            </div>\n          </div>\n        </div>`,\n      'text/html',\n    );\n\n    checkResults(\n      doc.querySelectorAll('div div'),\n      getElementsByTagNameHierarchy(doc, 'div div'),\n    );\n    checkResults(\n      doc.querySelectorAll('span'),\n      getElementsByTagNameHierarchy(doc, 'span'),\n    );\n    checkResults(\n      doc.querySelectorAll('div p'),\n      getElementsByTagNameHierarchy(doc, 'div p'),\n    );\n    checkResults(\n      doc.querySelectorAll('div p span'),\n      getElementsByTagNameHierarchy(doc, 'div p span'),\n    );\n    checkResults(\n      doc.querySelectorAll('div div span'),\n      getElementsByTagNameHierarchy(doc, 'div div span'),\n    );\n    checkResults(\n      doc.querySelectorAll('p span'),\n      getElementsByTagNameHierarchy(doc, 'p span'),\n    );\n    checkResults(\n      doc.querySelectorAll('div p div span'),\n      getElementsByTagNameHierarchy(doc, 'div p div span'),\n    );\n  });\n\n  test('ignores comment nodes', () => {\n    const doc = new DOMParser().parseFromString(\n      `<div>\n        <!-- Here's a comment -->\n        <div>Hello</div>\n      </div>`,\n      'text/html',\n    );\n\n    const els = getElementsByTagNameHierarchy(doc, 'div');\n    const expected = doc.querySelectorAll('div');\n\n    checkResults(expected, els);\n  });\n\n  test('mixed case tag names', () => {\n    const doc = new DOMParser().parseFromString(\n      `<div>\n          <span>Span</span>\n          <p>Paragraph</p>\n          <div>\n            <div>\n              <span>Hello</span>\n            </div>\n          </div>\n        </div>\n        <div>Hello</div>`,\n      'text/html',\n    );\n\n    const divs = getElementsByTagNameHierarchy(doc, 'DIV div');\n    const expectedDivs = doc.querySelectorAll('DIV div'.toLocaleLowerCase());\n    checkResults(expectedDivs, divs);\n\n    const spans = getElementsByTagNameHierarchy(doc, 'div P sPaN');\n    const expectedSpans = doc.querySelectorAll(\n      'div P sPaN'.toLocaleLowerCase(),\n    );\n    checkResults(expectedSpans, spans);\n  });\n});\n",
    "/src/get-elements-by-tag-name-hierarchy.ts": "export default function getElementsByTagNameHierarchy(\n  document: Document,\n  tagNames: string,\n): Array<Element> {\n  const results: Array<Element> = [];\n  const tagTokens = tagNames.toUpperCase().trim().split(/\\s+/);\n  const lastIndex = tagTokens.length - 1;\n\n  if (tagTokens.length === 0) {\n    return results;\n  }\n\n  function traverse(el: Element, tagTokenIndex: number) {\n    if (el == null) {\n      return;\n    }\n\n    const currentTagToken = tagTokens[tagTokenIndex];\n    const elementMatchesCurrentTag = el.tagName === currentTagToken;\n    const isLastTag = tagTokenIndex === lastIndex;\n\n    if (elementMatchesCurrentTag && isLastTag) {\n      results.push(el);\n    }\n\n    const nextIndex = elementMatchesCurrentTag\n      ? Math.min(tagTokenIndex + 1, lastIndex) // So as not to increment past the last index.\n      : tagTokenIndex;\n\n    for (const child of el.children) {\n      traverse(child, nextIndex);\n    }\n  }\n\n  traverse(document.body, 0);\n\n  return results;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [
      "dropbox"
    ],
    "created": 1723766400,
    "difficulty": "hard",
    "duration": 30,
    "excerpt": "Implement a function to get all DOM elements that match a tag hierarchy",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/get-elements-by-tag-name-hierarchy",
    "importance": "low",
    "languages": [
      "html",
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "get-elements-by-class-name",
      "get-elements-by-style",
      "get-elements-by-tag-name"
    ],
    "slug": "get-elements-by-tag-name-hierarchy",
    "subtitle": null,
    "title": "getElementsByTagNameHierarchy",
    "topics": [
      "web-api"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Document} document\n * @param {string} tagNames\n * @return {Array<Element>}\n */\nexport default function getElementsByTagNameHierarchy(document, tagNames) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function getElementsByTagNameHierarchy(\n  document: Document,\n  tagNames: string,\n): Array<Element> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var s=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var k=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var N=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),E=(t,e)=>{for(var a in e)s(t,a,{get:e[a],enumerable:!0})},c=(t,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!x.call(t,r)&&r!==a&&s(t,r,{get:()=>e[r],enumerable:!(l=T(e,r))||l.enumerable});return t};var b=(t,e,a)=>(a=t!=null?f(k(t)):{},c(e||!t||!t.__esModule?s(a,\"default\",{value:t,enumerable:!0}):a,t)),v=t=>c(s({},\"__esModule\",{value:!0}),t);var h=N((S,o)=>{o.exports=_jsx_runtime});var D={};E(D,{default:()=>C});var n=b(h());var i=MDXCodeBlock;var d=`/**\n * @param {Document} document\n * @param {string} tagNames\n * @return {Array<Element>}\n */\nexport default function getElementsByTagNameHierarchy(document, tagNames) {\n  const results = [];\n  const tagTokens = tagNames.toUpperCase().trim().split(/\\\\s+/);\n  const lastIndex = tagTokens.length - 1;\n\n  if (tagTokens.length === 0) {\n    return results;\n  }\n\n  function traverse(el, tagTokenIndex) {\n    if (el == null) {\n      return;\n    }\n\n    const currentTagToken = tagTokens[tagTokenIndex];\n    const elementMatchesCurrentTag = el.tagName === currentTagToken;\n    const isLastTag = tagTokenIndex === lastIndex;\n\n    if (elementMatchesCurrentTag && isLastTag) {\n      results.push(el);\n    }\n\n    const nextIndex = elementMatchesCurrentTag\n      ? Math.min(tagTokenIndex + 1, lastIndex) // So as not to increment past the last index.\n      : tagTokenIndex;\n\n    for (const child of el.children) {\n      traverse(child, nextIndex);\n    }\n  }\n\n  traverse(document.body, 0);\n\n  return results;\n}\n`;var g=`export default function getElementsByTagNameHierarchy(\n  document: Document,\n  tagNames: string,\n): Array<Element> {\n  const results: Array<Element> = [];\n  const tagTokens = tagNames.toUpperCase().trim().split(/\\\\s+/);\n  const lastIndex = tagTokens.length - 1;\n\n  if (tagTokens.length === 0) {\n    return results;\n  }\n\n  function traverse(el: Element, tagTokenIndex: number) {\n    if (el == null) {\n      return;\n    }\n\n    const currentTagToken = tagTokens[tagTokenIndex];\n    const elementMatchesCurrentTag = el.tagName === currentTagToken;\n    const isLastTag = tagTokenIndex === lastIndex;\n\n    if (elementMatchesCurrentTag && isLastTag) {\n      results.push(el);\n    }\n\n    const nextIndex = elementMatchesCurrentTag\n      ? Math.min(tagTokenIndex + 1, lastIndex) // So as not to increment past the last index.\n      : tagTokenIndex;\n\n    for (const child of el.children) {\n      traverse(child, nextIndex);\n    }\n  }\n\n  traverse(document.body, 0);\n\n  return results;\n}\n`;var m=`/**\n * @param {Document} document\n * @param {string} tagNames\n * @return {Array<Element>}\n */\nexport default function getElementsByTagNameHierarchy(document, tagNames) {\n  const tagTokens = tagNames.toUpperCase().trim().split(/\\\\s+/);\n\n  if (tagTokens.length === 0) {\n    return [];\n  }\n\n  const elements = [];\n  const lastTag = tagTokens[tagTokens.length - 1];\n\n  function findTag(el) {\n    if (el == null) {\n      return;\n    }\n\n    if (el.tagName === lastTag) {\n      elements.push(el);\n    }\n\n    for (const child of el.children) {\n      findTag(child);\n    }\n  }\n\n  findTag(document.body);\n\n  function checkAncestorHierarchy(el) {\n    let currentIndex = tagTokens.length - 1;\n    let currentEl = el;\n    let matchingElements = 0;\n\n    while (\n      currentEl != null &&\n      currentIndex >= 0 &&\n      matchingElements !== tagTokens.length\n    ) {\n      if (tagTokens[currentIndex] === currentEl.tagName) {\n        matchingElements++;\n        currentIndex--;\n      }\n\n      currentEl = currentEl.parentNode;\n    }\n\n    return matchingElements === tagTokens.length;\n  }\n\n  // Second step: check each tag's ancestor hierarchy and return the matching ones.\n  return elements.filter((el) => checkAncestorHierarchy(el));\n}\n`;var u=`export default function getElementsByTagNameHierarchy(\n  document: Document,\n  tagNames: string,\n): Array<Element> {\n  const tagTokens = tagNames.toUpperCase().trim().split(/\\\\s+/);\n\n  if (tagTokens.length === 0) {\n    return [];\n  }\n\n  const elements: Array<Element> = [];\n  const lastTag = tagTokens[tagTokens.length - 1];\n\n  function findMatchingTags(el: Element) {\n    if (el == null) {\n      return;\n    }\n\n    if (el.tagName === lastTag) {\n      elements.push(el);\n    }\n\n    for (const child of el.children) {\n      findMatchingTags(child);\n    }\n  }\n\n  // First step: find all the elements matching the last tag.\n  findMatchingTags(document.body);\n\n  function checkAncestorHierarchy(el: Element) {\n    let currentIndex = tagTokens.length - 1;\n    let currentEl: Node | null = el;\n    let matchingElements = 0;\n\n    while (\n      currentEl != null &&\n      currentIndex >= 0 &&\n      matchingElements !== tagTokens.length\n    ) {\n      if (\n        currentEl instanceof Element &&\n        tagTokens[currentIndex] === currentEl.tagName\n      ) {\n        matchingElements++;\n        currentIndex--;\n      }\n\n      currentEl = currentEl.parentNode;\n    }\n\n    return matchingElements === tagTokens.length;\n  }\n\n  // Second step: check each tag's ancestor hierarchy and return the matching ones.\n  return elements.filter((el) => checkAncestorHierarchy(el));\n}\n`;function p(t){let e=Object.assign({p:\"p\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",strong:\"strong\",h3:\"h3\",ol:\"ol\",h4:\"h4\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This solution assumes you have completed the \",(0,n.jsx)(e.a,{href:\"/questions/javascript/get-elements-by-tag-name\",children:\"getElementsByTagName\"}),\" question and fully understand its solution.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.a,{href:\"/questions/javascript/get-elements-by-tag-name\",children:\"getElementsByTagName\"}),\" question assesses you on basic DOM traversal APIs and recursion. This question is an advanced version where multiple tags can be specified.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Firstly, we need to note the following points, similar to \",(0,n.jsx)(e.a,{href:\"/questions/javascript/get-elements-by-tag-name\",children:\"getElementsByTagName\"}),\":\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Element.tagName\"}),\" returns an \",(0,n.jsx)(e.strong,{children:\"uppercase\"}),\" string of an element's tag name (e.g. \",(0,n.jsx)(e.code,{children:\"'DIV'\"}),\", \",(0,n.jsx)(e.code,{children:\"'SPAN'\"}),\"), so the tag name arguments have to be converted to be the same case before comparison.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Element.children\"}),\" which returns a live \",(0,n.jsx)(e.code,{children:\"HTMLCollection\"}),\" of the child elements. We use this over \",(0,n.jsx)(e.code,{children:\"Node.childNodes\"}),\" which returns a live \",(0,n.jsx)(e.code,{children:\"NodeList\"}),\" of child \",(0,n.jsx)(e.code,{children:\"Node\"}),\"s because \",(0,n.jsx)(e.code,{children:\"childNodes\"}),\" will include non-element nodes like text and comment nodes, which are not relevant in this question.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"However \",(0,n.jsx)(e.code,{children:\"HTMLCollection\"}),\" does not have \",(0,n.jsx)(e.code,{children:\".forEach\"}),\", so we have to iterate through it using traditional \",(0,n.jsx)(e.code,{children:\"for\"}),\" loops.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Approach 1: Top-down\"}),`\n`,(0,n.jsx)(e.p,{children:\"The solution approach can be broken down into two parts:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Splitting \",(0,n.jsx)(e.code,{children:\"tagNames\"}),\" into an array of tag name tokens.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Traversing the \",(0,n.jsx)(e.code,{children:\"document\"}),\" argument and finding elements that match the specified \",(0,n.jsx)(e.code,{children:\"tagNames\"}),\" hierarchy.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.h4,{children:[\"Splitting \",(0,n.jsx)(e.code,{children:\"tagNames\"}),\" (tokenization)\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"For this question, the \",(0,n.jsx)(e.code,{children:\"tagNames\"}),\" argument is quite flexible. It can:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Contain leading and trailing spaces.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Contain tags that are of any case \\u2013 lowercase, uppercase, mixed case. \",(0,n.jsx)(e.code,{children:\"document.querySelectorAll()\"}),\" is case-insensitive.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To tokenize the \",(0,n.jsx)(e.code,{children:\"tagNames\"}),\" string (identify the list of tag names accurately), we can:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Transform the string to uppercase via \",(0,n.jsx)(e.code,{children:\".toUpperCase()\"}),\" to handle any casing differences. Uppercase is chosen because \",(0,n.jsx)(e.code,{children:\"Element.tagName\"}),\" returns an uppercase string.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Trimming the string via \",(0,n.jsx)(e.code,{children:\".trim()\"}),\" to remove leading and trailing spaces.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Splitting the string via \",(0,n.jsx)(e.code,{children:\".split(/\\\\s+/)\"}),\" to split by whitespace, which can also split by consecutive whitespaces.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.h4,{children:[\"Traversing the \",(0,n.jsx)(e.code,{children:\"document\"}),\" to find matching elements\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The trickiest part of the problem is identifying the matching elements. The last tag in the list is the elements to be matched. All the tags before the last tag are for specifying the hierarchy.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// E.g. tagNames = 'div SPAN sPaN'\n// After tokenizing, tagTokens:\n[\n  'div', // hierarchy tag\n  'span', // hierarchy tag\n  'span', // element tag (to be matched)\n];\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Depth-first search (DFS) is used here because in DFS, for each node, the ancestors will be in its recursion stack. By making use of this fact, we can keep a pointer to the position within \",(0,n.jsx)(e.code,{children:\"tagTokens\"}),\" and if the current element's tag matches \",(0,n.jsx)(e.code,{children:\"tagTokens[tagTokenIndex]\"}),\", increment the index for the next traversal. Incrementing the index means that among the elements descendants, we only need to match the remaining tokens. However, we should not increment past the last index as the last index is a special one \\u2013 the last tag is the tag name to be matched.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"When \",(0,n.jsx)(e.code,{children:\"tagTokenIndex\"}),\" is the last index of \",(0,n.jsx)(e.code,{children:\"tagTokens\"}),\", any elements that match that tag are considered a match, and can be added to \",(0,n.jsx)(e.code,{children:\"results\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The traversal can be kicked off by using the \",(0,n.jsx)(e.code,{children:\"<body>\"}),\" element (via \",(0,n.jsx)(e.code,{children:\"document.body\"}),\") and a starting index of 0.\"]}),`\n`,(0,n.jsx)(i,{languages:{jsx:d,tsx:g}}),`\n`,(0,n.jsx)(e.h3,{children:\"Approach 2. Bottom-up\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"An alternative solution is to use the same approach as how browsers match selectors, by matching from the bottom-up. Browsers usually match selectors from right to left. This is more efficient because it allows the browser to quickly eliminate large sets of elements. For example, in the selector \",(0,n.jsx)(e.code,{children:\"div p\"}),\", the browser first finds all \",(0,n.jsx)(e.code,{children:\"<p>\"}),\" elements, then checks if they have a parent or ancestor that's a \",(0,n.jsx)(e.code,{children:\"<div>\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The first step is to find all the matching tags (the last tag in the list). This is essentially the \",(0,n.jsx)(e.a,{href:\"/questions/javascript/get-elements-by-tag-name\",children:\"getElementsByTagName\"}),\" question. For each of these tags, traverse the parent chain of nodes with \",(0,n.jsx)(e.code,{children:\"element.parentNode\"}),\" and check the ancestor hierarchy. This approach is clearer to understand but is longer to implement.\"]}),`\n`,(0,n.jsx)(i,{languages:{jsx:m,tsx:u}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Leading/trailing spaces in tag names string.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Additional spaces between tag names.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Non-lowercase tag name items.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Recursion\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"DOM APIs\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"How to check an \",(0,n.jsx)(e.code,{children:\"Element\"}),\"'s tag name\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"How to traverse an \",(0,n.jsx)(e.code,{children:\"Element\"}),\"'s children\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Element.tagName\"}),\" is uppercase (e.g. \",(0,n.jsx)(e.code,{children:\"'DIV'\"}),\", \",(0,n.jsx)(e.code,{children:\"'SPAN'\"}),\"), so be sure to use case-insensitive string comparisons.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\",children:\"Document: querySelectorAll() method - Web APIs | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\",children:\"Element: getElementsByTagName() method - Web APIs | MDN\"})}),`\n`]})]})}function B(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var C=B;return v(D);})();\n;return Component;",
  "workspace": {
    "main": "/src/get-elements-by-tag-name-hierarchy.ts",
    "run": "/src/get-elements-by-tag-name-hierarchy.run.test.ts",
    "submit": "/src/get-elements-by-tag-name-hierarchy.submit.test.ts"
  }
}