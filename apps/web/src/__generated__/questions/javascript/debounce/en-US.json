{
  "description": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var p=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var c in e)o(t,c,{get:e[c],enumerable:!0})},l=(t,e,c,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!f.call(t,i)&&i!==c&&o(t,i,{get:()=>e[i],enumerable:!(a=h(e,i))||a.enumerable});return t};var g=(t,e,c)=>(c=t!=null?u(b(t)):{},l(e||!t||!t.__esModule?o(c,\"default\",{value:t,enumerable:!0}):c,t)),v=t=>l(o({},\"__esModule\",{value:!0}),t);var s=p((_,d)=>{d.exports=_jsx_runtime});var j={};w(j,{default:()=>y,frontmatter:()=>x});var n=g(s()),x={title:\"Debounce\",excerpt:\"Implement a function to limit how many times a function can be executed by delaying the execution of the function until after a specified time after its last execution attempt\"};function r(t){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:'Debouncing is a technique used to control how many times we allow a function to be executed over time. When a JavaScript function is debounced with a wait time of X milliseconds, it must wait until after X milliseconds have elapsed since the debounced function was last called. You almost certainly have encountered debouncing in your daily lives before \\u2014 when entering an elevator. Only after X duration of not pressing the \"Door open\" button (the debounced function not being called) will the elevator door actually close (the callback function is executed).'}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"debounce\"}),\" function which accepts a callback function and a \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration. Calling \",(0,n.jsx)(e.code,{children:\"debounce()\"}),\" returns a function which has debounced invocations of the callback function following the behavior described above.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\nfunction increment() {\n  i++;\n}\nconst debouncedIncrement = debounce(increment, 100);\n\n// t = 0: Call debouncedIncrement().\ndebouncedIncrement(); // i = 0\n\n// t = 50: i is still 0 because 100ms have not passed.\n\n// t = 100: increment() was invoked and i is now 1.\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"debouncedIncrement()\"}),\" is called multiple times.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\nfunction increment() {\n  i++;\n}\nconst debouncedIncrement = debounce(increment, 100);\n\n// t = 0: Call debouncedIncrement().\ndebouncedIncrement(); // i = 0\n\n// t = 50: i is still 0 because 100ms have not passed.\n//  Call debouncedIncrement() again.\ndebouncedIncrement(); // i = 0\n\n// t = 100: i is still 0 because it has only\n//  been 50ms since the last debouncedIncrement() at t = 50.\n\n// t = 150: Because 100ms have passed since\n//  the last debouncedIncrement() at t = 50,\n//  increment was invoked and i is now 1 .\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Follow Up\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Debounce with a \",(0,n.jsx)(e.code,{children:\"cancel()\"}),\" method to cancel delayed invocations and a \",(0,n.jsx)(e.code,{children:\"flush()\"}),\" method to immediately invoke them.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Implement \",(0,n.jsx)(e.a,{href:\"/questions/javascript/throttle\",children:\"throttle\"}),\", which is similar to debounce but a little different.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://lodash.com/docs/4.17.15#debounce\",children:\"Debounce on Lodash Documentation\"})}),`\n`]})]})}function I(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(r,t)})):r(t)}var y=I;return v(j);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/debounce\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/debounce.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/debounce.run.test.ts": "import debounce from './debounce';\n\ndescribe('debounce', () => {\n  test('can be initialized', () => {\n    const increment = debounce(() => {}, 50);\n    expect(increment).toBeTruthy();\n  });\n\n  test('executes after duration', (done) => {\n    let i = 0;\n    const increment = debounce(() => {\n      i++;\n    }, 10);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(0);\n\n    setTimeout(() => {\n      expect(i).toBe(1);\n      done();\n    }, 20);\n  });\n});\n",
    "/src/debounce.submit.test.ts": "import debounce from './debounce';\n\ndescribe('debounce', () => {\n  test('can be initialized', () => {\n    const increment = debounce(() => {}, 50);\n    expect(increment).toBeTruthy();\n  });\n\n  test('executes after duration', (done) => {\n    let i = 0;\n    const increment = debounce(() => {\n      i++;\n    }, 10);\n\n    expect(i).toBe(0);\n    increment();\n    expect(i).toBe(0);\n\n    setTimeout(() => {\n      expect(i).toBe(1);\n      done();\n    }, 20);\n  });\n\n  describe('uses arguments', () => {\n    test('called once', (done) => {\n      let i = 21;\n      const increment = debounce((a: number, b: number) => {\n        i += a * b;\n      }, 10);\n\n      expect(i).toBe(21);\n      increment(3, 7);\n      expect(i).toBe(21);\n\n      setTimeout(() => {\n        expect(i).toBe(42);\n        done();\n      }, 20);\n    });\n\n    test('uses arguments of latest invocation', (done) => {\n      let i = 21;\n      const increment = debounce((a: number, b: number) => {\n        i += a * b;\n      }, 10);\n\n      expect(i).toBe(21);\n      increment(3, 7);\n      increment(4, 5);\n      expect(i).toBe(21);\n\n      setTimeout(() => {\n        expect(i).toBe(41);\n        done();\n      }, 20);\n    });\n  });\n\n  test('execute once even after calling it multiple times', (done) => {\n    let i = 0;\n    const increment = debounce(() => {\n      i++;\n    }, 20);\n\n    expect(i).toBe(0);\n    increment();\n    increment();\n    increment();\n    increment();\n    expect(i).toBe(0);\n\n    // Should not fire yet.\n    setTimeout(() => {\n      expect(i).toBe(0);\n    }, 10);\n\n    setTimeout(() => {\n      expect(i).toBe(1);\n      done();\n    }, 30);\n  });\n\n  test('duration extended if called again during window', (done) => {\n    let i = 0;\n    const increment = debounce(() => {\n      i++;\n    }, 100);\n\n    expect(i).toBe(0);\n    increment();\n    increment();\n    expect(i).toBe(0);\n\n    // Should not fire yet.\n    setTimeout(() => {\n      expect(i).toBe(0);\n      increment();\n      expect(i).toBe(0);\n    }, 50);\n\n    setTimeout(() => {\n      // Still 0 because we fired again at t=50, increment will only happen at t=150\n      expect(i).toBe(0);\n    }, 125);\n\n    setTimeout(() => {\n      expect(i).toBe(1);\n      done();\n      // Add a longer delay because the browser timer is unreliable.\n    }, 1500);\n  });\n\n  test('callbacks can access `this`', (done) => {\n    const increment = debounce(function (this: any, delta: number) {\n      this.val += delta;\n    }, 10);\n\n    const obj = {\n      val: 2,\n      increment,\n    };\n\n    expect(obj.val).toBe(2);\n    obj.increment(3);\n    expect(obj.val).toBe(2);\n\n    setTimeout(() => {\n      expect(obj.val).toBe(5);\n      done();\n    }, 20);\n  });\n});\n",
    "/src/debounce.ts": "export default function debounce(func: Function, wait: number = 0): Function {\n  let timeoutID: ReturnType<typeof setTimeout> | null = null;\n\n  return function (this: any, ...args: any[]) {\n    // Keep a reference to `this` so that\n    // func.apply() can access it.\n    const context = this;\n    clearTimeout(timeoutID ?? undefined);\n\n    timeoutID = setTimeout(function () {\n      timeoutID = null; // Not strictly necessary but good to do this.\n      func.apply(context, args);\n    }, wait);\n  };\n}\n"
  },
  "metadata": {
    "access": "free",
    "author": "yangshun",
    "companies": [
      "flipkart",
      "google",
      "lyft",
      "walmart",
      "yelp"
    ],
    "created": 1649894400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function to limit how many times a function can be executed by delaying the execution of the function until after a specified time after its last execution attempt",
    "featured": true,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/debounce",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "throttle",
      "debounce-ii",
      "holy-grail"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "throttle"
    ],
    "slug": "debounce",
    "subtitle": null,
    "title": "Debounce",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Function} func\n * @param {number} wait\n * @return {Function}\n */\nexport default function debounce(func, wait) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function debounce(func: Function, wait: number): Function {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),T=(t,e)=>{for(var i in e)c(t,i,{get:e[i],enumerable:!0})},a=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!v.call(t,o)&&o!==i&&c(t,o,{get:()=>e[o],enumerable:!(l=w(e,o))||l.enumerable});return t};var x=(t,e,i)=>(i=t!=null?p(b(t)):{},a(e||!t||!t.__esModule?c(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>a(c({},\"__esModule\",{value:!0}),t);var d=y((A,h)=>{h.exports=_jsx_runtime});var _={};T(_,{default:()=>C});var n=x(d());var r=MDXCodeBlock;var u=`/**\n * @param {Function} func\n * @param {number} wait\n * @return {Function}\n */\nexport default function debounce(func, wait = 0) {\n  let timeoutID = null;\n  return function (...args) {\n    // Keep a reference to \\`this\\` so that\n    // func.apply() can access it.\n    const context = this;\n    clearTimeout(timeoutID);\n\n    timeoutID = setTimeout(function () {\n      timeoutID = null; // Not strictly necessary but good to do this.\n      func.apply(context, args);\n    }, wait);\n  };\n}\n`;var s=`export default function debounce(func: Function, wait: number = 0): Function {\n  let timeoutID: ReturnType<typeof setTimeout> | null = null;\n\n  return function (this: any, ...args: any[]) {\n    // Keep a reference to \\`this\\` so that\n    // func.apply() can access it.\n    const context = this;\n    clearTimeout(timeoutID ?? undefined);\n\n    timeoutID = setTimeout(function () {\n      timeoutID = null; // Not strictly necessary but good to do this.\n      func.apply(context, args);\n    }, wait);\n  };\n}\n`;var f=`/**\n * @callback func\n * @param {number} wait\n * @return {Function}\n */\nexport default function debounce(func, wait = 0) {\n  let timeoutID = null;\n  return function (...args) {\n    clearTimeout(timeoutID);\n\n    timeoutID = setTimeout(() => {\n      timeoutID = null; // Not strictly necessary but good to include.\n      // Has the same \\`this\\` as the outer function's\n      // as it's within an arrow function.\n      func.apply(this, args);\n    }, wait);\n  };\n}\n`;function m(t){let e=Object.assign({p:\"p\",a:\"a\",h2:\"h2\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\",ol:\"ol\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Debounce, along with \",(0,n.jsx)(e.a,{href:\"/questions/javascript/throttle\",children:\"throttle\"}),\", are among the most common front end interview questions; it's the front end equivalent of inverting a binary tree. Hence you should make sure that you are very familiar with the question.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Given that there's a \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration before the function can be invoked, we know that we will need a timer, and \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" is the first thing that comes to mind.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We will also need to return a function which wraps around the callback function parameter. This function needs to do a few things:\"}),`\n`,(0,n.jsx)(e.h3,{children:\"1) Debounce invocation\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"It invokes the callback function only after a delay of \",(0,n.jsx)(e.code,{children:\"wait\"}),\". This is performed using \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\". Since we might need to clear the timer if the debounced function is called again while there's a pending invocation, we need to retain a reference to a \",(0,n.jsx)(e.code,{children:\"timeoutID\"}),\", which is the returned value of \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the function is called again while there's a pending invocation, we should cancel existing timers and schedule a new timer for the delayed invocation with the full \",(0,n.jsx)(e.code,{children:\"wait\"}),\" duration. We can cancel the timer via \",(0,n.jsx)(e.code,{children:\"clearTimeout(timeoutID)\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"2) Calls the callback function with the right parameters\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Debounced functions are used like the original functions, so we should forward the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" and function arguments when invoking the original callback functions.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"You may be tempted to use \",(0,n.jsx)(e.code,{children:\"func(...args)\"}),\" but \",(0,n.jsx)(e.code,{children:\"this\"}),\" will be lost if callback functions are invoked that way. Hence we have use \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" which allows us to specify \",(0,n.jsx)(e.code,{children:\"this\"}),\" as the first argument.\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"func.apply(thisArg, args)\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"func.call(thisArg, ...args)\"})}),`\n`]}),`\n`,(0,n.jsx)(r,{languages:{jsx:u,tsx:s}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The main pitfall in this question is invoking the callback function with the correct \",(0,n.jsx)(e.code,{children:\"this\"}),\", the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" when the debounced function was called. Since the callback function will be invoked in a timeout, we need to ensure that the first argument to \",(0,n.jsx)(e.code,{children:\"func.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"func.call()\"}),\" is the right value. There are two ways to achieve this:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Use another variable to keep a reference to \",(0,n.jsx)(e.code,{children:\"this\"}),\" and access \",(0,n.jsx)(e.code,{children:\"this\"}),\" via that variable from within the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" callback. This is the traditional way of preserving \",(0,n.jsx)(e.code,{children:\"this\"}),\" before arrow functions existed.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use an arrow function to declare the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" callback where the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value within it has lexical scope. The value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" within arrow functions is bound to the context in which the function is created, not to the environment in which the function is called.\"]}),`\n`]}),`\n`,(0,n.jsx)(r,{children:f}),`\n`,(0,n.jsxs)(e.p,{children:[\"Also, we should not implement the returned function using an arrow function for reasons mentioned above. The \",(0,n.jsx)(e.code,{children:\"this\"}),\" value of the returned function needs to be dynamically determined when executed.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Read this \",(0,n.jsx)(e.a,{href:\"https://medium.com/@griffinmichl/implementing-debounce-in-javascript-eab51a12311e\",children:\"article\"}),\" for a more in-depth explanation.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Closures.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"How \",(0,n.jsx)(e.code,{children:\"this\"}),\" works.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Invoking functions via \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"clearTimeout()\"}),\" is a forgiving function and passing an invalid ID to \",(0,n.jsx)(e.code,{children:\"clearTimeout()\"}),\" silently does nothing; no exception is thrown. Hence we don't have to check for \",(0,n.jsx)(e.code,{children:\"timeoutID === null\"}),\" before using \",(0,n.jsx)(e.code,{children:\"clearTimeout()\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://css-tricks.com/debouncing-throttling-explained-examples/\",children:\"Debouncing and Throttling Explained Through Examples\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://medium.com/@griffinmichl/implementing-debounce-in-javascript-eab51a12311e\",children:\"Implementing Debounce in JavaScript\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout\",children:\"clearTimeout() - Web APIs | MDN\"})}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=j;return k(_);})();\n;return Component;",
  "workspace": {
    "main": "/src/debounce.ts",
    "run": "/src/debounce.run.test.ts",
    "submit": "/src/debounce.submit.test.ts"
  }
}