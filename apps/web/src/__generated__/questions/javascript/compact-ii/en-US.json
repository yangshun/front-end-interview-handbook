{
  "description": "var Component=(()=>{var s=Object.create;var t=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var j=(c,e)=>()=>(e||c((e={exports:{}}).exports,e),e.exports),b=(c,e)=>{for(var l in e)t(c,l,{get:e[l],enumerable:!0})},a=(c,e,l,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!f.call(c,r)&&r!==l&&t(c,r,{get:()=>e[r],enumerable:!(o=u(e,r))||o.enumerable});return c};var y=(c,e,l)=>(l=c!=null?s(p(c)):{},a(e||!c||!c.__esModule?t(l,\"default\",{value:c,enumerable:!0}):l,c)),x=c=>a(t({},\"__esModule\",{value:!0}),c);var i=j((A,d)=>{d.exports=_jsx_runtime});var _={};b(_,{default:()=>w,frontmatter:()=>g});var n=y(i()),g={title:\"Compact II\",excerpt:\"Implement a function that returns an object with all falsey values removed\"};function h(c){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",pre:\"pre\"},c.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"compact(value)\"}),\" that returns a new object with all falsey values removed, including falsey values that are deeply-nested. You can assume the \",(0,n.jsx)(e.code,{children:\"value\"}),\" only contains JSON-serializable values (\",(0,n.jsx)(e.code,{children:\"null\"}),\", \",(0,n.jsx)(e.code,{children:\"boolean\"}),\", \",(0,n.jsx)(e.code,{children:\"number\"}),\", \",(0,n.jsx)(e.code,{children:\"string\"}),\", \",(0,n.jsx)(e.code,{children:\"Array\"}),\", \",(0,n.jsx)(e.code,{children:\"Object\"}),\") and will not contain any other objects like \",(0,n.jsx)(e.code,{children:\"Date\"}),\", \",(0,n.jsx)(e.code,{children:\"Regex\"}),\", \",(0,n.jsx)(e.code,{children:\"Map\"}),\" or \",(0,n.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The values \",(0,n.jsx)(e.code,{children:\"false\"}),\", \",(0,n.jsx)(e.code,{children:\"null\"}),\", \",(0,n.jsx)(e.code,{children:\"0\"}),\", \",(0,n.jsx)(e.code,{children:\"''\"}),\", \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", and \",(0,n.jsx)(e.code,{children:\"NaN\"}),\" are falsey (you should know this by heart!).\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"value\"}),\" \",(0,n.jsx)(e.em,{children:\"(Array|Object)\"}),\": The array/object to compact.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:\"(Array|Object)\"}),\": Returns the new compact array/object.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`compact([0, 1, false, 2, '', 3, null]); // => [1, 2, 3]\ncompact({ foo: true, bar: null }); // => { foo: true }\n`})})]})}function v(c={}){let{wrapper:e}=c.components||{};return e?(0,n.jsx)(e,Object.assign({},c,{children:(0,n.jsx)(h,c)})):h(c)}var w=v;return x(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/compact-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/compact-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/compact-ii.run.test.ts": "import compact from './compact-ii';\n\ndescribe('compact', () => {\n  test('arrays', () => {\n    expect(compact([1, 2])).toEqual([1, 2]);\n    expect(compact([null, 1])).toEqual([1]);\n    expect(compact([false, null])).toEqual([]);\n  });\n\n  test('objects', () => {\n    expect(compact({ foo: true, bar: 2 })).toEqual({ foo: true, bar: 2 });\n    expect(compact({ foo: false, bar: 2 })).toEqual({ bar: 2 });\n  });\n\n  test('nested objects', () => {\n    expect(compact({ foo: true, bar: { baz: 1, qux: 2 } })).toEqual({\n      foo: true,\n      bar: {\n        baz: 1,\n        qux: 2,\n      },\n    });\n    expect(compact({ foo: null, bar: { baz: null, qux: 2 } })).toEqual({\n      bar: {\n        qux: 2,\n      },\n    });\n  });\n});\n",
    "/src/compact-ii.submit.test.ts": "import compact from './compact-ii';\n\ndescribe('compact', () => {\n  describe('arrays', () => {\n    test('empty array', () => {\n      expect(compact([])).toEqual([]);\n    });\n\n    test('single-element array', () => {\n      expect(compact([1])).toEqual([1]);\n      expect(compact([null])).toEqual([]);\n    });\n\n    test('two-element array', () => {\n      expect(compact([1, 2])).toEqual([1, 2]);\n      expect(compact([null, 1])).toEqual([1]);\n      expect(compact([1, null])).toEqual([1]);\n      expect(compact([false, null])).toEqual([]);\n    });\n\n    test('remove all falsey values from the input array', () => {\n      expect(compact([0, 1, false, 2, '', 3])).toEqual([1, 2, 3]);\n    });\n\n    test('only falsey values', () => {\n      expect(compact([null, undefined, NaN, 0, false, '', ''])).toEqual([]);\n    });\n\n    test('no falsey values', () => {\n      expect(compact(['hello', true, 123, [], {}])).toEqual([\n        'hello',\n        true,\n        123,\n        [],\n        {},\n      ]);\n    });\n\n    test('nested arrays', () => {\n      expect(compact([1, [null]])).toEqual([1, []]);\n      expect(compact([1, [2, [3]]])).toEqual([1, [2, [3]]]);\n    });\n\n    test('nested objects', () => {\n      expect(compact([1, { foo: 'bar' }])).toEqual([1, { foo: 'bar' }]);\n      expect(compact([1, { foo: null }])).toEqual([1, {}]);\n    });\n\n    test('sparse arrays', () => {\n      expect(compact([1, , 2, , 3])).toEqual([1, 2, 3]);\n      expect(compact([1, , null, 2, , 3])).toEqual([1, 2, 3]);\n    });\n\n    test('should not modify the original input array', () => {\n      const input = [0, 1, false, 2, '', 3];\n      compact(input);\n      expect(input).toEqual([0, 1, false, 2, '', 3]);\n    });\n  });\n\n  describe('objects', () => {\n    test('empty object', () => {\n      expect(compact({})).toEqual({});\n    });\n\n    test('single-key object', () => {\n      expect(compact({ foo: true })).toEqual({ foo: true });\n      expect(compact({ foo: false })).toEqual({});\n      expect(compact({ foo: null })).toEqual({});\n      expect(compact({ foo: '' })).toEqual({});\n      expect(compact({ foo: 0 })).toEqual({});\n    });\n\n    test('multiple-key object', () => {\n      expect(compact({ foo: true, bar: 2 })).toEqual({ foo: true, bar: 2 });\n      expect(compact({ foo: false, bar: 2 })).toEqual({ bar: 2 });\n    });\n\n    test('nested arrays', () => {\n      expect(compact({ foo: true, bar: ['foo', 1, 2, 'bar'] })).toEqual({\n        foo: true,\n        bar: ['foo', 1, 2, 'bar'],\n      });\n      expect(compact({ foo: true, bar: [null, 1, 2, false] })).toEqual({\n        foo: true,\n        bar: [1, 2],\n      });\n    });\n\n    test('nested objects', () => {\n      expect(compact({ foo: true, bar: { baz: 1, qux: 2 } })).toEqual({\n        foo: true,\n        bar: {\n          baz: 1,\n          qux: 2,\n        },\n      });\n      expect(compact({ foo: null, bar: { baz: null, qux: 2 } })).toEqual({\n        bar: {\n          qux: 2,\n        },\n      });\n    });\n\n    test('should not modify the original input object', () => {\n      const input = { foo: false, bar: 2 };\n      compact(input);\n      expect(input).toEqual({ foo: false, bar: 2 });\n    });\n  });\n});\n",
    "/src/compact-ii.ts": "export default function compact<T extends Array<any> | Object>(value: T): T {\n  // Handle primitives.\n  if (typeof value !== 'object' || value == null) {\n    return value;\n  }\n\n  // Handle arrays.\n  if (Array.isArray(value)) {\n    const compactArr: Array<any> = [];\n    value.forEach((item) => {\n      if (item) {\n        compactArr.push(compact(item));\n      }\n    });\n\n    return compactArr as T;\n  }\n\n  // Lastly handle objects.\n  const compactObj = Object.create(null);\n  Object.entries(value).forEach(([key, val]) => {\n    if (val) {\n      compactObj[key] = compact(val);\n    }\n  });\n\n  return compactObj;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1690761600,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that returns an object with all falsey values removed",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/compact-ii",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "compact"
    ],
    "slug": "compact-ii",
    "subtitle": null,
    "title": "Compact II",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Array|Object} value\n * @return {Array|Object}\n */\nexport default function compact(value) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function compact<T extends Array<any> | Object>(value: T): T {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var v=Object.create;var c=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var g=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),O=(a,e)=>{for(var r in e)c(a,r,{get:e[r],enumerable:!0})},l=(a,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of y(e))!b.call(a,n)&&n!==r&&c(a,n,{get:()=>e[n],enumerable:!(i=f(e,n))||i.enumerable});return a};var A=(a,e,r)=>(r=a!=null?v(j(a)):{},l(e||!a||!a.__esModule?c(r,\"default\",{value:a,enumerable:!0}):r,a)),x=a=>l(c({},\"__esModule\",{value:!0}),a);var u=g((C,s)=>{s.exports=_jsx_runtime});var H={};O(H,{default:()=>T});var t=A(u());var o=MDXCodeBlock;var d=`/**\n * @param {Array|Object} value\n * @return {Array|Object}\n */\nexport default function compact(value) {\n  // Handle primitives.\n  if (typeof value !== 'object' || value == null) {\n    return value;\n  }\n\n  // Handle arrays.\n  if (Array.isArray(value)) {\n    const compactArr = [];\n    value.forEach((item) => {\n      if (item) {\n        compactArr.push(compact(item));\n      }\n    });\n\n    return compactArr;\n  }\n\n  // Lastly handle objects.\n  const compactObj = Object.create(null);\n  Object.entries(value).forEach(([key, val]) => {\n    if (val) {\n      compactObj[key] = compact(val);\n    }\n  });\n  return compactObj;\n}\n`;var h=`export default function compact<T extends Array<any> | Object>(value: T): T {\n  // Handle primitives.\n  if (typeof value !== 'object' || value == null) {\n    return value;\n  }\n\n  // Handle arrays.\n  if (Array.isArray(value)) {\n    const compactArr: Array<any> = [];\n    value.forEach((item) => {\n      if (item) {\n        compactArr.push(compact(item));\n      }\n    });\n\n    return compactArr as T;\n  }\n\n  // Lastly handle objects.\n  const compactObj = Object.create(null);\n  Object.entries(value).forEach(([key, val]) => {\n    if (val) {\n      compactObj[key] = compact(val);\n    }\n  });\n\n  return compactObj;\n}\n`;var m=`/**\n * @param {Array|Object} value\n * @return {Array|Object}\n */\nexport default function compact(value) {\n  if (typeof value !== 'object' || value == null) {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.filter((item) => item).map((item) => compact(item));\n  }\n\n  return Object.fromEntries(\n    Object.entries(value)\n      .filter(([_, value]) => value)\n      .map(([key, value]) => [key, compact(value)]),\n  );\n}\n`;function p(a){let e=Object.assign({h2:\"h2\",p:\"p\",ol:\"ol\",li:\"li\",strong:\"strong\",code:\"code\",ul:\"ul\"},a.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"Since the input value can be deeply nested, a recursive solution will be handy for traversing the nested values. The idea is to recursively visit all values in the input, iterating through array items and object entries, filtering out the falsey values and keeping only the non-falsey values.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Since there are only primitives, arrays, and objects for this question, there are three categories of values we need to handle:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Primitives\"}),\": This is the base case for the recursion and we can directly return the value. Given the data types available in this question, to check if a value is a primitive, we can use \",(0,t.jsx)(e.code,{children:\"typeof value !== 'object'\"}),\" and include a special case for \",(0,t.jsx)(e.code,{children:\"value == null\"}),\" since \",(0,t.jsx)(e.code,{children:\"typeof null\"}),\" is \",(0,t.jsx)(e.code,{children:\"'object'\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Arrays\"}),\": Iterate through the array and if the item is non-falsey, recursively call \",(0,t.jsx)(e.code,{children:\"compact\"}),\" on the item, adding the returned compacted item into a new array. Return the new compacted array at the end.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Objects\"}),\": Iterate through the entries of the object and if the object value is non-falsey, recursively call \",(0,t.jsx)(e.code,{children:\"compact\"}),\" on the object, putting the returned compacted value into a new object. Return the new compacted object at the end.\"]}),`\n`]}),`\n`,(0,t.jsx)(o,{languages:{jsx:d,tsx:h}}),`\n`,(0,t.jsx)(e.p,{children:\"Here's a shorter solution that adopts a more functional approach:\"}),`\n`,(0,t.jsx)(o,{children:m}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Empty arrays and objects are not considered falsey.\"}),`\n`]})]})}function E(a={}){let{wrapper:e}=a.components||{};return e?(0,t.jsx)(e,Object.assign({},a,{children:(0,t.jsx)(p,a)})):p(a)}var T=E;return x(H);})();\n;return Component;",
  "workspace": {
    "main": "/src/compact-ii.ts",
    "run": "/src/compact-ii.run.test.ts",
    "submit": "/src/compact-ii.submit.test.ts"
  }
}