{
  "description": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!f.call(t,i)&&i!==r&&o(t,i,{get:()=>e[i],enumerable:!(a=d(e,i))||a.enumerable});return t};var b=(t,e,r)=>(r=t!=null?h(m(t)):{},c(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),v=t=>c(o({},\"__esModule\",{value:!0}),t);var l=y((_,s)=>{s.exports=_jsx_runtime});var S={};g(S,{default:()=>O,frontmatter:()=>j});var n=b(l()),j={title:\"Curry III\",excerpt:\"Implement a function which transforms a function which takes variadic arguments into a function that can be repeatedly called with any number of arguments\"};function u(t){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",h2:\"h2\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,n.jsx)(e.a,{href:\"/questions/javascript/curry-ii\",children:\"Curry II\"}),\", you should complete that first before attempting this question. Also, this is a hard question and resembles a brainteaser more than an actual question candidates are expected to solve. However, solving this question is rewarding and is sure to improve your knowledge of JavaScript.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Currying is the technique of converting a function that takes multiple arguments into a sequence of functions that each takes a single argument.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement the \",(0,n.jsx)(e.code,{children:\"curry\"}),\" function which accepts a function as the only argument and returns a function that accepts a variadic number of arguments (vs only one argument at a time in \",(0,n.jsx)(e.a,{href:\"/questions/javascript/curry\",children:\"Curry\"}),\" and a fixed number of arguments in \",(0,n.jsx)(e.a,{href:\"/questions/javascript/curry-ii\",children:\"Curry II\"}),\") and returns a function which can be repeatedly called.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Expected output behavior\"}),`\n`,(0,n.jsx)(e.p,{children:\"When the returned function is in an expression that suggests the value should be a string or a number, the initial function argument is then invoked with the provided arguments and the result is used as the value.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function multiply(...numbers) {\n  return numbers.reduce((a, b) => a * b, 1);\n}\nconst curriedMultiply = curry(multiply);\nconst multiplyByThree = curriedMultiply(3);\nconsole.log(multiplyByThree); // 3\nconsole.log(multiplyByThree(4)); // 12\n\nconst multiplyByFifteen = multiplyByThree(5);\nconsole.log(multiplyByFifteen); // 15\nconsole.log(multiplyByFifteen(2)); // 30\n\nconsole.log(curriedMultiply(1)(2)(3)(4)); // 24\nconsole.log(curriedMultiply(1, 2, 3, 4)); // 24\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Hint\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Look up the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\",children:(0,n.jsx)(e.code,{children:\"Symbol.toPrimitive\"})}),\", \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\",children:(0,n.jsx)(e.code,{children:\"Object.prototype.toString()\"})}),\" and \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf\",children:(0,n.jsx)(e.code,{children:\"Object.prototype.valueOf()\"})}),\" functions.\"]})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var O=x;return v(S);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/curry-iii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/curry-iii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/curry-iii.run.test.ts": "import curry from './curry-iii';\n\nfunction multiply(...numbers: Array<number>) {\n  return numbers.reduce((a, b) => a * b, 1);\n}\nfunction sum(...numbers: Array<number>) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\ndescribe('curry', () => {\n  test('returns function', () => {\n    const curried = curry(multiply);\n    expect(curried).toBeInstanceOf(Function);\n  });\n\n  test('empty function', () => {\n    const curried = curry(multiply);\n    expect(+curried()).toBe(1);\n  });\n\n  test('single argument', () => {\n    const curried = curry(sum);\n    expect(+curried(3)).toBe(3);\n  });\n\n  test('one arg at a time', () => {\n    const curried = curry(multiply);\n    expect(+curried(7)(3)).toBe(21);\n  });\n\n  test('both args at once', () => {\n    const curried = curry(multiply);\n    expect(+curried(7, 3)).toBe(21);\n  });\n});\n",
    "/src/curry-iii.submit.test.ts": "import curry from './curry-iii';\n\nfunction multiply(...numbers: Array<number>) {\n  return numbers.reduce((a, b) => a * b, 1);\n}\nfunction sum(...numbers: Array<number>) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\ndescribe('curry', () => {\n  test('returns function', () => {\n    const curried = curry(multiply);\n    expect(curried).toBeInstanceOf(Function);\n  });\n\n  test('empty function', () => {\n    const curried = curry(multiply);\n    expect(+curried()).toBe(1);\n  });\n\n  test('single argument', () => {\n    const curried = curry(sum);\n    expect(+curried(3)).toBe(3);\n  });\n\n  describe('two arguments', () => {\n    test('one arg at a time', () => {\n      const curried = curry(multiply);\n      expect(+curried(7)(3)).toBe(21);\n    });\n\n    test('both args at once', () => {\n      const curried = curry(multiply);\n      expect(+curried(7, 3)).toBe(21);\n    });\n  });\n\n  describe('multiple arguments', () => {\n    test('one arg at a time', () => {\n      const curried = curry(multiply);\n      expect(+curried(7)(3)(2)).toBe(42);\n    });\n\n    test('multiple args at once', () => {\n      const curried = curry(multiply);\n      expect(+curried(7, 3, 2)).toBe(42);\n      expect(+curried(7, 3, 2)).toBe(42);\n      expect(+curried(7, 3)(2)).toBe(42);\n      expect(+curried(7)(3, 2)).toBe(42);\n    });\n  });\n\n  test('can be reused', () => {\n    const curriedMultiply = curry(multiply);\n    const multiplyByThree = curriedMultiply(3);\n    expect(+multiplyByThree).toBe(3);\n    expect(+multiplyByThree(4)).toBe(12);\n\n    const multiplyByFifteen = multiplyByThree(5);\n    expect(+multiplyByFifteen).toBe(15);\n    expect(+multiplyByFifteen(2)).toBe(30);\n  });\n\n  test('ignores empty args', () => {\n    const curried = curry(multiply);\n    expect(+curried()(4)()(3)()(2)).toBe(24);\n    expect(+curried()()()()(4)(2)(3)).toBe(24);\n  });\n\n  describe('can access this', () => {\n    test('single parameter', () => {\n      const curried = curry(function (this: any, val: number) {\n        return this.multiplier * val;\n      });\n\n      const obj = { multiplier: 5, mul: curried };\n      expect(obj.mul()).toBeInstanceOf(Function);\n      expect(+obj.mul(7)).toBe(35);\n    });\n\n    test('two arguments', () => {\n      const curried = curry(function (this: any, foo: number, bar: number) {\n        return this.base * foo + bar;\n      });\n\n      const obj = { base: 5, mul: curried };\n      expect(obj.mul()).toBeInstanceOf(Function);\n      expect(+obj.mul(3)(2)).toBe(17);\n      expect(+obj.mul(3, 2)).toBe(17);\n      expect(+obj.mul(3)()(2)).toBe(17);\n      expect(+obj.mul()(3)()(2)).toBe(17);\n    });\n\n    test('variadic arguments', () => {\n      const curried = curry(function (this: any, ...numbers: Array<number>) {\n        return this.multiplier * numbers.reduce((a, b) => a * b, 1);\n      });\n\n      const obj = { multiplier: 5, mul: curried };\n      expect(+obj.mul(7, 2)).toBe(70);\n    });\n  });\n});\n",
    "/src/curry-iii.ts": "export default function curry(func: Function): Function {\n  return function curried(this: any, ...args: Array<any>) {\n    const fn: any = curried.bind(this, ...args);\n\n    // Define using an arrow function to preserve `this`.\n    fn[Symbol.toPrimitive] = () => func.apply(this, args);\n    return fn;\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [
      "qualcomm"
    ],
    "created": 1670630400,
    "difficulty": "hard",
    "duration": 20,
    "excerpt": "Implement a function which transforms a function which takes variadic arguments into a function that can be repeatedly called with any number of arguments",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/curry-iii",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "curry",
      "curry-ii"
    ],
    "slug": "curry-iii",
    "subtitle": null,
    "title": "Curry III",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Function} func\n * @return {Function}\n */\nexport default function curry(func) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function curry(func: Function): Function {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var t=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),w=(r,e)=>{for(var i in e)t(r,i,{get:e[i],enumerable:!0})},a=(r,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of b(e))!g.call(r,o)&&o!==i&&t(r,o,{get:()=>e[o],enumerable:!(c=m(e,o))||c.enumerable});return r};var j=(r,e,i)=>(i=r!=null?f(y(r)):{},a(e||!r||!r.__esModule?t(i,\"default\",{value:r,enumerable:!0}):i,r)),S=r=>a(t({},\"__esModule\",{value:!0}),r);var l=v((C,s)=>{s.exports=_jsx_runtime});var O={};w(O,{default:()=>D});var n=j(l());var d=MDXCodeBlock;var h=`/**\n * @param {Function} func\n * @return {Function}\n */\nexport default function curry(func) {\n  return function curried(...args) {\n    const fn = curried.bind(this, ...args);\n\n    // Define using an arrow function to preserve \\`this\\`.\n    fn[Symbol.toPrimitive] = () => func.apply(this, args);\n    return fn;\n  };\n}\n`;var u=`export default function curry(func: Function): Function {\n  return function curried(this: any, ...args: Array<any>) {\n    const fn: any = curried.bind(this, ...args);\n\n    // Define using an arrow function to preserve \\`this\\`.\n    fn[Symbol.toPrimitive] = () => func.apply(this, args);\n    return fn;\n  };\n}\n`;function p(r){let e=Object.assign({p:\"p\",a:\"a\",h2:\"h2\",pre:\"pre\",code:\"code\",ul:\"ul\",li:\"li\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This solution assumes you have completed the \",(0,n.jsx)(e.a,{href:\"/questions/javascript/curry-ii\",children:\"Curry II\"}),\" question and fully understand its solution.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implicit type conversion is the fundamental concept that we need to be aware of here. When variable are used in scenarios with mismatched types, implicit type conversion happens as an attempt to make the operation succeed. Here are some examples from \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures\",children:\"MDN\"}),\" regarding type conversions:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const foo = 42; // foo is a number\nconst result = foo + '1'; // JavaScript coerces foo to a string, so it can be concatenated with the other operand.\nconsole.log(result); // 421\n\nconst bar = '42'; // bar is a string\nconst result2 = 2 * bar; // JavaScript coerces bar to a number, so it can be multiplied with the other operand.\nconsole.log(result2); // 84\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The function returned by \",(0,n.jsx)(e.code,{children:\"curry\"}),\" (we call it \",(0,n.jsx)(e.code,{children:\"curried\"}),\") is a function, which is a JavaScript object. Under usual circumstances, when a function is coerced into a string, the function's code is used as the string value:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function foo(a, b) {\n  return a + b;\n}\nconsole.log('hey ' + foo); // hey function foo(a, b) { return a + b }\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is not what we want. We want to call arbitrary logic when a function is used as a primitive value. In order for objects to be used as a primitive value (when being used in \",(0,n.jsx)(e.code,{children:\"console.log()\"}),\" or in expressions), we can override the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\",children:(0,n.jsx)(e.code,{children:\"Symbol.toPrimitive\"})}),\" property on objects, which is a method that accepts a preferred type and returns a primitive representation of an object.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Hence the solution to this question can be obtained by modifying the solution of Curry II slightly and calling \",(0,n.jsx)(e.code,{children:\"func.apply(this, args)\"}),\" within the method of \",(0,n.jsx)(e.code,{children:\"Symbol.toPrimitive\"}),\".\"]}),`\n`,(0,n.jsx)(d,{languages:{jsx:h,tsx:u}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Functions which access \",(0,n.jsx)(e.code,{children:\"this\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Closures.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Invoking functions via \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Type coercion.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"this\"}),\" should be preserved when calling the original function, which can be achieved by using an arrow function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Overriding \",(0,n.jsx)(e.code,{children:\"Object.prototype.valueOf\"}),\" and \",(0,n.jsx)(e.code,{children:\"Object.prototype.toString\"}),\" works as well, but defining an implementation for \",(0,n.jsx)(e.code,{children:\"Symbol.toPrimitive\"}),\" is more reliable.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://lodash.com/docs/4.17.15#curry\",children:\"Lodash curry\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive\",children:(0,n.jsx)(e.code,{children:\"Symbol.toPrimitive\"})})}),`\n`]})]})}function F(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(p,r)})):p(r)}var D=F;return S(O);})();\n;return Component;",
  "workspace": {
    "main": "/src/curry-iii.ts",
    "run": "/src/curry-iii.run.test.ts",
    "submit": "/src/curry-iii.submit.test.ts"
  }
}