{
  "description": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var r in e)o(n,r,{get:e[r],enumerable:!0})},a=(n,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of p(e))!j.call(n,c)&&c!==r&&o(n,c,{get:()=>e[c],enumerable:!(s=h(e,c))||s.enumerable});return n};var g=(n,e,r)=>(r=n!=null?m(u(n)):{},a(e||!n||!n.__esModule?o(r,\"default\",{value:n,enumerable:!0}):r,n)),x=n=>a(o({},\"__esModule\",{value:!0}),n);var d=b((w,i)=>{i.exports=_jsx_runtime});var _={};f(_,{default:()=>v,frontmatter:()=>y});var t=g(d()),y={title:\"Deep Omit\",excerpt:\"Implement a function that removes specified keys and their corresponding values from an object, including nested objects or arrays\"};function l(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a function \",(0,t.jsx)(e.code,{children:\"deepOmit(obj, keys)\"}),\" that removes specified keys and their corresponding values from an object, including nested objects or arrays. It works recursively to traverse through the entire object structure, ensuring that all occurrences of the specified keys are removed at all levels. The function takes in an object (\",(0,t.jsx)(e.code,{children:\"obj\"}),\") and an array of string keys (\",(0,t.jsx)(e.code,{children:\"keys\"}),\").\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`deepOmit({ a: 1, b: 2, c: 3 }, ['b']); // { a: 1, c: 3 }\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"A more complicated example with nested objects:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const obj = {\n  a: 1,\n  b: 2,\n  c: {\n    d: 3,\n    e: 4,\n  },\n  f: [5, 6],\n};\ndeepOmit(obj, ['b', 'c', 'e']); // { a: 1, f: [5, 6] }\n`})})]})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var v=k;return x(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/deep-omit\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/deep-omit.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/deep-omit.run.test.ts": "import deepOmit from './deep-omit';\n\nconst data = {\n  a: 1,\n  b: 2,\n  c: {\n    d: 3,\n    e: 4,\n  },\n  f: [5, 6],\n};\n\ndescribe('deepOmit', () => {\n  test('empty object', () => {\n    expect(deepOmit({}, [])).toEqual({});\n  });\n\n  test('single key', () => {\n    const keysToOmit = ['b'];\n    const result = deepOmit(\n      {\n        a: 1,\n        b: 2,\n        c: 3,\n      },\n      keysToOmit,\n    );\n    expect(result).toEqual({\n      a: 1,\n      c: 3,\n    });\n  });\n\n  test('multiple keys', () => {\n    const keysToOmit = ['b', 'c', 'e'];\n    const result = deepOmit(data, keysToOmit);\n    expect(result).toEqual({\n      a: 1,\n      f: [5, 6],\n    });\n  });\n});\n",
    "/src/deep-omit.submit.test.ts": "import deepOmit from './deep-omit';\n\nconst data = {\n  a: 1,\n  b: 2,\n  c: {\n    d: 3,\n    e: 4,\n  },\n  f: [5, 6],\n};\n\ndescribe('deepOmit', () => {\n  test('empty object', () => {\n    expect(deepOmit({}, [])).toEqual({});\n  });\n\n  test('empty keys', () => {\n    const data = {\n      a: 1,\n      b: 2,\n      c: {\n        d: 3,\n        e: 4,\n      },\n      f: [5, 6],\n    };\n    const result = deepOmit(data, []);\n    expect(result).toEqual(data);\n  });\n\n  describe('non-nested object', () => {\n    test('single key', () => {\n      const keysToOmit = ['b'];\n      const result = deepOmit(\n        {\n          a: 1,\n          b: 2,\n          c: 3,\n        },\n        keysToOmit,\n      );\n      expect(result).toEqual({\n        a: 1,\n        c: 3,\n      });\n    });\n\n    test('multiple keys', () => {\n      const keysToOmit = ['b', 'c', 'e'];\n      const result = deepOmit(data, keysToOmit);\n      expect(result).toEqual({\n        a: 1,\n        f: [5, 6],\n      });\n    });\n  });\n\n  describe('nested objects', () => {\n    test('remove from nested objects', () => {\n      const nestedData = {\n        a: 1,\n        b: 2,\n        c: {\n          d: 3,\n          e: {\n            f: 4,\n            g: 5,\n          },\n        },\n      };\n      const keysToOmit = ['b', 'f'];\n      const result = deepOmit(nestedData, keysToOmit);\n      const expected = {\n        a: 1,\n        c: {\n          d: 3,\n          e: {\n            g: 5,\n          },\n        },\n      };\n      expect(result).toEqual(expected);\n    });\n\n    test('remove entire nested object', () => {\n      const nestedData = {\n        a: 1,\n        b: 2,\n        c: {\n          d: 3,\n          e: {\n            f: 4,\n            g: 5,\n          },\n        },\n      };\n      const keysToOmit = ['e'];\n      const result = deepOmit(nestedData, keysToOmit);\n      const expected = {\n        a: 1,\n        b: 2,\n        c: {\n          d: 3,\n        },\n      };\n      expect(result).toEqual(expected);\n    });\n\n    test('remove all keys from object', () => {\n      const nestedData = {\n        a: 1,\n        b: 2,\n        c: {\n          d: 3,\n          e: {\n            f: 4,\n            g: 5,\n          },\n        },\n      };\n      const keysToOmit = ['d', 'e'];\n      const result = deepOmit(nestedData, keysToOmit);\n      const expected = {\n        a: 1,\n        b: 2,\n        c: {},\n      };\n      expect(result).toEqual(expected);\n    });\n  });\n\n  describe('arrays', () => {\n    test('basic', () => {\n      const dataWithArray = {\n        a: 1,\n        b: [2, 3],\n        c: {\n          d: 4,\n          e: [5, 6],\n        },\n      };\n      const keysToOmit = ['b', 'e'];\n      const result = deepOmit(dataWithArray, keysToOmit);\n      const expected = {\n        a: 1,\n        c: {\n          d: 4,\n        },\n      };\n      expect(result).toEqual(expected);\n    });\n\n    test('objects within arrays', () => {\n      const dataWithArray = {\n        a: 1,\n        b: [{ c: 2 }, 3],\n        c: [{ a: 2, b: 3 }],\n      };\n      const keysToOmit = ['b', 'e'];\n      const result = deepOmit(dataWithArray, keysToOmit);\n      const expected = {\n        a: 1,\n        c: [{ a: 2 }],\n      };\n      expect(result).toEqual(expected);\n    });\n\n    test('arrays within arrays', () => {\n      const dataWithArray = {\n        a: 1,\n        b: [{ c: 2 }, [3]],\n        c: [[{ a: 2, b: 3 }]],\n      };\n      const keysToOmit = ['b', 'e'];\n      const result = deepOmit(dataWithArray, keysToOmit);\n      const expected = {\n        a: 1,\n        c: [[{ a: 2 }]],\n      };\n      expect(result).toEqual(expected);\n    });\n  });\n\n  test('should not mutate the original object', () => {\n    const keysToOmit = ['b', 'c', 'e'];\n    deepOmit(data, keysToOmit);\n    expect(data).toEqual({\n      a: 1,\n      b: 2,\n      c: {\n        d: 3,\n        e: 4,\n      },\n      f: [5, 6],\n    });\n  });\n});\n",
    "/src/deep-omit.ts": "export default function deepOmit(val: unknown, keys: Array<string>): unknown {\n  // Handle arrays.\n  if (Array.isArray(val)) {\n    return val.map((item) => deepOmit(item, keys));\n  }\n\n  // Handle objects.\n  if (isPlainObject(val)) {\n    const newObj: Record<string, unknown> = {};\n    for (const key in val as Object) {\n      if (!keys.includes(key)) {\n        newObj[key] = deepOmit((val as any)[key], keys);\n      }\n    }\n\n    return newObj;\n  }\n\n  // Other values can be returned directly.\n  return val;\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": null,
    "companies": [],
    "created": 1690761600,
    "difficulty": "medium",
    "duration": 30,
    "excerpt": "Implement a function that removes specified keys and their corresponding values from an object, including nested objects or arrays",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/deep-omit",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "deep-map"
    ],
    "slug": "deep-omit",
    "subtitle": null,
    "title": "Deep Omit",
    "topics": [
      "recursion"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {any} val\n * @param {Array<string>} keys\n * @returns any\n */\nexport default function deepOmit(val, keys) {\n  throw 'Not implemented';\n}",
    "ts": "export default function deepOmit(val: unknown, keys: Array<string>): unknown {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var O=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),j=(n,e)=>{for(var r in e)a(n,r,{get:e[r],enumerable:!0})},l=(n,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of b(e))!k.call(n,i)&&i!==r&&a(n,i,{get:()=>e[i],enumerable:!(s=m(e,i))||s.enumerable});return n};var g=(n,e,r)=>(r=n!=null?f(v(n)):{},l(e||!n||!n.__esModule?a(r,\"default\",{value:n,enumerable:!0}):r,n)),w=n=>l(a({},\"__esModule\",{value:!0}),n);var d=O((_,c)=>{c.exports=_jsx_runtime});var D={};j(D,{default:()=>T});var t=g(d());var o=MDXCodeBlock;var u=`/**\n * @param {any} val\n * @param {Array<string>} keys\n * @returns any\n */\nexport default function deepOmit(val, keys) {\n  // Handle arrays.\n  if (Array.isArray(val)) {\n    return val.map((item) => deepOmit(item, keys));\n  }\n\n  // Handle objects.\n  if (isPlainObject(val)) {\n    const newObj = {};\n    for (const key in val) {\n      if (!keys.includes(key)) {\n        newObj[key] = deepOmit(val[key], keys);\n      }\n    }\n\n    return newObj;\n  }\n\n  // Other values can be returned directly.\n  return val;\n}\n\nfunction isPlainObject(value) {\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;var h=`export default function deepOmit(val: unknown, keys: Array<string>): unknown {\n  // Handle arrays.\n  if (Array.isArray(val)) {\n    return val.map((item) => deepOmit(item, keys));\n  }\n\n  // Handle objects.\n  if (isPlainObject(val)) {\n    const newObj: Record<string, unknown> = {};\n    for (const key in val as Object) {\n      if (!keys.includes(key)) {\n        newObj[key] = deepOmit((val as any)[key], keys);\n      }\n    }\n\n    return newObj;\n  }\n\n  // Other values can be returned directly.\n  return val;\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;var y=`/**\n * @param {any} val\n * @param {Array<string>} keys\n * @returns any\n */\nexport default function deepOmit(val, keys) {\n  if (!Array.isArray(val) && !isPlainObject(val)) {\n    return val;\n  }\n\n  // Both arrays and objects can be traversed using \\`for...in\\` statements.\n  const newObj = Array.isArray(val) ? [] : {};\n  for (const key in val) {\n    if (!keys.includes(key)) {\n      newObj[key] = deepOmit(val[key], keys);\n    }\n  }\n\n  return newObj;\n}\n\nfunction isPlainObject(value) {\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;function p(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",p:\"p\",ol:\"ol\",strong:\"strong\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Can there be values like \",(0,t.jsx)(e.code,{children:\"Date\"}),\", \",(0,t.jsx)(e.code,{children:\"Symbol\"}),\", \",(0,t.jsx)(e.code,{children:\"RegExp\"}),\" within the objects?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Yes, there can be.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Should we recurse into \",(0,t.jsx)(e.code,{children:\"Map\"}),\"s and \",(0,t.jsx)(e.code,{children:\"Set\"}),\"s?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"To keep the question simple, no. There are no tests cases containing \",(0,t.jsx)(e.code,{children:\"Map\"}),\"s and \",(0,t.jsx)(e.code,{children:\"Set\"}),\"s but you are free to add support if you wish.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Since the input value can be deeply nested, a recursive solution will be handy for traversing the nested values. The idea is to recursively visit all values in the input, iterating through array items and object entries, filtering out object entries where keys are within the \",(0,t.jsx)(e.code,{children:\"keys\"}),\" parameter.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Since arrays and objects need special handling, there are three categories of values we need to handle:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Arrays\"}),\": Use \",(0,t.jsx)(e.code,{children:\"Array.isArray()\"}),\" to check for this type. Iterate through the array and return a new array of each element after mapping with \",(0,t.jsx)(e.code,{children:\"deepOmit()\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Objects\"}),\": A helper function \",(0,t.jsx)(e.code,{children:\"isPlainObject()\"}),\" (from \",(0,t.jsx)(e.a,{href:\"/questions/javascript/type-utilities-ii\",children:\"Type Utilities II\"}),\") is used to check for plain object types. Doing \",(0,t.jsx)(e.code,{children:\"typeof element === 'object' && element !== null\"}),\" won't work because there are other values like \",(0,t.jsx)(e.code,{children:\"Date\"}),\" and \",(0,t.jsx)(e.code,{children:\"Set\"}),\" that will pass the check. Iterate through the keys of the object, filter out keys that are within \",(0,t.jsx)(e.code,{children:\"keys\"}),\", recursively call \",(0,t.jsx)(e.code,{children:\"deepOmit\"}),\" on the values, for non-omitted keys, adding the return values to \",(0,t.jsx)(e.code,{children:\"newObj\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Others\"}),\": This is the base case for the recursion and we can return the value directly since we don't need to recurse into it.\"]}),`\n`]}),`\n`,(0,t.jsx)(o,{languages:{jsx:u,tsx:h}}),`\n`,(0,t.jsxs)(e.p,{children:[\"Both arrays and objects can be iterated using \",(0,t.jsx)(e.code,{children:\"for...in\"}),\" loops. A shorter version is as follows. This is safe because the \",(0,t.jsx)(e.code,{children:\"keys\"}),\" inputs are strings and will not match the array keys, which are integers. However, writing it this way is not recommended as the code becomes harder to understand. It also becomes more challenging to write a typesafe version if you are using TypeScript.\"]}),`\n`,(0,t.jsx)(o,{children:y})]})}function S(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var T=S;return w(D);})();\n;return Component;",
  "workspace": {
    "main": "/src/deep-omit.ts",
    "run": "/src/deep-omit.run.test.ts",
    "submit": "/src/deep-omit.submit.test.ts"
  }
}