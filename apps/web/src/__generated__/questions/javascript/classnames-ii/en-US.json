{
  "description": "var Component=(()=>{var h=Object.create;var t=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var b=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),x=(o,e)=>{for(var s in e)t(o,s,{get:e[s],enumerable:!0})},r=(o,e,s,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of f(e))!p.call(o,c)&&c!==s&&t(o,c,{get:()=>e[c],enumerable:!(a=m(e,c))||a.enumerable});return o};var g=(o,e,s)=>(s=o!=null?h(u(o)):{},r(e||!o||!o.__esModule?t(s,\"default\",{value:o,enumerable:!0}):s,o)),j=o=>r(t({},\"__esModule\",{value:!0}),o);var d=b((I,l)=>{l.exports=_jsx_runtime});var _={};x(_,{default:()=>N,frontmatter:()=>y});var n=g(d()),y={title:\"Classnames II\",excerpt:\"Implement a function that conditionally joins CSS class names together and also handles de-duplication and function values\"};function i(o){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"In \",(0,n.jsx)(e.a,{href:\"/questions/javascript/classnames\",children:\"classnames\"}),\", we implemented \",(0,n.jsx)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:(0,n.jsx)(e.code,{children:\"classnames\"})}),\", a commonly-used utility in modern front end applications to conditionally join CSS class names together. However, there are some cases that the library does not do:\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Case\"}),(0,n.jsx)(e.th,{children:\"Example\"}),(0,n.jsx)(e.th,{children:\"Original\"}),(0,n.jsx)(e.th,{children:\"Improved\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"De-duplicate classnames\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"classNames('foo', 'foo)\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"'foo foo'\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"'foo'\"})})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Turn off classnames\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"classNames('foo', 'bar', { foo: false })\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"'foo bar'\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"'bar'\"})})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Function values\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"classNames(() => 'foo')\"})}),(0,n.jsx)(e.td,{children:\"Unsupported\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"'foo'\"})})]})]})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement an improved version of the \",(0,n.jsx)(e.code,{children:\"classnames\"}),\" function that handles the above cases.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`classNames('foo', 'foo'); // 'foo'\nclassNames({ foo: true }, { foo: true }); // 'foo'\nclassNames({ foo: true, bar: true }, { foo: false }); // 'bar'\nclassNames('foo', () => 'bar'); // 'foo bar'\nclassNames('foo', () => 'foo'); // 'foo'\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:[(0,n.jsx)(e.code,{children:\"classnames\"}),\" library on GitHub\"]})}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.a,{href:\"https://github.com/lukeed/clsx\",children:[(0,n.jsx)(e.code,{children:\"clsx\"}),\" library on GitHub\"]}),\": A newer version which serves as a faster and smaller drop-in replacement for \",(0,n.jsx)(e.code,{children:\"classnames\"}),\".\"]}),`\n`]})]})}function v(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(i,o)})):i(o)}var N=v;return j(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/classnames-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/classnames-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"esnext\"\n  }\n}\n",
    "/src/classnames-ii.run.test.ts": "import classNames from './classnames-ii';\n\ndescribe('classNames', () => {\n  test('empty values', () => {\n    expect(classNames([])).toEqual('');\n  });\n\n  test('single value', () => {\n    expect(classNames('foo')).toEqual('foo');\n  });\n\n  test('duplicate values', () => {\n    expect(classNames('foo', 'foo')).toEqual('foo');\n    expect(classNames({ foo: true }, { foo: true })).toEqual('foo');\n  });\n\n  test('turn off values', () => {\n    expect(classNames({ foo: true, bar: true }, { foo: false })).toEqual('bar');\n  });\n\n  test('function values', () => {\n    expect(classNames('foo', () => 'bar')).toEqual('foo bar');\n    expect(classNames('foo', () => 'foo')).toEqual('foo');\n  });\n});\n",
    "/src/classnames-ii.submit.test.ts": "import classNames from './classnames-ii';\n\ndescribe('classNames', () => {\n  test('empty values', () => {\n    expect(classNames([])).toEqual('');\n  });\n\n  test('single value', () => {\n    expect(classNames('foo')).toEqual('foo');\n  });\n\n  test('two values', () => {\n    expect(classNames('foo', 'bar')).toEqual('foo bar');\n  });\n\n  test('array values', () => {\n    expect(classNames(['foo', 'bar', 'baz'])).toEqual('foo bar baz');\n  });\n\n  test('object values', () => {\n    expect(classNames({ 'foo-bar': true })).toEqual('foo-bar');\n    expect(classNames({ 'foo-bar': false })).toEqual('');\n    expect(classNames({ foo: true }, { bar: true })).toEqual('foo bar');\n    expect(classNames({ foo: true, bar: false, qux: true })).toEqual('foo qux');\n  });\n\n  test('mixed values', () => {\n    expect(\n      classNames(\n        'foo',\n        {\n          bar: true,\n          duck: false,\n        },\n        'baz',\n        { quux: true },\n      ),\n    ).toEqual('foo bar baz quux');\n    expect(\n      classNames('boo', true && 'loo', false && 'booz', {\n        foo: true,\n        bar: false,\n        baz: 1,\n      }),\n    ).toEqual('boo loo foo baz');\n  });\n\n  test('ignores falsey values', () => {\n    expect(\n      classNames(null, false, 'bar', undefined, 0, 1, { baz: null }, ''),\n    ).toEqual('bar 1');\n  });\n\n  test('recursively flattens arrays', () => {\n    expect(classNames('a', ['b', { c: true, d: false }])).toEqual('a b c');\n    expect(classNames('a', ['b', ['c', ['d']]])).toEqual('a b c d');\n  });\n\n  describe('duplicate values', () => {\n    test('isolated', () => {\n      expect(classNames('foo', 'foo')).toEqual('foo');\n    });\n\n    test('composite', () => {\n      expect(classNames('foo', 'bar', 'foo')).toEqual('foo bar');\n      expect(classNames('foo', { foo: true }, 'bar')).toEqual('foo bar');\n      expect(classNames({ foo: true }, { bar: true }, { foo: true })).toEqual(\n        'foo bar',\n      );\n      expect(classNames(1, '1')).toEqual('1');\n      expect(classNames('foo', 1, '1')).toEqual('foo 1');\n    });\n\n    test('nested', () => {\n      expect(classNames('foo', ['foo'])).toEqual('foo');\n      expect(classNames('foo', [{ foo: true }])).toEqual('foo');\n      expect(classNames([{ foo: true }, { foo: true }])).toEqual('foo');\n      expect(classNames([1], '1')).toEqual('1');\n    });\n  });\n\n  describe('function values', () => {\n    test('single', () => {\n      expect(classNames(() => 'foo')).toEqual('foo');\n    });\n\n    test('composite', () => {\n      expect(classNames(() => 'foo', 'bar', 'foo')).toEqual('foo bar');\n      expect(classNames(() => 'foo', { foo: true }, 'bar')).toEqual('foo bar');\n      expect(classNames(() => 1, '1')).toEqual('1');\n      expect(classNames('foo', 1, () => '1')).toEqual('foo 1');\n    });\n\n    test('nested', () => {\n      expect(classNames('foo', [() => 'foo'])).toEqual('foo');\n      expect(classNames('foo', [{ foo: true }, () => 'bar'])).toEqual(\n        'foo bar',\n      );\n    });\n  });\n\n  describe('turning off values', () => {\n    test('single', () => {\n      expect(classNames('foo', { foo: false })).toEqual('');\n    });\n\n    test('on before off', () => {\n      expect(classNames(() => 'foo', 'bar', { foo: false })).toEqual('bar');\n      expect(classNames(() => 'foo', { foo: true }, 'bar')).toEqual('foo bar');\n      expect(classNames(() => 1, '1', { 1: false })).toEqual('');\n      expect(classNames('foo', 1, () => '1')).toEqual('foo 1');\n    });\n\n    test('off before on', () => {\n      expect(classNames(() => 'foo', 'bar', { foo: false }, 'foo')).toEqual(\n        'bar foo',\n      );\n      expect(\n        classNames(() => 'foo', { foo: false }, { foo: true }, 'bar'),\n      ).toEqual('foo bar');\n      expect(classNames(() => 1, '1', { 1: false }, 1)).toEqual('1');\n    });\n\n    describe('nested', () => {\n      test('turn off in nested', () => {\n        expect(classNames('foo', [{ foo: false }])).toEqual('');\n        expect(classNames('foo', [() => 'foo', { foo: false }])).toEqual('');\n      });\n\n      test('turn on in nested', () => {\n        expect(classNames('foo', [{ foo: false }, 'foo'])).toEqual('foo');\n        expect(\n          classNames('foo', [{ foo: false }, 'foo', { foo: false }]),\n        ).toEqual('');\n      });\n    });\n  });\n});\n",
    "/src/classnames-ii.ts": "export type ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | Function\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassDictionary = Record<string, any>;\nexport type ClassArray = Array<ClassValue>;\n\nexport default function classNames(...args: Array<ClassValue>): string {\n  const classes: Set<string> = new Set();\n\n  function classNamesImpl(...args: Array<ClassValue>) {\n    args.forEach((arg) => {\n      // Ignore falsey values.\n      if (!arg) {\n        return;\n      }\n\n      const argType = typeof arg;\n\n      // Handle string and numbers.\n      if (argType === 'string' || argType === 'number') {\n        classes.add(String(arg));\n        return;\n      }\n\n      // Handle functions.\n      if (argType === 'function') {\n        const result = (arg as Function)();\n        if (!result) {\n          return;\n        }\n\n        classes.add(String(result));\n      }\n\n      // Handle arrays.\n      if (Array.isArray(arg)) {\n        for (const cls of arg) {\n          classNamesImpl(cls);\n        }\n\n        return;\n      }\n\n      // Handle objects.\n      if (argType === 'object') {\n        const objArg = arg as ClassDictionary;\n        for (const key in objArg) {\n          // Only process non-inherited keys.\n          if (Object.hasOwn(objArg, key)) {\n            objArg[key] ? classes.add(key) : classes.delete(key);\n          }\n        }\n\n        return;\n      }\n    });\n  }\n\n  classNamesImpl(args);\n\n  return Array.from(classes).join(' ');\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1701302400,
    "difficulty": "hard",
    "duration": 25,
    "excerpt": "Implement a function that conditionally joins CSS class names together and also handles de-duplication and function values",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/classnames-ii",
    "importance": "medium",
    "languages": [
      "css",
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "classnames"
    ],
    "slug": "classnames-ii",
    "subtitle": null,
    "title": "Classnames II",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {...(any|Object|Array<any|Object|Array>|Function)} args\n * @return {string}\n */\nexport default function classNames(...args) {\n  throw 'Not implemented!';\n}",
    "ts": "export type ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | Function\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassDictionary = Record<string, any>;\nexport type ClassArray = Array<ClassValue>;\n\nexport default function classNames(...args: Array<ClassValue>): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var g=Object.create;var t=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var w=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports),v=(s,e)=>{for(var r in e)t(s,r,{get:e[r],enumerable:!0})},i=(s,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of y(e))!b.call(s,a)&&a!==r&&t(s,a,{get:()=>e[a],enumerable:!(l=f(e,a))||l.enumerable});return s};var k=(s,e,r)=>(r=s!=null?g(m(s)):{},i(e||!s||!s.__esModule?t(r,\"default\",{value:s,enumerable:!0}):r,s)),j=s=>i(t({},\"__esModule\",{value:!0}),s);var c=w((O,o)=>{o.exports=_jsx_runtime});var H={};v(H,{default:()=>C});var n=k(c());var d=MDXCodeBlock;var h=`/**\n * @param {...(any|Object|Array<any|Object|Array>|Function)} args\n * @return {string}\n */\nexport default function classNames(...args) {\n  const classes = new Set();\n\n  function classNamesImpl(...args) {\n    args.forEach((arg) => {\n      // Ignore falsey values.\n      if (!arg) {\n        return;\n      }\n\n      const argType = typeof arg;\n\n      // Handle string and numbers.\n      if (argType === 'string' || argType === 'number') {\n        classes.add(String(arg));\n        return;\n      }\n\n      // Handle functions.\n      if (argType === 'function') {\n        const result = arg();\n        if (!result) {\n          return;\n        }\n\n        classes.add(String(result));\n      }\n\n      // Handle arrays.\n      if (Array.isArray(arg)) {\n        for (const cls of arg) {\n          classNamesImpl(cls);\n        }\n\n        return;\n      }\n\n      // Handle objects.\n      if (argType === 'object') {\n        for (const key in arg) {\n          // Only process non-inherited keys.\n          if (Object.hasOwn(arg, key)) {\n            arg[key] ? classes.add(key) : classes.delete(key);\n          }\n        }\n\n        return;\n      }\n    });\n  }\n\n  classNamesImpl(args);\n\n  return Array.from(classes).join(' ');\n}\n`;var u=`export type ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | Function\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassDictionary = Record<string, any>;\nexport type ClassArray = Array<ClassValue>;\n\nexport default function classNames(...args: Array<ClassValue>): string {\n  const classes: Set<string> = new Set();\n\n  function classNamesImpl(...args: Array<ClassValue>) {\n    args.forEach((arg) => {\n      // Ignore falsey values.\n      if (!arg) {\n        return;\n      }\n\n      const argType = typeof arg;\n\n      // Handle string and numbers.\n      if (argType === 'string' || argType === 'number') {\n        classes.add(String(arg));\n        return;\n      }\n\n      // Handle functions.\n      if (argType === 'function') {\n        const result = (arg as Function)();\n        if (!result) {\n          return;\n        }\n\n        classes.add(String(result));\n      }\n\n      // Handle arrays.\n      if (Array.isArray(arg)) {\n        for (const cls of arg) {\n          classNamesImpl(cls);\n        }\n\n        return;\n      }\n\n      // Handle objects.\n      if (argType === 'object') {\n        const objArg = arg as ClassDictionary;\n        for (const key in objArg) {\n          // Only process non-inherited keys.\n          if (Object.hasOwn(objArg, key)) {\n            objArg[key] ? classes.add(key) : classes.delete(key);\n          }\n        }\n\n        return;\n      }\n    });\n  }\n\n  classNamesImpl(args);\n\n  return Array.from(classes).join(' ');\n}\n`;function p(s){let e=Object.assign({p:\"p\",a:\"a\",h2:\"h2\",blockquote:\"blockquote\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},s.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"This solution assumes you have completed the \",(0,n.jsx)(e.a,{href:\"/questions/javascript/classnames\",children:\"Classnames\"}),\" question and fully understand its solution.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,n.jsx)(e.p,{children:\"The following are good questions to ask the interviewer to demonstrate your thoughtfulness. Depending on their response, you might need to adjust the implementation accordingly.\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"If a class is turned off within a nested array, will it be turned off overall?\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"It depends on the position that the classes within the input, regardless of nested level. Classes that appear later will take precedence.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The tricky part of this solution is the recursive nature of the function. Hence we can separate out the solution into two parts:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Handling of each data type.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Recursing for array type.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Because the final result should only contain unique classnames and we need to turn classes on/off as we process each argument, we need a data structure that handles uniqueness; \",(0,n.jsx)(e.code,{children:\"Set\"}),\"s come to mind.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Classes that appear later will take precedence, regardless of nested level. This means that a pure recursive approach will not work as we need to know what classes exist in the classes that have been processed so far. We'll use the approach where an inner recursive helper modifies the external \",(0,n.jsx)(e.code,{children:\"classes\"}),\" set. The inner recursive helper does not return anything, it's main purpose is to process each argument and add them to \",(0,n.jsx)(e.code,{children:\"classes\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Here's how we will handle each data type:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Falsey values\"}),\": Ignore.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"String\"}),\": Add it to the \",(0,n.jsx)(e.code,{children:\"classes\"}),\" set.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Number\"}),\": Add it to the \",(0,n.jsx)(e.code,{children:\"classes\"}),\" set.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Array\"}),\": Recursively invoke the \",(0,n.jsx)(e.code,{children:\"classNames\"}),\" function or inner recursive function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Function\"}),\": Invoke the value and add it to \",(0,n.jsx)(e.code,{children:\"classes\"}),\" if it's truthy.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Object\"}),\": Loop through the key/value pairs. If the value is truthy, add it the \",(0,n.jsx)(e.code,{children:\"classes\"}),\" set. Otherwise, delete it from the \",(0,n.jsx)(e.code,{children:\"classes\"}),\" set.\"]}),`\n`]}),`\n`,(0,n.jsx)(d,{languages:{jsx:h,tsx:u}}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Familiar with JavaScript value types and how to check for them\"}),`\n`,(0,n.jsx)(e.li,{children:\"Recursion\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Conversion of \",(0,n.jsx)(e.code,{children:\"Set\"}),\"s to \",(0,n.jsx)(e.code,{children:\"Array\"}),\"s\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Handling of variadic arguments\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"typeof []\"}),\" gives \",(0,n.jsx)(e.code,{children:\"'object'\"}),\", so you need to handle arrays before objects.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"You are probably not expected to handle these scenario, but you should mention them:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Possibility of stack overflow. This applies to any recursive solution.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Possibility of circular references for arrays and objects. This applies to any input which has arbitrary depth.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:[(0,n.jsx)(e.code,{children:\"classnames\"}),\" library on GitHub\"]})}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.a,{href:\"https://github.com/lukeed/clsx\",children:[(0,n.jsx)(e.code,{children:\"clsx\"}),\" library on GitHub\"]}),\": A newer version which serves as a faster and smaller drop-in replacement for \",(0,n.jsx)(e.code,{children:\"classnames\"}),\".\"]}),`\n`]})]})}function T(s={}){let{wrapper:e}=s.components||{};return e?(0,n.jsx)(e,Object.assign({},s,{children:(0,n.jsx)(p,s)})):p(s)}var C=T;return j(H);})();\n;return Component;",
  "workspace": {
    "main": "/src/classnames-ii.ts",
    "run": "/src/classnames-ii.run.test.ts",
    "submit": "/src/classnames-ii.submit.test.ts"
  }
}