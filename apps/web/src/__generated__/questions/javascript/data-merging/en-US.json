{
  "description": "var Component=(()=>{var c=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!g.call(t,i)&&i!==r&&s(t,i,{get:()=>e[i],enumerable:!(o=h(e,i))||o.enumerable});return t};var q=(t,e,r)=>(r=t!=null?c(p(t)):{},a(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),x=t=>a(s({},\"__esModule\",{value:!0}),t);var d=f((_,l)=>{l.exports=_jsx_runtime});var D={};b(D,{default:()=>w,frontmatter:()=>j});var n=q(d()),j={title:\"Data Merging\",excerpt:\"Implement a function to merge rows of data from the same user\"};function u(t){let e=Object.assign({p:\"p\",pre:\"pre\",code:\"code\",ul:\"ul\",li:\"li\",strong:\"strong\",h2:\"h2\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"A data set of gym sessions looks like this:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`[\n  { user: 8, duration: 50, equipment: ['bench'] },\n  { user: 7, duration: 150, equipment: ['dumbbell'] },\n  { user: 1, duration: 10, equipment: ['barbell'] },\n  { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n  { user: 7, duration: 200, equipment: ['bike'] },\n  { user: 2, duration: 200, equipment: ['treadmill'] },\n  { user: 2, duration: 200, equipment: ['bike'] },\n];\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Each session has the following fields:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"user\"}),\": User ID of the session's user.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"duration\"}),\": Duration of the session, in minutes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"equipment\"}),\": Array of equipment used during the sessions, in alphabetical order. There are only 5 different equipments.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a method \",(0,n.jsx)(e.code,{children:\"mergeData\"}),\", which is used to return a unified view of each user's activities by merging data from each user. It has the interface \",(0,n.jsx)(e.code,{children:\"mergeData(sessions)\"}),\". Sessions from the same \",(0,n.jsx)(e.code,{children:\"user\"}),\" should be merged into one object. When merging:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sum up the \",(0,n.jsx)(e.code,{children:\"duration\"}),\" fields.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Combine all the \",(0,n.jsx)(e.code,{children:\"equipment\"}),\" used, de-duplicating the values and sorting alphabetically.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The order of the results should always remain unchanged from the original set, and in the case of merging sessions with the same users, the row should take the place of the \",(0,n.jsx)(e.strong,{children:\"earliest\"}),\" occurrence of that \",(0,n.jsx)(e.code,{children:\"user\"}),\". The input objects should not be modified.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.p,{children:\"The following example uses the data set above:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`mergeData(sessions);\n// [\n//   { user: 8, duration: 50, equipment: ['bench'] },\n//   { user: 7, duration: 450, equipment: ['bike', 'dumbbell', 'kettlebell'] },\n//   { user: 1, duration: 10, equipment: ['barbell'] },\n//   { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n// ];\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Data of user 7 and user 2 are merged into the first occurrence of that user.\"})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var w=k;return x(D);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/data-merging\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/data-merging.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/data-merging.run.test.ts": "import mergeData from './data-merging';\n\ndescribe('mergeData', () => {\n  test('empty data', () => {\n    expect(mergeData([])).toEqual([]);\n  });\n\n  test('merge for one user', () => {\n    expect(\n      mergeData([\n        { user: 1, duration: 10, equipment: ['barbell'] },\n        { user: 1, duration: 30, equipment: [] },\n      ]),\n    ).toEqual([{ user: 1, duration: 40, equipment: ['barbell'] }]);\n  });\n\n  test('merge for two users', () => {\n    expect(\n      mergeData([\n        { user: 8, duration: 50, equipment: ['bench'] },\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        { user: 8, duration: 50, equipment: ['bench'] },\n        { user: 7, duration: 150, equipment: ['bench', 'kettlebell'] },\n      ]),\n    ).toEqual([\n      { user: 8, duration: 100, equipment: ['bench'] },\n      {\n        user: 7,\n        duration: 300,\n        equipment: ['bench', 'dumbbell', 'kettlebell'],\n      },\n    ]);\n  });\n});\n",
    "/src/data-merging.submit.test.ts": "import mergeData from './data-merging';\n\nfunction dataSmall() {\n  return [\n    { user: 8, duration: 50, equipment: ['bench'] },\n    { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n    { user: 1, duration: 10, equipment: ['barbell'] },\n    { user: 7, duration: 100, equipment: ['bike', 'kettlebell'] },\n    { user: 7, duration: 200, equipment: ['bike'] },\n    { user: 2, duration: 200, equipment: ['treadmill'] },\n    { user: 2, duration: 200, equipment: ['bike'] },\n  ];\n}\n\ndescribe('mergeData', () => {\n  test('empty data', () => {\n    expect(mergeData([])).toEqual([]);\n  });\n\n  test('does not mutate data', () => {\n    const clonedData = dataSmall();\n    mergeData(clonedData);\n    expect(clonedData).toEqual(dataSmall());\n  });\n\n  describe('one user', () => {\n    test('single session', () => {\n      expect(\n        mergeData([{ user: 1, duration: 10, equipment: ['barbell'] }]),\n      ).toEqual([{ user: 1, duration: 10, equipment: ['barbell'] }]);\n    });\n\n    test('merge duration', () => {\n      expect(\n        mergeData([\n          { user: 1, duration: 10, equipment: ['barbell'] },\n          { user: 1, duration: 30, equipment: [] },\n        ]),\n      ).toEqual([{ user: 1, duration: 40, equipment: ['barbell'] }]);\n    });\n\n    test('merge equipment', () => {\n      expect(\n        mergeData([\n          { user: 1, duration: 10, equipment: ['bike'] },\n          { user: 1, duration: 30, equipment: ['barbell'] },\n        ]),\n      ).toEqual([{ user: 1, duration: 40, equipment: ['barbell', 'bike'] }]);\n    });\n\n    test('multiple sessions', () => {\n      expect(\n        mergeData([\n          { user: 1, duration: 10, equipment: ['bike'] },\n          { user: 1, duration: 30, equipment: ['barbell'] },\n        ]),\n      ).toEqual([{ user: 1, duration: 40, equipment: ['barbell', 'bike'] }]);\n    });\n  });\n\n  describe('multiple users', () => {\n    test('unique users', () => {\n      expect(\n        mergeData([\n          { user: 8, duration: 50, equipment: ['bench'] },\n          { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        ]),\n      ).toEqual([\n        { user: 8, duration: 50, equipment: ['bench'] },\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n      ]);\n    });\n\n    test('merge duration', () => {\n      expect(\n        mergeData([\n          { user: 8, duration: 50, equipment: ['bench'] },\n          { user: 8, duration: 50, equipment: ['bench'] },\n          { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        ]),\n      ).toEqual([\n        { user: 8, duration: 100, equipment: ['bench'] },\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n      ]);\n    });\n\n    test('merge equipment', () => {\n      expect(\n        mergeData([\n          { user: 8, duration: 50, equipment: ['bench', 'dumbbell'] },\n          { user: 8, duration: 50, equipment: ['bench'] },\n          { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        ]),\n      ).toEqual([\n        { user: 8, duration: 100, equipment: ['bench', 'dumbbell'] },\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n      ]);\n    });\n\n    test('preserves order', () => {\n      expect(\n        mergeData([\n          { user: 8, duration: 50, equipment: ['bench', 'dumbbell'] },\n          { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n          { user: 8, duration: 50, equipment: ['bench'] },\n          { user: 6, duration: 50, equipment: ['kettlebell'] },\n        ]),\n      ).toEqual([\n        { user: 8, duration: 100, equipment: ['bench', 'dumbbell'] },\n        { user: 7, duration: 150, equipment: ['dumbbell', 'kettlebell'] },\n        { user: 6, duration: 50, equipment: ['kettlebell'] },\n      ]);\n    });\n\n    test('integration', () => {\n      expect(mergeData(dataSmall())).toEqual([\n        { user: 8, duration: 50, equipment: ['bench'] },\n        {\n          user: 7,\n          duration: 450,\n          equipment: ['bike', 'dumbbell', 'kettlebell'],\n        },\n        { user: 1, duration: 10, equipment: ['barbell'] },\n        { user: 2, duration: 400, equipment: ['bike', 'treadmill'] },\n      ]);\n    });\n  });\n});\n",
    "/src/data-merging.ts": "type Session = { user: number; duration: number; equipment: Array<string> };\n\nexport default function mergeData(sessions: Array<Session>): Array<Session> {\n  const results: Array<{\n    user: number;\n    duration: number;\n    equipment: Set<string>;\n  }> = [];\n  const sessionsForUser = new Map();\n\n  sessions.forEach((session) => {\n    if (sessionsForUser.has(session.user)) {\n      const userSession = sessionsForUser.get(session.user);\n      userSession.duration += session.duration;\n      session.equipment.forEach((equipment) => {\n        userSession.equipment.add(equipment);\n      });\n    } else {\n      const clonedSession = {\n        ...session,\n        equipment: new Set(session.equipment),\n      };\n      sessionsForUser.set(session.user, clonedSession);\n      results.push(clonedSession);\n    }\n  });\n\n  // Sort equipment of each session and convert back into array.\n  return results.map((session) => ({\n    ...session,\n    equipment: Array.from(session.equipment).sort(),\n  }));\n}\n"
  },
  "info": {
    "excerpt": "Implement a function to merge rows of data from the same user",
    "title": "Data Merging"
  },
  "metadata": {
    "access": "standard",
    "author": null,
    "companies": [
      "soundcloud",
      "stripe"
    ],
    "created": 1690675200,
    "difficulty": "medium",
    "duration": 20,
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/data-merging",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "unique-array",
      "data-selection"
    ],
    "slug": "data-merging",
    "subtitle": null,
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Array<{user: number, duration: number, equipment: Array<string>}>} sessions\n * @return {Array}\n */\nexport default function mergeData(sessions) {\n  throw 'Not implemented!';\n}",
    "ts": "type Session = { user: number; duration: number; equipment: Array<string> };\n\nexport default function mergeData(sessions: Array<Session>): Array<Session> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var t=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),S=(n,e)=>{for(var r in e)t(n,r,{get:e[r],enumerable:!0})},a=(n,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!q.call(n,i)&&i!==r&&t(n,i,{get:()=>e[i],enumerable:!(o=f(e,i))||o.enumerable});return n};var w=(n,e,r)=>(r=n!=null?p(y(n)):{},a(e||!n||!n.__esModule?t(r,\"default\",{value:n,enumerable:!0}):r,n)),x=n=>a(t({},\"__esModule\",{value:!0}),n);var u=b((T,c)=>{c.exports=_jsx_runtime});var A={};S(A,{default:()=>v});var s=w(u());var d=MDXCodeBlock;var l=`/**\n * @param {Array<{user: number, duration: number, equipment: Array<string>}>} sessions\n * @return {Array<{user: number, duration: number, equipment: Array<string>}>}\n */\nexport default function mergeData(sessions) {\n  const results = [];\n  const sessionsForUser = new Map();\n\n  sessions.forEach((session) => {\n    if (sessionsForUser.has(session.user)) {\n      const userSession = sessionsForUser.get(session.user);\n      userSession.duration += session.duration;\n      session.equipment.forEach((equipment) => {\n        userSession.equipment.add(equipment);\n      });\n    } else {\n      const clonedSession = {\n        ...session,\n        equipment: new Set(session.equipment),\n      };\n      sessionsForUser.set(session.user, clonedSession);\n      results.push(clonedSession);\n    }\n  });\n\n  // Sort equipment of each session and convert back into array.\n  return results.map((session) => ({\n    ...session,\n    equipment: Array.from(session.equipment).sort(),\n  }));\n}\n`;var h=`type Session = { user: number; duration: number; equipment: Array<string> };\n\nexport default function mergeData(sessions: Array<Session>): Array<Session> {\n  const results: Array<{\n    user: number;\n    duration: number;\n    equipment: Set<string>;\n  }> = [];\n  const sessionsForUser = new Map();\n\n  sessions.forEach((session) => {\n    if (sessionsForUser.has(session.user)) {\n      const userSession = sessionsForUser.get(session.user);\n      userSession.duration += session.duration;\n      session.equipment.forEach((equipment) => {\n        userSession.equipment.add(equipment);\n      });\n    } else {\n      const clonedSession = {\n        ...session,\n        equipment: new Set(session.equipment),\n      };\n      sessionsForUser.set(session.user, clonedSession);\n      results.push(clonedSession);\n    }\n  });\n\n  // Sort equipment of each session and convert back into array.\n  return results.map((session) => ({\n    ...session,\n    equipment: Array.from(session.equipment).sort(),\n  }));\n}\n`;function m(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",blockquote:\"blockquote\",ol:\"ol\",li:\"li\",ul:\"ul\"},n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,s.jsxs)(e.p,{children:[\"We have to merge the data for sessions with the same \",(0,s.jsx)(e.code,{children:\"user\"}),\" field and also preserve the order. Note the requirement that:\"]}),`\n`,(0,s.jsxs)(e.blockquote,{children:[`\n`,(0,s.jsx)(e.p,{children:\"in the case of merging sessions with duplicate users, the row should take the place of the earliest occurrence of that user. The input objects should not be modified.\"}),`\n`]}),`\n`,(0,s.jsxs)(e.p,{children:[\"We can initialize a new array \",(0,s.jsx)(e.code,{children:\"results\"}),\", and adding user sessions into it. Before adding we need to check if there's a session for that user already in \",(0,s.jsx)(e.code,{children:\"results\"}),\", and update that object instead of adding to the new array. There are two ways to go about this:\"]}),`\n`,(0,s.jsxs)(e.ol,{children:[`\n`,(0,s.jsxs)(e.li,{children:[\"For every session item, iterate through the \",(0,s.jsx)(e.code,{children:\"results\"}),\" array and check for existing users. The iteration through the \",(0,s.jsx)(e.code,{children:\"results\"}),\" array will result in O(n\",(0,s.jsx)(\"exp\",{children:\"2\"}),\") time complexity.\"]}),`\n`,(0,s.jsxs)(e.li,{children:[\"Maintain a hash map \",(0,s.jsx)(e.code,{children:\"sessionsForUser\"}),\" (via \",(0,s.jsx)(e.code,{children:\"Object\"}),\" or \",(0,s.jsx)(e.code,{children:\"Map\"}),\" in JavaScript), and use it to retain a reference to the session for a specific user, by having the user ID as the key. This will allow O(1) user look up complexity at the cost of O(n) memory space. The overall time complexity will be O(n).\"]}),`\n`]}),`\n`,(0,s.jsxs)(e.p,{children:[\"The values within \",(0,s.jsx)(e.code,{children:\"results\"}),\" and \",(0,s.jsx)(e.code,{children:\"sessionsForUser\"}),\" point to the same object instances, such that updating the object instance will update the contents of both containers. To efficiently combine the \",(0,s.jsx)(e.code,{children:\"equipment\"}),\" field, we can use a \",(0,s.jsx)(e.code,{children:\"Set\"}),\" while processing and convert the field back into an array at the end just before returning. The time complexity required for sorting of the \",(0,s.jsx)(e.code,{children:\"equipment\"}),\" field while merging is considered constant because there are only 5 different equipments.\"]}),`\n`,(0,s.jsx)(d,{languages:{jsx:l,tsx:h}}),`\n`,(0,s.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,s.jsxs)(e.ul,{children:[`\n`,(0,s.jsxs)(e.li,{children:[\"Familiarity with JavaScript data structures like \",(0,s.jsx)(e.code,{children:\"Array\"}),\"s, \",(0,s.jsx)(e.code,{children:\"Map\"}),\"s, and \",(0,s.jsx)(e.code,{children:\"Set\"}),\"s.\"]}),`\n`]})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(m,n)})):m(n)}var v=F;return x(A);})();\n;return Component;",
  "workspace": {
    "main": "/src/data-merging.ts",
    "run": "/src/data-merging.run.test.ts",
    "submit": "/src/data-merging.submit.test.ts"
  }
}