{
  "description": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),j=(r,e)=>{for(var n in e)s(r,n,{get:e[n],enumerable:!0})},t=(r,e,n,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of P(e))!u.call(r,o)&&o!==n&&s(r,o,{get:()=>e[o],enumerable:!(l=h(e,o))||l.enumerable});return r};var v=(r,e,n)=>(n=r!=null?d(p(r)):{},t(e||!r||!r.__esModule?s(n,\"default\",{value:r,enumerable:!0}):n,r)),x=r=>t(s({},\"__esModule\",{value:!0}),r);var m=g((y,c)=>{c.exports=_jsx_runtime});var _={};j(_,{default:()=>M,frontmatter:()=>f});var i=v(m()),f={title:\"Promise \\u5408\\u5E76\",excerpt:\"\\u5B9E\\u73B0\\u4E00\\u4E2A\\u51FD\\u6570\\uFF0C\\u5C06\\u4E24\\u4E2A Promise \\u7684\\u7ED3\\u679C\\u5408\\u5E76\\u6210\\u4E00\\u4E2A\\u5355\\u4E00\\u7684\\u503C\"};function a(r){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},r.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:[\"\\u5B9E\\u73B0\\u4E00\\u4E2A\\u63A5\\u53D7\\u4E24\\u4E2A Promise \\u5E76\\u8FD4\\u56DE\\u5355\\u4E2A \",(0,i.jsx)(e.code,{children:\"Promise\"}),\" \\u7684\\u51FD\\u6570\\u3002\\u5F53\\u4E24\\u4E2A\\u8F93\\u5165 Promise \\u90FD\\u88AB\\u5151\\u73B0\\u65F6\\uFF0C\\u6B64\\u8FD4\\u56DE\\u7684 Promise \\u5C06\\u88AB\\u5151\\u73B0\\uFF0C\\u5E76\\u6839\\u636E\\u5151\\u73B0\\u503C\\u7684\\u987A\\u5E8F\\u548C\\u7C7B\\u578B\\u63D0\\u4F9B\\u4E00\\u4E2A\\u5355\\u4E00\\u7684\\u503C\\uFF1A\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"\\u6570\\u5B57\\u5E94\\u8BE5\\u76F8\\u52A0\\u3002\"}),`\n`,(0,i.jsx)(e.li,{children:\"\\u5B57\\u7B26\\u4E32\\u5E94\\u8BE5\\u8FDE\\u63A5\\u3002\"}),`\n`,(0,i.jsx)(e.li,{children:\"\\u6570\\u7EC4\\u5E94\\u8BE5\\u5408\\u5E76\\u6210\\u4E00\\u4E2A\\u5355\\u4E00\\u7684\\u6570\\u7EC4\\u3002\"}),`\n`,(0,i.jsx)(e.li,{children:\"\\u7EAF\\u5BF9\\u8C61\\u5E94\\u8BE5\\u5408\\u5E76\\u6210\\u4E00\\u4E2A\\u5355\\u4E00\\u7684\\u5BF9\\u8C61\\u3002\"}),`\n`,(0,i.jsx)(e.li,{children:\"\\u4E0D\\u652F\\u6301\\u5176\\u4ED6\\u7C7B\\u578B\\u3002\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"\\u5982\\u679C\\u53D1\\u751F\\u4EE5\\u4E0B\\u60C5\\u51B5\\u4E4B\\u4E00\\uFF0C\\u5219\\u8FD4\\u56DE\\u7684 Promise \\u4E5F\\u53EF\\u4EE5\\u88AB\\u62D2\\u7EDD\\uFF1A\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"\\u5151\\u73B0\\u7ED3\\u679C\\u7684\\u7C7B\\u578B\\u4E0D\\u5339\\u914D\\uFF0C\\u5219\\u62D2\\u7EDD\\u5E76\\u663E\\u793A\\u5B57\\u7B26\\u4E32 \",(0,i.jsx)(e.code,{children:\"'\\u4E0D\\u652F\\u6301\\u7684\\u6570\\u636E\\u7C7B\\u578B'\"}),\"\\u3002\"]}),`\n`,(0,i.jsx)(e.li,{children:\"\\u5176\\u4E2D\\u4E00\\u4E2A Promise \\u5931\\u8D25\\uFF0C\\u5219\\u62D2\\u7EDD\\u5E76\\u663E\\u793A\\u88AB\\u62D2\\u7EDD\\u7684 Promise \\u7684\\u539F\\u56E0\\u3002\"}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{children:\"\\u4F8B\\u5B50\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-js\",children:`await promiseMerge(Promise.resolve(1), Promise.resolve(2)); // 3\nawait promiseMerge(Promise.resolve('abc'), Promise.resolve('def')); // 'abcdef'\nawait promiseMerge(Promise.resolve([1, 2, 3]), Promise.resolve([4, 5, 6])); // [1, 2, 3, 4, 5, 6]\nawait promiseMerge(Promise.resolve({ foo: 1 }), Promise.resolve({ bar: 2 })); // { foo: 1, bar: 2}\n\nawait promiseMerge(Promise.resolve(1), Promise.resolve([])); // Rejected with 'Unsupported data types'\nawait promiseMerge(Promise.reject(1), Promise.resolve(2)); // Rejected with 1\n`})})]})}function w(r={}){let{wrapper:e}=r.components||{};return e?(0,i.jsx)(e,Object.assign({},r,{children:(0,i.jsx)(a,r)})):a(r)}var M=w;return x(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-merge\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-merge.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promise-merge.run.test.ts": "import promiseMerge from './promise-merge';\n\ndescribe('promiseMerge', () => {\n  test('returns a promise', () => {\n    const promise = promiseMerge(Promise.resolve(1), Promise.resolve(2));\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  test('numbers', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve(21), 10)),\n      new Promise((resolve) => setTimeout(() => resolve(22), 5)),\n    );\n    await expect(promise).resolves.toBe(43);\n  });\n\n  test('arrays', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve([1, 2, 3]), 5)),\n      new Promise((resolve) => setTimeout(() => resolve([4, 5, 6]), 10)),\n    );\n    await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n  });\n\n  test('objects', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve({ foo: 1 }), 5)),\n      new Promise((resolve) => setTimeout(() => resolve({ bar: 2 }), 10)),\n    );\n    await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n  });\n});\n",
    "/src/promise-merge.submit.test.ts": "import promiseMerge from './promise-merge';\n\ndescribe('promiseMerge', () => {\n  test('returns a promise', () => {\n    const promise = promiseMerge(Promise.resolve(1), Promise.resolve(2));\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  describe('resolved', () => {\n    describe('numbers', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(Promise.resolve(21), Promise.resolve(22));\n        await expect(promise).resolves.toBe(43);\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve(21), 10)),\n          new Promise((resolve) => setTimeout(() => resolve(22), 5)),\n        );\n        await expect(promise).resolves.toBe(43);\n      });\n    });\n\n    describe('strings', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve('123'),\n          Promise.resolve('456'),\n        );\n        await expect(promise).resolves.toBe('123456');\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve('123'), 10)),\n          new Promise((resolve) => setTimeout(() => resolve('456'), 5)),\n        );\n        await expect(promise).resolves.toBe('123456');\n      });\n    });\n\n    describe('arrays', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve([1, 2, 3]),\n          Promise.resolve([4, 5, 6]),\n        );\n        await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve([1, 2, 3]), 5)),\n          new Promise((resolve) => setTimeout(() => resolve([4, 5, 6]), 10)),\n        );\n        await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n      });\n    });\n\n    describe('objects', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve({ foo: 1 }),\n          Promise.resolve({ bar: 2 }),\n        );\n        await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve({ foo: 1 }), 5)),\n          new Promise((resolve) => setTimeout(() => resolve({ bar: 2 }), 10)),\n        );\n        await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n      });\n    });\n  });\n\n  describe('rejected', () => {\n    test('promises rejected', async () => {\n      const promise = promiseMerge(\n        new Promise((resolve) => setTimeout(() => resolve(1), 5)),\n        new Promise((_, reject) => setTimeout(() => reject(2), 10)),\n      );\n      await expect(promise).rejects.toEqual(2);\n    });\n\n    test('supported data types but not mergeable', async () => {\n      const promise = promiseMerge(\n        new Promise((resolve) => setTimeout(() => resolve(1), 5)),\n        new Promise((resolve) => setTimeout(() => resolve([]), 10)),\n      );\n      await expect(promise).rejects.toEqual('Unsupported data types');\n    });\n\n    test('unsupported data types', async () => {\n      const promise = promiseMerge(\n        // @ts-expect-error\n        new Promise((resolve) => setTimeout(() => resolve(new Set([1]), 5))),\n        // @ts-expect-error\n        new Promise((resolve) => setTimeout(() => resolve(new Set([2]), 10))),\n      );\n      await expect(promise).rejects.toEqual('Unsupported data types');\n    });\n  });\n});\n",
    "/src/promise-merge.ts": "export default function promiseMerge(\n  p1: Promise<unknown>,\n  p2: Promise<unknown>,\n): Promise<unknown> {\n  let unresolved = 2;\n  let p1Result: unknown, p2Result: unknown;\n\n  return new Promise((resolve, reject) => {\n    function then() {\n      unresolved--;\n      if (unresolved === 0) {\n        resolve(mergeResult(p1Result, p2Result));\n      }\n    }\n\n    p1.then((result) => {\n      p1Result = result;\n      then();\n    }).catch(reject);\n    p2.then((result) => {\n      p2Result = result;\n      then();\n    }).catch(reject);\n  });\n}\n\nfunction mergeResult(result1: unknown, result2: unknown): unknown {\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...(result1 as Object), ...(result2 as Object) };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1683331200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "实现一个函数，将两个 Promise 的结果合并成一个单一的值",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promise-merge",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "promise-all"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "promise-all",
      "promise-all-settled"
    ],
    "slug": "promise-merge",
    "subtitle": null,
    "title": "Promise 合并",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default function promiseMerge(p1, p2) {\n  throw 'Not implemented';\n}",
    "ts": "export default function promiseMerge(\n  p1: Promise<unknown>,\n  p2: Promise<unknown>,\n): Promise<unknown> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var h=Object.create;var l=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var O=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var n in e)l(t,n,{get:e[n],enumerable:!0})},i=(t,e,n,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of P(e))!g.call(t,s)&&s!==n&&l(t,s,{get:()=>e[s],enumerable:!(o=j(e,s))||o.enumerable});return t};var w=(t,e,n)=>(n=t!=null?h(b(t)):{},i(e||!t||!t.__esModule?l(n,\"default\",{value:t,enumerable:!0}):n,t)),A=t=>i(l({},\"__esModule\",{value:!0}),t);var a=O((D,p)=>{p.exports=_jsx_runtime});var F={};v(F,{default:()=>_});var r=w(a());var u=MDXCodeBlock;var c=`/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default function promiseMerge(p1, p2) {\n  let unresolved = 2;\n  let p1Result, p2Result;\n\n  return new Promise((resolve, reject) => {\n    function then() {\n      unresolved--;\n      if (unresolved === 0) {\n        resolve(mergeResult(p1Result, p2Result));\n      }\n    }\n\n    p1.then((result) => {\n      p1Result = result;\n      then();\n    }).catch(reject);\n    p2.then((result) => {\n      p2Result = result;\n      then();\n    }).catch(reject);\n  });\n}\n\nfunction mergeResult(result1, result2) {\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...result1, ...result2 };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;var d=`export default function promiseMerge(\n  p1: Promise<unknown>,\n  p2: Promise<unknown>,\n): Promise<unknown> {\n  let unresolved = 2;\n  let p1Result: unknown, p2Result: unknown;\n\n  return new Promise((resolve, reject) => {\n    function then() {\n      unresolved--;\n      if (unresolved === 0) {\n        resolve(mergeResult(p1Result, p2Result));\n      }\n    }\n\n    p1.then((result) => {\n      p1Result = result;\n      then();\n    }).catch(reject);\n    p2.then((result) => {\n      p2Result = result;\n      then();\n    }).catch(reject);\n  });\n}\n\nfunction mergeResult(result1: unknown, result2: unknown): unknown {\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...(result1 as Object), ...(result2 as Object) };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;var f=`/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default function promiseMerge(p1, p2) {\n  return Promise.all([p1, p2]).then(([result1, result2]) => {\n    try {\n      if (typeof result1 === 'number' && typeof result2 === 'number') {\n        return result1 + result2;\n      }\n\n      if (typeof result1 === 'string' && typeof result2 === 'string') {\n        return result1 + result2;\n      }\n\n      if (Array.isArray(result1) && Array.isArray(result2)) {\n        return [...result1, ...result2];\n      }\n\n      if (isPlainObject(result1) && isPlainObject(result2)) {\n        return { ...result1, ...result2 };\n      }\n\n      throw 'Unsupported data types';\n    } catch {\n      throw 'Unsupported data types';\n    }\n  });\n}\n\nfunction isPlainObject(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;var m=`/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default async function promiseMerge(p1, p2) {\n  const result1 = await p1;\n  const result2 = await p2;\n\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...result1, ...result2 };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;function y(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",h3:\"h3\",p:\"p\",code:\"code\",a:\"a\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"\\u6F84\\u6E05\\u95EE\\u9898\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"\\u5982\\u679C\\u8981\\u5408\\u5E76\\u7684\\u5BF9\\u8C61\\u6709\\u91CD\\u53E0\\u7684\\u5C5E\\u6027\\u4F1A\\u53D1\\u751F\\u4EC0\\u4E48\\uFF1F\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"\\u5B83\\u4EEC\\u53EF\\u4EE5\\u7B80\\u5355\\u5730\\u88AB\\u8986\\u76D6\\uFF0C\\u4E0D\\u9700\\u8981\\u6267\\u884C\\u6DF1\\u5C42\\u5408\\u5E76\\u3002\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"\\u89E3\\u51B3\\u65B9\\u6848\"}),`\n`,(0,r.jsx)(e.h3,{children:\"\\u65B9\\u6CD5 1\\uFF1A\\u624B\\u52A8\\u534F\\u8C03\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"\\u6211\\u4EEC\\u53EF\\u4EE5\\u901A\\u8FC7\\u8DDF\\u8E2A\\u672A\\u89E3\\u51B3\\u7684 promise \\u7684\\u6570\\u91CF\\u5E76\\u5B58\\u50A8\\u5DF2\\u89E3\\u51B3\\u7684 promise \\u7684\\u503C\\u6765\\u8DDF\\u8E2A promise \\u7684\\u72B6\\u6001\\u3002 \\u5982\\u679C\\u6CA1\\u6709\\u672A\\u89E3\\u51B3\\u7684 promise\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u7EE7\\u7EED\\u5408\\u5E76\\u7ED3\\u679C\\uFF0C\\u5E76\\u4F7F\\u7528\\u8BE5\\u7ED3\\u679C \",(0,r.jsx)(e.code,{children:\"resolve()\"}),\" \\u8FD4\\u56DE\\u7684 promise\\u3002\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"\\u5982\\u679C\\u60A8\\u77E5\\u9053\\u5982\\u4F55\\u68C0\\u67E5\\u5E38\\u89C1\\u6570\\u636E\\u7C7B\\u578B\\uFF0C\\u5408\\u5E76\\u7ED3\\u679C\\u975E\\u5E38\\u7B80\\u5355\\uFF0C\\u6211\\u4EEC\\u5DF2\\u7ECF\\u5728 \",(0,r.jsx)(e.a,{href:\"/questions/javascript/type-utilities\",children:\"\\u7C7B\\u578B\\u5B9E\\u7528\\u7A0B\\u5E8F\"}),\" \\u548C \",(0,r.jsx)(e.a,{href:\"/questions/javascript/type-utilities-ii\",children:\"\\u7C7B\\u578B\\u5B9E\\u7528\\u7A0B\\u5E8F II\"}),\" \\u4E2D\\u4ECB\\u7ECD\\u4E86\\u8FD9\\u4E9B\\u5185\\u5BB9\\u3002 \\u7531\\u4E8E\\u4EC5\\u652F\\u6301\\u7EAF\\u5BF9\\u8C61\\u7684\\u5408\\u5E76\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u533A\\u5206\\u7EAF\\u5BF9\\u8C61\\u548C\\u5176\\u4ED6\\u5BF9\\u8C61\\uFF0C\\u5982 \",(0,r.jsx)(e.code,{children:\"Set\"}),\" \\u548C \",(0,r.jsx)(e.code,{children:\"Map\"}),\"\\u3002\"]}),`\n`,(0,r.jsx)(u,{languages:{jsx:c,tsx:d}}),`\n`,(0,r.jsxs)(e.p,{children:[\"\\u8BF7\\u6CE8\\u610F\\uFF0C\\u8DDF\\u8E2A\\u5DF2\\u89E3\\u51B3\\u7684 promise \\u7ED3\\u679C\\u7684\\u903B\\u8F91\\u53EF\\u80FD\\u4F1A\\u53D8\\u5F97\\u91CD\\u590D\\uFF0C\\u5982\\u679C\\u8BE5\\u51FD\\u6570\\u652F\\u6301 2 \\u4E2A\\u4EE5\\u4E0A\\u7684 promise\\uFF0C\\u60C5\\u51B5\\u4F1A\\u53D8\\u5F97\\u66F4\\u7CDF\\u3002 \\u503C\\u5F97\\u5E86\\u5E78\\u7684\\u662F\\uFF0C\\u5B9E\\u9645\\u4E0A\\u6709\\u4E00\\u4E2A\\u5185\\u7F6E\\u7684\\u7ED3\\u6784\\u53EF\\u4EE5\\u5E2E\\u52A9\\u7BA1\\u7406\\u591A\\u4E2A promise \\u7684\\u72B6\\u6001\\uFF1A\",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\"\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u4F7F\\u7528\\u5B83\\u6765\\u7B80\\u5316\\u4EE3\\u7801\\u3002\"]}),`\n`,(0,r.jsxs)(e.h3,{children:[\"\\u65B9\\u6CD5 2\\uFF1A\\u4F7F\\u7528 \",(0,r.jsx)(e.code,{children:\"Promise.all()\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"\\u4F7F\\u7528 \",(0,r.jsx)(e.code,{children:\"Promise.all()\"}),\" \\u5C06\\u5927\\u5927\\u7B80\\u5316\\u4EE3\\u7801\\u3002 \\u4F46\\u662F\\uFF0C\\u9762\\u8BD5\\u65F6\\u53EF\\u80FD\\u4E0D\\u5141\\u8BB8\\u60A8\\u4F7F\\u7528\\u5B83\\uFF0C\\u56E0\\u6B64\\u4E86\\u89E3\\u5982\\u4F55\\u624B\\u52A8\\u8DDF\\u8E2A promise \\u7684\\u72B6\\u6001\\u4ECD\\u7136\\u5F88\\u6709\\u7528\\u3002\"]}),`\n`,(0,r.jsx)(u,{children:f}),`\n`,(0,r.jsxs)(e.h3,{children:[\"\\u65B9\\u6CD5 3\\uFF1A\\u4F7F\\u7528\\u4E32\\u884C \",(0,r.jsx)(e.code,{children:\"await\"}),\"\\uFF08\\u975E\\u6700\\u4F73\\uFF09\"]}),`\n`,(0,r.jsx)(e.p,{children:\"\\u6B64\\u89E3\\u51B3\\u65B9\\u6848\\u975E\\u5E38\\u7B80\\u5355\\uFF0C\\u4F46\\u5E76\\u975E\\u6700\\u4F73\\uFF0C\\u56E0\\u4E3A promise \\u662F\\u4E32\\u884C\\u800C\\u4E0D\\u662F\\u5E76\\u884C\\u89E3\\u51B3\\u7684\\u3002\"}),`\n`,(0,r.jsx)(u,{children:m})]})}function U(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(y,t)})):y(t)}var _=U;return A(F);})();\n;return Component;",
  "workspace": {
    "main": "/src/promise-merge.ts",
    "run": "/src/promise-merge.run.test.ts",
    "submit": "/src/promise-merge.submit.test.ts"
  }
}