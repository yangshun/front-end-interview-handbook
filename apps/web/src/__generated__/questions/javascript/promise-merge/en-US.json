{
  "description": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),j=(r,e)=>{for(var t in e)s(r,t,{get:e[t],enumerable:!0})},l=(r,e,t,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!f.call(r,o)&&o!==t&&s(r,o,{get:()=>e[o],enumerable:!(i=m(e,o))||i.enumerable});return r};var b=(r,e,t)=>(t=r!=null?h(u(r)):{},l(e||!r||!r.__esModule?s(t,\"default\",{value:r,enumerable:!0}):t,r)),w=r=>l(s({},\"__esModule\",{value:!0}),r);var c=g((_,a)=>{a.exports=_jsx_runtime});var M={};j(M,{default:()=>x,frontmatter:()=>P});var n=b(c()),P={title:\"Promise Merge\",excerpt:\"Implement a function to merge the results of two promises into a single value\"};function d(r){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function that accepts two promises and returns a single \",(0,n.jsx)(e.code,{children:\"Promise\"}),\". This returned promise fulfills when both input promises fulfill, with a single value according to the order and types of the fulfillment values:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Numbers should be added together.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Strings should be concatenated.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Arrays should be combined into a single array.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Plain objects should be merged into a single object.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Other types aren't supported.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The return promise can also be rejected if one of the following happens:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The types of the fulfilled results do not match, reject with the string \",(0,n.jsx)(e.code,{children:\"'Unsupported data types'\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"One of the promises fail, reject with the rejected promise's reason.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`await promiseMerge(Promise.resolve(1), Promise.resolve(2)); // 3\nawait promiseMerge(Promise.resolve('abc'), Promise.resolve('def')); // 'abcdef'\nawait promiseMerge(Promise.resolve([1, 2, 3]), Promise.resolve([4, 5, 6])); // [1, 2, 3, 4, 5, 6]\nawait promiseMerge(Promise.resolve({ foo: 1 }), Promise.resolve({ bar: 2 })); // { foo: 1, bar: 2}\n\nawait promiseMerge(Promise.resolve(1), Promise.resolve([])); // Rejected with 'Unsupported data types'\nawait promiseMerge(Promise.reject(1), Promise.resolve(2)); // Rejected with 1\n`})})]})}function v(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(d,r)})):d(r)}var x=v;return w(M);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-merge\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-merge.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promise-merge.run.test.ts": "import promiseMerge from './promise-merge';\n\ndescribe('promiseMerge', () => {\n  test('returns a promise', () => {\n    const promise = promiseMerge(Promise.resolve(1), Promise.resolve(2));\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  test('numbers', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve(21), 10)),\n      new Promise((resolve) => setTimeout(() => resolve(22), 5)),\n    );\n    await expect(promise).resolves.toBe(43);\n  });\n\n  test('arrays', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve([1, 2, 3]), 5)),\n      new Promise((resolve) => setTimeout(() => resolve([4, 5, 6]), 10)),\n    );\n    await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n  });\n\n  test('objects', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve({ foo: 1 }), 5)),\n      new Promise((resolve) => setTimeout(() => resolve({ bar: 2 }), 10)),\n    );\n    await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n  });\n});\n",
    "/src/promise-merge.submit.test.ts": "import promiseMerge from './promise-merge';\n\ndescribe('promiseMerge', () => {\n  test('returns a promise', () => {\n    const promise = promiseMerge(Promise.resolve(1), Promise.resolve(2));\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  describe('resolved', () => {\n    describe('numbers', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(Promise.resolve(21), Promise.resolve(22));\n        await expect(promise).resolves.toBe(43);\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve(21), 10)),\n          new Promise((resolve) => setTimeout(() => resolve(22), 5)),\n        );\n        await expect(promise).resolves.toBe(43);\n      });\n    });\n\n    describe('strings', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve('123'),\n          Promise.resolve('456'),\n        );\n        await expect(promise).resolves.toBe('123456');\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve('123'), 10)),\n          new Promise((resolve) => setTimeout(() => resolve('456'), 5)),\n        );\n        await expect(promise).resolves.toBe('123456');\n      });\n    });\n\n    describe('arrays', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve([1, 2, 3]),\n          Promise.resolve([4, 5, 6]),\n        );\n        await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve([1, 2, 3]), 5)),\n          new Promise((resolve) => setTimeout(() => resolve([4, 5, 6]), 10)),\n        );\n        await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n      });\n    });\n\n    describe('objects', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve({ foo: 1 }),\n          Promise.resolve({ bar: 2 }),\n        );\n        await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve({ foo: 1 }), 5)),\n          new Promise((resolve) => setTimeout(() => resolve({ bar: 2 }), 10)),\n        );\n        await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n      });\n    });\n  });\n\n  describe('rejected', () => {\n    test('promises rejected', async () => {\n      const promise = promiseMerge(\n        new Promise((resolve) => setTimeout(() => resolve(1), 5)),\n        new Promise((_, reject) => setTimeout(() => reject(2), 10)),\n      );\n      await expect(promise).rejects.toEqual(2);\n    });\n\n    test('supported data types but not mergeable', async () => {\n      const promise = promiseMerge(\n        new Promise((resolve) => setTimeout(() => resolve(1), 5)),\n        new Promise((resolve) => setTimeout(() => resolve([]), 10)),\n      );\n      await expect(promise).rejects.toEqual('Unsupported data types');\n    });\n\n    test('unsupported data types', async () => {\n      const promise = promiseMerge(\n        // @ts-expect-error\n        new Promise((resolve) => setTimeout(() => resolve(new Set([1]), 5))),\n        // @ts-expect-error\n        new Promise((resolve) => setTimeout(() => resolve(new Set([2]), 10))),\n      );\n      await expect(promise).rejects.toEqual('Unsupported data types');\n    });\n  });\n});\n",
    "/src/promise-merge.ts": "export default function promiseMerge(\n  p1: Promise<unknown>,\n  p2: Promise<unknown>,\n): Promise<unknown> {\n  let unresolved = 2;\n  let p1Result: unknown, p2Result: unknown;\n\n  return new Promise((resolve, reject) => {\n    function then() {\n      unresolved--;\n      if (unresolved === 0) {\n        resolve(mergeResult(p1Result, p2Result));\n      }\n    }\n\n    p1.then((result) => {\n      p1Result = result;\n      then();\n    }).catch(reject);\n    p2.then((result) => {\n      p2Result = result;\n      then();\n    }).catch(reject);\n  });\n}\n\nfunction mergeResult(result1: unknown, result2: unknown): unknown {\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...(result1 as Object), ...(result2 as Object) };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1683331200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function to merge the results of two promises into a single value",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promise-merge",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "promise-all"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "promise-all",
      "promise-all-settled"
    ],
    "slug": "promise-merge",
    "subtitle": null,
    "title": "Promise Merge",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default function promiseMerge(p1, p2) {\n  throw 'Not implemented';\n}",
    "ts": "export default function promiseMerge(\n  p1: Promise<unknown>,\n  p2: Promise<unknown>,\n): Promise<unknown> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var y=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),P=(r,e)=>{for(var n in e)o(r,n,{get:e[n],enumerable:!0})},i=(r,e,n,u)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of b(e))!w.call(r,s)&&s!==n&&o(r,s,{get:()=>e[s],enumerable:!(u=g(e,s))||u.enumerable});return r};var O=(r,e,n)=>(n=r!=null?y(j(r)):{},i(e||!r||!r.__esModule?o(n,\"default\",{value:r,enumerable:!0}):n,r)),k=r=>i(o({},\"__esModule\",{value:!0}),r);var a=v((C,p)=>{p.exports=_jsx_runtime});var F={};P(F,{default:()=>_});var t=O(a());var l=MDXCodeBlock;var c=`/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default function promiseMerge(p1, p2) {\n  let unresolved = 2;\n  let p1Result, p2Result;\n\n  return new Promise((resolve, reject) => {\n    function then() {\n      unresolved--;\n      if (unresolved === 0) {\n        resolve(mergeResult(p1Result, p2Result));\n      }\n    }\n\n    p1.then((result) => {\n      p1Result = result;\n      then();\n    }).catch(reject);\n    p2.then((result) => {\n      p2Result = result;\n      then();\n    }).catch(reject);\n  });\n}\n\nfunction mergeResult(result1, result2) {\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...result1, ...result2 };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;var d=`export default function promiseMerge(\n  p1: Promise<unknown>,\n  p2: Promise<unknown>,\n): Promise<unknown> {\n  let unresolved = 2;\n  let p1Result: unknown, p2Result: unknown;\n\n  return new Promise((resolve, reject) => {\n    function then() {\n      unresolved--;\n      if (unresolved === 0) {\n        resolve(mergeResult(p1Result, p2Result));\n      }\n    }\n\n    p1.then((result) => {\n      p1Result = result;\n      then();\n    }).catch(reject);\n    p2.then((result) => {\n      p2Result = result;\n      then();\n    }).catch(reject);\n  });\n}\n\nfunction mergeResult(result1: unknown, result2: unknown): unknown {\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...(result1 as Object), ...(result2 as Object) };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;var h=`/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default function promiseMerge(p1, p2) {\n  return Promise.all([p1, p2]).then(([result1, result2]) => {\n    try {\n      if (typeof result1 === 'number' && typeof result2 === 'number') {\n        return result1 + result2;\n      }\n\n      if (typeof result1 === 'string' && typeof result2 === 'string') {\n        return result1 + result2;\n      }\n\n      if (Array.isArray(result1) && Array.isArray(result2)) {\n        return [...result1, ...result2];\n      }\n\n      if (isPlainObject(result1) && isPlainObject(result2)) {\n        return { ...result1, ...result2 };\n      }\n\n      throw 'Unsupported data types';\n    } catch {\n      throw 'Unsupported data types';\n    }\n  });\n}\n\nfunction isPlainObject(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;var f=`/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default async function promiseMerge(p1, p2) {\n  const result1 = await p1;\n  const result2 = await p2;\n\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...result1, ...result2 };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value) {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n`;function m(r){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",h3:\"h3\",p:\"p\",code:\"code\",a:\"a\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"What happens if there are overlapping properties on objects to be merged?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"They can be overridden simply, a deep merge doesn't need to be performed.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Approach 1: Manual coordination\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can keep track of the state of the promises by tracking the number of unresolved promises and storing the values of the resolved promises. If there are no unresolved promises left, we can proceed to merge the results and \",(0,t.jsx)(e.code,{children:\"resolve()\"}),\" the returned promise with that result.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Merging the results is straightforward if you know how to check for the common data types, which we have covered in \",(0,t.jsx)(e.a,{href:\"/questions/javascript/type-utilities\",children:\"Type Utilities\"}),\" and \",(0,t.jsx)(e.a,{href:\"/questions/javascript/type-utilities-ii\",children:\"Type Utilities II\"}),\". Since only merging of plain objects is supported, we need to differentiate between plain objects and other objects like \",(0,t.jsx)(e.code,{children:\"Set\"}),\"s and \",(0,t.jsx)(e.code,{children:\"Map\"}),\"s.\"]}),`\n`,(0,t.jsx)(l,{languages:{jsx:c,tsx:d}}),`\n`,(0,t.jsxs)(e.p,{children:[\"Notice that the logic to keep track of the resolved promise results can get repetitive, and it gets worse if the function supports more than 2 promises. Thankfully, there's actually a built-in construct to help with managing state of multiple promises: \",(0,t.jsx)(e.code,{children:\"Promise.all\"}),\", which we can use to simplify the code.\"]}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 2: Using \",(0,t.jsx)(e.code,{children:\"Promise.all()\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Using \",(0,t.jsx)(e.code,{children:\"Promise.all()\"}),\" will simplify the code a lot. However, you might not be allowed to use that during interviews, so it's still useful to know how track the states of the promises manually.\"]}),`\n`,(0,t.jsx)(l,{children:h}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 3: Using serial \",(0,t.jsx)(e.code,{children:\"await\"}),\" (non-optimal)\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This solution is very simple but is non-optimal because the promises are resolved serially instead of in parallel.\"}),`\n`,(0,t.jsx)(l,{children:f})]})}function U(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(m,r)})):m(r)}var _=U;return k(F);})();\n;return Component;",
  "workspace": {
    "main": "/src/promise-merge.ts",
    "run": "/src/promise-merge.run.test.ts",
    "submit": "/src/promise-merge.submit.test.ts"
  }
}