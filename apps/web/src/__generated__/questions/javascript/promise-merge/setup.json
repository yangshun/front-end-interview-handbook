{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-merge\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-merge.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promise-merge.run.test.ts": "import promiseMerge from './promise-merge';\n\ndescribe('promiseMerge', () => {\n  test('returns a promise', () => {\n    const promise = promiseMerge(Promise.resolve(1), Promise.resolve(2));\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  test('numbers', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve(21), 10)),\n      new Promise((resolve) => setTimeout(() => resolve(22), 5)),\n    );\n    await expect(promise).resolves.toBe(43);\n  });\n\n  test('arrays', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve([1, 2, 3]), 5)),\n      new Promise((resolve) => setTimeout(() => resolve([4, 5, 6]), 10)),\n    );\n    await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n  });\n\n  test('objects', async () => {\n    const promise = promiseMerge(\n      new Promise((resolve) => setTimeout(() => resolve({ foo: 1 }), 5)),\n      new Promise((resolve) => setTimeout(() => resolve({ bar: 2 }), 10)),\n    );\n    await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n  });\n});\n",
    "/src/promise-merge.submit.test.ts": "import promiseMerge from './promise-merge';\n\ndescribe('promiseMerge', () => {\n  test('returns a promise', () => {\n    const promise = promiseMerge(Promise.resolve(1), Promise.resolve(2));\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  describe('resolved', () => {\n    describe('numbers', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(Promise.resolve(21), Promise.resolve(22));\n        await expect(promise).resolves.toBe(43);\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve(21), 10)),\n          new Promise((resolve) => setTimeout(() => resolve(22), 5)),\n        );\n        await expect(promise).resolves.toBe(43);\n      });\n    });\n\n    describe('strings', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve('123'),\n          Promise.resolve('456'),\n        );\n        await expect(promise).resolves.toBe('123456');\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve('123'), 10)),\n          new Promise((resolve) => setTimeout(() => resolve('456'), 5)),\n        );\n        await expect(promise).resolves.toBe('123456');\n      });\n    });\n\n    describe('arrays', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve([1, 2, 3]),\n          Promise.resolve([4, 5, 6]),\n        );\n        await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve([1, 2, 3]), 5)),\n          new Promise((resolve) => setTimeout(() => resolve([4, 5, 6]), 10)),\n        );\n        await expect(promise).resolves.toEqual([1, 2, 3, 4, 5, 6]);\n      });\n    });\n\n    describe('objects', () => {\n      test('immediately', async () => {\n        const promise = promiseMerge(\n          Promise.resolve({ foo: 1 }),\n          Promise.resolve({ bar: 2 }),\n        );\n        await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n      });\n\n      test('delayed', async () => {\n        const promise = promiseMerge(\n          new Promise((resolve) => setTimeout(() => resolve({ foo: 1 }), 5)),\n          new Promise((resolve) => setTimeout(() => resolve({ bar: 2 }), 10)),\n        );\n        await expect(promise).resolves.toEqual({ bar: 2, foo: 1 });\n      });\n    });\n  });\n\n  describe('rejected', () => {\n    test('promises rejected', async () => {\n      const promise = promiseMerge(\n        new Promise((resolve) => setTimeout(() => resolve(1), 5)),\n        new Promise((_, reject) => setTimeout(() => reject(2), 10)),\n      );\n      await expect(promise).rejects.toEqual(2);\n    });\n\n    test('supported data types but not mergeable', async () => {\n      const promise = promiseMerge(\n        new Promise((resolve) => setTimeout(() => resolve(1), 5)),\n        new Promise((resolve) => setTimeout(() => resolve([]), 10)),\n      );\n      await expect(promise).rejects.toEqual('Unsupported data types');\n    });\n\n    test('unsupported data types', async () => {\n      const promise = promiseMerge(\n        // @ts-expect-error\n        new Promise((resolve) => setTimeout(() => resolve(new Set([1]), 5))),\n        // @ts-expect-error\n        new Promise((resolve) => setTimeout(() => resolve(new Set([2]), 10))),\n      );\n      await expect(promise).rejects.toEqual('Unsupported data types');\n    });\n  });\n});\n",
    "/src/promise-merge.ts": "export default function promiseMerge(\n  p1: Promise<unknown>,\n  p2: Promise<unknown>,\n): Promise<unknown> {\n  let unresolved = 2;\n  let p1Result: unknown, p2Result: unknown;\n\n  return new Promise((resolve, reject) => {\n    function then() {\n      unresolved--;\n      if (unresolved === 0) {\n        resolve(mergeResult(p1Result, p2Result));\n      }\n    }\n\n    p1.then((result) => {\n      p1Result = result;\n      then();\n    }).catch(reject);\n    p2.then((result) => {\n      p2Result = result;\n      then();\n    }).catch(reject);\n  });\n}\n\nfunction mergeResult(result1: unknown, result2: unknown): unknown {\n  try {\n    if (typeof result1 === 'number' && typeof result2 === 'number') {\n      return result1 + result2;\n    }\n\n    if (typeof result1 === 'string' && typeof result2 === 'string') {\n      return result1 + result2;\n    }\n\n    if (Array.isArray(result1) && Array.isArray(result2)) {\n      return [...result1, ...result2];\n    }\n\n    if (isPlainObject(result1) && isPlainObject(result2)) {\n      return { ...(result1 as Object), ...(result2 as Object) };\n    }\n\n    throw 'Unsupported data types';\n  } catch {\n    throw 'Unsupported data types';\n  }\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  // For null and undefined.\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Promise} p1\n * @param {Promise} p2\n * @return {Promise<any>}\n */\nexport default function promiseMerge(p1, p2) {\n  throw 'Not implemented';\n}",
    "ts": "export default function promiseMerge(\n  p1: Promise<unknown>,\n  p2: Promise<unknown>,\n): Promise<unknown> {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/promise-merge.ts",
    "run": "/src/promise-merge.run.test.ts",
    "submit": "/src/promise-merge.submit.test.ts"
  }
}