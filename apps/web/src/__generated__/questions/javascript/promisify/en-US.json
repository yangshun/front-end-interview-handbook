{
  "description": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var t in e)o(n,t,{get:e[t],enumerable:!0})},s=(n,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!u.call(n,r)&&r!==t&&o(n,r,{get:()=>e[r],enumerable:!(c=m(e,r))||c.enumerable});return n};var y=(n,e,t)=>(t=n!=null?h(f(n)):{},s(e||!n||!n.__esModule?o(t,\"default\",{value:n,enumerable:!0}):t,n)),k=n=>s(o({},\"__esModule\",{value:!0}),n);var l=g((F,i)=>{i.exports=_jsx_runtime});var _={};b(_,{default:()=>w,frontmatter:()=>j});var a=y(l()),j={title:\"Promisify\",excerpt:\"Implement a function that takes a function following the common error-first callback style and returns a version that returns promises\"};function d(n){let e=Object.assign({p:\"p\",code:\"code\",a:\"a\",h2:\"h2\",pre:\"pre\"},n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.p,{children:[\"Before promises/\",(0,a.jsx)(e.code,{children:\"async\"}),\"/\",(0,a.jsx)(e.code,{children:\"await\"}),\" became the standard, it was a convention for async APIs in JavaScript to accept callbacks as the last argument. Many async versions of Node.js APIs (e.g. \",(0,a.jsx)(e.a,{href:\"https://nodejs.org/api/fs.html#fsreadfilepath-options-callback\",children:(0,a.jsx)(e.code,{children:\"fs.readFile\"})}),\" and \",(0,a.jsx)(e.a,{href:\"https://nodejs.org/api/fs.html#fsrmpath-options-callback\",children:(0,a.jsx)(e.code,{children:\"fs.rm\"})}),\") have such signatures. Node.js' \",(0,a.jsx)(e.a,{href:\"https://nodejs.org/api/util.html#util_util_promisify_original\",children:(0,a.jsx)(e.code,{children:\"util.promisify\"})}),\" function was created to wrap around callback-based functions by returning \",(0,a.jsx)(e.code,{children:\"Promise\"}),\"s so that they can be used with \",(0,a.jsx)(e.code,{children:\"async\"}),\"/\",(0,a.jsx)(e.code,{children:\"await\"}),\".\"]}),`\n`,(0,a.jsxs)(e.p,{children:[\"Implement a function \",(0,a.jsx)(e.code,{children:\"promisify\"}),\" that takes a function following the common callback-last error-first style, i.e. taking a \",(0,a.jsx)(e.code,{children:\"(err, value) => ...\"}),\" callback as the last argument, and returns a version that returns promises.\"]}),`\n`,(0,a.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:\"language-js\",children:`// Example function with callback as last argument\n// The callback has the signature \\`(err, value) => any\\`\nfunction foo(url, options, callback) {\n  apiCall(url, options)\n    .then((data) => callback(null, data))\n    .catch((err) => callback(err));\n}\n\nconst promisifiedFoo = promisify(foo);\nconst data = await promisifiedFoo('example.com', { foo: 1 });\n`})})]})}function x(n={}){let{wrapper:e}=n.components||{};return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(d,n)})):d(n)}var w=x;return k(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promisify\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promisify.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promisify.run.test.ts": "import promisify from './promisify';\n\ndescribe('promisify', () => {\n  function delayedResolve(cb: Function) {\n    setTimeout(() => {\n      cb(null, 42);\n    }, 10);\n  }\n\n  function asyncError(x: number, cb: Function) {\n    setTimeout(() => {\n      cb(x);\n    }, 10);\n  }\n\n  test('returns a function', () => {\n    const promisified = promisify(delayedResolve);\n    expect(promisified).toBeInstanceOf(Function);\n  });\n\n  test('calling promisified returns a promise', () => {\n    const promisified = promisify(delayedResolve);\n    expect(promisified()).toBeInstanceOf(Promise);\n  });\n\n  test('one argument', async () => {\n    function asyncIdentity<T>(x: T, cb: Function) {\n      setTimeout(() => {\n        cb(null, x);\n      }, 10);\n    }\n\n    expect.assertions(1);\n    const promisified = promisify(asyncIdentity);\n    const res = await promisified(23);\n    expect(res).toBe(23);\n  });\n\n  test('rejected', async () => {\n    expect.assertions(1);\n    try {\n      const promisified = promisify(asyncError);\n      await promisified(23);\n    } catch (err) {\n      expect(err).toBe(23);\n    }\n  });\n});\n",
    "/src/promisify.submit.test.ts": "import promisify from './promisify';\n\ndescribe('promisify', () => {\n  function delayedResolve(cb: Function) {\n    setTimeout(() => {\n      cb(null, 42);\n    }, 10);\n  }\n\n  function asyncError(x: number, cb: Function) {\n    setTimeout(() => {\n      cb(x);\n    }, 10);\n  }\n\n  describe('returns correct types', () => {\n    test('returns a function', () => {\n      const promisified = promisify(delayedResolve);\n      expect(promisified).toBeInstanceOf(Function);\n    });\n\n    test('calling promisified returns a promise', () => {\n      const promisified = promisify(delayedResolve);\n      expect(promisified()).toBeInstanceOf(Promise);\n    });\n  });\n\n  describe('use with await', () => {\n    describe('resolved', () => {\n      test('no arguments', async () => {\n        expect.assertions(1);\n        const promisified = promisify(delayedResolve);\n        const res = await promisified();\n        expect(res).toBe(42);\n      });\n\n      test('one argument', async () => {\n        function asyncIdentity<T>(x: T, cb: Function) {\n          setTimeout(() => {\n            cb(null, x);\n          }, 10);\n        }\n\n        expect.assertions(1);\n        const promisified = promisify(asyncIdentity);\n        const res = await promisified(23);\n        expect(res).toBe(23);\n      });\n\n      test('two arguments', async () => {\n        function asyncAdd(a: number, b: number, cb: Function) {\n          setTimeout(() => {\n            cb(null, a + b);\n          }, 10);\n        }\n\n        expect.assertions(1);\n        const promisified = promisify(asyncAdd);\n        const res = await promisified(17, 19);\n        expect(res).toBe(36);\n      });\n    });\n\n    test('rejected', async () => {\n      expect.assertions(1);\n      try {\n        const promisified = promisify(asyncError);\n        await promisified(23);\n      } catch (err) {\n        expect(err).toBe(23);\n      }\n    });\n  });\n\n  test('can access `this`', async () => {\n    expect.assertions(1);\n    function asyncAdd(this: any, a: number, b: number, cb: Function) {\n      setTimeout(() => {\n        cb(null, a + b + this.base);\n      }, 10);\n    }\n\n    const promisifiedAdd = promisify(asyncAdd);\n    const obj = { base: 5, add: promisifiedAdd };\n    const res = await obj.add(17, 19);\n    expect(res).toBe(41);\n  });\n\n  describe('use without await', () => {\n    test('then', (done) => {\n      expect.assertions(1);\n      const promisified = promisify(delayedResolve);\n      promisified().then((res) => {\n        expect(res).toBe(42);\n        done();\n      });\n    });\n\n    test('catch', (done) => {\n      expect.assertions(1);\n      const promisified = promisify(asyncError);\n      promisified(23)\n        .then()\n        .catch((err) => {\n          expect(err).toBe(23);\n          done();\n        });\n    });\n  });\n});\n",
    "/src/promisify.ts": "export default function promisify<T>(\n  func: (...args: any[]) => void,\n): (this: any, ...args: any[]) => Promise<T> {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      func.call(this, ...args, (err: any, result: T) =>\n        err ? reject(err) : resolve(result),\n      );\n    });\n  };\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": null,
    "companies": [
      "amazon",
      "microsoft"
    ],
    "created": 1690070400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that takes a function following the common error-first callback style and returns a version that returns promises",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promisify",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "promisify-ii"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "promisify",
    "subtitle": null,
    "title": "Promisify",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @callback func\n * @returns Function\n */\nexport default function promisify(func) {\n  throw 'Not implemented';\n}",
    "ts": "export default function promisify<T>(\n  func: (...args: any[]) => void,\n): (this: any, ...args: any[]) => Promise<T> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var b=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),v=(r,e)=>{for(var i in e)o(r,i,{get:e[i],enumerable:!0})},s=(r,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of y(e))!w.call(r,t)&&t!==i&&o(r,t,{get:()=>e[t],enumerable:!(c=p(e,t))||c.enumerable});return r};var k=(r,e,i)=>(i=r!=null?m(g(r)):{},s(e||!r||!r.__esModule?o(i,\"default\",{value:r,enumerable:!0}):i,r)),j=r=>s(o({},\"__esModule\",{value:!0}),r);var l=b((C,a)=>{a.exports=_jsx_runtime});var I={};v(I,{default:()=>_});var n=k(l());var h=MDXCodeBlock;var d=`/**\n * @callback func\n * @returns Function\n */\nexport default function promisify(func) {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      func.call(this, ...args, (err, result) =>\n        err ? reject(err) : resolve(result),\n      );\n    });\n  };\n}\n`;var u=`export default function promisify<T>(\n  func: (...args: any[]) => void,\n): (this: any, ...args: any[]) => Promise<T> {\n  return function (...args) {\n    return new Promise((resolve, reject) => {\n      func.call(this, ...args, (err: any, result: T) =>\n        err ? reject(err) : resolve(result),\n      );\n    });\n  };\n}\n`;function f(r){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",code:\"code\",p:\"p\",h3:\"h3\",a:\"a\",ul:\"ul\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" function takes a single argument \",(0,n.jsx)(e.code,{children:\"func\"}),\", which is the callback-based function you want to promisify.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"return\"}),\" statement returns a new function that wraps \",(0,n.jsx)(e.code,{children:\"func\"}),\". This new function is the promisified version.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Inside the returned function, we use the spread operator \",(0,n.jsx)(e.code,{children:\"...args\"}),\" to capture any arguments passed to the promisified function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"We create a new \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" that wraps the original callback-based function. The Promise constructor takes a function with two arguments: \",(0,n.jsx)(e.code,{children:\"resolve\"}),\" and \",(0,n.jsx)(e.code,{children:\"reject\"}),\". These are functions we call based on the outcome of the asynchronous operation.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Inside the Promise's function, we invoke \",(0,n.jsx)(e.code,{children:\"func\"}),\" with the provided arguments \",(0,n.jsx)(e.code,{children:\"(...args)\"}),\" and pass a callback function as its last argument as that's what \",(0,n.jsx)(e.code,{children:\"func\"}),\" expects.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The callback function takes two arguments: \",(0,n.jsx)(e.code,{children:\"err\"}),\" (error) and \",(0,n.jsx)(e.code,{children:\"result\"}),\" (success value). If \",(0,n.jsx)(e.code,{children:\"err\"}),\" is truthy, we reject the \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" with the \",(0,n.jsx)(e.code,{children:\"err\"}),\". Otherwise, we resolve the \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" with the \",(0,n.jsx)(e.code,{children:\"result\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"With the \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" function, you can convert any callback-based function into a \",(0,n.jsx)(e.code,{children:\"Promise\"}),\"-based function, making it easier to work with asynchronous operations using modern Promise syntax.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To preserve the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value, the returned function should not be defined using arrow functions and \",(0,n.jsx)(e.code,{children:\"func\"}),\" should be invoked with \",(0,n.jsx)(e.code,{children:\"call\"}),\"/\",(0,n.jsx)(e.code,{children:\"apply\"}),\" and the correct \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" value.\"]}),`\n`,(0,n.jsx)(h,{languages:{jsx:d,tsx:u}}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"promisify\"}),\" function assumes the callback is the last argument and that the callback uses an error-first format. If the function you are trying to promisify is not the last argument or has a different format, you cannot use this. Node.js provides a custom promisify function \",(0,n.jsx)(e.a,{href:\"https://nodejs.org/api/util.html#util_custom_promisified_functions\",children:(0,n.jsx)(e.code,{children:\"util.promisify.custom\"})}),\" that you can use for such cases.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Not every function that accepts callbacks can/should be promisified! A promise can have only one result, but a callback can be called many times (e.g. \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\"). Hence promisification is only meant for functions that call the callback once because further calls will be ignored.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://nodejs.org/api/util.html#utilpromisifyoriginal\",children:[\"Node.js \",(0,n.jsx)(e.code,{children:\"util.promisify\"})]})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/promisify\",children:\"Promisification\"})}),`\n`]})]})}function P(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(f,r)})):f(r)}var _=P;return j(I);})();\n;return Component;",
  "workspace": {
    "main": "/src/promisify.ts",
    "run": "/src/promisify.run.test.ts",
    "submit": "/src/promisify.submit.test.ts"
  }
}