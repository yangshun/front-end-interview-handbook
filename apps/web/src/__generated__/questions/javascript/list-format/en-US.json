{
  "description": "var Component=(()=>{var m=Object.create;var a=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var g=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),p=(e,n)=>{for(var o in n)a(e,o,{get:n[o],enumerable:!0})},s=(e,n,o,r)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let i of B(n))!b.call(e,i)&&i!==o&&a(e,i,{get:()=>n[i],enumerable:!(r=d(n,i))||r.enumerable});return e};var J=(e,n,o)=>(o=e!=null?m(u(e)):{},s(n||!e||!e.__esModule?a(o,\"default\",{value:e,enumerable:!0}):o,e)),f=e=>s(a({},\"__esModule\",{value:!0}),e);var h=g((v,l)=>{l.exports=_jsx_runtime});var j={};p(j,{default:()=>x,frontmatter:()=>F});var t=J(h()),F={title:\"List Format\",excerpt:\"Implement a function that formats a list of items into a single readable string\"};function c(e){let n=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[\"Given a list of strings, implement a function \",(0,t.jsx)(n.code,{children:\"listFormat\"}),\" that returns the items concatenated into a single string. A common use case would be in summarizing the reactions for social media posts.\"]}),`\n`,(0,t.jsx)(n.p,{children:\"The function should support a few options as the second parameter:\"}),`\n`,(0,t.jsxs)(n.ul,{children:[`\n`,(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:\"sorted\"}),\": Sorts the items by alphabetical order.\"]}),`\n`,(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:\"length\"}),\": Show only the first \",(0,t.jsx)(n.code,{children:\"length\"}),' items, using \"and X other(s)\" for the remaining. Ignore invalid values (negative, 0, etc).']}),`\n`,(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:\"unique\"}),\": Remove duplicate items.\"]}),`\n`]}),`\n`,(0,t.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:\"language-js\",children:`listFormat([]); // ''\n\nlistFormat(['Bob']); // 'Bob'\nlistFormat(['Bob', 'Alice']); // 'Bob and Alice'\n\nlistFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John']);\n// 'Bob, Ben, Tim, Jane and John'\n\nlistFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], {\n  length: 3,\n}); // 'Bob, Ben, Tim and 2 others'\n\nlistFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], {\n  length: 4,\n}); // 'Bob, Ben, Tim, Jane and 1 other'\n\nlistFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], {\n  length: 3,\n  sorted: true,\n}); // 'Ben, Bob, Jane and 2 others'\n\nlistFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John', 'Bob'], {\n  length: 3,\n  unique: true,\n}); // 'Bob, Ben, Tim and 2 others'\n\nlistFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], {\n  length: 3,\n  unique: true,\n}); // 'Bob, Ben, Tim and 2 others'\n\nlistFormat(['Bob', 'Ben', '', '', 'John']); // 'Bob, Ben and John'\n`})})]})}function T(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(c,e)})):c(e)}var x=T;return f(j);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/list-format\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/list-format.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/list-format.run.test.ts": "import listFormat from './list-format';\n\ndescribe('listFormat', () => {\n  test('empty', () => {\n    expect(listFormat([])).toEqual('');\n  });\n\n  test('one item', () => {\n    expect(listFormat(['Bob'])).toEqual('Bob');\n    expect(listFormat(['Bob'], { length: 2 })).toEqual('Bob');\n  });\n\n  test('two items', () => {\n    expect(listFormat(['Bob', 'Alice'])).toEqual('Bob and Alice');\n  });\n\n  test('many items', () => {\n    expect(listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'])).toEqual(\n      'Bob, Ben, Tim, Jane and John',\n    );\n  });\n});\n",
    "/src/list-format.submit.test.ts": "import listFormat from './list-format';\n\ndescribe('listFormat', () => {\n  test('empty', () => {\n    expect(listFormat([])).toEqual('');\n  });\n\n  test('one item', () => {\n    expect(listFormat(['Bob'])).toEqual('Bob');\n    expect(listFormat(['Bob'], { length: 2 })).toEqual('Bob');\n  });\n\n  test('two items', () => {\n    expect(listFormat(['Bob', 'Alice'])).toEqual('Bob and Alice');\n  });\n\n  test('many items', () => {\n    expect(listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'])).toEqual(\n      'Bob, Ben, Tim, Jane and John',\n    );\n  });\n\n  test('duplicate items', () => {\n    expect(listFormat(['Bob', 'Ben', 'Bob', 'Ben', 'John'])).toEqual(\n      'Bob, Ben, Bob, Ben and John',\n    );\n    expect(\n      listFormat(['Bob', 'Ben', 'Bob', 'Ben', 'John'], { sorted: true }),\n    ).toEqual('Ben, Ben, Bob, Bob and John');\n  });\n\n  test('length specified', () => {\n    expect(\n      listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], { length: 3 }),\n    ).toEqual('Bob, Ben, Tim and 2 others');\n    expect(\n      listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], { length: 4 }),\n    ).toEqual('Bob, Ben, Tim, Jane and 1 other');\n    expect(\n      listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], { length: 100 }),\n    ).toEqual('Bob, Ben, Tim, Jane and John');\n    expect(\n      listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], { length: 0 }),\n    ).toEqual('Bob, Ben, Tim, Jane and John');\n    expect(\n      listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], { length: -1 }),\n    ).toEqual('Bob, Ben, Tim, Jane and John');\n  });\n\n  test('sorted items', () => {\n    expect(\n      listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], {\n        length: 3,\n        sorted: true,\n      }),\n    ).toEqual('Ben, Bob, Jane and 2 others');\n    expect(\n      listFormat(['Bob', 'Ben', 'Bob', 'Ben', 'John'], {\n        length: 3,\n        sorted: true,\n      }),\n    ).toEqual('Ben, Ben, Bob and 2 others');\n  });\n\n  test('unique items', () => {\n    expect(\n      listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John', 'Bob'], {\n        length: 3,\n        unique: true,\n      }),\n    ).toEqual('Bob, Ben, Tim and 2 others');\n  });\n\n  test('missing items', () => {\n    expect(listFormat(['Bob', 'Ben', '', '', 'John'])).toEqual(\n      'Bob, Ben and John',\n    );\n    expect(listFormat(['Bob', ''])).toEqual('Bob');\n    expect(listFormat(['', ''])).toEqual('');\n  });\n\n  test('all the options', () => {\n    expect(\n      listFormat(['Bob', 'Ben', 'Tim', 'Jane', 'John'], {\n        length: 3,\n        unique: true,\n        sorted: true,\n      }),\n    ).toEqual('Ben, Bob, Jane and 2 others');\n  });\n});\n",
    "/src/list-format.ts": "const SEPARATOR = ', ';\nconst OTHERS_SEPARATOR = ' and ';\nconst OTHERS_LABEL = 'other';\n\nexport default function listFormat(\n  itemsParam: Array<string>,\n  options?: { sorted?: boolean; length?: number; unique?: boolean },\n): string {\n  // Filter falsey values.\n  let items = itemsParam.filter((item) => !!item);\n\n  if (!items || items.length === 0) {\n    return '';\n  }\n\n  // No processing is needed if there's only one item.\n  if (items.length === 1) {\n    return items[0];\n  }\n\n  // Sort values.\n  if (options?.sorted) {\n    items.sort();\n  }\n\n  // Remove duplicate values.\n  if (options?.unique) {\n    items = Array.from(new Set(items));\n  }\n\n  // Length is specified and valid.\n  if (\n    options?.length &&\n    options?.length > 0 &&\n    options?.length < items.length\n  ) {\n    const firstSection = items.slice(0, options?.length).join(SEPARATOR);\n    const count = items.length - options?.length;\n    const secondSection = `${count} ${OTHERS_LABEL + (count > 1 ? 's' : '')}`;\n    return [firstSection, secondSection].join(OTHERS_SEPARATOR);\n  }\n\n  // Case where length is not specified.\n  const firstSection = items.slice(0, items.length - 1).join(SEPARATOR);\n  const secondSection = items[items.length - 1];\n  return [firstSection, secondSection].join(OTHERS_SEPARATOR);\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": "yangshun",
    "companies": [
      "dropbox"
    ],
    "created": 1652832000,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that formats a list of items into a single readable string",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/list-format",
    "importance": "medium",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "list-format",
    "subtitle": null,
    "title": "List Format",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Array<string>} items\n * @param {{sorted?: boolean, length?: number, unique?: boolean}} [options]\n * @return {string}\n */\nexport default function listFormat(items, options) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function listFormat(\n  items: Array<string>,\n  options?: { sorted?: boolean; length?: number; unique?: boolean },\n): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var u=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var S=Object.getPrototypeOf,R=Object.prototype.hasOwnProperty;var A=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),T=(n,e)=>{for(var i in e)s(n,i,{get:e[i],enumerable:!0})},l=(n,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!R.call(n,o)&&o!==i&&s(n,o,{get:()=>e[o],enumerable:!(r=f(e,o))||r.enumerable});return n};var E=(n,e,i)=>(i=n!=null?u(S(n)):{},l(e||!n||!n.__esModule?s(i,\"default\",{value:n,enumerable:!0}):i,n)),O=n=>l(s({},\"__esModule\",{value:!0}),n);var a=A((y,c)=>{c.exports=_jsx_runtime});var v={};T(v,{default:()=>P});var t=E(a());var h=MDXCodeBlock;var d=`const SEPARATOR = ', ';\nconst OTHERS_SEPARATOR = ' and ';\nconst OTHERS_LABEL = 'other';\n\n/**\n * @param {Array<string>} itemsParam\n * @param {{sorted?: boolean, length?: number, unique?: boolean}} [options]\n * @return {string}\n */\nexport default function listFormat(itemsParam, options = {}) {\n  // Filter falsey values.\n  let items = itemsParam.filter((item) => !!item);\n\n  if (!items || items.length === 0) {\n    return '';\n  }\n\n  // No processing is needed if there's only one item.\n  if (items.length === 1) {\n    return items[0];\n  }\n\n  // Sort values.\n  if (options.sorted) {\n    items.sort();\n  }\n\n  // Remove duplicate values.\n  if (options.unique) {\n    items = Array.from(new Set(items));\n  }\n\n  // Length is specified and valid.\n  if (options.length && options.length > 0 && options.length < items.length) {\n    const firstSection = items.slice(0, options.length).join(SEPARATOR);\n    const count = items.length - options.length;\n    const secondSection = \\`\\${count} \\${OTHERS_LABEL + (count > 1 ? 's' : '')}\\`;\n    return [firstSection, secondSection].join(OTHERS_SEPARATOR);\n  }\n\n  // Case where length is not specified.\n  const firstSection = items.slice(0, items.length - 1).join(SEPARATOR);\n  const secondSection = items[items.length - 1];\n  return [firstSection, secondSection].join(OTHERS_SEPARATOR);\n}\n`;var m=`const SEPARATOR = ', ';\nconst OTHERS_SEPARATOR = ' and ';\nconst OTHERS_LABEL = 'other';\n\nexport default function listFormat(\n  itemsParam: Array<string>,\n  options?: { sorted?: boolean; length?: number; unique?: boolean },\n): string {\n  // Filter falsey values.\n  let items = itemsParam.filter((item) => !!item);\n\n  if (!items || items.length === 0) {\n    return '';\n  }\n\n  // No processing is needed if there's only one item.\n  if (items.length === 1) {\n    return items[0];\n  }\n\n  // Sort values.\n  if (options?.sorted) {\n    items.sort();\n  }\n\n  // Remove duplicate values.\n  if (options?.unique) {\n    items = Array.from(new Set(items));\n  }\n\n  // Length is specified and valid.\n  if (\n    options?.length &&\n    options?.length > 0 &&\n    options?.length < items.length\n  ) {\n    const firstSection = items.slice(0, options?.length).join(SEPARATOR);\n    const count = items.length - options?.length;\n    const secondSection = \\`\\${count} \\${OTHERS_LABEL + (count > 1 ? 's' : '')}\\`;\n    return [firstSection, secondSection].join(OTHERS_SEPARATOR);\n  }\n\n  // Case where length is not specified.\n  const firstSection = items.slice(0, items.length - 1).join(SEPARATOR);\n  const secondSection = items[items.length - 1];\n  return [firstSection, secondSection].join(OTHERS_SEPARATOR);\n}\n`;function p(n){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"This question is inspired by the \",(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat/format\",children:[(0,t.jsx)(e.code,{children:\"Intl.ListFormat.prototype.format()\"}),\" API\"]}),\" which assists with language-specific list formatting.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"By looking at the examples, we can split the solution into two sections:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Processing the input list \\u2013 removing empty values, sorting, de-duplicating\"}),`\n`,(0,t.jsx)(e.li,{children:\"Formatting the items into a second string\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The first section is pretty straightforward, we can just maintain an \",(0,t.jsx)(e.code,{children:\"items\"}),\" array that we mutate according to the \",(0,t.jsx)(e.code,{children:\"options\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The second section is a little trickier, but we can observe the following:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The \",(0,t.jsx)(e.code,{children:\"length\"}),\" option splits the array into two parts\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The first part will be joined with a \",(0,t.jsx)(e.code,{children:\"', '\"}),\" and the second will be joined with \",(0,t.jsx)(e.code,{children:\"'and'\"}),\". Whether to show \",(0,t.jsx)(e.code,{children:\"'X other(s)'\"}),\" for the second part is dependent on whether the \",(0,t.jsx)(e.code,{children:\"length\"}),\" value is a valid value within the range \",(0,t.jsx)(e.code,{children:\"[1, items.length]\"})]}),`\n`]}),`\n`,(0,t.jsx)(h,{languages:{jsx:d,tsx:m}}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This function is not as usable as the \",(0,t.jsx)(e.code,{children:\"Intl.ListFormat.prototype.format()\"}),\" API because the separators are hardcoded in English. The \",(0,t.jsx)(e.code,{children:\"Intl\"}),\" API is meant for internationalization (i18n) in the first place and also allows for customization of the separators (the comma and the \",(0,t.jsx)(e.code,{children:\"and\"}),\"), so there shouldn't be any hardcoding of separators if this function is meant for production use.\"]}),`\n`,(0,t.jsx)(e.p,{children:'To make this function better, we could allow customization of the list separator and the \"others\" separator.'}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/ListFormat\",children:[(0,t.jsx)(e.code,{children:\"Intl.ListFormat\"}),\" MDN\"]})}),`\n`]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var P=j;return O(v);})();\n;return Component;",
  "workspace": {
    "main": "/src/list-format.ts",
    "run": "/src/list-format.run.test.ts",
    "submit": "/src/list-format.submit.test.ts"
  }
}