{
  "description": "var Component=(()=>{var m=Object.create;var l=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),g=(a,e)=>{for(var t in e)l(a,t,{get:e[t],enumerable:!0})},i=(a,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!b.call(a,r)&&r!==t&&l(a,r,{get:()=>e[r],enumerable:!(c=h(e,r))||c.enumerable});return a};var I=(a,e,t)=>(t=a!=null?m(p(a)):{},i(e||!a||!a.__esModule?l(t,\"default\",{value:a,enumerable:!0}):t,a)),x=a=>i(l({},\"__esModule\",{value:!0}),a);var o=v((w,s)=>{s.exports=_jsx_runtime});var k={};g(k,{default:()=>y,frontmatter:()=>f});var n=I(o()),f={title:\"Resumable Interval\",excerpt:\"Implement a function that creates a resumable interval object\"};function d(a){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",ol:\"ol\",li:\"li\",pre:\"pre\",h2:\"h2\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" It is recommended to have completed the \",(0,n.jsx)(e.a,{href:\"/questions/javascript/cancellable-interval\",children:\"Cancellable Interval\"}),\" question before attempting this question.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"createResumableInterval\"}),\", that acts like \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" and has the exact same signature. However instead of returning a timer ID, it returns an object that contains three methods:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"start\"}),\": Runs the callback \",(0,n.jsx)(e.strong,{children:\"immediately\"}),\" and every \",(0,n.jsx)(e.code,{children:\"delay\"}),\" milliseconds.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"pause\"}),\": Pauses the interval so that it stops running. Execution can be resumed by calling \",(0,n.jsx)(e.code,{children:\"start()\"}),\" again.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"stop\"}),\": Stops the interval permanently, cannot be restarted.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`createResumableInterval(callback);\ncreateResumableInterval(callback, delay);\ncreateResumableInterval(callback, delay, param1);\ncreateResumableInterval(callback, delay, param1, param2);\ncreateResumableInterval(callback, delay, param1, param2, /* \\u2026 ,*/ paramN);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You are recommended to read up on for \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" on \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval\",children:\"MDN Docs\"}),\" if you are unfamiliar.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\n// t = 0:\nconst interval = createResumableInterval(() => {\n  i++;\n}, 10);\n// t = 10:\ninterval.start(); // i is now 1.\n// t = 20: callback executes and i is now 2.\n// t = 25:\ninterval.pause();\n// t = 30: i remains at 2 because interval.pause() was called.\n// t = 35:\ninterval.start(); // i is now 3.\n// t = 45: callback executes and i is now 4.\n// t = 50:\ninterval.stop(); // i remains at 4.\n`})})]})}function j(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var y=j;return x(k);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/resumable-interval\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/resumable-interval.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/resumable-interval.run.test.ts": "import createResumableInterval from './resumable-interval';\n\ndescribe('createResumableInterval', () => {\n  test('returns an object with the necessary methods', () => {\n    const interval = createResumableInterval(() => {});\n    expect(typeof interval).toBe('object');\n    expect(interval.start).toBeTruthy();\n    expect(interval.pause).toBeTruthy();\n    expect(interval.stop).toBeTruthy();\n  });\n\n  test('start', (done) => {\n    expect.assertions(3);\n    let i = 0;\n    const { start } = createResumableInterval(() => {\n      i++;\n    }, 10);\n    expect(i).toBe(0);\n    start();\n    expect(i).toBe(1);\n    setTimeout(() => {\n      expect(i).toBeGreaterThan(1);\n      done();\n    }, 20);\n  });\n\n  test('can resume', (done) => {\n    expect.assertions(5);\n    let i = 0;\n    const { start, pause, stop } = createResumableInterval(() => {\n      i++;\n    }, 10);\n    expect(i).toBe(0);\n    start();\n    expect(i).toBe(1);\n    pause();\n    expect(i).toBe(1);\n    start();\n    expect(i).toBe(2);\n    setTimeout(() => {\n      expect(i).toBe(3);\n      stop?.();\n      done();\n    }, 15);\n  });\n});\n",
    "/src/resumable-interval.submit.test.ts": "import createResumableInterval from './resumable-interval';\n\ndescribe('createResumableInterval', () => {\n  test('returns an object with the necessary methods', () => {\n    const interval = createResumableInterval(() => {});\n    expect(typeof interval).toBe('object');\n    expect(interval.start).toBeTruthy();\n    expect(interval.pause).toBeTruthy();\n    expect(interval.stop).toBeTruthy();\n  });\n\n  test('paused by default', (done) => {\n    expect.assertions(2);\n    let i = 0;\n    createResumableInterval(() => {\n      i++;\n    }, 10);\n    expect(i).toBe(0);\n    setTimeout(() => {\n      expect(i).toBe(0);\n      done();\n    }, 20);\n  });\n\n  describe('start', () => {\n    test('callback is executed immediately after starting', (done) => {\n      expect.assertions(3);\n      let i = 0;\n      const { start } = createResumableInterval(() => {\n        i++;\n      }, 10);\n      expect(i).toBe(0);\n      start();\n      expect(i).toBe(1);\n      setTimeout(() => {\n        expect(i).toBeGreaterThan(1);\n        done();\n      }, 20);\n    });\n\n    test('callback runs at intervals', (done) => {\n      let i = 0;\n      const { start, stop } = createResumableInterval(() => {\n        i++;\n        if (i === 3) {\n          stop?.();\n          done();\n        }\n      }, 10);\n      expect(i).toBe(0);\n      start();\n      expect(i).toBe(1);\n    });\n\n    test('calling start() multiple times does not execute callback each time', (done) => {\n      let i = 0;\n      const { start } = createResumableInterval(() => {\n        i++;\n      }, 10);\n      expect(i).toBe(0);\n      start();\n      expect(i).toBe(1);\n      start();\n      expect(i).toBe(1);\n      done();\n    });\n  });\n\n  describe('pause', () => {\n    describe('can be paused', () => {\n      test('immediately', (done) => {\n        expect.assertions(3);\n        let i = 0;\n        const { start, pause } = createResumableInterval(() => {\n          i++;\n        }, 10);\n        expect(i).toBe(0);\n        start();\n        expect(i).toBe(1);\n        pause();\n        setTimeout(() => {\n          expect(i).toBe(1);\n          done();\n        }, 20);\n      });\n\n      test('after first execution', (done) => {\n        expect.assertions(4);\n        let i = 0;\n        const { start, pause } = createResumableInterval(() => {\n          i++;\n        }, 10);\n        expect(i).toBe(0);\n        start();\n        expect(i).toBe(1);\n        setTimeout(() => {\n          pause();\n          expect(i).toBe(2);\n        }, 15);\n        setTimeout(() => {\n          expect(i).toBe(2);\n          done();\n        }, 25);\n      });\n    });\n\n    test('can resume', (done) => {\n      expect.assertions(5);\n      let i = 0;\n      const { start, pause, stop } = createResumableInterval(() => {\n        i++;\n      }, 10);\n      expect(i).toBe(0);\n      start();\n      expect(i).toBe(1);\n      pause();\n      expect(i).toBe(1);\n      start();\n      expect(i).toBe(2);\n      setTimeout(() => {\n        expect(i).toBe(3);\n        stop?.();\n        done();\n      }, 15);\n    });\n\n    test('can pause multiple times', (done) => {\n      expect.assertions(5);\n      let i = 0;\n      const { start, pause, stop } = createResumableInterval(() => {\n        i++;\n      }, 10);\n      expect(i).toBe(0);\n      start();\n      expect(i).toBe(1);\n      pause();\n      expect(i).toBe(1);\n      pause();\n      expect(i).toBe(1);\n      setTimeout(() => {\n        expect(i).toBe(1);\n        stop?.();\n        done();\n      }, 15);\n    });\n\n    test('can resume after pausing multiple times', (done) => {\n      expect.assertions(7);\n      let i = 0;\n      const { start, pause, stop } = createResumableInterval(() => {\n        i++;\n      }, 10);\n      expect(i).toBe(0);\n      start();\n      expect(i).toBe(1);\n      pause();\n      expect(i).toBe(1);\n      pause();\n      expect(i).toBe(1);\n      pause();\n      expect(i).toBe(1);\n      start();\n      expect(i).toBe(2);\n      setTimeout(() => {\n        expect(i).toBe(3);\n        stop?.();\n        done();\n      }, 15);\n    });\n  });\n\n  describe('stop', () => {\n    describe('can be stopped', () => {\n      test('immediately', (done) => {\n        expect.assertions(3);\n        let i = 0;\n        const { start, stop } = createResumableInterval(() => {\n          i++;\n        }, 10);\n        expect(i).toBe(0);\n        start();\n        expect(i).toBe(1);\n        stop();\n        setTimeout(() => {\n          expect(i).toBe(1);\n          done();\n        }, 15);\n      });\n\n      test('after first execution', (done) => {\n        expect.assertions(4);\n        let i = 0;\n        const { start, stop } = createResumableInterval(() => {\n          i++;\n        }, 10);\n        expect(i).toBe(0);\n        start();\n        expect(i).toBe(1);\n        setTimeout(() => {\n          stop();\n          expect(i).toBe(2);\n        }, 15);\n        setTimeout(() => {\n          expect(i).toBe(2);\n          done();\n        }, 25);\n      });\n    });\n\n    describe('cannot be resumed', () => {\n      test('stopped immediately', (done) => {\n        expect.assertions(4);\n        let i = 0;\n        const { start, stop } = createResumableInterval(() => {\n          i++;\n        }, 10);\n        expect(i).toBe(0);\n        start();\n        expect(i).toBe(1);\n        stop();\n        start();\n        setTimeout(() => {\n          expect(i).toBe(1);\n        }, 15);\n        setTimeout(() => {\n          expect(i).toBe(1);\n          done();\n        }, 25);\n      });\n\n      test('stopped after first execution', (done) => {\n        expect.assertions(4);\n        let i = 0;\n        const { start, stop } = createResumableInterval(() => {\n          i++;\n        }, 10);\n        expect(i).toBe(0);\n        start();\n        expect(i).toBe(1);\n        setTimeout(() => {\n          stop();\n          expect(i).toBe(2);\n          start();\n        }, 15);\n        setTimeout(() => {\n          expect(i).toBe(2);\n          done();\n        }, 30);\n      });\n    });\n  });\n\n  // TODO: Disabled for now.\n  // test('integration', (done) => {\n  //   expect.assertions(10);\n  //   let i = 0;\n  //   const { start, pause, stop } = createResumableInterval(() => {\n  //     i++;\n  //   }, 10);\n  //   expect(i).toBe(0);\n  //   start();\n  //   expect(i).toBe(1);\n  //   pause();\n  //   pause();\n  //   expect(i).toBe(1);\n  //   start();\n  //   expect(i).toBe(2);\n  //   setTimeout(() => {\n  //     pause();\n  //     expect(i).toBe(3);\n  //   }, 15);\n  //   setTimeout(() => {\n  //     expect(i).toBe(3);\n  //     start();\n  //     expect(i).toBe(4);\n  //   }, 30);\n  //   setTimeout(() => {\n  //     expect(i).toBe(5);\n  //     stop();\n  //   }, 45);\n  //   setTimeout(() => {\n  //     expect(i).toBe(5);\n  //     start();\n  //     pause();\n  //   }, 60);\n  //   setTimeout(() => {\n  //     expect(i).toBe(5);\n  //     done();\n  //   }, 100);\n  // });\n});\n",
    "/src/resumable-interval.ts": "interface Resumable {\n  start: () => void;\n  pause: () => void;\n  stop: () => void;\n}\n\nexport default function createResumableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): Resumable {\n  let timerId: number | null = null;\n  let stopped = false;\n\n  function start() {\n    if (stopped || timerId != null) {\n      return;\n    }\n\n    callback(...args);\n    timerId = setInterval(callback, delay, ...args);\n  }\n\n  function clearTimer() {\n    clearInterval(timerId ?? undefined);\n    timerId = null;\n  }\n\n  function pause() {\n    if (stopped) {\n      return;\n    }\n\n    clearTimer();\n  }\n\n  function stop() {\n    stopped = true;\n    clearTimer();\n  }\n\n  return {\n    start,\n    pause,\n    stop,\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1689552000,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that creates a resumable interval object",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/resumable-interval",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "resumable-timeout"
    ],
    "slug": "resumable-interval",
    "subtitle": null,
    "title": "Resumable Interval",
    "topics": [
      "async",
      "closure"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {{start: Function, pause: Function, stop: Function}}\n */\nexport default function createResumableInterval(callback, delay, ...args) {\n  throw 'Not implemented';\n}",
    "ts": "interface Resumable {\n  start: () => void;\n  pause: () => void;\n  stop: () => void;\n}\n\nexport default function createResumableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): Resumable {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var v=Object.create;var s=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),S=(n,e)=>{for(var a in e)s(n,a,{get:e[a],enumerable:!0})},o=(n,e,a,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!w.call(n,r)&&r!==a&&s(n,r,{get:()=>e[r],enumerable:!(c=I(e,r))||c.enumerable});return n};var x=(n,e,a)=>(a=n!=null?v(g(n)):{},o(e||!n||!n.__esModule?s(a,\"default\",{value:n,enumerable:!0}):a,n)),k=n=>o(s({},\"__esModule\",{value:!0}),n);var d=y((W,l)=>{l.exports=_jsx_runtime});var _={};S(_,{default:()=>T});var t=x(d());var i=MDXCodeBlock;var h=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {{start: Function, pause: Function, stop: Function}}\n */\nexport default function createResumableInterval(callback, delay, ...args) {\n  let timerId = null;\n  let stopped = false;\n\n  function start() {\n    if (stopped || timerId != null) {\n      return;\n    }\n\n    callback(...args);\n    timerId = setInterval(callback, delay, ...args);\n  }\n\n  function clearTimer() {\n    clearInterval(timerId);\n    timerId = null;\n  }\n\n  function pause() {\n    if (stopped) {\n      return;\n    }\n\n    clearTimer();\n  }\n\n  function stop() {\n    stopped = true;\n    clearTimer();\n  }\n\n  return {\n    start,\n    pause,\n    stop,\n  };\n}\n`;var p=`interface Resumable {\n  start: () => void;\n  pause: () => void;\n  stop: () => void;\n}\n\nexport default function createResumableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): Resumable {\n  let timerId: number | null = null;\n  let stopped = false;\n\n  function start() {\n    if (stopped || timerId != null) {\n      return;\n    }\n\n    callback(...args);\n    timerId = setInterval(callback, delay, ...args);\n  }\n\n  function clearTimer() {\n    clearInterval(timerId ?? undefined);\n    timerId = null;\n  }\n\n  function pause() {\n    if (stopped) {\n      return;\n    }\n\n    clearTimer();\n  }\n\n  function stop() {\n    stopped = true;\n    clearTimer();\n  }\n\n  return {\n    start,\n    pause,\n    stop,\n  };\n}\n`;var u=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {{start: Function, pause: Function, stop: Function}}\n */\nexport default function createResumableInterval(callback, delay, ...args) {\n  let timerId;\n  let state = 'paused';\n\n  function nextState(action) {\n    const newState = stateMachine[state][action];\n    if (newState === state) {\n      return;\n    }\n\n    state = newState;\n    switch (state) {\n      case 'paused':\n      case 'stopped':\n        clearInterval(timerId);\n        timerId = null;\n        return;\n      case 'running':\n        callback(...args);\n        timerId = setInterval(callback, delay, ...args);\n        return;\n    }\n  }\n\n  return {\n    start: () => nextState('start'),\n    pause: () => nextState('pause'),\n    stop: () => nextState('stop'),\n  };\n}\n\nconst stateMachine = {\n  stopped: {\n    pause: 'stopped',\n    start: 'stopped',\n    stop: 'stopped',\n  },\n  paused: {\n    pause: 'paused',\n    start: 'running',\n    stop: 'stopped',\n  },\n  running: {\n    pause: 'paused',\n    start: 'running',\n    stop: 'stopped',\n  },\n};\n`;var m=`interface Resumable {\n  start: () => void;\n  pause: () => void;\n  stop: () => void;\n}\n\nexport default function createResumableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): Resumable {\n  let timerId: number | null;\n  let state: State = 'paused';\n\n  function nextState(action: Action) {\n    const newState: State = stateMachine[state][action];\n    if (newState === state) {\n      return;\n    }\n\n    state = newState;\n    switch (state) {\n      case 'paused':\n      case 'stopped':\n        clearInterval(timerId ?? undefined);\n        timerId = null;\n        return;\n      case 'running':\n        callback(...args);\n        timerId = setInterval(callback, delay, ...args);\n        return;\n    }\n  }\n\n  return {\n    start: () => nextState('start'),\n    pause: () => nextState('pause'),\n    stop: () => nextState('stop'),\n  };\n}\n\ntype State = 'stopped' | 'paused' | 'running';\ntype Action = 'pause' | 'start' | 'stop';\ntype StateMachine = Record<State, Record<Action, State>>;\n\nconst stateMachine: StateMachine = {\n  stopped: {\n    pause: 'stopped',\n    start: 'stopped',\n    stop: 'stopped',\n  },\n  paused: {\n    pause: 'paused',\n    start: 'running',\n    stop: 'stopped',\n  },\n  running: {\n    pause: 'paused',\n    start: 'running',\n    stop: 'stopped',\n  },\n};\n`;function f(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",h3:\"h3\",code:\"code\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" It is recommended to have completed the \",(0,t.jsx)(e.a,{href:\"/questions/javascript/cancellable-interval\",children:\"Cancellable Interval\"}),\" question before attempting this question.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"The complexity of this question lies in modelling the inner state of the interval, whether it's paused, running, or stopped (which is a terminal state) and how to modify the state correctly based on the methods.\"}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 1: Using a \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" boolean flag\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can have use variables, \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" and \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" to model all possible states:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" is \",(0,t.jsx)(e.code,{children:\"null\"}),\", the interval is paused.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" is non-\",(0,t.jsx)(e.code,{children:\"null\"}),\", the interval is running and the value is the ID of the timer.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" is \",(0,t.jsx)(e.code,{children:\"true\"}),\", the interval has stopped and cannot be restarted, regardless of the \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" value.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In our \",(0,t.jsx)(e.code,{children:\"start\"}),\" and \",(0,t.jsx)(e.code,{children:\"pause\"}),\" functions, we first have to check if \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" is \",(0,t.jsx)(e.code,{children:\"true\"}),\" and terminate if so.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.code,{children:\"start\"}),\" function, we have to first check if \",(0,t.jsx)(e.code,{children:\"timerId != null\"}),\", and terminate early as well, otherwise we will be running two intervals at the same time.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.code,{children:\"pause\"}),\" function, once we have determined the interval is not in the \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" state, call \",(0,t.jsx)(e.code,{children:\"clearInterval(timerId)\"}),\" to stop the interval callback.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.code,{children:\"stop\"}),\" function, set \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" to \",(0,t.jsx)(e.code,{children:\"true\"}),\" and call \",(0,t.jsx)(e.code,{children:\"clearInterval(timerId)\"}),\" to stop the interval callback. It doesn't matter if the interval is still running because \",(0,t.jsx)(e.code,{children:\"clearInterval(null)\"}),\" is a no-op.\"]}),`\n`,(0,t.jsx)(i,{languages:{jsx:h,tsx:p}}),`\n`,(0,t.jsxs)(e.p,{children:[\"We don't have to worry about \",(0,t.jsx)(e.code,{children:\"this\"}),\" within the callback function because there's no option to pass a \",(0,t.jsx)(e.code,{children:\"thisArg\"}),\" to \",(0,t.jsx)(e.code,{children:\"setInterval\"}),\" unlike \",(0,t.jsx)(e.code,{children:\"Array.prototype.forEach()\"}),\"/\",(0,t.jsx)(e.code,{children:\"Array.prototype.reduce()\"}),\". Read more about \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval#the_this_problem\",children:\"this on MDN\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Approach 2: State machine\"}),`\n`,(0,t.jsx)(e.p,{children:\"With 3 states and 3 possible actions, modeling the state and actions with imperative logic is already starting to feel complicated. State machines are a declarative way to model state and the associated interactions. A state machine takes the current state and an action and returns the next state. We can then call the necessary logic based on the new state.\"}),`\n`,(0,t.jsx)(e.p,{children:\"For this question, we have the following states and actions:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"States: \",(0,t.jsx)(e.code,{children:\"'paused'\"}),\", \",(0,t.jsx)(e.code,{children:\"'stopped'\"}),\", \",(0,t.jsx)(e.code,{children:\"'running'\"})]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Actions: \",(0,t.jsx)(e.code,{children:\"start()\"}),\", \",(0,t.jsx)(e.code,{children:\"pause()\"}),\", \",(0,t.jsx)(e.code,{children:\"stop()\"})]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can define a \",(0,t.jsx)(e.code,{children:\"stateMachine\"}),\" object where the top-level key is the current state, and the values are objects where the key is an action and value is the new state. Deriving the new state is simply \",(0,t.jsx)(e.code,{children:\"const newState = stateMachine[state][action]\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If the \",(0,t.jsx)(e.code,{children:\"newState\"}),\" and the current \",(0,t.jsx)(e.code,{children:\"state\"}),\" is the same, there's nothing to be done. Otherwise, we can perform the necessary logic based on the \",(0,t.jsx)(e.code,{children:\"newState\"}),\", either to stop the interval or start it. The exposed methods just have to call the \",(0,t.jsx)(e.code,{children:\"nextState\"}),\" function with the corresponding action.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Although there's some duplication in the values of the key, it is much easier to determine at a glance that the state transitions are correct. Compare to the other approach, this state machine approach requires much fewer conditional statements and state assignment statements!\"}),`\n`,(0,t.jsx)(i,{languages:{jsx:u,tsx:m}}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval\",children:[(0,t.jsx)(e.code,{children:\"setInterval()\"}),\" | MDN\"]})}),`\n`]})]})}function R(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var T=R;return k(_);})();\n;return Component;",
  "workspace": {
    "main": "/src/resumable-interval.ts",
    "run": "/src/resumable-interval.run.test.ts",
    "submit": "/src/resumable-interval.submit.test.ts"
  }
}