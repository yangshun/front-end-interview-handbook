{
  "description": "var Component=(()=>{var m=Object.create;var l=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),g=(a,e)=>{for(var t in e)l(a,t,{get:e[t],enumerable:!0})},i=(a,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!b.call(a,r)&&r!==t&&l(a,r,{get:()=>e[r],enumerable:!(c=h(e,r))||c.enumerable});return a};var I=(a,e,t)=>(t=a!=null?m(p(a)):{},i(e||!a||!a.__esModule?l(t,\"default\",{value:a,enumerable:!0}):t,a)),x=a=>i(l({},\"__esModule\",{value:!0}),a);var o=v((w,s)=>{s.exports=_jsx_runtime});var k={};g(k,{default:()=>y,frontmatter:()=>f});var n=I(o()),f={title:\"Resumable Interval\",excerpt:\"Implement a function that creates a resumable interval object\"};function d(a){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",ol:\"ol\",li:\"li\",pre:\"pre\",h2:\"h2\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" It is recommended to have completed the \",(0,n.jsx)(e.a,{href:\"/questions/javascript/cancellable-interval\",children:\"Cancellable Interval\"}),\" question before attempting this question.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"createResumableInterval\"}),\", that acts like \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" and has the exact same signature. However instead of returning a timer ID, it returns an object that contains three methods:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"start\"}),\": Runs the callback \",(0,n.jsx)(e.strong,{children:\"immediately\"}),\" and every \",(0,n.jsx)(e.code,{children:\"delay\"}),\" milliseconds.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"pause\"}),\": Pauses the interval so that it stops running. Execution can be resumed by calling \",(0,n.jsx)(e.code,{children:\"start()\"}),\" again.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"stop\"}),\": Stops the interval permanently, cannot be restarted.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`createResumableInterval(callback);\ncreateResumableInterval(callback, delay);\ncreateResumableInterval(callback, delay, param1);\ncreateResumableInterval(callback, delay, param1, param2);\ncreateResumableInterval(callback, delay, param1, param2, /* \\u2026 ,*/ paramN);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You are recommended to read up on for \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" on \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval\",children:\"MDN Docs\"}),\" if you are unfamiliar.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\n// t = 0:\nconst interval = createResumableInterval(() => {\n  i++;\n}, 10);\n// t = 10:\ninterval.start(); // i is now 1.\n// t = 20: callback executes and i is now 2.\n// t = 25:\ninterval.pause();\n// t = 30: i remains at 2 because interval.pause() was called.\n// t = 35:\ninterval.start(); // i is now 3.\n// t = 45: callback executes and i is now 4.\n// t = 50:\ninterval.stop(); // i remains at 4.\n`})})]})}function j(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var y=j;return x(k);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function that creates a resumable interval object",
    "title": "Resumable Interval"
  },
  "solution": "var Component=(()=>{var v=Object.create;var s=Object.defineProperty;var I=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),S=(n,e)=>{for(var a in e)s(n,a,{get:e[a],enumerable:!0})},o=(n,e,a,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!w.call(n,r)&&r!==a&&s(n,r,{get:()=>e[r],enumerable:!(c=I(e,r))||c.enumerable});return n};var x=(n,e,a)=>(a=n!=null?v(g(n)):{},o(e||!n||!n.__esModule?s(a,\"default\",{value:n,enumerable:!0}):a,n)),k=n=>o(s({},\"__esModule\",{value:!0}),n);var d=y((W,l)=>{l.exports=_jsx_runtime});var _={};S(_,{default:()=>T});var t=x(d());var i=MDXCodeBlock;var h=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {{start: Function, pause: Function, stop: Function}}\n */\nexport default function createResumableInterval(callback, delay, ...args) {\n  let timerId = null;\n  let stopped = false;\n\n  function start() {\n    if (stopped || timerId != null) {\n      return;\n    }\n\n    callback(...args);\n    timerId = setInterval(callback, delay, ...args);\n  }\n\n  function clearTimer() {\n    clearInterval(timerId);\n    timerId = null;\n  }\n\n  function pause() {\n    if (stopped) {\n      return;\n    }\n\n    clearTimer();\n  }\n\n  function stop() {\n    stopped = true;\n    clearTimer();\n  }\n\n  return {\n    start,\n    pause,\n    stop,\n  };\n}\n`;var p=`interface Resumable {\n  start: () => void;\n  pause: () => void;\n  stop: () => void;\n}\n\nexport default function createResumableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): Resumable {\n  let timerId: number | null = null;\n  let stopped = false;\n\n  function start() {\n    if (stopped || timerId != null) {\n      return;\n    }\n\n    callback(...args);\n    timerId = setInterval(callback, delay, ...args);\n  }\n\n  function clearTimer() {\n    clearInterval(timerId ?? undefined);\n    timerId = null;\n  }\n\n  function pause() {\n    if (stopped) {\n      return;\n    }\n\n    clearTimer();\n  }\n\n  function stop() {\n    stopped = true;\n    clearTimer();\n  }\n\n  return {\n    start,\n    pause,\n    stop,\n  };\n}\n`;var u=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {{start: Function, pause: Function, stop: Function}}\n */\nexport default function createResumableInterval(callback, delay, ...args) {\n  let timerId;\n  let state = 'paused';\n\n  function nextState(action) {\n    const newState = stateMachine[state][action];\n    if (newState === state) {\n      return;\n    }\n\n    state = newState;\n    switch (state) {\n      case 'paused':\n      case 'stopped':\n        clearInterval(timerId);\n        timerId = null;\n        return;\n      case 'running':\n        callback(...args);\n        timerId = setInterval(callback, delay, ...args);\n        return;\n    }\n  }\n\n  return {\n    start: () => nextState('start'),\n    pause: () => nextState('pause'),\n    stop: () => nextState('stop'),\n  };\n}\n\nconst stateMachine = {\n  stopped: {\n    pause: 'stopped',\n    start: 'stopped',\n    stop: 'stopped',\n  },\n  paused: {\n    pause: 'paused',\n    start: 'running',\n    stop: 'stopped',\n  },\n  running: {\n    pause: 'paused',\n    start: 'running',\n    stop: 'stopped',\n  },\n};\n`;var m=`interface Resumable {\n  start: () => void;\n  pause: () => void;\n  stop: () => void;\n}\n\nexport default function createResumableInterval(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): Resumable {\n  let timerId: number | null;\n  let state: State = 'paused';\n\n  function nextState(action: Action) {\n    const newState: State = stateMachine[state][action];\n    if (newState === state) {\n      return;\n    }\n\n    state = newState;\n    switch (state) {\n      case 'paused':\n      case 'stopped':\n        clearInterval(timerId ?? undefined);\n        timerId = null;\n        return;\n      case 'running':\n        callback(...args);\n        timerId = setInterval(callback, delay, ...args);\n        return;\n    }\n  }\n\n  return {\n    start: () => nextState('start'),\n    pause: () => nextState('pause'),\n    stop: () => nextState('stop'),\n  };\n}\n\ntype State = 'stopped' | 'paused' | 'running';\ntype Action = 'pause' | 'start' | 'stop';\ntype StateMachine = Record<State, Record<Action, State>>;\n\nconst stateMachine: StateMachine = {\n  stopped: {\n    pause: 'stopped',\n    start: 'stopped',\n    stop: 'stopped',\n  },\n  paused: {\n    pause: 'paused',\n    start: 'running',\n    stop: 'stopped',\n  },\n  running: {\n    pause: 'paused',\n    start: 'running',\n    stop: 'stopped',\n  },\n};\n`;function f(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",h3:\"h3\",code:\"code\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" It is recommended to have completed the \",(0,t.jsx)(e.a,{href:\"/questions/javascript/cancellable-interval\",children:\"Cancellable Interval\"}),\" question before attempting this question.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"The complexity of this question lies in modelling the inner state of the interval, whether it's paused, running, or stopped (which is a terminal state) and how to modify the state correctly based on the methods.\"}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 1: Using a \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" boolean flag\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can have use variables, \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" and \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" to model all possible states:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" is \",(0,t.jsx)(e.code,{children:\"null\"}),\", the interval is paused.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" is non-\",(0,t.jsx)(e.code,{children:\"null\"}),\", the interval is running and the value is the ID of the timer.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" is \",(0,t.jsx)(e.code,{children:\"true\"}),\", the interval has stopped and cannot be restarted, regardless of the \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" value.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In our \",(0,t.jsx)(e.code,{children:\"start\"}),\" and \",(0,t.jsx)(e.code,{children:\"pause\"}),\" functions, we first have to check if \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" is \",(0,t.jsx)(e.code,{children:\"true\"}),\" and terminate if so.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.code,{children:\"start\"}),\" function, we have to first check if \",(0,t.jsx)(e.code,{children:\"timerId != null\"}),\", and terminate early as well, otherwise we will be running two intervals at the same time.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.code,{children:\"pause\"}),\" function, once we have determined the interval is not in the \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" state, call \",(0,t.jsx)(e.code,{children:\"clearInterval(timerId)\"}),\" to stop the interval callback.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.code,{children:\"stop\"}),\" function, set \",(0,t.jsx)(e.code,{children:\"stopped\"}),\" to \",(0,t.jsx)(e.code,{children:\"true\"}),\" and call \",(0,t.jsx)(e.code,{children:\"clearInterval(timerId)\"}),\" to stop the interval callback. It doesn't matter if the interval is still running because \",(0,t.jsx)(e.code,{children:\"clearInterval(null)\"}),\" is a no-op.\"]}),`\n`,(0,t.jsx)(i,{languages:{jsx:h,tsx:p}}),`\n`,(0,t.jsxs)(e.p,{children:[\"We don't have to worry about \",(0,t.jsx)(e.code,{children:\"this\"}),\" within the callback function because there's no option to pass a \",(0,t.jsx)(e.code,{children:\"thisArg\"}),\" to \",(0,t.jsx)(e.code,{children:\"setInterval\"}),\" unlike \",(0,t.jsx)(e.code,{children:\"Array.prototype.forEach()\"}),\"/\",(0,t.jsx)(e.code,{children:\"Array.prototype.reduce()\"}),\". Read more about \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval#the_this_problem\",children:\"this on MDN\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Approach 2: State machine\"}),`\n`,(0,t.jsx)(e.p,{children:\"With 3 states and 3 possible actions, modeling the state and actions with imperative logic is already starting to feel complicated. State machines are a declarative way to model state and the associated interactions. A state machine takes the current state and an action and returns the next state. We can then call the necessary logic based on the new state.\"}),`\n`,(0,t.jsx)(e.p,{children:\"For this question, we have the following states and actions:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"States: \",(0,t.jsx)(e.code,{children:\"'paused'\"}),\", \",(0,t.jsx)(e.code,{children:\"'stopped'\"}),\", \",(0,t.jsx)(e.code,{children:\"'running'\"})]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Actions: \",(0,t.jsx)(e.code,{children:\"start()\"}),\", \",(0,t.jsx)(e.code,{children:\"pause()\"}),\", \",(0,t.jsx)(e.code,{children:\"stop()\"})]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can define a \",(0,t.jsx)(e.code,{children:\"stateMachine\"}),\" object where the top-level key is the current state, and the values are objects where the key is an action and value is the new state. Deriving the new state is simply \",(0,t.jsx)(e.code,{children:\"const newState = stateMachine[state][action]\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If the \",(0,t.jsx)(e.code,{children:\"newState\"}),\" and the current \",(0,t.jsx)(e.code,{children:\"state\"}),\" is the same, there's nothing to be done. Otherwise, we can perform the necessary logic based on the \",(0,t.jsx)(e.code,{children:\"newState\"}),\", either to stop the interval or start it. The exposed methods just have to call the \",(0,t.jsx)(e.code,{children:\"nextState\"}),\" function with the corresponding action.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Although there's some duplication in the values of the key, it is much easier to determine at a glance that the state transitions are correct. Compare to the other approach, this state machine approach requires much fewer conditional statements and state assignment statements!\"}),`\n`,(0,t.jsx)(i,{languages:{jsx:u,tsx:m}}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setInterval\",children:[(0,t.jsx)(e.code,{children:\"setInterval()\"}),\" | MDN\"]})}),`\n`]})]})}function R(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var T=R;return k(_);})();\n;return Component;"
}