{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-reject\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-reject.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promise-reject.run.test.ts": "import promiseReject from './promise-reject';\n\ndescribe('promiseReject', () => {\n  test('returns promise', async () => {\n    expect.assertions(1);\n    try {\n      const p = promiseReject(1);\n      expect(p).toBeInstanceOf(Promise);\n      await p;\n    } catch {}\n  });\n\n  test('rejects', async () => {\n    const p = promiseReject(42);\n    expect(p).rejects.toBe(42);\n  });\n\n  test('argument is promise', async () => {\n    expect.assertions(1);\n    try {\n      const p = promiseReject(new Promise((resolve) => resolve(42)));\n      expect(p).toBeInstanceOf(Promise);\n      await p;\n    } catch {}\n  });\n});\n",
    "/src/promise-reject.submit.test.ts": "import promiseReject from './promise-reject';\n\ndescribe('promiseReject', () => {\n  describe('non-promise', () => {\n    test('returns promise', async () => {\n      expect.assertions(1);\n      try {\n        const p = promiseReject(1);\n        expect(p).toBeInstanceOf(Promise);\n        await p;\n      } catch {}\n    });\n\n    test('rejects', async () => {\n      const p = promiseReject(42);\n      expect(p).rejects.toBe(42);\n    });\n  });\n\n  describe('promise', () => {\n    test('returns promise', async () => {\n      expect.assertions(1);\n      try {\n        const p = promiseReject(new Promise((resolve) => resolve(42)));\n        expect(p).toBeInstanceOf(Promise);\n        await p;\n      } catch {}\n    });\n\n    test('returns different promise instance', async () => {\n      expect.assertions(1);\n      try {\n        const reason = new Promise((resolve) => resolve(42));\n        const p = promiseReject(reason);\n        expect(p).not.toBe(reason);\n        await p;\n      } catch {}\n    });\n\n    test('rejects', async () => {\n      const p = promiseReject(42);\n      expect(p).rejects.toBe(42);\n    });\n\n    test('use with catch', (done) => {\n      expect.assertions(1);\n      const p = promiseReject(42);\n      p.catch((err) => {\n        expect(err).toBe(42);\n        done();\n      });\n    });\n  });\n\n  test('use with Promise.all()', async () => {\n    const p0 = promiseReject(3);\n    const p1 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve('foo');\n      }, 100);\n    });\n\n    expect(Promise.all([p0, p1])).rejects.toBe(3);\n  });\n\n  test('use with Promise.allSettled()', async () => {\n    const p0 = promiseReject(2);\n    const p1 = promiseReject(3);\n\n    const res = await Promise.allSettled([p0, p1]);\n    expect(res).toEqual([\n      {\n        status: 'rejected',\n        reason: 2,\n      },\n      {\n        status: 'rejected',\n        reason: 3,\n      },\n    ]);\n  });\n\n  test('use with Promise.any()', async () => {\n    expect.assertions(2);\n    const p0 = promiseReject(2);\n\n    try {\n      await Promise.any([p0]);\n    } catch (err: any) {\n      expect(err).toBeInstanceOf(AggregateError);\n      expect(err.errors).toEqual([2]);\n    }\n  });\n\n  test('use with Promise.race()', async () => {\n    const p0 = promiseReject(2);\n    const p1 = new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(3);\n      }, 10);\n    });\n\n    expect(Promise.race([p0, p1])).rejects.toBe(2);\n  });\n});\n",
    "/src/promise-reject.ts": "export default function promiseReject<T = never>(reason: any): Promise<T> {\n  return new Promise((_, reject) => reject(reason));\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {*} reason\n * @returns Promise\n */\nexport default function promiseReject(reason) {\n  throw 'Not implemented';\n}",
    "ts": "export default function promiseReject<T = never>(reason: any): Promise<T> {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/promise-reject.ts",
    "run": "/src/promise-reject.run.test.ts",
    "submit": "/src/promise-reject.submit.test.ts"
  }
}