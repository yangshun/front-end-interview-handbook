{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-mediated-state\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-mediated-state.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/use-mediated-state.run.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useMediatedState from './use-mediated-state';\n\ndescribe('useMediatedState', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useMediatedState(() => {}));\n\n    expect(Array.isArray(result.current)).toBe(true);\n    expect(result.current.length).toBe(2);\n    expect(typeof result.current[0]).toBe('undefined');\n    expect(typeof result.current[1]).toBe('function');\n  });\n\n  test('initial state', () => {\n    const initialState = 42;\n    const { result } = renderHook(() =>\n      useMediatedState(() => initialState, initialState),\n    );\n\n    expect(result.current[0]).toBe(initialState);\n  });\n\n  test('mediator', () => {\n    const { result } = renderHook(() => useMediatedState((x) => x * 2, 1));\n\n    act(() => result.current[1](2));\n\n    expect(result.current[0]).toBe(4);\n  });\n\n  test('mediator with dispatch', () => {\n    const { result } = renderHook(() =>\n      // @ts-expect-error\n      useMediatedState((x, dispatch) => dispatch(x * 2), 1),\n    );\n\n    act(() => result.current[1](2));\n\n    expect(result.current[0]).toBe(4);\n  });\n});\n",
    "/src/use-mediated-state.submit.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useMediatedState from './use-mediated-state';\nimport { useState } from 'react';\n\ndescribe('useMediatedState', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useMediatedState(() => {}));\n\n    expect(Array.isArray(result.current)).toBe(true);\n    expect(result.current.length).toBe(2);\n    expect(typeof result.current[0]).toBe('undefined');\n    expect(typeof result.current[1]).toBe('function');\n  });\n\n  test('initial state', () => {\n    const initialState = 42;\n    const { result } = renderHook(() =>\n      useMediatedState(() => initialState, initialState),\n    );\n\n    expect(result.current[0]).toBe(initialState);\n  });\n\n  test('mediator', () => {\n    const { result } = renderHook(() => useMediatedState((x) => x * 2, 1));\n\n    act(() => result.current[1](2));\n\n    expect(result.current[0]).toBe(4);\n  });\n\n  test('mediator with dispatch', () => {\n    const { result } = renderHook(() =>\n      // @ts-expect-error\n      useMediatedState((x, dispatch) => dispatch(x * 2), 1),\n    );\n\n    act(() => result.current[1](2));\n\n    expect(result.current[0]).toBe(4);\n  });\n\n  test('works with updater function', () => {\n    const { result } = renderHook(() => useMediatedState((x) => x * 2, 1));\n\n    act(() => result.current[1]((x) => x + 1));\n\n    expect(result.current[0]).toBe(4);\n  });\n\n  test('works with updater function and dispatch', () => {\n    const { result } = renderHook(() =>\n      // @ts-expect-error\n      useMediatedState((x, dispatch) => dispatch(x * 2), 1),\n    );\n\n    act(() => result.current[1]((x) => x + 1));\n\n    expect(result.current[0]).toBe(4);\n  });\n});\n",
    "/src/use-mediated-state.ts": "import { Dispatch, SetStateAction, useCallback, useRef, useState } from 'react';\n\ninterface StateMediator<T = unknown> {\n  (newState: T): T;\n  (newState: T, dispatch: Dispatch<SetStateAction<T>>): void;\n}\n\nexport default function useMediatedState<T = unknown>(\n  mediator: StateMediator<T>,\n  initialState?: T,\n): [T, Dispatch<SetStateAction<T>>] {\n  const mediatorFn = useRef(mediator);\n\n  const [state, setMediatedState] = useState<T>(initialState!);\n\n  const setState: Dispatch<SetStateAction<T>> = useCallback(\n    (newStateOrUpdaterFunction) => {\n      const newState =\n        newStateOrUpdaterFunction instanceof Function\n          ? newStateOrUpdaterFunction(state)\n          : newStateOrUpdaterFunction;\n\n      const mediator = mediatorFn.current;\n\n      if (mediator.length === 2) {\n        mediator(newState, setMediatedState);\n      } else {\n        setMediatedState(mediator(newState));\n      }\n    },\n    [state],\n  );\n\n  return [state, setState];\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {Function} mediator\n * @param {T | undefined} initialState\n */\nexport default function useMediatedState(mediator, initialState) {\n  throw 'Not implemented';\n}",
    "ts": "import { Dispatch, SetStateAction } from 'react';\n\ninterface StateMediator<S = unknown> {\n  (newState: S): S;\n  (newState: S, dispatch: Dispatch<SetStateAction<S>>): void;\n}\n\nexport default function useMediatedState<S = unknown>(\n  mediator: StateMediator<S>,\n  initialState?: S,\n): [S, Dispatch<SetStateAction<S>>] {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/use-mediated-state.ts",
    "run": "/src/use-mediated-state.run.test.ts",
    "submit": "/src/use-mediated-state.submit.test.ts"
  }
}