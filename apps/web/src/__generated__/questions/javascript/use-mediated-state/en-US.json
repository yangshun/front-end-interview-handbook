{
  "description": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),S=(n,e)=>{for(var a in e)i(n,a,{get:e[a],enumerable:!0})},c=(n,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!f.call(n,r)&&r!==a&&i(n,r,{get:()=>e[r],enumerable:!(s=u(e,r))||s.enumerable});return n};var v=(n,e,a)=>(a=n!=null?h(m(n)):{},c(e||!n||!n.__esModule?i(a,\"default\",{value:n,enumerable:!0}):a,n)),x=n=>c(i({},\"__esModule\",{value:!0}),n);var d=g((M,o)=>{o.exports=_jsx_runtime});var T={};S(T,{default:()=>y,frontmatter:()=>w});var t=v(d()),w={title:\"useMediatedState\",excerpt:\"Implement a hook that is similar to useState, but supports a mediation process\"};function l(n){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a \",(0,t.jsx)(e.code,{children:\"useMediatedState\"}),\" hook that is similar to \",(0,t.jsx)(e.code,{children:\"useState\"}),\", but supports a mediator function that runs on each state set. This mediator function can be used to transform or intercept state updates.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`const replaceMultipleSpaces = (s) => s.replace(/[\\\\s]+/g, ' ');\n\nexport default function Component() {\n  const [state, setState] = useMediatedState(replaceMultipleSpaces, '');\n\n  return (\n    <div>\n      <div>You will not be able to enter more than one space</div>\n      <input\n        type=\"text\"\n        min=\"0\"\n        max=\"10\"\n        value={state}\n        onChange={(e) => setState(e.target.value)}\n      />\n    </div>\n  );\n}\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"mediator\"}),\": A function that receives the new state and returns the transformed state. This function can have two forms:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"(newState: T) => T\"}),\" that receives 1 argument: the new state dispatched by \",(0,t.jsx)(e.code,{children:\"setState\"}),\", and returns the final state, or\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"(newState: T, dispatch) => void\"}),\" that receives 2 arguments: the new state dispatched by \",(0,t.jsx)(e.code,{children:\"setState\"}),\", and a function \",(0,t.jsx)(e.code,{children:\"dispatch\"}),\" that will actually run the state update. It returns nothing.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"initialState\"}),\": The initial state value\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note\"}),\": \",(0,t.jsx)(e.code,{children:\"mediator\"}),\" should stay the same, even if it's changed into a new and/or different function.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,t.jsx)(e.p,{children:\"The hook returns an array with two elements:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The current state\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"The function \",(0,t.jsx)(e.code,{children:\"setState\"}),\" to update the state. It must be the same as the second element of the array returned by \",(0,t.jsx)(e.code,{children:\"useState\"})]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Essentially, the hook returns the same values as \",(0,t.jsx)(e.code,{children:\"useState\"}),\".\"]})]})}function b(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var y=b;return x(T);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-mediated-state\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-mediated-state.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/src/use-mediated-state.run.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useMediatedState from './use-mediated-state';\n\ndescribe('useMediatedState', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useMediatedState(() => {}));\n\n    expect(Array.isArray(result.current)).toBe(true);\n    expect(result.current.length).toBe(2);\n    expect(typeof result.current[0]).toBe('undefined');\n    expect(typeof result.current[1]).toBe('function');\n  });\n\n  test('initial state', () => {\n    const initialState = 42;\n    const { result } = renderHook(() =>\n      useMediatedState(() => initialState, initialState),\n    );\n\n    expect(result.current[0]).toBe(initialState);\n  });\n\n  test('mediator', () => {\n    const { result } = renderHook(() => useMediatedState((x) => x * 2, 1));\n\n    act(() => result.current[1](2));\n\n    expect(result.current[0]).toBe(4);\n  });\n\n  test('mediator with dispatch', () => {\n    const { result } = renderHook(() =>\n      // @ts-expect-error\n      useMediatedState((x, dispatch) => dispatch(x * 2), 1),\n    );\n\n    act(() => result.current[1](2));\n\n    expect(result.current[0]).toBe(4);\n  });\n});\n",
    "/src/use-mediated-state.submit.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useMediatedState from './use-mediated-state';\nimport { useState } from 'react';\n\ndescribe('useMediatedState', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useMediatedState(() => {}));\n\n    expect(Array.isArray(result.current)).toBe(true);\n    expect(result.current.length).toBe(2);\n    expect(typeof result.current[0]).toBe('undefined');\n    expect(typeof result.current[1]).toBe('function');\n  });\n\n  test('initial state', () => {\n    const initialState = 42;\n    const { result } = renderHook(() =>\n      useMediatedState(() => initialState, initialState),\n    );\n\n    expect(result.current[0]).toBe(initialState);\n  });\n\n  test('mediator', () => {\n    const { result } = renderHook(() => useMediatedState((x) => x * 2, 1));\n\n    act(() => result.current[1](2));\n\n    expect(result.current[0]).toBe(4);\n  });\n\n  test('mediator with dispatch', () => {\n    const { result } = renderHook(() =>\n      // @ts-expect-error\n      useMediatedState((x, dispatch) => dispatch(x * 2), 1),\n    );\n\n    act(() => result.current[1](2));\n\n    expect(result.current[0]).toBe(4);\n  });\n\n  test('works with updater function', () => {\n    const { result } = renderHook(() => useMediatedState((x) => x * 2, 1));\n\n    act(() => result.current[1]((x) => x + 1));\n\n    expect(result.current[0]).toBe(4);\n  });\n\n  test('works with updater function and dispatch', () => {\n    const { result } = renderHook(() =>\n      // @ts-expect-error\n      useMediatedState((x, dispatch) => dispatch(x * 2), 1),\n    );\n\n    act(() => result.current[1]((x) => x + 1));\n\n    expect(result.current[0]).toBe(4);\n  });\n});\n",
    "/src/use-mediated-state.ts": "import { Dispatch, SetStateAction, useCallback, useRef, useState } from 'react';\n\ninterface StateMediator<T = unknown> {\n  (newState: T): T;\n  (newState: T, dispatch: Dispatch<SetStateAction<T>>): void;\n}\n\nexport default function useMediatedState<T = unknown>(\n  mediator: StateMediator<T>,\n  initialState?: T,\n): [T, Dispatch<SetStateAction<T>>] {\n  const mediatorFn = useRef(mediator);\n\n  const [state, setMediatedState] = useState<T>(initialState!);\n\n  const setState: Dispatch<SetStateAction<T>> = useCallback(\n    (newStateOrUpdaterFunction) => {\n      const newState =\n        newStateOrUpdaterFunction instanceof Function\n          ? newStateOrUpdaterFunction(state)\n          : newStateOrUpdaterFunction;\n\n      const mediator = mediatorFn.current;\n\n      if (mediator.length === 2) {\n        mediator(newState, setMediatedState);\n      } else {\n        setMediatedState(mediator(newState));\n      }\n    },\n    [state],\n  );\n\n  return [state, setState];\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": "phillmont",
    "companies": [],
    "created": 1742169600,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a hook that is similar to useState, but supports a mediation process",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/use-mediated-state",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "use-state-with-reset"
    ],
    "slug": "use-mediated-state",
    "subtitle": null,
    "title": "useMediatedState",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {Function} mediator\n * @param {T | undefined} initialState\n */\nexport default function useMediatedState(mediator, initialState) {\n  throw 'Not implemented';\n}",
    "ts": "import { Dispatch, SetStateAction } from 'react';\n\ninterface StateMediator<S = unknown> {\n  (newState: S): S;\n  (newState: S, dispatch: Dispatch<SetStateAction<S>>): void;\n}\n\nexport default function useMediatedState<S = unknown>(\n  mediator: StateMediator<S>,\n  initialState?: S,\n): [S, Dispatch<SetStateAction<S>>] {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var T=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),M=(t,e)=>{for(var a in e)i(t,a,{get:e[a],enumerable:!0})},r=(t,e,a,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of f(e))!w.call(t,o)&&o!==a&&i(t,o,{get:()=>e[o],enumerable:!(c=S(e,o))||c.enumerable});return t};var x=(t,e,a)=>(a=t!=null?m(p(t)):{},r(e||!t||!t.__esModule?i(a,\"default\",{value:t,enumerable:!0}):a,t)),k=t=>r(i({},\"__esModule\",{value:!0}),t);var s=T((C,d)=>{d.exports=_jsx_runtime});var D={};M(D,{default:()=>g});var n=x(s());var u=MDXCodeBlock;var h=`import { Dispatch, SetStateAction, useCallback, useRef, useState } from 'react';\n\ninterface StateMediator<T = unknown> {\n  (newState: T): T;\n  (newState: T, dispatch: Dispatch<SetStateAction<T>>): void;\n}\n\nexport default function useMediatedState<T = unknown>(\n  mediator: StateMediator<T>,\n  initialState?: T,\n): [T, Dispatch<SetStateAction<T>>] {\n  const mediatorFn = useRef(mediator);\n\n  const [state, setMediatedState] = useState<T>(initialState!);\n\n  const setState: Dispatch<SetStateAction<T>> = useCallback(\n    (newStateOrUpdaterFunction) => {\n      const newState =\n        newStateOrUpdaterFunction instanceof Function\n          ? newStateOrUpdaterFunction(state)\n          : newStateOrUpdaterFunction;\n\n      const mediator = mediatorFn.current;\n\n      if (mediator.length === 2) {\n        mediator(newState, setMediatedState);\n      } else {\n        setMediatedState(mediator(newState));\n      }\n    },\n    [state],\n  );\n\n  return [state, setState];\n}\n`;function l(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"useMediatedState\"}),\" hook can be implemented with \",(0,n.jsx)(e.code,{children:\"useState\"}),\" and a setter function that calls the \",(0,n.jsx)(e.code,{children:\"mediator\"}),\" function before updating the state. To determine the number of arguments a \",(0,n.jsx)(e.code,{children:\"mediator\"}),\" function receives, we can use \",(0,n.jsx)(e.code,{children:\"mediator.length\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To memoize the \",(0,n.jsx)(e.code,{children:\"mediator\"}),\", we can either use \",(0,n.jsx)(e.code,{children:\"useRef\"}),\", \",(0,n.jsx)(e.code,{children:\"useMemo\"}),\", or \",(0,n.jsx)(e.code,{children:\"useCallback\"}),\" since we know for a fact that \",(0,n.jsx)(e.code,{children:\"mediator\"}),\" is a function. The simplest way is to use \",(0,n.jsx)(e.code,{children:\"useRef\"}),\" since there's no need to run any memoization function on the first render.\"]}),`\n`,(0,n.jsx)(u,{children:h})]})}function b(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(l,t)})):l(t)}var g=b;return k(D);})();\n;return Component;",
  "workspace": {
    "main": "/src/use-mediated-state.ts",
    "run": "/src/use-mediated-state.run.test.ts",
    "submit": "/src/use-mediated-state.submit.test.ts"
  }
}