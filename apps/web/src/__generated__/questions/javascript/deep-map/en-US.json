{
  "description": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var o in e)c(n,o,{get:e[o],enumerable:!0})},d=(n,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of h(e))!b.call(n,a)&&a!==o&&c(n,a,{get:()=>e[a],enumerable:!(r=u(e,a))||r.enumerable});return n};var g=(n,e,o)=>(o=n!=null?p(m(n)):{},d(e||!n||!n.__esModule?c(o,\"default\",{value:n,enumerable:!0}):o,n)),j=n=>d(c({},\"__esModule\",{value:!0}),n);var l=f((O,i)=>{i.exports=_jsx_runtime});var y={};x(y,{default:()=>_,frontmatter:()=>M});var t=g(l()),M={title:\"Deep Map\",excerpt:\"Implement a function to recursively transform values\"};function s(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a function \",(0,t.jsx)(e.code,{children:\"deepMap(value, fn)\"}),\" to return a new value containing the results of calling a provided function on every non-\",(0,t.jsx)(e.code,{children:\"Array\"}),\" and non-\",(0,t.jsx)(e.code,{children:\"Object\"}),\" element in the \",(0,t.jsx)(e.code,{children:\"value\"}),\" input, including elements within nested \",(0,t.jsx)(e.code,{children:\"Array\"}),\"s and \",(0,t.jsx)(e.code,{children:\"Object\"}),\"s. The function \",(0,t.jsx)(e.code,{children:\"fn\"}),\" is called with a single argument, the element that is being mapped/transformed.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const double = (x) => x * 2;\n\ndeepMap(2, double); // 4\ndeepMap([1, 2, 3], double); // [4, 5, 6]\ndeepMap({ a: 1, b: 2, c: 3 }, double); // { a: 2, b: 4, c: 6 }\ndeepMap(\n  {\n    foo: 1,\n    bar: [2, 3, 4],\n    qux: { a: 5, b: 6 },\n  },\n  double,\n); // => { foo: 2, bar: [4, 6, 8], qux: { a: 10, b: 12 } }\n`})})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(s,n)})):s(n)}var _=v;return j(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/deep-map\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/deep-map.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/deep-map.run.test.ts": "import deepMap from './deep-map';\n\nconst identity = <T>(x: T) => x;\nconst square = (x: number) => x * x;\nconst double = (x: number) => x * 2;\n\ndescribe('deepMap', () => {\n  test('numbers', () => {\n    expect(deepMap(3, square)).toBe(9);\n    expect(deepMap(3, double)).toBe(6);\n  });\n\n  test('arrays', () => {\n    expect(deepMap([-4, 10], identity)).toEqual([-4, 10]);\n    expect(deepMap([-4, 10], square)).toEqual([16, 100]);\n  });\n\n  test('objects', () => {\n    expect(deepMap({ foo: 3, bar: [7, 5] }, double)).toEqual({\n      foo: 6,\n      bar: [14, 10],\n    });\n  });\n});\n",
    "/src/deep-map.submit.test.ts": "import deepMap from './deep-map';\n\nconst identity = <T>(x: T) => x;\nconst dummy = () => 'dummy';\nconst square = (x: number) => x * x;\nconst negate = (x: boolean) => !x;\nconst length = (x: { length: number }) => x.length;\nconst double = (x: number) => x * 2;\n\ndescribe('deepMap', () => {\n  describe('primitives', () => {\n    test('numbers', () => {\n      expect(deepMap(3, square)).toBe(9);\n      expect(deepMap(3, double)).toBe(6);\n    });\n\n    test('boolean', () => {\n      expect(deepMap(true, negate)).toBe(false);\n      expect(deepMap(false, negate)).toBe(true);\n    });\n\n    test('strings', () => {\n      expect(deepMap('hello', length)).toBe(5);\n      expect(deepMap('byebye', length)).toBe(6);\n    });\n\n    test('null', () => {\n      expect(deepMap(null, identity)).toBe(null);\n    });\n  });\n\n  describe('non-primitives', () => {\n    test('regexp', () => {\n      expect(deepMap(/hello/, dummy)).toBe('dummy');\n    });\n\n    test('functions', () => {\n      expect(deepMap(() => {}, dummy)).toBe('dummy');\n    });\n  });\n\n  describe('arrays', () => {\n    test('empty array', () => {\n      expect(deepMap([], identity)).toEqual([]);\n      expect(deepMap([], square)).toEqual([]);\n    });\n\n    test('one value', () => {\n      expect(deepMap([10], identity)).toEqual([10]);\n      expect(deepMap([10], square)).toEqual([100]);\n    });\n\n    test('two values', () => {\n      expect(deepMap([-4, 10], identity)).toEqual([-4, 10]);\n      expect(deepMap([-4, 10], square)).toEqual([16, 100]);\n    });\n\n    test('multiple values', () => {\n      expect(deepMap([1, 2, 3, 4], identity)).toEqual([1, 2, 3, 4]);\n      expect(deepMap([1, 2, 3, 4, 5], square)).toEqual([1, 4, 9, 16, 25]);\n    });\n\n    test('nested objects', () => {\n      expect(deepMap([2, { foo: 3 }], double)).toEqual([4, { foo: 6 }]);\n      expect(deepMap([2, { foo: 3 }], square)).toEqual([4, { foo: 9 }]);\n    });\n\n    test('nested arrays', () => {\n      expect(deepMap([2, [3, [4]]], double)).toEqual([4, [6, [8]]]);\n      expect(deepMap([2, [3, [4]]], square)).toEqual([4, [9, [16]]]);\n    });\n\n    test('does not mutate the input', () => {\n      const obj = [3, 2];\n      expect(deepMap(obj, double)).toEqual([6, 4]);\n      expect(obj).toEqual([3, 2]);\n    });\n  });\n\n  describe('objects', () => {\n    test('empty', () => {\n      expect(deepMap({}, double)).toEqual({});\n    });\n\n    test('single key', () => {\n      expect(deepMap({ foo: 2 }, double)).toEqual({ foo: 4 });\n    });\n\n    test('multiple keys', () => {\n      expect(deepMap({ foo: 2, bar: 3 }, double)).toEqual({ foo: 4, bar: 6 });\n    });\n\n    test('nested objects', () => {\n      expect(deepMap({ foo: 3, bar: { baz: 5, qux: 6 } }, identity)).toEqual({\n        foo: 3,\n        bar: {\n          baz: 5,\n          qux: 6,\n        },\n      });\n      expect(deepMap({ foo: 3, bar: { baz: 5, qux: 6 } }, double)).toEqual({\n        foo: 6,\n        bar: {\n          baz: 10,\n          qux: 12,\n        },\n      });\n    });\n\n    test('nested arrays', () => {\n      expect(deepMap({ foo: 3, bar: [7, 5] }, identity)).toEqual({\n        foo: 3,\n        bar: [7, 5],\n      });\n      expect(deepMap({ foo: 3, bar: [7, 5] }, double)).toEqual({\n        foo: 6,\n        bar: [14, 10],\n      });\n    });\n\n    test('does not mutate the input', () => {\n      const obj = { bar: 3, foo: 2 };\n      expect(deepMap(obj, double)).toEqual({\n        foo: 4,\n        bar: 6,\n      });\n      expect(obj).toEqual({\n        foo: 2,\n        bar: 3,\n      });\n    });\n  });\n\n  test('can access `this`', () => {\n    expect(\n      deepMap({ bar: 3, foo: 2 }, function (this: any, x: number) {\n        return this.foo * x;\n      }),\n    ).toEqual({\n      foo: 4,\n      bar: 6,\n    });\n  });\n});\n",
    "/src/deep-map.ts": "export default function deepMap(value: unknown, fn: Function): unknown {\n  return mapHelper(value, fn, value);\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\nfunction mapHelper(element: unknown, fn: Function, original: unknown): unknown {\n  // Handle arrays.\n  if (Array.isArray(element)) {\n    return element.map((item) => mapHelper(item, fn, original));\n  }\n\n  // Handle plain objects.\n  if (isPlainObject(element)) {\n    return Object.fromEntries(\n      Object.entries(element as Object).map(([key, value]) => [\n        key,\n        mapHelper(value, fn, original),\n      ]),\n    );\n  }\n\n  // Handle other types.\n  return fn.call(original, element);\n}\n"
  },
  "format": "javascript",
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1690761600,
    "difficulty": "medium",
    "duration": 25,
    "excerpt": "Implement a function to recursively transform values",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/deep-map",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "array-map",
      "object-map"
    ],
    "slug": "deep-map",
    "subtitle": null,
    "title": "Deep Map",
    "topics": [
      "recursion"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {any} value\n * @param {Function} fn\n * @returns any\n */\nexport default function deepMap(value, fn) {\n  throw 'Not implemented';\n}",
    "ts": "export default function deepMap(value: unknown, fn: Function): unknown {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var r in e)l(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!b.call(t,i)&&i!==r&&l(t,i,{get:()=>e[i],enumerable:!(a=m(e,i))||a.enumerable});return t};var w=(t,e,r)=>(r=t!=null?f(v(t)):{},c(e||!t||!t.__esModule?l(r,\"default\",{value:t,enumerable:!0}):r,t)),k=t=>c(l({},\"__esModule\",{value:!0}),t);var s=g((P,o)=>{o.exports=_jsx_runtime});var M={};j(M,{default:()=>A});var n=w(s());var d=MDXCodeBlock;var h=`/**\n * @param {any} value\n * @param {Function} fn\n * @returns any\n */\nexport default function deepMap(value, fn) {\n  return mapHelper(value, fn, value);\n}\n\nfunction isPlainObject(value) {\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\nfunction mapHelper(element, fn, original) {\n  // Handle arrays.\n  if (Array.isArray(element)) {\n    return element.map((item) => mapHelper(item, fn, original));\n  }\n\n  // Handle plain objects.\n  if (isPlainObject(element)) {\n    return Object.fromEntries(\n      Object.entries(element).map(([key, value]) => [\n        key,\n        mapHelper(value, fn, original),\n      ]),\n    );\n  }\n\n  // Handle other types.\n  return fn.call(original, element);\n}\n`;var u=`export default function deepMap(value: unknown, fn: Function): unknown {\n  return mapHelper(value, fn, value);\n}\n\nfunction isPlainObject(value: unknown): boolean {\n  if (value == null) {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(value);\n  return prototype === null || prototype === Object.prototype;\n}\n\nfunction mapHelper(element: unknown, fn: Function, original: unknown): unknown {\n  // Handle arrays.\n  if (Array.isArray(element)) {\n    return element.map((item) => mapHelper(item, fn, original));\n  }\n\n  // Handle plain objects.\n  if (isPlainObject(element)) {\n    return Object.fromEntries(\n      Object.entries(element as Object).map(([key, value]) => [\n        key,\n        mapHelper(value, fn, original),\n      ]),\n    );\n  }\n\n  // Handle other types.\n  return fn.call(original, element);\n}\n`;function p(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",p:\"p\",ol:\"ol\",strong:\"strong\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Should we recurse into \",(0,n.jsx)(e.code,{children:\"Map\"}),\"s and \",(0,n.jsx)(e.code,{children:\"Set\"}),\"s?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"To keep the question simple, no. There are no tests cases containing \",(0,n.jsx)(e.code,{children:\"Map\"}),\"s and \",(0,n.jsx)(e.code,{children:\"Set\"}),\"s but you are free to add support if you wish.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"What should the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" be within the callback function?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The input \",(0,n.jsx)(e.code,{children:\"value\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since the input \",(0,n.jsx)(e.code,{children:\"value\"}),\" can be a deeply nested structure, a recursive solution will be handy for traversing the nested values. The idea is to recursively visit all elements in \",(0,n.jsx)(e.code,{children:\"value\"}),\" and transforming each element using the \",(0,n.jsx)(e.code,{children:\"fn\"}),\" function except if the element is an \",(0,n.jsx)(e.code,{children:\"Array\"}),\" or an \",(0,n.jsx)(e.code,{children:\"Object\"}),\", recursion needs to take place instead.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Since arrays and objects need special handling, there are three categories of values we need to handle:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Arrays\"}),\": Use \",(0,n.jsx)(e.code,{children:\"Array.isArray()\"}),\" to check for this type. Iterate through the array and return a new array of each mapped element. However, we shouldn't directly call \",(0,n.jsx)(e.code,{children:\"fn\"}),\" on array elements, instead we should recurse into each element. This is because array elements can be non-primitives as well and more recursing can be required.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Objects\"}),\": A helper function \",(0,n.jsx)(e.code,{children:\"isPlainObject()\"}),\" (from \",(0,n.jsx)(e.a,{href:\"/questions/javascript/type-utilities-ii\",children:\"Type Utilities II\"}),\") is used to check for plain object types. Doing \",(0,n.jsx)(e.code,{children:\"typeof element === 'object' && element !== null\"}),\" won't work because there are other value types like \",(0,n.jsx)(e.code,{children:\"Date\"}),\" and \",(0,n.jsx)(e.code,{children:\"Set\"}),\" that will pass the check. Iterate through the entries of the object and recurse into each object value, similar to array elements.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Primitives\"}),\": This is the base case for the recursion and we can return the value after mapping it with \",(0,n.jsx)(e.code,{children:\"fn\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The next tricky part of the question is to provide the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" for the \",(0,n.jsx)(e.code,{children:\"fn\"}),\" via \",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\"/\",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\". In \",(0,n.jsx)(e.code,{children:\"Array.prototype.map()\"}),\", the \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" value can be provided as a second argument to the \",(0,n.jsx)(e.code,{children:\".map()\"}),\" function and the callback function will be invoked with \",(0,n.jsx)(e.code,{children:\"thisArg\"}),\" as the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value. In our case, the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value within callbacks is not explicitly specified but a reasonable assumption is to use the \",(0,n.jsx)(e.code,{children:\"value\"}),\" input as \",(0,n.jsx)(e.code,{children:\"this\"}),\". We need to pass the original \",(0,n.jsx)(e.code,{children:\"value\"}),\" object across recursion calls, hence we create a \",(0,n.jsx)(e.code,{children:\"mapHelper()\"}),\" helper function that takes in an extra parameter \",(0,n.jsx)(e.code,{children:\"original\"}),\", so that all recursive calls have access to both the current element and the \",(0,n.jsx)(e.code,{children:\"original\"}),\" value.\"]}),`\n`,(0,n.jsx)(d,{languages:{jsx:h,tsx:u}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Accessing \",(0,n.jsx)(e.code,{children:\"this\"}),\" within the callback function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Values with \",(0,n.jsx)(e.code,{children:\"null\"}),\", \",(0,n.jsx)(e.code,{children:\"Date\"}),\", \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\", etc.\"]}),`\n`]})]})}function H(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var A=H;return k(M);})();\n;return Component;",
  "workspace": {
    "main": "/src/deep-map.ts",
    "run": "/src/deep-map.run.test.ts",
    "submit": "/src/deep-map.submit.test.ts"
  }
}