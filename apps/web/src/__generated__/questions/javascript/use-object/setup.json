{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-object\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-object.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/use-object.run.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useObject from './use-object';\n\ndescribe('useObject', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useObject({}));\n\n    expect(Array.isArray(result.current)).toBe(true);\n    expect(result.current).toHaveLength(2);\n    expect(typeof result.current[0]).toBe('object');\n    expect(typeof result.current[1]).toBe('function');\n  });\n\n  test('initial value', () => {\n    const initialValue = { foo: 'bar' };\n    const { result } = renderHook(() => useObject(initialValue));\n\n    expect(result.current[0]).toEqual(initialValue);\n  });\n\n  test('update object', () => {\n    const { result } = renderHook(() => useObject({}));\n\n    act(() => result.current[1]({ foo: 'bar' }));\n\n    expect(result.current[0]).toEqual({ foo: 'bar' });\n  });\n\n  test('update object with updater function', () => {\n    const { result } = renderHook(() => useObject({}));\n\n    act(() => result.current[1]((prev) => ({ ...prev, foo: 'bar' })));\n\n    expect(result.current[0]).toEqual({ foo: 'bar' });\n  });\n});\n",
    "/src/use-object.submit.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useObject from './use-object';\n\ndescribe('useObject', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useObject({}));\n\n    expect(Array.isArray(result.current)).toBe(true);\n    expect(result.current).toHaveLength(2);\n    expect(typeof result.current[0]).toBe('object');\n    expect(typeof result.current[1]).toBe('function');\n  });\n\n  test('initial value', () => {\n    const initialValue = { foo: 'bar' };\n    const { result } = renderHook(() => useObject(initialValue));\n\n    expect(result.current[0]).toEqual(initialValue);\n  });\n\n  test('update object', () => {\n    const { result } = renderHook(() => useObject({}));\n\n    act(() => result.current[1]({ foo: 'bar' }));\n\n    expect(result.current[0]).toEqual({ foo: 'bar' });\n  });\n\n  test('update object with updater function', () => {\n    const { result } = renderHook(() => useObject({}));\n\n    act(() => result.current[1]((prev) => ({ ...prev, foo: 'bar' })));\n\n    expect(result.current[0]).toEqual({ foo: 'bar' });\n  });\n\n  test('merge object', () => {\n    const { result } = renderHook(() =>\n      useObject<Record<string, string>>({ bar: 'foo' }),\n    );\n\n    act(() => result.current[1]({ foo: 'bar' }));\n\n    expect(result.current[0]).toEqual({ bar: 'foo', foo: 'bar' });\n  });\n\n  test('merge object with updater function', () => {\n    const { result } = renderHook(() =>\n      useObject<Record<string, string>>({ bar: 'foo' }),\n    );\n\n    act(() => result.current[1](() => ({ foo: 'bar' })));\n\n    expect(result.current[0]).toEqual({ bar: 'foo', foo: 'bar' });\n  });\n});\n",
    "/src/use-object.ts": "import { useCallback, useState } from 'react';\n\nfunction isPlainObject(value: unknown) {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\ntype UseObjectUpdater<T extends Record<string | number | symbol, any>> = (\n  partialOrUpdaterFunction: Partial<T> | ((prev: T) => Partial<T>),\n) => void;\n\nexport default function useObject<\n  T extends Record<string | number | symbol, any>,\n>(initialValue: T): [T, UseObjectUpdater<T>] {\n  const [state, setState] = useState(initialValue);\n\n  const merge: UseObjectUpdater<T> = useCallback((partialOrUpdaterFunction) => {\n    if (partialOrUpdaterFunction instanceof Function)\n      return setState((previousState) => {\n        const newState = partialOrUpdaterFunction(previousState);\n        if (!isPlainObject(newState)) {\n          throw new Error('Invalid new state');\n        }\n\n        return { ...previousState, ...newState };\n      });\n\n    if (!isPlainObject(partialOrUpdaterFunction)) {\n      throw new Error('Invalid new state');\n    }\n\n    setState((previousState) => ({\n      ...previousState,\n      ...partialOrUpdaterFunction,\n    }));\n  }, []);\n\n  return [state, merge];\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {T} initialValue\n */\nexport default function useObject(initialValue) {\n  throw 'Not implemented';\n}",
    "ts": "type UseObjectUpdater<T extends Record<string | number | symbol, any>> = (\n  partialOrUpdaterFunction: Partial<T> | ((prev: T) => Partial<T>),\n) => void;\n\nexport default function useObject<\n  T extends Record<string | number | symbol, any>,\n>(initialValue: T): [T, UseObjectUpdater<T>] {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/use-object.ts",
    "run": "/src/use-object.run.test.ts",
    "submit": "/src/use-object.submit.test.ts"
  }
}