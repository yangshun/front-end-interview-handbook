{
  "description": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var o in e)i(t,o,{get:e[o],enumerable:!0})},a=(t,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of d(e))!f.call(t,s)&&s!==o&&i(t,s,{get:()=>e[s],enumerable:!(r=h(e,s))||r.enumerable});return t};var j=(t,e,o)=>(o=t!=null?u(p(t)):{},a(e||!t||!t.__esModule?i(o,\"default\",{value:t,enumerable:!0}):o,t)),x=t=>a(i({},\"__esModule\",{value:!0}),t);var m=w((P,c)=>{c.exports=_jsx_runtime});var b={};g(b,{default:()=>_,frontmatter:()=>v});var n=j(m()),v={title:\"Promise Timeout\",excerpt:\"Implement a function that resolves a promise if it is fulfilled within a timeout period and rejects otherwise\"};function l(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"When fetching data or performing other async operations, it is sometimes useful to set a timeout duration, i.e. enforce that a response is received before the timeout, otherwise deem the request a failed one.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"promiseTimeout\"}),\" function that accepts a promise and a timeout duration (in milliseconds) and returns a \",(0,n.jsx)(e.code,{children:\"Promise\"}),`. If the promise argument is settled within the timeout period, the returned promise is settled with the promise argument's settled value, which can be both resolved/rejected values. Otherwise, the returned promise will reject with the string \"Promise timeout\".`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function fakeFetch(latency) {\n  return new Promise((resolve, reject) => {\n    // Simulate an asynchronous operation that resolves after \\`latency\\`.\n    setTimeout(() => {\n      resolve('Data successfully fetched!');\n    }, latency);\n  });\n}\n\nconst response = await promiseTimeout(fakeFetch(1000), 2000);\nconsole.log(response); // Data successfully fetched!\n\nawait promiseTimeout(fakeFetch(5000), 2000);\n// \"Promise timeout\" thrown.\n`})})]})}function y(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(l,t)})):l(t)}var _=y;return x(b);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-timeout\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-timeout.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promise-timeout.run.test.ts": "import promiseTimeout from './promise-timeout';\n\ndescribe('promiseTimeout', () => {\n  test('returns a promise', () => {\n    const promise = promiseTimeout(Promise.resolve(1), 100);\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  test('resolves before timeout', async () => {\n    const promise = promiseTimeout(\n      new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(42);\n        }, 50);\n      }),\n      100,\n    );\n    await expect(promise).resolves.toBe(42);\n  });\n\n  test('timeout', async () => {\n    const promise = promiseTimeout(\n      new Promise((resolve) => {\n        setTimeout(() => {\n          resolve(42);\n        }, 200);\n      }),\n      100,\n    );\n    await expect(promise).rejects.toBe('Promise timeout');\n  });\n});\n",
    "/src/promise-timeout.submit.test.ts": "import promiseTimeout from './promise-timeout';\n\ndescribe('promiseTimeout', () => {\n  test('returns a promise', () => {\n    const promise = promiseTimeout(Promise.resolve(1), 100);\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  describe('settled', () => {\n    describe('resolved', () => {\n      test('immediately', async () => {\n        const promise = promiseTimeout(Promise.resolve(42), 100);\n        await expect(promise).resolves.toBe(42);\n      });\n\n      test('next tick', async () => {\n        const promise = promiseTimeout(\n          new Promise((resolve) => {\n            setTimeout(() => {\n              resolve(42);\n            }, 0);\n          }),\n          100,\n        );\n        await expect(promise).resolves.toBe(42);\n      });\n\n      test('before timeout', async () => {\n        const promise = promiseTimeout(\n          new Promise((resolve) => {\n            setTimeout(() => {\n              resolve(42);\n            }, 50);\n          }),\n          100,\n        );\n        await expect(promise).resolves.toBe(42);\n      });\n    });\n\n    describe('rejected', () => {\n      test('immediately', async () => {\n        const promise = promiseTimeout(Promise.reject(42), 100);\n        await expect(promise).rejects.toBe(42);\n      });\n\n      test('next tick', async () => {\n        const promise = promiseTimeout(\n          new Promise((_, reject) => {\n            setTimeout(() => {\n              reject(42);\n            }, 0);\n          }),\n          100,\n        );\n        await expect(promise).rejects.toBe(42);\n      });\n\n      test('before timeout', async () => {\n        const promise = promiseTimeout(\n          new Promise((_, reject) => {\n            setTimeout(() => {\n              reject(42);\n            }, 50);\n          }),\n          100,\n        );\n        await expect(promise).rejects.toBe(42);\n      });\n    });\n  });\n\n  describe('timeout', () => {\n    test('immediate', async () => {\n      const promise = promiseTimeout(\n        new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(42);\n          }, 500);\n        }),\n        0,\n      );\n\n      await expect(promise).rejects.toBe('Promise timeout');\n    });\n\n    test('all immediate', async () => {\n      const promise = promiseTimeout(\n        new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(42);\n          }, 0);\n        }),\n        0,\n      );\n      await expect(promise).resolves.toBe(42);\n    });\n\n    test('non-immediate', async () => {\n      const promise = promiseTimeout(\n        new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(42);\n          }, 200);\n        }),\n        100,\n      );\n      await expect(promise).rejects.toBe('Promise timeout');\n    });\n  });\n});\n",
    "/src/promise-timeout.ts": "export default function promiseTimeout<T>(\n  promise: Promise<T>,\n  duration: number,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject('Promise timeout');\n    }, duration);\n\n    promise\n      .then(resolve)\n      .catch(reject)\n      .finally(() => {\n        clearTimeout(timeoutId);\n      });\n  });\n}\n"
  },
  "info": {
    "excerpt": "Implement a function that resolves a promise if it is fulfilled within a timeout period and rejects otherwise",
    "title": "Promise Timeout"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1689552000,
    "difficulty": "medium",
    "duration": 15,
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promise-timeout",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "promise-timeout",
    "subtitle": null,
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {Promise<T>} promise\n * @param {number} duration\n * @return {Promise<T>}\n */\nexport default function promiseTimeout(promise, duration) {\n  throw 'Not implemented';\n}",
    "ts": "export default function promiseTimeout<T>(\n  promise: Promise<T>,\n  duration: number,\n): Promise<T> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var T=Object.create;var n=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var P=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=>{for(var r in e)n(i,r,{get:e[r],enumerable:!0})},m=(i,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of P(e))!g.call(i,o)&&o!==r&&n(i,o,{get:()=>e[o],enumerable:!(c=j(e,o))||c.enumerable});return i};var v=(i,e,r)=>(r=i!=null?T(w(i)):{},m(e||!i||!i.__esModule?n(r,\"default\",{value:i,enumerable:!0}):r,i)),y=i=>m(n({},\"__esModule\",{value:!0}),i);var l=x((B,d)=>{d.exports=_jsx_runtime});var W={};b(W,{default:()=>D});var t=v(l());var s=MDXCodeBlock;var u=`/**\n * @template T\n * @param {Promise<T>} promise\n * @param {number} duration\n * @return {Promise<T>}\n */\nexport default function promiseTimeout(promise, duration) {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject('Promise timeout');\n    }, duration);\n\n    promise\n      .then(resolve)\n      .catch(reject)\n      .finally(() => {\n        clearTimeout(timeoutId);\n      });\n  });\n}\n`;var a=`export default function promiseTimeout<T>(\n  promise: Promise<T>,\n  duration: number,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const timeoutId = setTimeout(() => {\n      reject('Promise timeout');\n    }, duration);\n\n    promise\n      .then(resolve)\n      .catch(reject)\n      .finally(() => {\n        clearTimeout(timeoutId);\n      });\n  });\n}\n`;var h=`/**\n * @template T\n * @param {Promise<T>} promise\n * @param {number} duration\n * @return {Promise<T>}\n */\nexport default function promiseTimeout(promise, duration) {\n  const timeout = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject('Promise timeout');\n    }, duration);\n  });\n\n  return Promise.race([promise, timeout]);\n}\n`;var p=`export default function promiseTimeout<T>(\n  promise: Promise<T>,\n  duration: number,\n): Promise<T> {\n  const timeout = new Promise((_, reject) => {\n    setTimeout(() => {\n      reject('Promise timeout');\n    }, duration);\n  });\n\n  return Promise.race([promise, timeout]) as Promise<T>;\n}\n`;function f(i){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",code:\"code\",h3:\"h3\",p:\"p\",ul:\"ul\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The \",(0,t.jsx)(e.code,{children:\"promiseTimeout\"}),\" function takes two parameters: the original \",(0,t.jsx)(e.code,{children:\"promise\"}),\" and the timeout \",(0,t.jsx)(e.code,{children:\"duration\"}),\" in milliseconds.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Inside the function, create and return a new \",(0,t.jsx)(e.code,{children:\"Promise\"}),\" which will \",(0,t.jsx)(e.code,{children:\"reject()\"}),\" with a custom error after the specified \",(0,t.jsx)(e.code,{children:\"duration\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the \",(0,t.jsx)(e.code,{children:\"promise\"}),\" argument is fulfilled before \",(0,t.jsx)(e.code,{children:\"duration\"}),\" is up, we can \",(0,t.jsx)(e.code,{children:\"resolve()\"}),\" the promise with the fulfilled value. If it is rejected, we can \",(0,t.jsx)(e.code,{children:\"reject()\"}),\" with the rejected reason.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"We use \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\" to set up the timeout mechanism. When the timeout is reached, the returned promise will \",(0,t.jsx)(e.code,{children:\"reject()\"}),\" with the custom error message.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the promise is settled before the timeout, we should clear the timer. We can keep a reference the id returned from \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\", and in the \",(0,t.jsx)(e.code,{children:\".finally()\"}),\" method, clear the timeout using \",(0,t.jsx)(e.code,{children:\"clearTimeout\"}),\" so that the \",(0,t.jsx)(e.code,{children:\"reject()\"}),\" within the timeout is not unnecessarily called.\"]}),`\n`]}),`\n`,(0,t.jsx)(s,{languages:{jsx:u,tsx:a}}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Using \",(0,t.jsx)(e.code,{children:\"Promise.race()\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\" is also an async operation and hence be wrapped in a \",(0,t.jsx)(e.code,{children:\"Promise\"}),\". We can simplify the execution logic by using \",(0,t.jsx)(e.code,{children:\"Promise.race()\"}),\"; whichever promise that is settled first will determine the outcome of the returned \",(0,t.jsx)(e.code,{children:\"Promise\"}),\".\"]}),`\n`,(0,t.jsx)(s,{languages:{jsx:h,tsx:p}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If the \",(0,t.jsx)(e.code,{children:\"promise\"}),\" argument resolves immediately, the overall result should be resolved regardless of the timeout duration, even if it is 0.\"]}),`\n`]})]})}function C(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(f,i)})):f(i)}var D=C;return y(W);})();\n;return Component;",
  "workspace": {
    "main": "/src/promise-timeout.ts",
    "run": "/src/promise-timeout.run.test.ts",
    "submit": "/src/promise-timeout.submit.test.ts"
  }
}