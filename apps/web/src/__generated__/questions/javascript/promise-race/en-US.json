{
  "description": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var j=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),v=(r,e)=>{for(var o in e)s(r,o,{get:e[o],enumerable:!0})},i=(r,e,o,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!f.call(r,t)&&t!==o&&s(r,t,{get:()=>e[t],enumerable:!(c=h(e,t))||c.enumerable});return r};var b=(r,e,o)=>(o=r!=null?d(u(r)):{},i(e||!r||!r.__esModule?s(o,\"default\",{value:r,enumerable:!0}):o,r)),g=r=>i(s({},\"__esModule\",{value:!0}),r);var l=j((k,a)=>{a.exports=_jsx_runtime});var y={};v(y,{default:()=>x,frontmatter:()=>w});var n=b(l()),w={title:\"Promise.race\",excerpt:\"Implement the Promise.race() function that resolves or rejects when any of the input elements are resolved or rejected\"};function m(r){let e=Object.assign({blockquote:\"blockquote\",p:\"p\",code:\"code\",em:\"em\",a:\"a\",h2:\"h2\",pre:\"pre\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Promise.race()\"}),\" method returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects, with the value or reason from that promise.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"If the iterable passed is empty, the promise returned will be forever pending.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"If the iterable contains one or more non-promise value and/or an already settled promise, then \",(0,n.jsx)(e.code,{children:\"Promise.race()\"}),\" will resolve to the first of these values found in the iterable.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"Source: \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\",children:\"Promise.race() - JavaScript | MDN\"})]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's implement our own version of \",(0,n.jsx)(e.code,{children:\"Promise.race()\"}),\", a \",(0,n.jsx)(e.code,{children:\"promiseRace\"}),\" function, with the difference being the function takes in an array instead of an iterable. Be sure to read the description carefully and implement accordingly!\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const p0 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve(42);\n  }, 100);\n});\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('Err!');\n  }, 400);\n});\n\nawait promiseRace([p0, p1]); // 42\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const p0 = Promise.resolve(42);\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(21);\n  }, 100);\n});\n\nawait promiseRace([p0, p1]); // 42\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const p0 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve(42);\n  }, 400);\n});\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('Err!');\n  }, 100);\n});\n\ntry {\n  await promiseRace([p0, p1]);\n} catch (err) {\n  console.log(err); // 'Err!'\n}\n`})})]})}function P(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(m,r)})):m(r)}var x=P;return g(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-race\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-race.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/promise-race.run.test.ts": "import promiseRace from './promise-race';\n\ndescribe('promiseRace', () => {\n  test('returns a promise', () => {\n    const promise = promiseRace([]);\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  test('empty input array', (done) => {\n    expect.assertions(1);\n    const promise = promiseRace([]);\n    expect(promise).toBeInstanceOf(Promise);\n    promise.then(\n      (value) => {\n        expect(value).toBeTruthy();\n      },\n      (reason) => {\n        expect(reason).toBeTruthy();\n      },\n    );\n\n    setTimeout(() => {\n      done();\n    }, 10);\n  });\n\n  test('one promise', async () => {\n    expect.assertions(1);\n    const p0 = 2;\n\n    const res = await promiseRace([p0]);\n    expect(res).toEqual(2);\n  });\n\n  test('mix of resolve and reject', async () => {\n    expect.assertions(1);\n    const p0 = Promise.resolve(42);\n    const p1 = new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(2);\n      }, 10);\n    });\n\n    const res = await promiseRace([p0, p1]);\n    expect(res).toEqual(42);\n  });\n});\n",
    "/src/promise-race.submit.test.ts": "import promiseRace from './promise-race';\n\ndescribe('promiseRace', () => {\n  test('returns a promise', () => {\n    const promise = promiseRace([]);\n    expect(promise).toBeInstanceOf(Promise);\n  });\n\n  test('empty input array', (done) => {\n    expect.assertions(1);\n    const promise = promiseRace([]);\n    expect(promise).toBeInstanceOf(Promise);\n    promise.then(\n      (value) => {\n        expect(value).toBeTruthy();\n      },\n      (reason) => {\n        expect(reason).toBeTruthy();\n      },\n    );\n\n    setTimeout(() => {\n      done();\n    }, 10);\n  });\n\n  describe('one promise', () => {\n    describe('resolve', () => {\n      test('value', async () => {\n        expect.assertions(1);\n        const p0 = 2;\n\n        const res = await promiseRace([p0]);\n        expect(res).toEqual(2);\n      });\n\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n\n        const res = await promiseRace([p0]);\n        expect(res).toEqual(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 10);\n        });\n\n        const res = await promiseRace([p0]);\n        expect(res).toEqual(2);\n      });\n    });\n\n    describe('reject', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(2);\n\n        await expect(promiseRace([p0])).rejects.toBe(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseRace([p0])).rejects.toBe(2);\n      });\n    });\n  });\n\n  describe('multiple promises', () => {\n    describe('all resolve', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n        const p1 = Promise.resolve(3);\n\n        const res = await promiseRace([p0, p1]);\n        expect(res).toEqual(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 10);\n        });\n\n        const res = await promiseRace([p0, p1]);\n        expect(res).toEqual(2);\n      });\n\n      test('mixture', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 10);\n        });\n        const p1 = Promise.resolve(3);\n        const p2 = 4;\n\n        const res = await promiseRace([p0, p1, p2]);\n        expect(res).toEqual(3);\n      });\n\n      test('many delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(1);\n          }, 200);\n        });\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 100);\n        });\n        const p2 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 10);\n        });\n\n        const res = await promiseRace([p0, p1, p2]);\n        expect(res).toEqual(3);\n      });\n    });\n\n    describe('all reject', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(2);\n        const p1 = Promise.reject(3);\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(3);\n          }, 1);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(3);\n      });\n\n      test('mixture', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(42);\n      });\n    });\n\n    describe('mix of resolve and reject', () => {\n      test('instant resolve delayed reject', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(42);\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        const res = await promiseRace([p0, p1]);\n        expect(res).toEqual(42);\n      });\n\n      test('instant resolve instant reject', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(42);\n        const p1 = Promise.reject(2);\n\n        const res = await promiseRace([p0, p1]);\n        expect(res).toEqual(42);\n      });\n\n      test('instant reject instant resolve', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = Promise.resolve(2);\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(42);\n      });\n\n      test('instant rejects', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = Promise.reject(43);\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(42);\n      });\n\n      test('delayed resolve', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(1);\n          }, 10);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 100);\n        });\n        const p2 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 200);\n        });\n\n        await expect(promiseRace([p0, p1, p2])).resolves.toBe(1);\n      });\n\n      test('delayed reject', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(1);\n          }, 200);\n        });\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 100);\n        });\n        const p2 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(3);\n          }, 10);\n        });\n\n        await expect(promiseRace([p0, p1, p2])).rejects.toBe(3);\n      });\n\n      test('delayed throw', async () => {\n        expect.assertions(1);\n        const p0 = new Promise(() => {\n          throw 42;\n        });\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 100);\n        });\n\n        await expect(promiseRace([p0, p1])).rejects.toBe(42);\n      });\n    });\n  });\n});\n",
    "/src/promise-race.ts": "export default function promiseRace<T extends readonly unknown[] | []>(\n  iterable: T,\n): Promise<Awaited<T[number]>> {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      return;\n    }\n\n    iterable.forEach(async (item) => {\n      try {\n        const result = await item;\n        resolve(result as Awaited<T[number]>);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n}\n"
  },
  "format": "javascript",
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [
      "google"
    ],
    "created": 1655596800,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement the Promise.race() function that resolves or rejects when any of the input elements are resolved or rejected",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promise-race",
    "importance": "medium",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "promise-all",
      "promise-all-settled",
      "promise-any"
    ],
    "slug": "promise-race",
    "subtitle": null,
    "title": "Promise.race",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseRace(iterable) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function promiseRace<T extends readonly unknown[] | []>(\n  iterable: T,\n): Promise<Awaited<T[number]>> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var P=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var i in e)o(n,i,{get:e[i],enumerable:!0})},d=(n,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of v(e))!y.call(n,t)&&t!==i&&o(n,t,{get:()=>e[t],enumerable:!(l=w(e,t))||l.enumerable});return n};var j=(n,e,i)=>(i=n!=null?f(b(n)):{},d(e||!n||!n.__esModule?o(i,\"default\",{value:n,enumerable:!0}):i,n)),x=n=>d(o({},\"__esModule\",{value:!0}),n);var h=P((I,a)=>{a.exports=_jsx_runtime});var _={};g(_,{default:()=>S});var r=j(h());var c=MDXCodeBlock;var s=`/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseRace(iterable) {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      return;\n    }\n\n    iterable.forEach(async (item) => {\n      try {\n        const result = await item;\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n}\n`;var m=`export default function promiseRace<T extends readonly unknown[] | []>(\n  iterable: T,\n): Promise<Awaited<T[number]>> {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      return;\n    }\n\n    iterable.forEach(async (item) => {\n      try {\n        const result = await item;\n        resolve(result as Awaited<T[number]>);\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n}\n`;var u=`/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseRace(iterable) {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      return;\n    }\n\n    iterable.forEach((item) => Promise.resolve(item).then(resolve, reject));\n  });\n}\n`;function p(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",h3:\"h3\",ul:\"ul\",pre:\"pre\",a:\"a\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"Async programming is frequently tested during interviews. Understanding how \",(0,r.jsx)(e.code,{children:\"Promise.race\"}),\" works under the hood will help you in understanding the mechanisms behind similar \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"-related functions like \",(0,r.jsx)(e.code,{children:\"Promise.any\"}),\", \",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\", \",(0,r.jsx)(e.code,{children:\"Promise.allSettled\"}),\" etc.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsx)(e.p,{children:\"There are a few aspects to this question we need to bear in mind and handle:\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"Promise\"}),\"s are meant to be chained, so the function needs to return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the input array is empty, the returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" will be forever pending.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s.\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Solution 1: Using \",(0,r.jsx)(e.code,{children:\"await\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We'll return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" at the top level of the function. First check if the input array is empty, if so we need to return a forever-pending promise. That can be done by \",(0,r.jsx)(e.code,{children:\"return\"}),\"-ing without calling \",(0,r.jsx)(e.code,{children:\"resolve()\"}),\" or \",(0,r.jsx)(e.code,{children:\"reject()\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We then need to attempt resolving every item in the input array. This can be achieved using \",(0,r.jsx)(e.code,{children:\"Array.prototype.forEach\"}),\" or \",(0,r.jsx)(e.code,{children:\"Array.prototype.map\"}),\".\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If an item is resolved, \",(0,r.jsx)(e.code,{children:\"resolve()\"}),\" with the result.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If an item is rejected, \",(0,r.jsx)(e.code,{children:\"reject()\"}),\" with the reason.\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Since it's a race, we don't have to do much coordination unlike in \",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\". Whichever item resolves/rejects first wins the race and calls the \",(0,r.jsx)(e.code,{children:\"resolve\"}),\"/\",(0,r.jsx)(e.code,{children:\"reject\"}),\" function respectively to determine the final state and value/reason of the returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"One thing to note here is that because the input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, if we are not \",(0,r.jsx)(e.code,{children:\"await\"}),\"-ing them, we need to wrap each value with \",(0,r.jsx)(e.code,{children:\"Promise.resolve()\"}),\" which allows us to use \",(0,r.jsx)(e.code,{children:\".then()\"}),\" on each of them so we don't have to differentiate between \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" vs non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values and whether they need to be resolved.\"]}),`\n`,(0,r.jsx)(c,{languages:{jsx:s,tsx:m}}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Solution 2: Using \",(0,r.jsx)(e.code,{children:\"Promise.then()\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Here's an alternative version which uses \",(0,r.jsx)(e.code,{children:\"Promise.then()\"}),\" if you prefer not to use \",(0,r.jsx)(e.code,{children:\"async\"}),\"/\",(0,r.jsx)(e.code,{children:\"await\"}),\", which is much shorter.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Note that rejected promises also call \",(0,r.jsx)(e.code,{children:\".then()\"}),\" and the second parameter of \",(0,r.jsx)(e.code,{children:\".then()\"}),\" is the callback to handle rejected promises.\"]}),`\n`,(0,r.jsx)(c,{children:u}),`\n`,(0,r.jsxs)(e.p,{children:[\"It's important to \",(0,r.jsx)(e.code,{children:\"reject()\"}),\" rejected promises in the \",(0,r.jsx)(e.code,{children:\".then()\"}),\" call (via the second callback parameter) and not within \",(0,r.jsx)(e.code,{children:\"catch()\"}),\". The approach below looks similar but doesn't work for cases where the \",(0,r.jsx)(e.code,{children:\"iterable\"}),\" contains both immediately resolved and rejected promises (e.g. \",(0,r.jsx)(e.code,{children:\"[Promise.reject(42), Promise.resolve(2)]\"}),\").\"]}),`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:\".catch()\"}),\" is scheduled, and does not run immediately after \",(0,r.jsx)(e.code,{children:\".then()\"}),\". For immediately settled promises, \",(0,r.jsx)(e.code,{children:\"then()\"}),\" run before any \",(0,r.jsx)(e.code,{children:\".catch()\"}),\", hence the overall \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" is fulfilled with 2 instead of rejected with 42.\"]}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`export default function promiseRace(iterable) {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      return;\n    }\n\n    iterable.forEach((item) =>\n      // Incorrect to use \\`catch()\\`, use onReject in \\`then()\\`.\n      Promise.resolve(item).then(resolve).catch(reject),\n    );\n  });\n}\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Empty input array. A forever-pending promise should be returned.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the array contains non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, \",(0,r.jsx)(e.code,{children:\"Promise.race()\"}),\" will resolve to the first of these values found in the iterable.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Knowledge of \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s, how to construct one, how to use them.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Async programming.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race\",children:\"Promise.race() - JavaScript | MDN\"})}),`\n`]})]})}function A(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(p,n)})):p(n)}var S=A;return x(_);})();\n;return Component;",
  "workspace": {
    "main": "/src/promise-race.ts",
    "run": "/src/promise-race.run.test.ts",
    "submit": "/src/promise-race.submit.test.ts"
  }
}