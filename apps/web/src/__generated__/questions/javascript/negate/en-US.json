{
  "description": "var Component=(()=>{var l=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var c in e)r(t,c,{get:e[c],enumerable:!0})},d=(t,e,c,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!g.call(t,i)&&i!==c&&r(t,i,{get:()=>e[i],enumerable:!(a=u(e,i))||a.enumerable});return t};var j=(t,e,c)=>(c=t!=null?l(p(t)):{},d(e||!t||!t.__esModule?r(c,\"default\",{value:t,enumerable:!0}):c,t)),_=t=>d(r({},\"__esModule\",{value:!0}),t);var h=f((N,o)=>{o.exports=_jsx_runtime});var w={};x(w,{default:()=>b,frontmatter:()=>O});var n=j(h()),O={title:\"Negate\",excerpt:\"Implement a function that creates a function that negates the result of the predicate function\"};function s(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",ul:\"ul\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"negate(predicate)\"}),\" that creates a function that negates the result of the predicate function. The predicate is invoked with the \",(0,n.jsx)(e.code,{children:\"this\"}),\" binding and arguments of the created function.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`negate(predicate);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"predicate\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The predicate to negate.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:(0,n.jsx)(e.code,{children:\"(Function)\"})}),\": Returns the new negated function.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const isOdd = negate(isEven);\nisOdd(1); // => true\nisOdd(2); // => false\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#negate\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.negate\"})]})}),`\n`]})]})}function F(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(s,t)})):s(t)}var b=F;return _(w);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function that creates a function that negates the result of the predicate function",
    "title": "Negate"
  },
  "solution": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var j=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),_=(n,e)=>{for(var r in e)o(n,r,{get:e[r],enumerable:!0})},s=(n,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!w.call(n,i)&&i!==r&&o(n,i,{get:()=>e[i],enumerable:!(c=x(e,i))||c.enumerable});return n};var T=(n,e,r)=>(r=n!=null?m(b(n)):{},s(e||!n||!n.__esModule?o(r,\"default\",{value:n,enumerable:!0}):r,n)),F=n=>s(o({},\"__esModule\",{value:!0}),n);var h=j((X,d)=>{d.exports=_jsx_runtime});var P={};_(P,{default:()=>D});var t=T(h());var a=MDXCodeBlock;var l=`/**\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n */\nexport default function negate(predicate) {\n  return function (...args) {\n    return !predicate.apply(this, args);\n  };\n}\n`;var u=`export default function negate<P extends any[], R>(\n  predicate: (this: any, ...args: P) => R,\n): (...args: P) => boolean {\n  return function (this: any, ...args: P): boolean {\n    return !predicate.apply(this, args);\n  };\n}\n`;var p=`export default function negate(predicate) {\n  return function () {\n    return !predicate.apply(this, arguments);\n  };\n}\n`;var g=`export default function negate(predicate: Function): Function {\n  return function (this: any): boolean {\n    return !predicate.apply(this, arguments);\n  };\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",h3:\"h3\",code:\"code\",ol:\"ol\",li:\"li\",p:\"p\",ul:\"ul\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 1: Uses \",(0,t.jsx)(e.code,{children:\"...args\"}),\" to allow for unknown number of parameters\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The \",(0,t.jsx)(e.code,{children:\"predicate.apply(this, args)\"}),\" part is where the original \",(0,t.jsx)(e.code,{children:\"predicate\"}),\" function is invoked.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The \",(0,t.jsx)(e.code,{children:\"apply\"}),\" method is used to call the \",(0,t.jsx)(e.code,{children:\"predicate\"}),\" with a specific \",(0,t.jsx)(e.code,{children:\"this\"}),\" context and an array of arguments. In this case, \",(0,t.jsx)(e.code,{children:\"this\"}),\" refers to the \",(0,t.jsx)(e.code,{children:\"this\"}),\" context of the anonymous function at the time it is called, and \",(0,t.jsx)(e.code,{children:\"args\"}),\" is an array of the arguments passed to the anonymous function. This ensures that the predicate function is executed in the correct context and with the same arguments that were passed to the negated function. Additionally, due to the need of using the right \",(0,t.jsx)(e.code,{children:\"this\"}),\" context, the outermost function should not be declared using arrow functions.\"]}),`\n`]}),`\n`,(0,t.jsx)(a,{languages:{jsx:l,tsx:u}}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 2: Uses \",(0,t.jsx)(e.code,{children:\"arguments\"}),\" as the arguments passed into the negated predicate\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Uses \",(0,t.jsx)(e.code,{children:\"arguments\"}),\" to pass all received arguments to the predicate, offering flexibility in handling an indefinite number of parameters without explicitly listing them, suitable for functions where parameter types and numbers are variable or unknown.\"]}),`\n`,(0,t.jsx)(a,{languages:{jsx:p,tsx:g}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"When using \",(0,t.jsx)(e.code,{children:\"negate\"}),\" with \",(0,t.jsx)(e.code,{children:\"predicate\"}),\" functions that depend on their \",(0,t.jsx)(e.code,{children:\"this\"}),\" context, such as object methods, unexpected behavior may occur due to context loss. To preserve context, we can bind the \",(0,t.jsx)(e.code,{children:\"predicate\"}),\" to its original context using \",(0,t.jsx)(e.code,{children:\"predicate.bind(object)\"}),\" before passing it to \",(0,t.jsx)(e.code,{children:\"negate\"}),\", ensuring \",(0,t.jsx)(e.code,{children:\"this\"}),\" remains correctly bound.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#negate\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.negate\"})]})}),`\n`]})]})}function C(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var D=C;return F(P);})();\n;return Component;"
}