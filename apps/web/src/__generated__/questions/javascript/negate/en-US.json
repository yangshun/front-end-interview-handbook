{
  "description": "var Component=(()=>{var l=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var c in e)r(t,c,{get:e[c],enumerable:!0})},d=(t,e,c,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!g.call(t,i)&&i!==c&&r(t,i,{get:()=>e[i],enumerable:!(a=u(e,i))||a.enumerable});return t};var j=(t,e,c)=>(c=t!=null?l(p(t)):{},d(e||!t||!t.__esModule?r(c,\"default\",{value:t,enumerable:!0}):c,t)),_=t=>d(r({},\"__esModule\",{value:!0}),t);var h=f((N,o)=>{o.exports=_jsx_runtime});var w={};x(w,{default:()=>b,frontmatter:()=>O});var n=j(h()),O={title:\"Negate\",excerpt:\"Implement a function that creates a function that negates the result of the predicate function\"};function s(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",ul:\"ul\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"negate(predicate)\"}),\" that creates a function that negates the result of the predicate function. The predicate is invoked with the \",(0,n.jsx)(e.code,{children:\"this\"}),\" binding and arguments of the created function.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`negate(predicate);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"predicate\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The predicate to negate.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:(0,n.jsx)(e.code,{children:\"(Function)\"})}),\": Returns the new negated function.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const isOdd = negate(isEven);\nisOdd(1); // => true\nisOdd(2); // => false\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#negate\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.negate\"})]})}),`\n`]})]})}function F(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(s,t)})):s(t)}var b=F;return _(w);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/negate\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/negate.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/negate.run.test.ts": "import negate from './negate';\n\ndescribe('negate function', () => {\n  test('negate a function returning true', () => {\n    const alwaysTrue = () => true;\n    const negated = negate(alwaysTrue);\n    expect(negated()).toEqual(false);\n  });\n\n  test('negate a function returning false', () => {\n    const alwaysFalse = () => false;\n    const negated = negate(alwaysFalse);\n    expect(negated()).toEqual(true);\n  });\n\n  test('negate a function with a single numeric argument', () => {\n    const isEven = (n: number) => n % 2 === 0;\n    const isOdd = negate(isEven);\n    expect(isOdd(3)).toEqual(true);\n    expect(isOdd(4)).toEqual(false);\n  });\n});\n",
    "/src/negate.submit.test.ts": "import negate from './negate';\n\ndescribe('negate function', () => {\n  test('negate a function returning true', () => {\n    const alwaysTrue = () => true;\n    const negated = negate(alwaysTrue);\n    expect(negated()).toEqual(false);\n  });\n\n  test('negate a function returning false', () => {\n    const alwaysFalse = () => false;\n    const negated = negate(alwaysFalse);\n    expect(negated()).toEqual(true);\n  });\n\n  test('negate a function with a single numeric argument', () => {\n    const isEven = (n: number) => n % 2 === 0;\n    const isOdd = negate(isEven);\n    expect(isOdd(3)).toEqual(true);\n    expect(isOdd(4)).toEqual(false);\n  });\n\n  test('negate a function with multiple arguments', () => {\n    const sumGreaterThan = (a: number, b: number, threshold: number) =>\n      a + b > threshold;\n    const sumNotGreaterThan = negate(sumGreaterThan);\n    expect(sumNotGreaterThan(1, 1, 3)).toEqual(true);\n    expect(sumNotGreaterThan(2, 2, 3)).toEqual(false);\n  });\n\n  test('negate a function with side effects', () => {\n    let counter = 0;\n    const incrementCounter = () => {\n      counter++;\n      return counter % 2 === 0;\n    };\n    const negated = negate(incrementCounter);\n    expect(negated()).toEqual(true);\n    expect(negated()).toEqual(false);\n  });\n\n  test('negate a function with `this` parameter', () => {\n    function getFoo(this: any) {\n      return this.foo;\n    }\n    const getFooNegated = negate(getFoo);\n    const obj = {\n      foo: true,\n      getFoo,\n      getFooNegated,\n    };\n\n    expect(obj.getFoo()).toBe(true);\n    expect(obj.getFooNegated()).toBe(false);\n  });\n});\n",
    "/src/negate.ts": "export default function negate<P extends any[], R>(\n  predicate: (this: any, ...args: P) => R,\n): (...args: P) => boolean {\n  return function (this: any, ...args: P): boolean {\n    return !predicate.apply(this, args);\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1712188800,
    "difficulty": "medium",
    "duration": 10,
    "excerpt": "Implement a function that creates a function that negates the result of the predicate function",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/negate",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": false,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "negate",
    "subtitle": null,
    "title": "Negate",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n */\nexport default function negate(predicate) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function negate<P extends Array<any>>(\n  predicate: (this: any, ...args: P) => boolean,\n): (...args: P) => boolean {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var j=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),_=(n,e)=>{for(var r in e)o(n,r,{get:e[r],enumerable:!0})},s=(n,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!w.call(n,i)&&i!==r&&o(n,i,{get:()=>e[i],enumerable:!(c=x(e,i))||c.enumerable});return n};var T=(n,e,r)=>(r=n!=null?m(b(n)):{},s(e||!n||!n.__esModule?o(r,\"default\",{value:n,enumerable:!0}):r,n)),F=n=>s(o({},\"__esModule\",{value:!0}),n);var h=j((A,d)=>{d.exports=_jsx_runtime});var R={};_(R,{default:()=>P});var t=T(h());var a=MDXCodeBlock;var l=`/**\n * @param {Function} predicate The predicate to negate.\n * @returns {Function} Returns the new negated function.\n */\nexport default function negate(predicate) {\n  return function (...args) {\n    return !predicate.apply(this, args);\n  };\n}\n`;var u=`export default function negate<P extends any[], R>(\n  predicate: (this: any, ...args: P) => R,\n): (...args: P) => boolean {\n  return function (this: any, ...args: P): boolean {\n    return !predicate.apply(this, args);\n  };\n}\n`;var p=`export default function negate(predicate) {\n  return function () {\n    return !predicate.apply(this, arguments);\n  };\n}\n`;var g=`export default function negate(predicate: Function): Function {\n  return function (this: any): boolean {\n    return !predicate.apply(this, arguments);\n  };\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",h3:\"h3\",code:\"code\",ol:\"ol\",li:\"li\",p:\"p\",ul:\"ul\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Solution 1: Uses \",(0,t.jsx)(e.code,{children:\"...args\"}),\" to allow for unknown number of parameters\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The \",(0,t.jsx)(e.code,{children:\"predicate.apply(this, args)\"}),\" part is where the original \",(0,t.jsx)(e.code,{children:\"predicate\"}),\" function is invoked.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The \",(0,t.jsx)(e.code,{children:\"apply\"}),\" method is used to call the \",(0,t.jsx)(e.code,{children:\"predicate\"}),\" with a specific \",(0,t.jsx)(e.code,{children:\"this\"}),\" context and an array of arguments. In this case, \",(0,t.jsx)(e.code,{children:\"this\"}),\" refers to the \",(0,t.jsx)(e.code,{children:\"this\"}),\" context of the anonymous function at the time it is called, and \",(0,t.jsx)(e.code,{children:\"args\"}),\" is an array of the arguments passed to the anonymous function. This ensures that the predicate function is executed in the correct context and with the same arguments that were passed to the negated function. Additionally, due to the need of using the right \",(0,t.jsx)(e.code,{children:\"this\"}),\" context, the outermost function should not be declared using arrow functions.\"]}),`\n`]}),`\n`,(0,t.jsx)(a,{languages:{jsx:l,tsx:u}}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Solution 2: Uses \",(0,t.jsx)(e.code,{children:\"arguments\"}),\" as the arguments passed into the negated predicate\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Uses \",(0,t.jsx)(e.code,{children:\"arguments\"}),\" to pass all received arguments to the predicate, offering flexibility in handling an indefinite number of parameters without explicitly listing them, suitable for functions where parameter types and numbers are variable or unknown.\"]}),`\n`,(0,t.jsx)(a,{languages:{jsx:p,tsx:g}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"When using \",(0,t.jsx)(e.code,{children:\"negate\"}),\" with \",(0,t.jsx)(e.code,{children:\"predicate\"}),\" functions that depend on their \",(0,t.jsx)(e.code,{children:\"this\"}),\" context, such as object methods, unexpected behavior may occur due to context loss. To preserve context, we can bind the \",(0,t.jsx)(e.code,{children:\"predicate\"}),\" to its original context using \",(0,t.jsx)(e.code,{children:\"predicate.bind(object)\"}),\" before passing it to \",(0,t.jsx)(e.code,{children:\"negate\"}),\", ensuring \",(0,t.jsx)(e.code,{children:\"this\"}),\" remains correctly bound.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#negate\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.negate\"})]})}),`\n`]})]})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var P=D;return F(R);})();\n;return Component;",
  "workspace": {
    "main": "/src/negate.ts",
    "run": "/src/negate.run.test.ts",
    "submit": "/src/negate.submit.test.ts"
  }
}