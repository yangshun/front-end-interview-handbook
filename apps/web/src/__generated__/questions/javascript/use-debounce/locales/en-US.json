{
  "description": "var Component=(()=>{var i=Object.create;var d=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var r in e)d(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!f.call(t,o)&&o!==r&&d(t,o,{get:()=>e[o],enumerable:!(a=h(e,o))||a.enumerable});return t};var v=(t,e,r)=>(r=t!=null?i(m(t)):{},c(e||!t||!t.__esModule?d(r,\"default\",{value:t,enumerable:!0}):r,t)),x=t=>c(d({},\"__esModule\",{value:!0}),t);var l=y((_,s)=>{s.exports=_jsx_runtime});var j={};b(j,{default:()=>D,frontmatter:()=>w});var n=v(l()),w={title:\"useDebounce\",excerpt:\"Implement a hook that debounces a value\"};function u(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",a:\"a\",h2:\"h2\",ol:\"ol\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"useDebounce\"}),\" hook that delays state updates until a specified \",(0,n.jsx)(e.code,{children:\"delay\"}),\" has passed without any further changes to the provided \",(0,n.jsx)(e.code,{children:\"value\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`export default function Component() {\n  const [keyword, setKeyword] = useState('');\n  const debouncedKeyword = useDebounce(keyword, 1000);\n\n  return (\n    <div>\n      <input value={keyword} onChange={(e) => setKeyword(e.target.value)} />\n      <p>Debounced keyword: {debouncedKeyword}</p>\n    </div>\n  );\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The observable outcome of using \",(0,n.jsx)(e.code,{children:\"useDebounce\"}),\" is quite similar to React's \",(0,n.jsx)(e.a,{href:\"https://react.dev/reference/react/useDeferredValue\",children:(0,n.jsx)(e.code,{children:\"useDeferredValue\"})}),\", the former returns an updated value after a fixed duration while the latter always returns the updated value but updates to the DOM relies on React's priority system.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"value\"}),\": The value to debounce\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"delay: number\"}),\": The delay in milliseconds\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsx)(e.p,{children:\"The hook returns the debounced value.\"})]})}function g(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var D=g;return x(j);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a hook that debounces a value",
    "title": "useDebounce"
  },
  "solution": "var Component=(()=>{var m=Object.create;var c=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var D=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var o in e)c(t,o,{get:e[o],enumerable:!0})},a=(t,e,o,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let u of p(e))!x.call(t,u)&&u!==o&&c(t,u,{get:()=>e[u],enumerable:!(d=f(e,u))||d.enumerable});return t};var j=(t,e,o)=>(o=t!=null?m(b(t)):{},a(e||!t||!t.__esModule?c(o,\"default\",{value:t,enumerable:!0}):o,t)),T=t=>a(c({},\"__esModule\",{value:!0}),t);var l=D((C,r)=>{r.exports=_jsx_runtime});var y={};v(y,{default:()=>g});var n=j(l());var s=MDXCodeBlock;var i=`import { useState, useEffect } from 'react';\n\nexport default function useDebounce<T>(value: T, delay: number) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n`;function h(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"useDebounce\"}),\" hook can be implemented with \",(0,n.jsx)(e.code,{children:\"useState\"}),\" to store the current debounced value and \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" to update the debounced value after the specified \",(0,n.jsx)(e.code,{children:\"delay\"}),\" with \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\". If \",(0,n.jsx)(e.code,{children:\"value\"}),\" changes, it must mean that there's a state update, so we clear the timeout with \",(0,n.jsx)(e.code,{children:\"clearTimeout\"}),\" on unmount and set a new timeout to update the current debounced value.\"]}),`\n`,(0,n.jsx)(s,{children:i})]})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var g=w;return T(y);})();\n;return Component;"
}