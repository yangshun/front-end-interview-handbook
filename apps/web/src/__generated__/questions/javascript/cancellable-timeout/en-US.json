{
  "description": "var Component=(()=>{var d=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),T=(n,e)=>{for(var t in e)c(n,t,{get:e[t],enumerable:!0})},i=(n,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of h(e))!b.call(n,l)&&l!==t&&c(n,l,{get:()=>e[l],enumerable:!(o=u(e,l))||o.enumerable});return n};var g=(n,e,t)=>(t=n!=null?d(p(n)):{},i(e||!n||!n.__esModule?c(t,\"default\",{value:n,enumerable:!0}):t,n)),x=n=>i(c({},\"__esModule\",{value:!0}),n);var s=f((D,r)=>{r.exports=_jsx_runtime});var _={};T(_,{default:()=>k,frontmatter:()=>C});var a=g(s()),C={title:\"Cancellable Timeout\",excerpt:\"Implement a function that acts like setTimeout but returns a function to cancel the pending callback\"};function m(n){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",a:\"a\",h2:\"h2\"},n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(e.p,{children:[\"Implement a function \",(0,a.jsx)(e.code,{children:\"setCancellableTimeout\"}),\", that acts like \",(0,a.jsx)(e.code,{children:\"setTimeout\"}),\" but instead of returning a timer ID, it returns a function that when called, cancels the pending callback function. The \",(0,a.jsx)(e.code,{children:\"setCancellableTimeout\"}),\" function should have the exact same signature as \",(0,a.jsx)(e.code,{children:\"setTimeout\"}),\":\"]}),`\n`,(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:\"language-js\",children:`setCancellableTimeout(callback);\nsetCancellableTimeout(callback, delay);\nsetCancellableTimeout(callback, delay, param1);\nsetCancellableTimeout(callback, delay, param1, param2);\nsetCancellableTimeout(callback, delay, param1, param2, /* \\u2026 ,*/ paramN);\n`})}),`\n`,(0,a.jsxs)(e.p,{children:[\"You are recommended to read up on for \",(0,a.jsx)(e.code,{children:\"setTimeout\"}),\" on \",(0,a.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setTimeout\",children:\"MDN Docs\"}),\" if you are unfamiliar.\"]}),`\n`,(0,a.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:\"language-js\",children:`let i = 0;\n// t = 0:\nconst cancel = setCancellableTimeout(() => {\n  i++;\n}, 100);\n// t = 50:\ncancel();\n// t = 100: i is still 0 because cancel() was called.\n`})})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(m,n)})):m(n)}var k=j;return x(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/cancellable-timeout\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/cancellable-timeout.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/cancellable-timeout.run.test.ts": "import setCancellableTimeout from './cancellable-timeout';\n\ndescribe('setCancellableTimeout', () => {\n  test('returns a function', () => {\n    expect(typeof setCancellableTimeout(() => {})).toBe('function');\n  });\n\n  test('cancelled immediately', (done) => {\n    expect.assertions(2);\n    let i = 0;\n\n    setTimeout(() => {\n      // Ensure setTimeout callback is never called.\n      expect(i).toBe(0);\n      done();\n    });\n    const cancel = setCancellableTimeout(() => {\n      i++;\n    }, 10);\n    cancel();\n    expect(i).toBe(0);\n  });\n\n  test('not cancelled', (done) => {\n    expect.assertions(2);\n    let i = 0;\n\n    setCancellableTimeout(() => {\n      i++;\n      expect(i).toBe(1);\n      done();\n    }, 100);\n\n    expect(i).toBe(0);\n  });\n});\n",
    "/src/cancellable-timeout.submit.test.ts": "import setCancellableTimeout from './cancellable-timeout';\n\ndescribe('setCancellableTimeout', () => {\n  test('returns a function', () => {\n    expect(typeof setCancellableTimeout(() => {})).toBe('function');\n  });\n\n  describe('cancelled', () => {\n    test('immediately', (done) => {\n      expect.assertions(2);\n      let i = 0;\n\n      setTimeout(() => {\n        // Ensure setTimeout callback is never called.\n        expect(i).toBe(0);\n        done();\n      });\n      const cancel = setCancellableTimeout(() => {\n        i++;\n      }, 10);\n      cancel();\n      expect(i).toBe(0);\n    });\n\n    test('delayed', (done) => {\n      expect.assertions(2);\n      let i = 0;\n\n      setTimeout(() => {\n        // Ensure setTimeout callback is never called.\n        expect(i).toBe(0);\n        done();\n      }, 20);\n      const cancel = setCancellableTimeout(() => {\n        i++;\n      }, 10);\n      cancel();\n      expect(i).toBe(0);\n    });\n  });\n\n  describe('not cancelled', () => {\n    test('immediately', (done) => {\n      expect.assertions(2);\n      let i = 0;\n\n      setCancellableTimeout(() => {\n        i++;\n        expect(i).toBe(1);\n        done();\n      });\n\n      expect(i).toBe(0);\n    });\n\n    test('delayed', (done) => {\n      expect.assertions(2);\n      let i = 0;\n\n      setCancellableTimeout(() => {\n        i++;\n        expect(i).toBe(1);\n        done();\n      }, 100);\n\n      expect(i).toBe(0);\n    });\n\n    test('uses parameters', (done) => {\n      expect.assertions(2);\n      let i = 1;\n\n      setCancellableTimeout(\n        (foo: number, bar: number) => {\n          i += foo;\n          i *= bar;\n          expect(i).toBe(21);\n          done();\n        },\n        10,\n        2,\n        7,\n      );\n\n      expect(i).toBe(1);\n    });\n\n    test('cancelling afterwards is safe', (done) => {\n      expect.assertions(3);\n      let i = 1;\n\n      const cancel = setCancellableTimeout(\n        (foo: number, bar: number) => {\n          i += foo;\n          i *= bar;\n          expect(i).toBe(21);\n        },\n        10,\n        2,\n        7,\n      );\n\n      setTimeout(() => {\n        cancel();\n        expect(i).toBe(21);\n        done();\n      }, 50);\n\n      expect(i).toBe(1);\n    });\n  });\n\n  test('callbacks can access `this`', (done) => {\n    expect.assertions(2);\n\n    function increment(this: any, delta: number) {\n      this.val += delta;\n    }\n\n    const obj = {\n      val: 13,\n    };\n\n    setCancellableTimeout(increment.bind(obj), 10, 15);\n\n    expect(obj.val).toBe(13);\n\n    setTimeout(() => {\n      expect(obj.val).toBe(28);\n      done();\n    }, 20);\n  });\n});\n",
    "/src/cancellable-timeout.ts": "export default function setCancellableTimeout(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): () => void {\n  const timerId = setTimeout(callback, delay, ...args);\n\n  return () => {\n    clearTimeout(timerId);\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1689552000,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement a function that acts like setTimeout but returns a function to cancel the pending callback",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/cancellable-timeout",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "cancellable-interval"
    ],
    "slug": "cancellable-timeout",
    "subtitle": null,
    "title": "Cancellable Timeout",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {Function}\n */\nexport default function setCancellableTimeout(callback, delay, ...args) {\n  throw 'Not implemented';\n}",
    "ts": "export default function setCancellableTimeout(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): () => void {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var c=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var x=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),w=(a,e)=>{for(var n in e)c(a,n,{get:e[n],enumerable:!0})},i=(a,e,n,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of T(e))!k.call(a,l)&&l!==n&&c(a,l,{get:()=>e[l],enumerable:!(o=y(e,l))||o.enumerable});return a};var I=(a,e,n)=>(n=a!=null?f(g(a)):{},i(e||!a||!a.__esModule?c(n,\"default\",{value:a,enumerable:!0}):n,a)),v=a=>i(c({},\"__esModule\",{value:!0}),a);var s=x((B,d)=>{d.exports=_jsx_runtime});var D={};w(D,{default:()=>M});var t=I(s());var r=MDXCodeBlock;var u=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {Function}\n */\nexport default function setCancellableTimeout(callback, delay, ...args) {\n  const timerId = setTimeout(callback, delay, ...args);\n\n  return () => {\n    clearTimeout(timerId);\n  };\n}\n`;var h=`export default function setCancellableTimeout(\n  callback: Function,\n  delay?: number,\n  ...args: Array<any>\n): () => void {\n  const timerId = setTimeout(callback, delay, ...args);\n\n  return () => {\n    clearTimeout(timerId);\n  };\n}\n`;var m=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {Function}\n */\nexport default function setCancellableTimeout(...args) {\n  const timerId = setTimeout(...args);\n\n  return () => {\n    clearTimeout(timerId);\n  };\n}\n`;var p=`/**\n * @param {Function} callback\n * @param {number} delay\n * @param {...any} args\n * @returns {Function}\n */\nexport default function setCancellableTimeout(callback, delay, ...args) {\n  let cancelled = false;\n  setTimeout(() => {\n    if (cancelled) {\n      return;\n    }\n\n    callback(...args);\n  }, delay);\n\n  return () => {\n    cancelled = true;\n  };\n}\n`;function b(a){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",a:\"a\",ul:\"ul\",li:\"li\"},a.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The benefit of returning a cancel function as opposed to a \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" is that the delay mechanism is abstracted away, and can be swapped for something else. Realistically though, there aren't many other ways to achieved delay execution in JavaScript and that's why you probably don't see this outside of interviews.\"]}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 1: Return a function that calls \",(0,t.jsx)(e.code,{children:\"clearTimeout\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"setTimeout\"}),\" returns a timer ID. To cancel the timer, we can call \",(0,t.jsx)(e.code,{children:\"clearTimeout(timerId)\"}),\". One simple way to solve this question is to return a function that does exactly that. We can forward all the parameters to \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\".\"]}),`\n`,(0,t.jsx)(r,{languages:{jsx:u,tsx:h}}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can simplify the code a little and forward all the parameters to \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\".\"]}),`\n`,(0,t.jsx)(r,{children:m}),`\n`,(0,t.jsxs)(e.p,{children:[\"We don't have to worry about \",(0,t.jsx)(e.code,{children:\"this\"}),\" within the callback function because there's no option to pass a \",(0,t.jsx)(e.code,{children:\"thisArg\"}),\" to \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\" unlike \",(0,t.jsx)(e.code,{children:\"Array.prototype.forEach()\"}),\"/\",(0,t.jsx)(e.code,{children:\"Array.prototype.reduce()\"}),\". Read more about \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#the_this_problem\",children:\"this on MDN\"}),\".\"]}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 2: Maintain a \",(0,t.jsx)(e.code,{children:\"cancelled\"}),\" flag (non-optimal)\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Another way is to maintain a \",(0,t.jsx)(e.code,{children:\"cancelled\"}),\" flag that the returned function will set to \",(0,t.jsx)(e.code,{children:\"true\"}),\" when called. Before the \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\" callback is called, check the value of \",(0,t.jsx)(e.code,{children:\"cancelled\"}),\" before executing the \",(0,t.jsx)(e.code,{children:\"callback\"}),\". This is non-optimal because the \",(0,t.jsx)(e.code,{children:\"setTimeout\"}),\" callback is still invoked unnecessarily and ends up doing nothing.\"]}),`\n`,(0,t.jsx)(r,{children:p}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setTimeout\",children:[(0,t.jsx)(e.code,{children:\"setTimeout()\"}),\" | MDN\"]})}),`\n`]})]})}function C(a={}){let{wrapper:e}=a.components||{};return e?(0,t.jsx)(e,Object.assign({},a,{children:(0,t.jsx)(b,a)})):b(a)}var M=C;return v(D);})();\n;return Component;",
  "workspace": {
    "main": "/src/cancellable-timeout.ts",
    "run": "/src/cancellable-timeout.run.test.ts",
    "submit": "/src/cancellable-timeout.submit.test.ts"
  }
}