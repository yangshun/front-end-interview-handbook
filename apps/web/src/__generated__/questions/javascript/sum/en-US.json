{
  "description": "var Component=(()=>{var i=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var a in e)s(n,a,{get:e[a],enumerable:!0})},o=(n,e,a,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of d(e))!g.call(n,r)&&r!==a&&s(n,r,{get:()=>e[r],enumerable:!(c=h(e,r))||c.enumerable});return n};var b=(n,e,a)=>(a=n!=null?i(p(n)):{},o(e||!n||!n.__esModule?s(a,\"default\",{value:n,enumerable:!0}):a,n)),j=n=>o(s({},\"__esModule\",{value:!0}),n);var m=f((D,l)=>{l.exports=_jsx_runtime});var C={};x(C,{default:()=>y,frontmatter:()=>w});var t=b(m()),w={title:\"Sum\",excerpt:\"Implement a function that sums numbers by accepting a number and allows for repeated calling with more numbers until it is not called with any number\"};function u(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a \",(0,t.jsx)(e.code,{children:\"sum\"}),\" function that accepts a number and allows for repeated calling with more numbers. Calling the function without an argument will sum up all the arguments thus far and return the total.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`sum(1)(); // 1\nsum(1)(2)(); // 3\nsum(1)(2)(-3)(); // 0\n`})})]})}function _(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var y=_;return j(C);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/sum\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/sum.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/sum.run.test.ts": "import sum from './sum';\n\ndescribe('sum', () => {\n  test('one number', () => {\n    expect(sum(1)()).toBe(1);\n  });\n\n  test('two numbers', () => {\n    // @ts-ignore\n    expect(sum(1)(2)()).toBe(3);\n  });\n});\n",
    "/src/sum.submit.test.ts": "import sum from './sum';\n\ndescribe('sum', () => {\n  test('one number', () => {\n    expect(sum(1)()).toBe(1);\n    expect(sum(-1)()).toBe(-1);\n  });\n\n  test('two numbers', () => {\n    // @ts-ignore\n    expect(sum(1)(2)()).toBe(3);\n    // @ts-ignore\n    expect(sum(89)(11)()).toBe(100);\n    // @ts-ignore\n    expect(sum(-1)(-2)()).toBe(-3);\n  });\n\n  test('zero works', () => {\n    // @ts-ignore\n    expect(sum(0)(0)(0)()).toBe(0);\n    // @ts-ignore\n    expect(sum(1)(2)(0)()).toBe(3);\n    // @ts-ignore\n    expect(sum(1)(0)(89)(10)()).toBe(100);\n    // @ts-ignore\n    expect(sum(-1)(0)(-2)()).toBe(-3);\n  });\n\n  test('negative numbers', () => {\n    // @ts-ignore\n    expect(sum(-1)(-2)()).toBe(-3);\n    // @ts-ignore\n    expect(sum(-89)(-2)()).toBe(-91);\n    // @ts-ignore\n    expect(sum(-42)(42)()).toBe(0);\n  });\n\n  test('returns function if not terminated', () => {\n    expect(sum(1)).toBeInstanceOf(Function);\n    // @ts-ignore\n    expect(sum(1)(2)).toBeInstanceOf(Function);\n    // @ts-ignore\n    expect(sum(1)(2)(3)).toBeInstanceOf(Function);\n  });\n\n  test('can be reused', () => {\n    const addTwo = sum(2);\n    // @ts-ignore\n    expect(addTwo(3)()).toBe(5);\n    // @ts-ignore\n    expect(addTwo(4)()).toBe(6);\n    // @ts-ignore\n    expect(addTwo(3)(4)()).toBe(9);\n  });\n});\n",
    "/src/sum.ts": "type SumResult = (value?: number) => number | SumResult;\n\nexport default function sum(numberA: number): SumResult {\n  return function (numberB) {\n    return numberB === undefined ? numberA : sum(numberA + numberB);\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [
      "amazon"
    ],
    "created": 1655251200,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement a function that sums numbers by accepting a number and allows for repeated calling with more numbers until it is not called with any number",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/sum",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "curry",
      "curry-ii"
    ],
    "slug": "sum",
    "subtitle": null,
    "title": "Sum",
    "topics": [
      "closure"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {number} value\n * @return {Function}\n */\nexport default function sum(value) {\n  throw 'Not implemented!';\n}",
    "ts": "type SumResult = (value?: number) => number | SumResult;\n\nexport default function sum(value: number): SumResult {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var b=Object.create;var u=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),A=(t,e)=>{for(var r in e)u(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!v.call(t,i)&&i!==r&&u(t,i,{get:()=>e[i],enumerable:!(o=p(e,i))||o.enumerable});return t};var T=(t,e,r)=>(r=t!=null?b(w(t)):{},a(e||!t||!t.__esModule?u(r,\"default\",{value:t,enumerable:!0}):r,t)),j=t=>a(u({},\"__esModule\",{value:!0}),t);var c=x((D,l)=>{l.exports=_jsx_runtime});var F={};A(F,{default:()=>y});var n=T(c());var s=MDXCodeBlock;var d=`/**\n * @param {number} valueA\n * @return {Function}\n */\nexport default function sum(valueA) {\n  return function (valueB) {\n    return valueB === undefined ? valueA : sum(valueA + valueB);\n  };\n}\n`;var h=`type SumResult = (value?: number) => number | SumResult;\n\nexport default function sum(numberA: number): SumResult {\n  return function (numberB) {\n    return numberB === undefined ? numberA : sum(numberA + numberB);\n  };\n}\n`;var m=`const sum = (a) => (b) => b !== undefined ? sum(a + b) : a;\nexport default sum;\n`;function f(t){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",h3:\"h3\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"This question evaluates your understanding of closures and first-class functions - functions in JavaScript are variables that can be returned and passed into other functions as arguments.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"What if we call \",(0,n.jsx)(e.code,{children:\"sum()\"}),\" at the start without any arguments?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"We won't test this case. But we recommend throwing an \",(0,n.jsx)(e.code,{children:\"Error\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"sum\"}),\" function returns functions until it is called without any arguments, then it will return the total sum so far. Since we need to retain a running sum of the values added so far, we can use a variable for that. How do we achieve that without classes? The answer is closures.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"A closure is the combination of a function bundled together with references to its lexical environment (surrounding state). We can make use of closures to keep a reference to the running total.\"}),`\n`,(0,n.jsx)(e.p,{children:\"We declare an inner function that will be returned for subsequent calls to the function. That function will determine if there's a value being passed in. If there is, we add to the running total and return itself so that subsequent calls can be made, otherwise we return the running total.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can check for the presence of an argument by using \",(0,n.jsx)(e.code,{children:\"argument === undefined\"}),\". Note that we shouldn't be using \",(0,n.jsx)(e.code,{children:\"==\"}),\" here because \",(0,n.jsx)(e.code,{children:\"null == undefined\"}),\" is \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`,(0,n.jsx)(s,{languages:{jsx:d,tsx:h}}),`\n`,(0,n.jsx)(e.h3,{children:\"One-liner using Arrow Functions\"}),`\n`,(0,n.jsx)(e.p,{children:\"Using arrow functions, this function can be written in a single line.\"}),`\n`,(0,n.jsx)(s,{children:m}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,n.jsx)(e.p,{children:\"Intermediate results should be able to be used again for separate evaluations.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const addTwo = sum(2);\naddTwo(3)(); // 5\naddTwo(4)(); // 6\naddTwo(3)(4)(); // 9\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Closures\"}),`\n`,(0,n.jsx)(e.li,{children:\"First-class functions\"}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"null\"}),\" vs \",(0,n.jsx)(e.code,{children:\"undefined\"})]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Do not use \",(0,n.jsx)(e.code,{children:\"==\"}),\" to check for presence of an argument because \",(0,n.jsx)(e.code,{children:\"null == undefined\"}),\" is \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var y=k;return j(F);})();\n;return Component;",
  "workspace": {
    "main": "/src/sum.ts",
    "run": "/src/sum.run.test.ts",
    "submit": "/src/sum.submit.test.ts"
  }
}