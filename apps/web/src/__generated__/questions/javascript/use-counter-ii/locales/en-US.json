{
  "description": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var a=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),C=(t,e)=>{for(var o in e)c(t,o,{get:e[o],enumerable:!0})},d=(t,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!f.call(t,r)&&r!==o&&c(t,r,{get:()=>e[r],enumerable:!(i=a(e,r))||i.enumerable});return t};var b=(t,e,o)=>(o=t!=null?h(p(t)):{},d(e||!t||!t.__esModule?c(o,\"default\",{value:t,enumerable:!0}):o,t)),x=t=>d(c({},\"__esModule\",{value:!0}),t);var u=v((A,l)=>{l.exports=_jsx_runtime});var _={};C(_,{default:()=>I,frontmatter:()=>g});var n=b(u()),g={title:\"useCounter II\",excerpt:\"Implement an optimized version of the useCounter hook\"};function s(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement an optimized version of the \",(0,n.jsx)(e.code,{children:\"useCounter\"}),\" hook. The returned methods should be memoized, the same function instance is returned across re-renders.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`export default function Component() {\n  const { count, increment, decrement, reset, setCount } = useCounter();\n\n  return (\n    <div>\n      <p>Counter: {count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={decrement}>Decrement</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"initialValue: number\"}),\": Initial value of the counter state. If not provided, it should default to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"useCounter\"}),\" hook returns an \",(0,n.jsx)(e.code,{children:\"object\"}),\" with the following properties:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"count: number\"}),\": The current counter value\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"increment: () => void\"}),\": A function to increment the counter value\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"decrement: () => void\"}),\": A function to decrement the counter value\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"reset: () => void\"}),\": A function to reset the counter value to \",(0,n.jsx)(e.code,{children:\"initialValue\"}),\", or \",(0,n.jsx)(e.code,{children:\"0\"}),\" if not provided\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"setCount: (value: number) => void\"}),\": A function to set the counter value to \",(0,n.jsx)(e.code,{children:\"value\"}),\", it has the same signature as \",(0,n.jsx)(e.code,{children:\"setState\"})]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"increment\"}),\", \",(0,n.jsx)(e.code,{children:\"decrement\"}),\", \",(0,n.jsx)(e.code,{children:\"reset\"}),\", and \",(0,n.jsx)(e.code,{children:\"setCount\"}),\" must be the same function instance across re-renders.\"]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(s,t)})):s(t)}var I=j;return x(_);})();\n;return Component;",
  "info": {
    "excerpt": "Implement an optimized version of the useCounter hook",
    "title": "useCounter II"
  },
  "solution": "var Component=(()=>{var m=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var C=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),S=(n,e)=>{for(var o in e)c(n,o,{get:e[o],enumerable:!0})},a=(n,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!y.call(n,r)&&r!==o&&c(n,r,{get:()=>e[r],enumerable:!(i=p(e,r))||i.enumerable});return n};var x=(n,e,o)=>(o=n!=null?m(C(n)):{},a(e||!n||!n.__esModule?c(o,\"default\",{value:n,enumerable:!0}):o,n)),g=n=>a(c({},\"__esModule\",{value:!0}),n);var u=b((j,s)=>{s.exports=_jsx_runtime});var V={};S(V,{default:()=>k});var t=x(u());var d=MDXCodeBlock;var l=`import { Dispatch, SetStateAction, useCallback, useState } from 'react';\n\ninterface UseCounterReturn {\n  count: number;\n  increment: () => void;\n  decrement: () => void;\n  reset: () => void;\n  setCount: Dispatch<SetStateAction<number>>;\n}\n\nexport default function useCounter(initialValue = 0): UseCounterReturn {\n  const [count, setCount] = useState(initialValue);\n\n  const increment = useCallback(() => {\n    setCount((x) => x + 1);\n  }, []);\n\n  const decrement = useCallback(() => {\n    setCount((x) => x - 1);\n  }, []);\n\n  const reset = useCallback(() => {\n    setCount(initialValue);\n  }, [initialValue]);\n\n  return {\n    count,\n    increment,\n    decrement,\n    reset,\n    setCount,\n  };\n}\n`;function h(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"useCounter\"}),\" hook uses \",(0,t.jsx)(e.code,{children:\"useState\"}),\" to manage the \",(0,t.jsx)(e.code,{children:\"number\"}),\" state. The setter functions can be implemented in terms of \",(0,t.jsx)(e.code,{children:\"setValue\"}),\" from the \",(0,t.jsx)(e.code,{children:\"useState\"}),\" hook.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`import { useState } from 'react';\n\nexport default function useCounter(initialValue = 0) {\n  const [count, setCount] = useState(initialValue);\n\n  return {\n    count,\n    increment: () => setCount((x) => x + 1),\n    decrement: () => setCount((x) => x - 1),\n    reset: () => setCount(initialValue),\n    setCount,\n  };\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"However, writing the hook this way means that components that rely on the utility functions will always be re-rendered since these functions are always freshly created on each render. To avoid this, we can use \",(0,t.jsx)(e.code,{children:\"useCallback\"}),\" to memoize them.\"]}),`\n`,(0,t.jsx)(d,{children:l}),`\n`,(0,t.jsxs)(e.p,{children:[\"To ensure consistency, the \",(0,t.jsx)(e.code,{children:\"increment\"}),\" and \",(0,t.jsx)(e.code,{children:\"decrement\"}),\" functions use an \",(0,t.jsx)(e.a,{href:\"https://react.dev/reference/react/useState#updating-state-based-on-the-previous-state\",children:\"updater function\"}),\" to calculate the new value based on the previous value. As an added bonus, if you're wrapping them in \",(0,t.jsx)(e.code,{children:\"useCallback\"}),\", you don't have to add \",(0,t.jsx)(e.code,{children:\"initialValue\"}),\" to the dependency array and \",(0,t.jsx)(e.code,{children:\"increment\"}),\" and \",(0,t.jsx)(e.code,{children:\"decrement\"}),\" will always be memoized once.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If you're using TypeScript, the tricky part is figuring out the right type for \",(0,t.jsx)(e.code,{children:\"setCount\"}),\" since it can also accept an updater function. Simply hover the setter function from \",(0,t.jsx)(e.code,{children:\"useState\"}),\" in your favourite IDE and you'll see the type signature in the form of \",(0,t.jsx)(e.code,{children:\"Dispatch<SetStateAction<...>>\"}),\" where the type of the state is \",(0,t.jsx)(e.code,{children:\"...\"}),\". \",(0,t.jsx)(e.code,{children:\"Dispatch\"}),\" and \",(0,t.jsx)(e.code,{children:\"SetStateAction\"}),\" can be imported from \",(0,t.jsx)(e.code,{children:\"react\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"If you prefer to be verbose, it essentially boils down to this.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ts\",children:`type SetCount = (\n  valueOrUpdater: number | ((previousValue: number) => number),\n) => void;\n`})})]})}function w(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var k=w;return g(V);})();\n;return Component;"
}