{
  "description": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),y=(n,e)=>{for(var t in e)s(n,t,{get:e[t],enumerable:!0})},i=(n,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!g.call(n,o)&&o!==t&&s(n,o,{get:()=>e[o],enumerable:!(a=m(e,o))||a.enumerable});return n};var j=(n,e,t)=>(t=n!=null?d(u(n)):{},i(e||!n||!n.__esModule?s(t,\"default\",{value:n,enumerable:!0}):t,n)),v=n=>i(s({},\"__esModule\",{value:!0}),n);var l=f((A,c)=>{c.exports=_jsx_runtime});var E={};y(E,{default:()=>P,frontmatter:()=>b});var r=j(l()),b={title:\"Promise.any\",excerpt:\"Implement the Promise.any() function that resolves when any of the input elements are resolved\"};function h(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",blockquote:\"blockquote\",em:\"em\",h2:\"h2\",pre:\"pre\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"Note:\"}),\" If you haven't completed the \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,r.jsx)(e.code,{children:\"Promise.all\"})}),\" question, you should attempt that first.\"]}),`\n`,(0,r.jsxs)(e.blockquote,{children:[`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:\"Promise.any()\"}),\" takes an iterable of elements (usually \",(0,r.jsx)(e.code,{children:\"Promises\"}),\"). It returns a single promise that resolves as soon as any of the elements in the iterable fulfills, with the value of the fulfilled promise. If no promises in the iterable fulfill (if all of the given elements are rejected), then the returned promise is rejected with an \",(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError\",children:(0,r.jsx)(e.code,{children:\"AggregateError\"})}),\", a new subclass of Error that groups together individual errors.\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.blockquote,{children:[`\n`,(0,r.jsxs)(e.p,{children:[\"If an empty iterable is passed, then the promise returned by this method is rejected synchronously. The rejected reason is an \",(0,r.jsx)(e.code,{children:\"AggregateError\"}),\" object whose errors property is an empty array.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.p,{children:(0,r.jsxs)(e.em,{children:[\"Source: \",(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\",children:\"Promise.any() - JavaScript | MDN\"})]})}),`\n`,(0,r.jsxs)(e.p,{children:[\"Let's implement our own version of \",(0,r.jsx)(e.code,{children:\"Promise.any()\"}),\", a \",(0,r.jsx)(e.code,{children:\"promiseAny\"}),\" function, with the difference being the function takes in an array instead of an iterable and \",(0,r.jsx)(e.code,{children:\"AggregateError\"}),\"s returned just have to return an array of error reasons, the message doesn't have to be set. Refer to the \",(0,r.jsx)(e.code,{children:\"AggregateError\"}),\" constructor \",(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError/AggregateError\",children:\"examples on MDN\"}),\".\"]}),`\n`,(0,r.jsx)(e.p,{children:\"Be sure to read the description carefully and implement accordingly!\"}),`\n`,(0,r.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`const p0 = Promise.resolve(42);\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(21);\n  }, 100);\n});\n\nawait promiseAny([p0, p1]); // 42\n`})}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`const p0 = new Promise((resolve) => {\n  setTimeout(() => {\n    resolve(42);\n  }, 100);\n});\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('Err!');\n  }, 400);\n});\n\nawait promiseAny([p0, p1]); // 42\n`})}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`const p0 = new Promise((resolve) => {\n  setTimeout(() => {\n    reject(42);\n  }, 400);\n});\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('Err!');\n  }, 100);\n});\n\ntry {\n  await promiseAny([p0, p1]);\n} catch (err) {\n  console.log(e instanceof AggregateError); // true\n  console.log(e.errors); // [ 42, \"Err!\" ]\n}\n`})})]})}function w(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(h,n)})):h(n)}var P=w;return v(E);})();\n;return Component;",
  "info": {
    "excerpt": "Implement the Promise.any() function that resolves when any of the input elements are resolved",
    "title": "Promise.any"
  },
  "solution": "var Component=(()=>{var g=Object.create;var o=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),j=(n,e)=>{for(var t in e)o(n,t,{get:e[t],enumerable:!0})},c=(n,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of w(e))!v.call(n,i)&&i!==t&&o(n,i,{get:()=>e[i],enumerable:!(l=y(e,i))||l.enumerable});return n};var A=(n,e,t)=>(t=n!=null?g(f(n)):{},c(e||!n||!n.__esModule?o(t,\"default\",{value:n,enumerable:!0}):t,n)),P=n=>c(o({},\"__esModule\",{value:!0}),n);var d=b((S,s)=>{s.exports=_jsx_runtime});var q={};j(q,{default:()=>_});var r=A(d());var a=MDXCodeBlock;var h=`/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseAny(iterable) {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      reject(new AggregateError([]));\n    }\n\n    let pending = iterable.length;\n    const errors = new Array(iterable.length);\n\n    iterable.forEach(async (item, index) => {\n      try {\n        const value = await item;\n        resolve(value);\n      } catch (err) {\n        errors[index] = err;\n        pending--;\n\n        if (pending === 0) {\n          reject(new AggregateError(errors));\n        }\n      }\n    });\n  });\n}\n`;var p=`export default function promiseAny<T>(iterable: Array<T>): Promise<T> {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      reject(new AggregateError([]));\n    }\n\n    let pending = iterable.length;\n    const errors = new Array(iterable.length);\n\n    iterable.forEach(async (item, index) => {\n      try {\n        const value = await item;\n        resolve(value);\n      } catch (err) {\n        errors[index] = err;\n        pending--;\n\n        if (pending === 0) {\n          reject(new AggregateError(errors));\n        }\n      }\n    });\n  });\n}\n`;var u=`/**\n * @param {Array} iterable\n * @return {Promise}\n */\nexport default function promiseAny(iterable) {\n  return new Promise((resolve, reject) => {\n    if (iterable.length === 0) {\n      reject(new AggregateError([]));\n    }\n\n    let pending = iterable.length;\n    const errors = new Array(iterable.length);\n\n    iterable.forEach((item, index) =>\n      Promise.resolve(item).then(\n        (value) => {\n          resolve(value);\n        },\n        (reason) => {\n          errors[index] = reason;\n          pending--;\n\n          if (pending === 0) {\n            reject(new AggregateError(errors));\n          }\n        },\n      ),\n    );\n  });\n}\n`;function m(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",pre:\"pre\",ul:\"ul\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"Note:\"}),\" If you haven't completed the \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,r.jsx)(e.code,{children:\"Promise.all\"})}),\" question, you should attempt that first.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Async programming is frequently tested during interviews. Understanding how \",(0,r.jsx)(e.code,{children:\"Promise.any\"}),\" works under the hood will help you in understanding the mechanisms behind similar \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"-related functions like \",(0,r.jsx)(e.code,{children:\"Promise.race\"}),\", \",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\", \",(0,r.jsx)(e.code,{children:\"Promise.allSettled\"}),\" etc.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:\"Promise.any\"}),\" is very similar to \",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\", but the resolves and rejects are swapped around.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"There are a few aspects to this question we need to bear in mind and handle:\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"Promise\"}),\"s are meant to be chained, so the function needs to return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the input array is empty, an \",(0,r.jsx)(e.code,{children:\"AggregateError\"}),\" is returned with \",(0,r.jsx)(e.code,{children:\"errors\"}),\" set to an empty array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" resolved immediately with the first input value that is resolved.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" is rejected with an \",(0,r.jsx)(e.code,{children:\"AggregateError\"}),\" containing an array of errors values in the same order as the input array if all of them are rejected.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s.\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We'll return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" at the top level of the function. We first check if the input array is empty, and reject with an empty \",(0,r.jsx)(e.code,{children:\"AggregateError\"}),\" (\",(0,r.jsx)(e.code,{children:\"new AggregateError([])\"}),\") if so.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We then need to attempt resolving every item in the input array. This can be achieved using \",(0,r.jsx)(e.code,{children:\"Array.prototype.forEach\"}),\" or \",(0,r.jsx)(e.code,{children:\"Array.prototype.map\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"If any of the items are fulfilled, we resolve the top-level \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" immediately with that value without waiting for any other pending promises.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"As we encounter rejections, we need to keep them in an errors array in case all the promises turn out to be rejected. As the returned errors will need to preserve the order of the input array, we create an \",(0,r.jsx)(e.code,{children:\"errors\"}),\" array and slot the value in the right place using its \",(0,r.jsx)(e.code,{children:\"index\"}),\" within the input array.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"To know when all the input array values are no longer pending, we keep track of how many pending promises there are by initializing a counter of pending values and decrementing it whenever a value is rejected. When the counter reaches 0, we can reject with an \",(0,r.jsx)(e.code,{children:\"AggregateError\"}),\" using the \",(0,r.jsx)(e.code,{children:\"errors\"}),\". There is no need to modify the pending counter when a value is resolved because the overall promise will be resolved.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"One thing to note here is that because the input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, if we are not \",(0,r.jsx)(e.code,{children:\"await\"}),\"-ing them, we need to wrap each value with \",(0,r.jsx)(e.code,{children:\"Promise.resolve()\"}),\" which allows us to use \",(0,r.jsx)(e.code,{children:\".then()\"}),\" on each of them and we don't have to differentiate between \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" vs non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values and whether they need to be resolved.\"]}),`\n`,(0,r.jsx)(a,{languages:{jsx:h,tsx:p}}),`\n`,(0,r.jsxs)(e.p,{children:[\"The pending counter is essential in ensuring correct behavior. For example, an alternative approach that seems to work (but doesn't) is to check if the length of the \",(0,r.jsx)(e.code,{children:\"errors\"}),\" array is equal to the length of the \",(0,r.jsx)(e.code,{children:\"iterable\"}),\":\"]}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`errors[index] = await error;\nif (errors.length == iterable.length) {\n  reject(new AggregateError(errors));\n}\n`})}),`\n`,(0,r.jsxs)(e.p,{children:[\"Suppose we have passed in an array of 3 promises, and the last promise is rejected first, causing \",(0,r.jsx)(e.code,{children:\"errors[2]\"}),\" to be assigned. When this happens, the length of \",(0,r.jsx)(e.code,{children:\"errors\"}),\" array is now 3, and \",(0,r.jsx)(e.code,{children:\"reject()\"}),\" will be invoked with an incomplete \",(0,r.jsx)(e.code,{children:\"errors\"}),\" array because the other 2 promises are still pending; we should not call \",(0,r.jsx)(e.code,{children:\"reject()\"}),\" yet.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"The pending values counter avoids this problem by ensuring that we only call \",(0,r.jsx)(e.code,{children:\"reject()\"}),\" when all the promises have rejected and thus are no longer pending.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Here's an alternative version which uses \",(0,r.jsx)(e.code,{children:\"Promise.then()\"}),\" if you prefer not to use \",(0,r.jsx)(e.code,{children:\"async\"}),\"/\",(0,r.jsx)(e.code,{children:\"await\"}),\".\"]}),`\n`,(0,r.jsx)(a,{children:u}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Empty input array. The promise should reject with an \",(0,r.jsx)(e.code,{children:\"AggregateError\"}),\".\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Knowledge of \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s, how to construct one, how to use them.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Async programming.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"The evaluator does not verify that your input array is resolved concurrently rather than sequentially.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any\",children:\"Promise.any() - JavaScript | MDN\"})}),`\n`]})]})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(m,n)})):m(n)}var _=k;return P(q);})();\n;return Component;"
}