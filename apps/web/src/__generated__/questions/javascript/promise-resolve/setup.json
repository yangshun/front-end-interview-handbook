{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-resolve\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-resolve.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promise-resolve.run.test.ts": "import promiseResolve from './promise-resolve';\n\ndescribe('promiseResolve', () => {\n  test('returns promise', () => {\n    expect(promiseResolve(1) instanceof Promise).toBe(true);\n  });\n\n  test('returns the value', () => {\n    const p = promiseResolve(42);\n    return expect(p).resolves.toBe(42);\n  });\n\n  test('returns the same promise instance', () => {\n    const p = new Promise((resolve) => resolve(42));\n    expect(promiseResolve(p)).toBe(p);\n  });\n\n  test('thenable', () => {\n    const p = promiseResolve({\n      then(resolve: Function) {\n        resolve(42);\n      },\n    });\n\n    return expect(p).resolves.toBe(42);\n  });\n});\n",
    "/src/promise-resolve.submit.test.ts": "import promiseResolve from './promise-resolve';\n\n// TODO: fix tests passing even if resolved value is incorrect.\ndescribe('promiseResolve', () => {\n  test('returns promise', () => {\n    expect(promiseResolve(1)).toBeInstanceOf(Promise);\n  });\n\n  describe('non-promise', () => {\n    test('returns promise', () => {\n      expect(promiseResolve(1)).toBeInstanceOf(Promise);\n    });\n\n    test('resolves', () => {\n      const p = promiseResolve(42);\n      return expect(p).resolves.toBe(42);\n    });\n  });\n\n  describe('promise', () => {\n    test('returns promise', () => {\n      expect(\n        promiseResolve(new Promise((resolve) => resolve(42))),\n      ).toBeInstanceOf(Promise);\n    });\n\n    test('returns the same promise instance', () => {\n      const p = new Promise((resolve) => resolve(42));\n      expect(promiseResolve(p)).toBe(p);\n    });\n\n    test('resolves', () => {\n      const p = promiseResolve(new Promise((resolve) => resolve(42)));\n      return expect(p).resolves.toBe(42);\n    });\n\n    test('nested', () => {\n      const p = promiseResolve(\n        new Promise((resolve) =>\n          resolve(new Promise((resolve) => resolve(42))),\n        ),\n      );\n      return expect(p).resolves.toBe(42);\n    });\n\n    test('rejects', () => {\n      const p = promiseResolve(new Promise((_, reject) => reject(42)));\n      return expect(p).rejects.toBe(42);\n    });\n\n    test('use with then', (done) => {\n      expect.assertions(1);\n      const p = promiseResolve(new Promise((resolve) => resolve(42)));\n      p.then((result) => {\n        expect(result).toBe(42);\n        done();\n      });\n    });\n  });\n\n  describe('thenable', () => {\n    test('returns promise', () => {\n      expect(\n        promiseResolve({\n          then(resolve: Function) {\n            resolve(42);\n          },\n        }),\n      ).toBeInstanceOf(Promise);\n    });\n\n    test('resolves', () => {\n      const p = promiseResolve({\n        then(resolve: Function) {\n          resolve(42);\n        },\n      });\n      return expect(p).resolves.toBe(42);\n    });\n\n    test('throw', () => {\n      const p = promiseResolve({\n        then() {\n          throw 42;\n        },\n      });\n      return expect(p).rejects.toBe(42);\n    });\n\n    test('throw after resolving', () => {\n      const p = promiseResolve({\n        then(resolve: Function) {\n          resolve(42);\n          throw 42;\n        },\n      });\n      return expect(p).resolves.toBe(42);\n    });\n\n    test('rejects', () => {\n      const p = promiseResolve({\n        then(_, reject: Function) {\n          reject(42);\n        },\n      });\n      return expect(p).rejects.toBe(42);\n    });\n\n    test('use with then', (done) => {\n      expect.assertions(1);\n      const p = promiseResolve({\n        then(resolve: Function) {\n          resolve(42);\n        },\n      });\n      p.then((result) => {\n        expect(result).toBe(42);\n        done();\n      });\n    });\n\n    test('nested', () => {\n      const p = promiseResolve({\n        then(resolve: Function) {\n          resolve({\n            then(resolve: Function) {\n              resolve(42);\n            },\n          });\n        },\n      });\n      return expect(p).resolves.toBe(42);\n    });\n\n    test('can access `this`', () => {\n      const p = promiseResolve({\n        value: 42,\n        then(this: any, resolve: Function) {\n          resolve(this.value);\n        },\n      });\n      return expect(p).resolves.toBe(42);\n    });\n  });\n\n  test('use with Promise.all()', () => {\n    const p0 = promiseResolve(3);\n    const p1 = new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve('foo');\n      }, 100);\n    });\n\n    return expect(Promise.all([p0, p1])).resolves.toStrictEqual([3, 'foo']);\n  });\n\n  test('use with Promise.allSettled()', async () => {\n    const p0 = promiseResolve(2);\n    const p1 = promiseResolve(3);\n\n    const res = await Promise.allSettled([p0, p1]);\n    expect(res).toEqual([\n      {\n        status: 'fulfilled',\n        value: 2,\n      },\n      {\n        status: 'fulfilled',\n        value: 3,\n      },\n    ]);\n  });\n\n  test('use with Promise.any()', async () => {\n    const p0 = promiseResolve(2);\n    const p1 = new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(3);\n      }, 10);\n    });\n\n    const res = await Promise.any([p0, p1]);\n    expect(res).toEqual(2);\n  });\n\n  test('use with Promise.race()', async () => {\n    const p0 = promiseResolve(2);\n    const p1 = new Promise((_, reject) => {\n      setTimeout(() => {\n        reject(3);\n      }, 10);\n    });\n\n    const res = await Promise.race([p0, p1]);\n    expect(res).toEqual(2);\n  });\n});\n",
    "/src/promise-resolve.ts": "export default function promiseResolve<T>(\n  value: T | PromiseLike<T>,\n): Promise<Awaited<T>> {\n  if (value instanceof Promise) {\n    return value;\n  }\n\n  if (typeof (value as PromiseLike<T>).then === 'function') {\n    // Note that the typing can be improved.\n    return new Promise((value as PromiseLike<T>).then.bind(value) as any);\n  }\n\n  return new Promise((resolve) => resolve(value as Awaited<T>));\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {*} value\n * @returns Promise\n */\nexport default function promiseResolve(value) {\n  throw 'Not implemented';\n}",
    "ts": "export default function promiseResolve(value: any): Promise<any> {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/promise-resolve.ts",
    "run": "/src/promise-resolve.run.test.ts",
    "submit": "/src/promise-resolve.submit.test.ts"
  }
}