{
  "description": "var Component=(()=>{var h=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var p=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),w=(t,n)=>{for(var c in n)a(t,c,{get:n[c],enumerable:!0})},i=(t,n,c,o)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let s of u(n))!x.call(t,s)&&s!==c&&a(t,s,{get:()=>n[s],enumerable:!(o=m(n,s))||o.enumerable});return t};var k=(t,n,c)=>(c=t!=null?h(f(t)):{},i(n||!t||!t.__esModule?a(c,\"default\",{value:t,enumerable:!0}):c,t)),g=t=>i(a({},\"__esModule\",{value:!0}),t);var d=p((F,r)=>{r.exports=_jsx_runtime});var y={};w(y,{default:()=>b,frontmatter:()=>j});var e=k(d()),j={title:\"Middlewares\",excerpt:\"Implement a function that composes asynchronous middleware functions like in Koa.js\"};function l(t){let n=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",strong:\"strong\",a:\"a\",h2:\"h2\",pre:\"pre\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"Implement a \",(0,e.jsx)(n.code,{children:\"middlewares\"}),\" function that takes any number of middleware functions and composes them into a single callable function. This composed function accepts a \",(0,e.jsx)(n.code,{children:\"context\"}),\", returns a \",(0,e.jsx)(n.code,{children:\"Promise\"}),\", and calls each middleware in order.\"]}),`\n`,(0,e.jsx)(n.p,{children:\"Each middleware is a function that receives two arguments:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"context\"}),\": An object shared across all middlewares\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"next\"}),\": A function that invokes the next middleware in the chain\"]}),`\n`]}),`\n`,(0,e.jsxs)(n.p,{children:[\"When \",(0,e.jsx)(n.code,{children:\"next()\"}),\" is called, the next middleware should run. If a middleware does not call \",(0,e.jsx)(n.code,{children:\"next\"}),\", the chain stops.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"The execution should be \",(0,e.jsx)(n.strong,{children:\"asynchronous and sequential\"}),\", similar to how middleware works in frameworks like \",(0,e.jsx)(n.a,{href:\"https://koajs.com/\",children:\"Koa\"}),\".\"]}),`\n`,(0,e.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`async function fn1(ctx, next) {\n  ctx.stack.push('fn1-start');\n  await next();\n  ctx.stack.push('fn1-end');\n}\n\nasync function fn2(ctx, next) {\n  ctx.stack.push('fn2-start');\n  await new Promise((resolve) => setTimeout(resolve, 1000));\n  await next();\n  ctx.stack.push('fn2-end');\n}\n\nfunction fn3(ctx, next) {\n  ctx.stack.push('fn3-start');\n  next();\n  ctx.stack.push('fn3-end');\n}\n\nconst composedFn = middlewares(fn1, fn2, fn3);\n\nconst context = { stack: [] };\nawait composedFn(context);\n\nconsole.log(context.stack);\n// ['fn1-start', 'fn2-start', 'fn3-start', 'fn3-end', 'fn2-end', 'fn1-end']\n`})})]})}function _(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(l,t)})):l(t)}var b=_;return g(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/middlewares\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/middlewares.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/middlewares.run.test.ts": "import middlewares from './middlewares';\n\nasync function sleep(duration: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n\ndescribe('middlewares', () => {\n  describe('return values', () => {\n    test('returns a function', () => {\n      const fn = middlewares();\n      expect(typeof fn).toBe('function');\n    });\n\n    test('returns a function that returns a promise', () => {\n      const fn = middlewares();\n      const result = fn();\n      expect(result).toBeInstanceOf(Promise);\n      expect(typeof result.then).toBe('function');\n      expect(typeof result.catch).toBe('function');\n    });\n  });\n\n  test('no functions', async () => {\n    const calls: string[] = [];\n\n    const fn = middlewares();\n\n    await fn({});\n    expect(calls).toEqual([]);\n  });\n\n  test('one function', async () => {\n    const calls: string[] = [];\n\n    function f1(ctx: any, next: Function) {\n      calls.push('f1-start');\n      next();\n      calls.push('f1-end');\n    }\n\n    const fn = middlewares(f1);\n\n    await fn({});\n    expect(calls).toEqual(['f1-start', 'f1-end']);\n  });\n\n  describe('two functions', () => {\n    test('synchronous', async () => {\n      const calls: string[] = [];\n\n      function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        next();\n        calls.push('f1-end');\n      }\n\n      function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        next();\n        calls.push('f2-end');\n      }\n\n      const fn = middlewares(f1, f2);\n\n      await fn({});\n      expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n    });\n\n    test('asynchronous', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      async function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        sleep(300);\n        await next();\n        calls.push('f2-end');\n      }\n\n      const fn = middlewares(f1, f2);\n\n      await fn({});\n      expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n    });\n  });\n});\n",
    "/src/middlewares.submit.test.ts": "import middlewares from './middlewares';\n\nasync function sleep(duration: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n\ndescribe('middlewares', () => {\n  describe('return values', () => {\n    test('returns a function', () => {\n      const fn = middlewares();\n      expect(typeof fn).toBe('function');\n    });\n\n    test('returns a function that returns a promise', () => {\n      const fn = middlewares();\n      const result = fn();\n      expect(result).toBeInstanceOf(Promise);\n      expect(typeof result.then).toBe('function');\n      expect(typeof result.catch).toBe('function');\n    });\n  });\n\n  test('no functions', async () => {\n    const calls: string[] = [];\n\n    const fn = middlewares();\n\n    await fn({});\n    expect(calls).toEqual([]);\n  });\n\n  test('one function', async () => {\n    const calls: string[] = [];\n\n    function f1(ctx: any, next: Function) {\n      calls.push('f1-start');\n      next();\n      calls.push('f1-end');\n    }\n\n    const fn = middlewares(f1);\n\n    await fn({});\n    expect(calls).toEqual(['f1-start', 'f1-end']);\n  });\n\n  describe('two functions', () => {\n    test('synchronous', async () => {\n      const calls: string[] = [];\n\n      function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        next();\n        calls.push('f1-end');\n      }\n\n      function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        next();\n        calls.push('f2-end');\n      }\n\n      const fn = middlewares(f1, f2);\n\n      await fn({});\n      expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n    });\n\n    test('asynchronous', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      async function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        sleep(300);\n        await next();\n        calls.push('f2-end');\n      }\n\n      const fn = middlewares(f1, f2);\n\n      await fn({});\n      expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n    });\n  });\n\n  describe('three functions', () => {\n    test('synchronous', async () => {\n      const calls: string[] = [];\n\n      function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        next();\n        calls.push('f1-end');\n      }\n\n      function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        next();\n        calls.push('f2-end');\n      }\n\n      function f3(ctx: any, next: Function) {\n        calls.push('f3-start');\n        next();\n        calls.push('f3-end');\n      }\n\n      const fn = middlewares(f1, f2, f3);\n\n      await fn({});\n      expect(calls).toEqual([\n        'f1-start',\n        'f2-start',\n        'f3-start',\n        'f3-end',\n        'f2-end',\n        'f1-end',\n      ]);\n    });\n\n    test('asynchronous', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      async function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        sleep(300);\n        await next();\n        calls.push('f2-end');\n      }\n\n      async function f3(ctx: any, next: Function) {\n        calls.push('f3-start');\n        await next();\n        calls.push('f3-end');\n      }\n\n      const fn = middlewares(f1, f2, f3);\n\n      await fn({});\n      expect(calls).toEqual([\n        'f1-start',\n        'f2-start',\n        'f3-start',\n        'f3-end',\n        'f2-end',\n        'f1-end',\n      ]);\n    });\n\n    test('middle function sync', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        return next().then(() => {\n          calls.push('f2-end');\n        });\n      }\n\n      async function f3(ctx: any, next: Function) {\n        calls.push('f3-start');\n        await next();\n        calls.push('f3-end');\n      }\n\n      const fn = middlewares(f1, f2, f3);\n\n      await fn({});\n      expect(calls).toEqual([\n        'f1-start',\n        'f2-start',\n        'f3-start',\n        'f3-end',\n        'f2-end',\n        'f1-end',\n      ]);\n    });\n\n    test('last function sync', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      async function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        sleep(300);\n        await next();\n        calls.push('f2-end');\n      }\n\n      function f3(ctx: any, next: Function) {\n        calls.push('f3-start');\n        next();\n        calls.push('f3-end');\n      }\n\n      const fn = middlewares(f1, f2, f3);\n\n      await fn({});\n      expect(calls).toEqual([\n        'f1-start',\n        'f2-start',\n        'f3-start',\n        'f3-end',\n        'f2-end',\n        'f1-end',\n      ]);\n    });\n  });\n\n  test('does not call next()', async () => {\n    const calls: string[] = [];\n\n    async function f1(ctx: any, next: Function) {\n      calls.push('f1-start');\n      await next();\n      calls.push('f1-end');\n    }\n\n    async function f2(ctx: any, next: Function) {\n      calls.push('f2-start');\n      calls.push('f2-end');\n    }\n\n    function f3(ctx: any, next: Function) {\n      calls.push('f3-start');\n      next();\n      calls.push('f3-end');\n    }\n\n    const fn = middlewares(f1, f2, f3);\n\n    await fn({});\n    expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n  });\n\n  test('context is passed', async () => {\n    async function f1(ctx: any, next: Function) {\n      ctx.push('f1-start');\n      await next();\n      ctx.push('f1-end');\n    }\n\n    async function f2(ctx: any, next: Function) {\n      ctx.push('f2-start');\n      await next();\n      ctx.push('f2-end');\n    }\n\n    function f3(ctx: any, next: Function) {\n      ctx.push('f3-start');\n      next();\n      ctx.push('f3-end');\n    }\n\n    const fn = middlewares(f1, f2, f3);\n\n    const context: string[] = [];\n    await fn(context);\n\n    expect(context).toEqual([\n      'f1-start',\n      'f2-start',\n      'f3-start',\n      'f3-end',\n      'f2-end',\n      'f1-end',\n    ]);\n  });\n\n  test('can be called multiple times', async () => {\n    let count = 0;\n\n    async function f1(ctx: any, next: Function) {\n      count++;\n      ctx.push('f1-start');\n      await next();\n      ctx.push('f1-end');\n    }\n\n    async function f2(ctx: any, next: Function) {\n      count++;\n      ctx.push('f2-start');\n      await next();\n      ctx.push('f2-end');\n    }\n\n    function f3(ctx: any, next: Function) {\n      count++;\n      ctx.push('f3-start');\n      next();\n      ctx.push('f3-end');\n    }\n\n    const fn = middlewares(f1, f2, f3);\n\n    const context1: string[] = [];\n    const context2: string[] = [];\n\n    await Promise.all([fn(context1), fn(context2)]);\n\n    expect(context1).toEqual([\n      'f1-start',\n      'f2-start',\n      'f3-start',\n      'f3-end',\n      'f2-end',\n      'f1-end',\n    ]);\n    expect(context2).toEqual([\n      'f1-start',\n      'f2-start',\n      'f3-start',\n      'f3-end',\n      'f2-end',\n      'f1-end',\n    ]);\n    expect(count).toBe(6);\n  });\n});\n",
    "/src/middlewares.ts": "type MiddlewareFn =\n  | ((context: any, next: () => Promise<void>) => Promise<void>)\n  | ((context: any, next: () => Promise<void>) => void);\n\nexport default function middlewares(\n  ...fns: Array<MiddlewareFn>\n): (context?: any) => Promise<void> {\n  return async function (context = {}) {\n    async function execute(index: number): Promise<void> {\n      if (index === fns.length) {\n        return;\n      }\n\n      const fn = fns[index];\n      await fn(context, () => execute(index + 1));\n    }\n\n    await execute(0);\n  };\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": "yangshun",
    "companies": [
      "bytedance",
      "tiktok"
    ],
    "created": 1743206400,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that composes asynchronous middleware functions like in Koa.js",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/middlewares",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "compose"
    ],
    "slug": "middlewares",
    "subtitle": null,
    "title": "Middlewares",
    "topics": [
      "recursion",
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {...Function} fns\n * @returns {Function}\n */\nexport default function middlewares(...fns) {\n  throw 'Not implemented!';\n}",
    "ts": "type MiddlewareFn =\n  | ((context: any, next: () => Promise<void>) => Promise<void>)\n  | ((context: any, next: () => Promise<void>) => void);\n\nexport default function middlewares(\n  ...fns: Array<MiddlewareFn>\n): (context?: any) => Promise<void> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var x=Object.create;var d=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),v=(i,e)=>{for(var t in e)d(i,t,{get:e[t],enumerable:!0})},l=(i,e,t,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of p(e))!y.call(i,c)&&c!==t&&d(i,c,{get:()=>e[c],enumerable:!(r=m(e,c))||r.enumerable});return i};var b=(i,e,t)=>(t=i!=null?x(w(i)):{},l(e||!i||!i.__esModule?d(t,\"default\",{value:i,enumerable:!0}):t,i)),P=i=>l(d({},\"__esModule\",{value:!0}),i);var s=g((S,a)=>{a.exports=_jsx_runtime});var T={};v(T,{default:()=>N});var n=b(s());var o=MDXCodeBlock;var h=`type MiddlewareFn =\n  | ((context: any, next: () => Promise<void>) => Promise<void>)\n  | ((context: any, next: () => Promise<void>) => void);\n\nexport default function middlewares(\n  ...fns: Array<MiddlewareFn>\n): (context?: any) => Promise<void> {\n  return async function (context = {}) {\n    async function execute(index: number): Promise<void> {\n      if (index === fns.length) {\n        return;\n      }\n\n      const fn = fns[index];\n      await fn(context, () => execute(index + 1));\n    }\n\n    await execute(0);\n  };\n}\n`;var u=`type MiddlewareFn =\n  | ((context: any, next: () => Promise<void>) => Promise<void>)\n  | ((context: any, next: () => Promise<void>) => void);\n\nexport default function middlewares(\n  ...fns: Array<MiddlewareFn>\n): (context?: any) => Promise<void> {\n  return function (context = {}) {\n    function execute(index: number): Promise<void> {\n      if (index === fns.length) {\n        return Promise.resolve();\n      }\n\n      const fn = fns[index];\n      return Promise.resolve(fn(context, () => execute(index + 1)));\n    }\n\n    return execute(0);\n  };\n}\n`;function f(i){let e=Object.assign({h2:\"h2\",p:\"p\",strong:\"strong\",code:\"code\",ul:\"ul\",li:\"li\",em:\"em\",h3:\"h3\",pre:\"pre\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This problem is about \",(0,n.jsx)(e.strong,{children:\"function composition\"}),\" with control handed off via a \",(0,n.jsx)(e.code,{children:\"next()\"}),\" callback. The key idea is \",(0,n.jsx)(e.strong,{children:\"recursion\"}),\":\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Each middleware gets called with a \",(0,n.jsx)(e.code,{children:\"next()\"}),\" function\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"When \",(0,n.jsx)(e.code,{children:\"next()\"}),\" is invoked, it should move to the \",(0,n.jsx)(e.em,{children:\"next middleware\"}),\" in the chain\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"This recursion needs to be \",(0,n.jsx)(e.strong,{children:\"asynchronous\"}),\" to support \",(0,n.jsx)(e.code,{children:\"await\"}),\" statements inside each middleware\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"for\"}),\" loop cannot be used because we need to \",(0,n.jsx)(e.code,{children:\"await\"}),\" each layer's completion before continuing. Only recursion or a controlled \",(0,n.jsx)(e.code,{children:\"next\"}),\" chain can model this kind of control flow.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Step 1: Wrapper function\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Define a function \",(0,n.jsx)(e.code,{children:\"middlewares(...fns)\"}),\" that accepts any number of middleware functions and returns a composed callable function. This function accepts the context.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function middlewares(...fns) {\n  return async function(context = {}) {\n    ...\n  };\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Step 2: Recursive execution\"}),`\n`,(0,n.jsx)(e.p,{children:\"This recursive function is responsible for executing each middleware in order.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function execute(index) {\n  if (index === fns.length) {\n    return;\n  }\n\n  const fn = fns[index];\n  await fn(context, () => execute(index + 1));\n}\n`})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"index\"}),\" tracks the position in the middleware chain\"]}),`\n`,(0,n.jsx)(e.li,{children:\"We stop when we reach the end of the chain\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Each \",(0,n.jsx)(e.code,{children:\"fn\"}),\" is called with the current \",(0,n.jsx)(e.code,{children:\"context\"}),\" and a \",(0,n.jsx)(e.code,{children:\"next()\"}),\" function, which calls \",(0,n.jsx)(e.code,{children:\"execute(index + 1)\"})]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This allows \",(0,n.jsx)(e.code,{children:\"await next()\"}),\" to pause execution of the current middleware until all downstream middlewares have completed.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Step 3: Start the chain\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Kick off the middleware chain by calling \",(0,n.jsx)(e.code,{children:\"execute(0)\"}),\" inside the returned function.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`await execute(0);\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Example walkthrough\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// stack = []\n\nfn1 => push \"fn1-start\"\n       await next()\n         \\u21B3 fn2 => push \"fn2-start\"\n                  await delay\n                  await next()\n                    \\u21B3 fn3 => push \"fn3-start\"\n                             next()\n                             push \"fn3-end\"\n                  push \"fn2-end\"\n       push \"fn1-end\"\n\n// Final stack:\n['fn1-start', 'fn2-start', 'fn3-start', 'fn3-end', 'fn2-end', 'fn1-end']\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Here is the full solution:\"}),`\n`,(0,n.jsx)(o,{children:h}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note\"}),\": \",(0,n.jsx)(e.code,{children:\"index\"}),\" should not be defined as a variable outside of the returned function otherwise all invocations of the returned function will reference the same \",(0,n.jsx)(e.code,{children:\"index\"}),\" value and the function can only be called once.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The code below uses a shared \",(0,n.jsx)(e.code,{children:\"index\"}),\" and fails some test cases:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`type MiddlewareFn =\n  | ((context: any, next: () => Promise<void>) => Promise<void>)\n  | ((context: any, next: () => Promise<void>) => void);\n\nexport default function middlewares(\n  ...fns: Array<MiddlewareFn>\n): (context?: any) => Promise<void> {\n  let index = 0; // WRONG: All function invocations share this index\n\n  return async function (context = {}) {\n    async function execute(): Promise<void> {\n      if (index === fns.length) {\n        return;\n      }\n\n      const fn = fns[index];\n      await fn(context, () => {\n        index++;\n        execute();\n      });\n    }\n\n    await execute();\n  };\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Alternative approach: using promises only\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The following solution does not use \",(0,n.jsx)(e.code,{children:\"async\"}),\"/\",(0,n.jsx)(e.code,{children:\"await\"}),\".\"]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsx)(e.h3,{children:\"No middleware provided\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const composed = middlewares();\nawait composed(); // Should do nothing, not crash\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Synchronous middleware\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Your code must still handle \",(0,n.jsx)(e.code,{children:\"next()\"}),\" being called synchronously and not awaited. The recursive structure ensures this still works correctly.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Middleware that does not call \",(0,n.jsx)(e.code,{children:\"next()\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"This will stop the chain early. It's expected behavior:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function fn(ctx, next) {\n  console.log(\"Doesn't call next\");\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Middleware throws\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"You may optionally wrap each middleware call in a \",(0,n.jsx)(e.code,{children:\"try\"}),\"/\",(0,n.jsx)(e.code,{children:\"catch\"}),\" to handle this gracefully, but it's not strictly required unless specified.\"]})]})}function k(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(f,i)})):f(i)}var N=k;return P(T);})();\n;return Component;",
  "workspace": {
    "main": "/src/middlewares.ts",
    "run": "/src/middlewares.run.test.ts",
    "submit": "/src/middlewares.submit.test.ts"
  }
}