{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/middlewares\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/middlewares.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/middlewares.run.test.ts": "import middlewares from './middlewares';\n\nasync function sleep(duration: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n\ndescribe('middlewares', () => {\n  describe('return values', () => {\n    test('returns a function', () => {\n      const fn = middlewares();\n      expect(typeof fn).toBe('function');\n    });\n\n    test('returns a function that returns a promise', () => {\n      const fn = middlewares();\n      const result = fn();\n      expect(result).toBeInstanceOf(Promise);\n      expect(typeof result.then).toBe('function');\n      expect(typeof result.catch).toBe('function');\n    });\n  });\n\n  test('no functions', async () => {\n    const calls: string[] = [];\n\n    const fn = middlewares();\n\n    await fn({});\n    expect(calls).toEqual([]);\n  });\n\n  test('one function', async () => {\n    const calls: string[] = [];\n\n    function f1(ctx: any, next: Function) {\n      calls.push('f1-start');\n      next();\n      calls.push('f1-end');\n    }\n\n    const fn = middlewares(f1);\n\n    await fn({});\n    expect(calls).toEqual(['f1-start', 'f1-end']);\n  });\n\n  describe('two functions', () => {\n    test('synchronous', async () => {\n      const calls: string[] = [];\n\n      function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        next();\n        calls.push('f1-end');\n      }\n\n      function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        next();\n        calls.push('f2-end');\n      }\n\n      const fn = middlewares(f1, f2);\n\n      await fn({});\n      expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n    });\n\n    test('asynchronous', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      async function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        sleep(300);\n        await next();\n        calls.push('f2-end');\n      }\n\n      const fn = middlewares(f1, f2);\n\n      await fn({});\n      expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n    });\n  });\n});\n",
    "/src/middlewares.submit.test.ts": "import middlewares from './middlewares';\n\nasync function sleep(duration: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, duration));\n}\n\ndescribe('middlewares', () => {\n  describe('return values', () => {\n    test('returns a function', () => {\n      const fn = middlewares();\n      expect(typeof fn).toBe('function');\n    });\n\n    test('returns a function that returns a promise', () => {\n      const fn = middlewares();\n      const result = fn();\n      expect(result).toBeInstanceOf(Promise);\n      expect(typeof result.then).toBe('function');\n      expect(typeof result.catch).toBe('function');\n    });\n  });\n\n  test('no functions', async () => {\n    const calls: string[] = [];\n\n    const fn = middlewares();\n\n    await fn({});\n    expect(calls).toEqual([]);\n  });\n\n  test('one function', async () => {\n    const calls: string[] = [];\n\n    function f1(ctx: any, next: Function) {\n      calls.push('f1-start');\n      next();\n      calls.push('f1-end');\n    }\n\n    const fn = middlewares(f1);\n\n    await fn({});\n    expect(calls).toEqual(['f1-start', 'f1-end']);\n  });\n\n  describe('two functions', () => {\n    test('synchronous', async () => {\n      const calls: string[] = [];\n\n      function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        next();\n        calls.push('f1-end');\n      }\n\n      function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        next();\n        calls.push('f2-end');\n      }\n\n      const fn = middlewares(f1, f2);\n\n      await fn({});\n      expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n    });\n\n    test('asynchronous', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      async function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        sleep(300);\n        await next();\n        calls.push('f2-end');\n      }\n\n      const fn = middlewares(f1, f2);\n\n      await fn({});\n      expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n    });\n  });\n\n  describe('three functions', () => {\n    test('synchronous', async () => {\n      const calls: string[] = [];\n\n      function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        next();\n        calls.push('f1-end');\n      }\n\n      function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        next();\n        calls.push('f2-end');\n      }\n\n      function f3(ctx: any, next: Function) {\n        calls.push('f3-start');\n        next();\n        calls.push('f3-end');\n      }\n\n      const fn = middlewares(f1, f2, f3);\n\n      await fn({});\n      expect(calls).toEqual([\n        'f1-start',\n        'f2-start',\n        'f3-start',\n        'f3-end',\n        'f2-end',\n        'f1-end',\n      ]);\n    });\n\n    test('asynchronous', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      async function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        sleep(300);\n        await next();\n        calls.push('f2-end');\n      }\n\n      async function f3(ctx: any, next: Function) {\n        calls.push('f3-start');\n        await next();\n        calls.push('f3-end');\n      }\n\n      const fn = middlewares(f1, f2, f3);\n\n      await fn({});\n      expect(calls).toEqual([\n        'f1-start',\n        'f2-start',\n        'f3-start',\n        'f3-end',\n        'f2-end',\n        'f1-end',\n      ]);\n    });\n\n    test('middle function sync', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        return next().then(() => {\n          calls.push('f2-end');\n        });\n      }\n\n      async function f3(ctx: any, next: Function) {\n        calls.push('f3-start');\n        await next();\n        calls.push('f3-end');\n      }\n\n      const fn = middlewares(f1, f2, f3);\n\n      await fn({});\n      expect(calls).toEqual([\n        'f1-start',\n        'f2-start',\n        'f3-start',\n        'f3-end',\n        'f2-end',\n        'f1-end',\n      ]);\n    });\n\n    test('last function sync', async () => {\n      const calls: string[] = [];\n\n      async function f1(ctx: any, next: Function) {\n        calls.push('f1-start');\n        await next();\n        calls.push('f1-end');\n      }\n\n      async function f2(ctx: any, next: Function) {\n        calls.push('f2-start');\n        sleep(300);\n        await next();\n        calls.push('f2-end');\n      }\n\n      function f3(ctx: any, next: Function) {\n        calls.push('f3-start');\n        next();\n        calls.push('f3-end');\n      }\n\n      const fn = middlewares(f1, f2, f3);\n\n      await fn({});\n      expect(calls).toEqual([\n        'f1-start',\n        'f2-start',\n        'f3-start',\n        'f3-end',\n        'f2-end',\n        'f1-end',\n      ]);\n    });\n  });\n\n  test('does not call next()', async () => {\n    const calls: string[] = [];\n\n    async function f1(ctx: any, next: Function) {\n      calls.push('f1-start');\n      await next();\n      calls.push('f1-end');\n    }\n\n    async function f2(ctx: any, next: Function) {\n      calls.push('f2-start');\n      calls.push('f2-end');\n    }\n\n    function f3(ctx: any, next: Function) {\n      calls.push('f3-start');\n      next();\n      calls.push('f3-end');\n    }\n\n    const fn = middlewares(f1, f2, f3);\n\n    await fn({});\n    expect(calls).toEqual(['f1-start', 'f2-start', 'f2-end', 'f1-end']);\n  });\n\n  test('context is passed', async () => {\n    async function f1(ctx: any, next: Function) {\n      ctx.push('f1-start');\n      await next();\n      ctx.push('f1-end');\n    }\n\n    async function f2(ctx: any, next: Function) {\n      ctx.push('f2-start');\n      await next();\n      ctx.push('f2-end');\n    }\n\n    function f3(ctx: any, next: Function) {\n      ctx.push('f3-start');\n      next();\n      ctx.push('f3-end');\n    }\n\n    const fn = middlewares(f1, f2, f3);\n\n    const context: string[] = [];\n    await fn(context);\n\n    expect(context).toEqual([\n      'f1-start',\n      'f2-start',\n      'f3-start',\n      'f3-end',\n      'f2-end',\n      'f1-end',\n    ]);\n  });\n\n  test('can be called multiple times', async () => {\n    let count = 0;\n\n    async function f1(ctx: any, next: Function) {\n      count++;\n      ctx.push('f1-start');\n      await next();\n      ctx.push('f1-end');\n    }\n\n    async function f2(ctx: any, next: Function) {\n      count++;\n      ctx.push('f2-start');\n      await next();\n      ctx.push('f2-end');\n    }\n\n    function f3(ctx: any, next: Function) {\n      count++;\n      ctx.push('f3-start');\n      next();\n      ctx.push('f3-end');\n    }\n\n    const fn = middlewares(f1, f2, f3);\n\n    const context1: string[] = [];\n    const context2: string[] = [];\n\n    await Promise.all([fn(context1), fn(context2)]);\n\n    expect(context1).toEqual([\n      'f1-start',\n      'f2-start',\n      'f3-start',\n      'f3-end',\n      'f2-end',\n      'f1-end',\n    ]);\n    expect(context2).toEqual([\n      'f1-start',\n      'f2-start',\n      'f3-start',\n      'f3-end',\n      'f2-end',\n      'f1-end',\n    ]);\n    expect(count).toBe(6);\n  });\n});\n",
    "/src/middlewares.ts": "type MiddlewareFn =\n  | ((context: any, next: () => Promise<void>) => Promise<void>)\n  | ((context: any, next: () => Promise<void>) => void);\n\nexport default function middlewares(\n  ...fns: Array<MiddlewareFn>\n): (context?: any) => Promise<void> {\n  return async function (context = {}) {\n    async function execute(index: number): Promise<void> {\n      if (index === fns.length) {\n        return;\n      }\n\n      const fn = fns[index];\n      await fn(context, () => execute(index + 1));\n    }\n\n    await execute(0);\n  };\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {...Function} fns\n * @returns {Function}\n */\nexport default function middlewares(...fns) {\n  throw 'Not implemented!';\n}",
    "ts": "type MiddlewareFn =\n  | ((context: any, next: () => Promise<void>) => Promise<void>)\n  | ((context: any, next: () => Promise<void>) => void);\n\nexport default function middlewares(\n  ...fns: Array<MiddlewareFn>\n): (context?: any) => Promise<void> {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/middlewares.ts",
    "run": "/src/middlewares.run.test.ts",
    "submit": "/src/middlewares.submit.test.ts"
  }
}