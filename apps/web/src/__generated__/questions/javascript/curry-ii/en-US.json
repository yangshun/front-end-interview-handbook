{
  "description": "var Component=(()=>{var l=Object.create;var i=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var r in e)i(n,r,{get:e[r],enumerable:!0})},o=(n,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!f.call(n,a)&&a!==r&&i(n,a,{get:()=>e[a],enumerable:!(c=h(e,a))||c.enumerable});return n};var T=(n,e,r)=>(r=n!=null?l(p(n)):{},o(e||!n||!n.__esModule?i(r,\"default\",{value:n,enumerable:!0}):r,n)),b=n=>o(i({},\"__esModule\",{value:!0}),n);var s=y((F,u)=>{u.exports=_jsx_runtime});var x={};g(x,{default:()=>v,frontmatter:()=>w});var t=T(s()),w={title:\"Curry II\",excerpt:\"Implement a function that transforms a function that takes multiple arguments into a function that can be repeatedly called with any number of arguments\"};function d(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,t.jsx)(e.a,{href:\"/questions/javascript/curry\",children:\"Curry\"}),\", you should complete that first before attempting this question.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Currying is the technique of converting a function that takes multiple arguments into a sequence of functions that each takes a single argument.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement the \",(0,t.jsx)(e.code,{children:\"curry\"}),\" function which accepts a function as the only argument and returns a function that accepts any number of arguments (vs only one argument at a time in \",(0,t.jsx)(e.a,{href:\"/questions/javascript/curry\",children:\"Curry\"}),\") and returns a function which can be repeatedly called until at least the minimum number of arguments has been provided (determined by how many arguments the original function accepts). The initial function argument is then invoked with the provided arguments.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function addTwo(a, b) {\n  return a + b;\n}\nconst curriedAddTwo = curry(addTwo);\ncurriedAddTwo(3)(4); // 7\ncurriedAddTwo(3, 4); // 7\nconst alreadyAddedThree = curriedAddTwo(3);\nalreadyAddedThree(4); // 7\n`})}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function multiplyThree(a, b, c) {\n  return a * b * c;\n}\nconst curriedMultiplyThree = curry(multiplyThree);\ncurriedMultiplyThree(4)(5)(6); // 120\ncurriedMultiplyThree(4)(5, 6); // 120\ncurriedMultiplyThree(4, 5)(6); // 120\ncurriedMultiplyThree(4, 5, 6); // 120\n\nconst containsFour = curriedMultiplyThree(4);\nconst containsFourMulFive = containsFour(5);\ncontainsFourMulFive(6); // 120\n`})})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var v=j;return b(x);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/curry-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/curry-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/curry-ii.run.test.ts": "import curry from './curry-ii';\n\nconst empty = () => 0;\nconst square = (a: number) => a * a;\nconst mul = (a: number, b: number) => a * b;\n\ndescribe('curry', () => {\n  test('returns function', () => {\n    const curried = curry(square);\n    expect(curried).toBeInstanceOf(Function);\n  });\n\n  test('empty function', () => {\n    const curried = curry(empty);\n    expect(curried()).toBe(0);\n  });\n\n  test('single argument', () => {\n    const curried = curry(square);\n    expect(curried()).toBeInstanceOf(Function);\n    expect(curried(2)).toBe(4);\n  });\n\n  test('one arg at a time', () => {\n    const curried = curry(mul);\n    expect(curried()).toBeInstanceOf(Function);\n    expect(curried(7)(3)).toBe(21);\n  });\n\n  test('both args at once', () => {\n    const curried = curry(mul);\n    expect(curried()).toBeInstanceOf(Function);\n    expect(curried(7, 3)).toBe(21);\n  });\n});\n",
    "/src/curry-ii.submit.test.ts": "import curry from './curry-ii';\n\nconst empty = () => 0;\nconst square = (a: number) => a * a;\nconst mul = (a: number, b: number) => a * b;\nconst mulThree = (a: number, b: number, c: number) => a * b * c;\n\ndescribe('curry', () => {\n  test('returns function', () => {\n    const curried = curry(square);\n    expect(curried).toBeInstanceOf(Function);\n  });\n\n  test('empty function', () => {\n    const curried = curry(empty);\n    expect(curried()).toBe(0);\n  });\n\n  test('single argument', () => {\n    const curried = curry(square);\n    expect(curried()).toBeInstanceOf(Function);\n    expect(curried(2)).toBe(4);\n  });\n\n  describe('two arguments', () => {\n    test('one arg at a time', () => {\n      const curried = curry(mul);\n      expect(curried()).toBeInstanceOf(Function);\n      expect(curried(7)(3)).toBe(21);\n    });\n\n    test('both args at once', () => {\n      const curried = curry(mul);\n      expect(curried()).toBeInstanceOf(Function);\n      expect(curried(7, 3)).toBe(21);\n    });\n  });\n\n  describe('multiple arguments', () => {\n    test('one arg at a time', () => {\n      const curried = curry(mulThree);\n      expect(curried()).toBeInstanceOf(Function);\n      expect(curried(7)(3)(2)).toBe(42);\n    });\n\n    test('multiple args at once', () => {\n      const curried = curry(mulThree);\n      expect(curried()).toBeInstanceOf(Function);\n      expect(curried(7, 3, 2)).toBe(42);\n      expect(curried(7, 3)(2)).toBe(42);\n      expect(curried(7)(3, 2)).toBe(42);\n    });\n  });\n\n  test('can be reused', () => {\n    const curried = curry(square);\n    expect(curried()).toBeInstanceOf(Function);\n    expect(curried(2)).toBe(4);\n    expect(curried(3)).toBe(9);\n  });\n\n  test('ignores empty args', () => {\n    const curried = curry(mulThree);\n    expect(curried()(4)()(3)()(2)).toBe(24);\n    expect(curried()()()()(4)(2)(3)).toBe(24);\n  });\n\n  describe('can access this', () => {\n    test('single parameter', () => {\n      const curried = curry(function (this: any, val: number) {\n        return this.multiplier * val;\n      });\n\n      const obj = { multiplier: 5, mul: curried };\n      expect(obj.mul()).toBeInstanceOf(Function);\n      expect(obj.mul(7)).toBe(35);\n    });\n\n    test('multiple arguments', () => {\n      const curried = curry(function (this: any, foo: number, bar: number) {\n        return this.base * foo + bar;\n      });\n\n      const obj = { base: 5, mul: curried };\n      expect(obj.mul()).toBeInstanceOf(Function);\n      expect(obj.mul(3)(2)).toBe(17);\n      expect(obj.mul(3, 2)).toBe(17);\n      expect(obj.mul(3)()(2)).toBe(17);\n      expect(obj.mul()(3)()(2)).toBe(17);\n    });\n  });\n});\n",
    "/src/curry-ii.ts": "/**\n * @param {Function} func\n * @return {Function}\n */\nexport default function curry(func: Function): Function {\n  return function curried(this: any, ...args: Array<any>) {\n    if (args.length === func.length) {\n      return func.apply(this, args);\n    }\n\n    return (...args2: Array<any>) => curried.apply(this, [...args, ...args2]);\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [
      "qualcomm"
    ],
    "created": 1655510400,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that transforms a function that takes multiple arguments into a function that can be repeatedly called with any number of arguments",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/curry-ii",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "curry-iii"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "curry"
    ],
    "slug": "curry-ii",
    "subtitle": null,
    "title": "Curry II",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Function} func\n * @return {Function}\n */\nexport default function curry(func) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function curry(func: Function): Function {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var c=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(r,n)=>()=>(n||r((n={exports:{}}).exports,n),n.exports),F=(r,n)=>{for(var t in n)c(r,t,{get:n[t],enumerable:!0})},u=(r,n,t,a)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let i of v(n))!x.call(r,i)&&i!==t&&c(r,i,{get:()=>n[i],enumerable:!(a=y(n,i))||a.enumerable});return r};var k=(r,n,t)=>(t=r!=null?m(w(r)):{},u(n||!r||!r.__esModule?c(t,\"default\",{value:r,enumerable:!0}):t,r)),C=r=>u(c({},\"__esModule\",{value:!0}),r);var l=b((I,s)=>{s.exports=_jsx_runtime});var S={};F(S,{default:()=>M});var e=k(l());var o=MDXCodeBlock;var h=`/**\n * @param {Function} func\n * @return {Function}\n */\nexport default function curry(func) {\n  return function curried(...args) {\n    if (args.length === func.length) {\n      return func.apply(this, args);\n    }\n\n    return (...args2) => curried.apply(this, [...args, ...args2]);\n  };\n}\n`;var d=`/**\n * @param {Function} func\n * @return {Function}\n */\nexport default function curry(func: Function): Function {\n  return function curried(this: any, ...args: Array<any>) {\n    if (args.length === func.length) {\n      return func.apply(this, args);\n    }\n\n    return (...args2: Array<any>) => curried.apply(this, [...args, ...args2]);\n  };\n}\n`;var f=`/**\n * @param {Function} func\n * @return {Function}\n */\nexport default function curry(func) {\n  return function curried(...args) {\n    if (args.length >= func.length) {\n      return func.apply(this, args);\n    }\n\n    return curried.bind(this, ...args);\n  };\n}\n`;var g=`/**\n * @param {Function} func\n * @return {Function}\n */\nexport default function curry(func) {\n  return function curried(...args) {\n    if (args.length >= func.length) {\n      return func.call(this, ...args);\n    }\n\n    return (...args2) => curried.call(this, ...args, ...args2);\n  };\n}\n`;function p(r){let n=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",strong:\"strong\",a:\"a\"},r.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"Currying is not commonly used in real-world development but is a moderately common question for interviews as it tests the candidate's understanding of certain JavaScript fundamentals like arity and closures.\"}),`\n`,(0,e.jsx)(n.h2,{children:\"Clarification questions\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"What value types will \",(0,e.jsx)(n.code,{children:\"curry\"}),\" expect?\"]}),`\n`,(0,e.jsx)(n.li,{children:\"Should the function expect values of different types?\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Solution\"}),`\n`,(0,e.jsx)(n.p,{children:\"We first need to understand a few terms:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Arity\"}),\": The number of arguments or operands taken by a function.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Closure\"}),\": A closure is the combination of a function bundled together with references to its lexical environment (surrounding state).\"]}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"The curried function will stop accepting arguments after the number of arguments have been passed into the curried function equals the arity of the original function.\"}),`\n`,(0,e.jsx)(n.p,{children:\"We can keep a record of the curried function arguments so far via closures. Each time the curried function is called, we compare the number of arguments so far with the arity of the original function.\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"If they're the same, we call the original function with the arguments.\"}),`\n`,(0,e.jsx)(n.li,{children:\"If more arguments are needed, we will return a function that accepts more arguments and invokes the curried function with the new arguments.\"}),`\n`]}),`\n`,(0,e.jsxs)(n.p,{children:[\"The solutions for this question can also work for \",(0,e.jsx)(n.a,{href:\"/questions/javascript/curry/\",children:\"Curry\"}),\", because this solution is a general version that doesn't make any assumptions on the number of arguments needed.\"]}),`\n`,(0,e.jsx)(o,{languages:{jsx:h,tsx:d}}),`\n`,(0,e.jsxs)(n.p,{children:[\"An alternative solution using \",(0,e.jsx)(n.code,{children:\"Function.prototype.call\"}),\":\"]}),`\n`,(0,e.jsx)(o,{children:g}),`\n`,(0,e.jsxs)(n.p,{children:[\"Since the innermost function is essentially meant for preserving the \",(0,e.jsx)(n.code,{children:\"this\"}),\" scope and passing arguments along, it can be achieved with \",(0,e.jsx)(n.code,{children:\"Function.prototype.bind\"}),\":\"]}),`\n`,(0,e.jsx)(o,{children:f}),`\n`,(0,e.jsx)(n.h2,{children:\"Edge cases\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Calling the function without any arguments should not have any effect, unless the function does not take in any arguments.\"}),`\n`,(0,e.jsxs)(n.li,{children:[\"Functions which access \",(0,e.jsx)(n.code,{children:\"this\"}),\". Do test this case for curried functions that are meant to receive multiple arguments as well.\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Techniques\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Closures.\"}),`\n`,(0,e.jsxs)(n.li,{children:[\"Invoking functions via \",(0,e.jsx)(n.code,{children:\"Function.prototype.apply()\"}),\"/\",(0,e.jsx)(n.code,{children:\"Function.prototype.call()\"}),\".\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Notes\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"Intermediate functions should be reusable as seen from the examples in the question description.\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Resources\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://blog.logrocket.com/understanding-javascript-currying\",children:\"Understanding JavaScript currying\"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://lodash.com/docs/4.17.15#curry\",children:\"Lodash curry\"})}),`\n`]})]})}function D(r={}){let{wrapper:n}=r.components||{};return n?(0,e.jsx)(n,Object.assign({},r,{children:(0,e.jsx)(p,r)})):p(r)}var M=D;return C(S);})();\n;return Component;",
  "workspace": {
    "main": "/src/curry-ii.ts",
    "run": "/src/curry-ii.run.test.ts",
    "submit": "/src/curry-ii.submit.test.ts"
  }
}