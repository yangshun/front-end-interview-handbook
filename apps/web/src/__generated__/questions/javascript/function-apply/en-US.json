{
  "description": "var Component=(()=>{var d=Object.create;var r=Object.defineProperty;var s=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var o in e)r(n,o,{get:e[o],enumerable:!0})},i=(n,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of u(e))!y.call(n,c)&&c!==o&&r(n,c,{get:()=>e[c],enumerable:!(a=s(e,c))||a.enumerable});return n};var j=(n,e,o)=>(o=n!=null?d(m(n)):{},i(e||!n||!n.__esModule?r(o,\"default\",{value:n,enumerable:!0}):o,n)),v=n=>i(r({},\"__esModule\",{value:!0}),n);var p=g((A,l)=>{l.exports=_jsx_runtime});var _={};f(_,{default:()=>b,frontmatter:()=>x});var t=j(p()),x={title:\"Function.prototype.apply\",excerpt:\"Implement the Function.prototype.apply() function that calls the function with a given `this` value and arguments as an array\"};function h(n){let e=Object.assign({blockquote:\"blockquote\",p:\"p\",code:\"code\",em:\"em\",a:\"a\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" method calls the specified function with a given \",(0,t.jsx)(e.code,{children:\"this\"}),\" value, and \",(0,t.jsx)(e.code,{children:\"arguments\"}),\" provided as an array (or an array-like object).\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsxs)(e.em,{children:[\"Source: \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/apply\",children:\"Function.prototype.apply() - JavaScript | MDN\"})]})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement your own \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" without calling the native \",(0,t.jsx)(e.code,{children:\"apply\"}),\" method. To avoid overwriting the actual \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply\"}),\", implement the function as \",(0,t.jsx)(e.code,{children:\"Function.prototype.myApply\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function multiplyAge(multiplier = 1) {\n  return this.age * multiplier;\n}\n\nconst mary = {\n  age: 21,\n};\n\nconst john = {\n  age: 42,\n};\n\nmultiplyAge.myApply(mary); // 21\nmultiplyAge.myApply(john, [2]); // 84\n`})})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var b=F;return v(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/function-apply\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/function-apply.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/function-apply.run.test.ts": "import './function-apply';\n\ndescribe('Function.prototype.myApply', () => {\n  const person = {\n    name: 'John',\n  };\n\n  function getName(this: any) {\n    return this.name;\n  }\n\n  function sum(...args: Array<number>) {\n    return args.reduce((acc, num) => acc + num, 0);\n  }\n\n  test('Function.prototype.myApply is a function', () => {\n    expect(typeof Function.prototype.myApply).toBe('function');\n  });\n\n  test('`this` is bound', () => {\n    expect(getName.myApply(person)).toStrictEqual('John');\n  });\n\n  test('with a parameter', () => {\n    expect(sum.myApply(null, [1])).toBe(1);\n  });\n});\n",
    "/src/function-apply.submit.test.ts": "import './function-apply';\n\ndescribe('Function.prototype.myApply', () => {\n  const person = {\n    name: 'John',\n  };\n\n  function getName(this: any) {\n    return this.name;\n  }\n\n  function sum(...args: Array<number>) {\n    return args.reduce((acc, num) => acc + num, 0);\n  }\n\n  function greeting(this: any, prefix: string, message: string) {\n    return `${prefix} ${this.name}, ${message}`;\n  }\n\n  test('Function.prototype.myApply is a function', () => {\n    expect(typeof Function.prototype.myApply).toBe('function');\n  });\n\n  test('`this` is bound', () => {\n    expect(getName.myApply(person)).toStrictEqual('John');\n  });\n\n  describe('without `this`', () => {\n    test('single parameter', () => {\n      expect(sum.myApply(null, [1])).toBe(1);\n    });\n\n    test('two parameters', () => {\n      expect(sum.myApply(null, [1, 2])).toBe(3);\n    });\n\n    test('three parameters', () => {\n      expect(sum.myApply(null, [1, 2, 3])).toBe(6);\n    });\n  });\n\n  test('`this` and parameters', () => {\n    expect(greeting.myApply(person, ['Hello', 'how are you?'])).toStrictEqual(\n      'Hello John, how are you?',\n    );\n  });\n});\n",
    "/src/function-apply.ts": "interface Function {\n  myApply(this: any, thisArg: any, argArray?: any[]): any;\n}\n\nFunction.prototype.myApply = function (thisArg, argArray = []) {\n  return this.bind(thisArg)(...argArray);\n};\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1690329600,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement the Function.prototype.apply() function that calls the function with a given `this` value and arguments as an array",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/function-apply",
    "importance": "medium",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "function-bind",
      "function-call"
    ],
    "slug": "function-apply",
    "subtitle": null,
    "title": "Function.prototype.apply",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n * @param thisArg The object to be used as the this object.\n * @param argArray A set of arguments to be passed to the function.\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, argArray) {\n  throw 'Not implemented!';\n};",
    "ts": "interface Function {\n  myApply(this: any, thisArg: any, argArray?: any[]): any;\n}\n\nFunction.prototype.myApply = function (thisArg, args) {\n  throw 'Not implemented!';\n};"
  },
  "solution": "var Component=(()=>{var m=Object.create;var a=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var F=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var r in e)a(n,r,{get:e[r],enumerable:!0})},s=(n,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of A(e))!w.call(n,i)&&i!==r&&a(n,i,{get:()=>e[i],enumerable:!(c=b(e,i))||c.enumerable});return n};var v=(n,e,r)=>(r=n!=null?m(j(n)):{},s(e||!n||!n.__esModule?a(r,\"default\",{value:n,enumerable:!0}):r,n)),C=n=>s(a({},\"__esModule\",{value:!0}),n);var l=F((q,h)=>{h.exports=_jsx_runtime});var X={};x(X,{default:()=>D});var t=v(l());var o=MDXCodeBlock;var d=`/**\n * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n * @param thisArg The object to be used as the this object.\n * @param argArray A set of arguments to be passed to the function.\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, argArray = []) {\n  return this.bind(thisArg)(...argArray);\n};\n`;var p=`interface Function {\n  myApply(this: any, thisArg: any, argArray?: any[]): any;\n}\n\nFunction.prototype.myApply = function (thisArg, argArray = []) {\n  return this.bind(thisArg)(...argArray);\n};\n`;var u=`/**\n * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n * @param thisArg The object to be used as the this object.\n * @param argArray A set of arguments to be passed to the function.\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, argArray = []) {\n  return this.bind(thisArg, ...argArray)();\n};\n`;var y=`/**\n * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n * @param thisArg The object to be used as the this object.\n * @param argArray A set of arguments to be passed to the function.\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, argArray = []) {\n  return this.call(thisArg, ...argArray);\n};\n`;var f=`/**\n * Calls the function, substituting the specified object for the this value of the function, and the specified array for the arguments of the function.\n * @param thisArg The object to be used as the this object.\n * @param argArray A set of arguments to be passed to the function.\n * @return {any}\n */\nFunction.prototype.myApply = function (thisArg, argArray = []) {\n  const sym = Symbol();\n  const wrapperObj = Object(thisArg);\n  Object.defineProperty(wrapperObj, sym, {\n    enumerable: false,\n    value: this,\n  });\n\n  return wrapperObj[sym](...argArray);\n};\n`;function g(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",h3:\"h3\",pre:\"pre\",ul:\"ul\",li:\"li\",strong:\"strong\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" function is a built-in method in JavaScript that allows you to call a function with a specified this value and an array of arguments. Like \",(0,t.jsx)(e.code,{children:\"Function.prototype.call()\"}),\", it allows you to explicitly define the context (\",(0,t.jsx)(e.code,{children:\"this\"}),\" value) in which the function will be executed.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"As \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" takes in an array of arguments, we have to define a default empty array parameter for \",(0,t.jsx)(e.code,{children:\"argArray\"}),\" if we are to spread it, because we can only spread iterables.\"]}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 1: Using \",(0,t.jsx)(e.code,{children:\"bind\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"bind\"}),\", \",(0,t.jsx)(e.code,{children:\"apply\"}),\", and \",(0,t.jsx)(e.code,{children:\"call\"}),\" can be viewed as sibling functions. They're highly similar in terms of function signature and usage. Within \",(0,t.jsx)(e.code,{children:\"Function.prototype\"}),\" methods, \",(0,t.jsx)(e.code,{children:\"this\"}),\" refers to the \",(0,t.jsx)(e.code,{children:\"Function\"}),\" object itself. If the \",(0,t.jsx)(e.code,{children:\"this\"}),\" context is not used at all, the following will work:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`Function.prototype.myApply = function (thisArg, argArray = []) {\n  return this(...argArray);\n};\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"However, \",(0,t.jsx)(e.code,{children:\"thisArg\"}),\" is still used widely in modern code, so we need another way to do this. \",(0,t.jsx)(e.code,{children:\"Function.prototype.bind\"}),\" creates a new function with a specified \",(0,t.jsx)(e.code,{children:\"this\"}),\" value and initial arguments, without executing the original function immediately. It allows us to permanently bind a specific context (\",(0,t.jsx)(e.code,{children:\"this\"}),\" value) to the function and partially apply arguments if needed. This is exactly what we need to bridge the gap in the solution above.\"]}),`\n`,(0,t.jsx)(o,{languages:{jsx:d,tsx:p}}),`\n`,(0,t.jsxs)(e.p,{children:[\"Or you can also pass the \",(0,t.jsx)(e.code,{children:\"argArray\"}),\" into \",(0,t.jsx)(e.code,{children:\"bind()\"}),\" before executing it.\"]}),`\n`,(0,t.jsx)(o,{children:u}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 2: Using \",(0,t.jsx)(e.code,{children:\"call\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"Function.prototype.call\"}),\" and \",(0,t.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" are very similar. Here's an easy way to remember each function's signature:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Function.prototype.call\"}),\" takes in a \",(0,t.jsx)(e.strong,{children:\"c\"}),\"omma-separated list of arguments.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" takes in an \",(0,t.jsx)(e.strong,{children:\"a\"}),\"rray of arguments.\"]}),`\n`]}),`\n`,(0,t.jsx)(o,{children:y}),`\n`,(0,t.jsxs)(e.h3,{children:[\"Approach 3: Using \",(0,t.jsx)(e.code,{children:\"Symbol\"})]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Another approach is to create a \",(0,t.jsx)(e.code,{children:\"Symbol\"}),\" and add it as a property to a newly-created \",(0,t.jsx)(e.code,{children:\"Object\"}),\" with \",(0,t.jsx)(e.code,{children:\"thisArg\"}),\" bound to it. This is very similar to one of the solutions to the \",(0,t.jsx)(e.a,{href:\"/questions/javascript/function-bind\",children:(0,t.jsx)(e.code,{children:\"Function.prototype.bind\"})}),\" question.\"]}),`\n`,(0,t.jsx)(o,{children:f})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(g,n)})):g(n)}var D=M;return C(X);})();\n;return Component;",
  "workspace": {
    "main": "/src/function-apply.ts",
    "run": "/src/function-apply.run.test.ts",
    "submit": "/src/function-apply.submit.test.ts"
  }
}