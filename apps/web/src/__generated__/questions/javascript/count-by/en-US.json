{
  "description": "var Component=(()=>{var s=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var t in e)c(r,t,{get:e[t],enumerable:!0})},i=(r,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!y.call(r,o)&&o!==t&&c(r,o,{get:()=>e[o],enumerable:!(a=u(e,o))||a.enumerable});return r};var j=(r,e,t)=>(t=r!=null?s(p(r)):{},i(e||!r||!r.__esModule?c(t,\"default\",{value:r,enumerable:!0}):t,r)),x=r=>i(c({},\"__esModule\",{value:!0}),r);var d=f((T,l)=>{l.exports=_jsx_runtime});var k={};g(k,{default:()=>_,frontmatter:()=>b});var n=j(d()),b={title:\"Count By\",excerpt:\"Implement a function that counts the number of times a value appears in an array based on a function or property name\"};function h(r){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",ul:\"ul\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a function \",(0,n.jsx)(e.code,{children:\"countBy(array, iteratee)\"}),\" that creates an object composed of keys generated from the results of running each element of \",(0,n.jsx)(e.code,{children:\"array\"}),\" through \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\". The corresponding value of each key is the number of times the key was returned by \",(0,n.jsx)(e.code,{children:\"iteratee\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`countBy(array, iteratee);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"array\"}),\" \",(0,n.jsx)(e.em,{children:\"(Array)\"}),\": The array to iterate over.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"iteratee\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The iteratee function to transform elements. The function is invoked with one argument: \",(0,n.jsx)(e.em,{children:\"(value)\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:(0,n.jsx)(e.code,{children:\"(Object)\"})}),\": Returns the composed aggregate object.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`countBy([6.1, 4.2, 6.3], Math.floor);\n// => { '4': 1, '6': 2 }\n\ncountBy([{ n: 3 }, { n: 5 }, { n: 3 }], (o) => o.n);\n// => { '3': 2, '5': 1 }\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The function should return \",\" when \",(0,n.jsx)(e.code,{children:\"array\"}),\" is empty and treat null / undefined keys after going through iteratee as it is.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`countBy([], (o) => o); // => {}\n\ncountBy([{ n: 1 }, { n: 2 }], (o) => o.m); // => { undefined: 2 }\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#countBy\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.countBy\"})]})}),`\n`]})]})}function B(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var _=B;return x(k);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/count-by\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/count-by.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/count-by.run.test.ts": "import countBy from './count-by';\n\ndescribe('countBy', () => {\n  test('empty array', () => {\n    expect(countBy([], Math.floor)).toEqual({});\n  });\n\n  test('single-element arrays', () => {\n    expect(countBy([6.1], Math.floor)).toEqual({ 6: 1 });\n  });\n\n  test('two-element arrays', () => {\n    expect(countBy([6.1, 4.2], Math.floor)).toEqual({ 4: 1, 6: 1 });\n  });\n});\n",
    "/src/count-by.submit.test.ts": "import countBy from './count-by';\n\ndescribe('countBy', () => {\n  test('empty array', () => {\n    expect(countBy([], Math.floor)).toEqual({});\n  });\n\n  test('undefined keys', () => {\n    expect(countBy([{ n: 1 }, { n: 2 }], (o: any) => o.m)).toEqual({\n      undefined: 2,\n    });\n  });\n\n  describe('function iteratees', () => {\n    test('single-element arrays', () => {\n      expect(countBy([6.1], Math.floor)).toEqual({ 6: 1 });\n    });\n\n    test('two-element arrays', () => {\n      expect(countBy([6.1, 4.2], Math.floor)).toEqual({ 4: 1, 6: 1 });\n    });\n\n    test('multiple element arrays', () => {\n      expect(countBy([6.1, 4.2, 6.3], Math.floor)).toEqual({ 4: 1, 6: 2 });\n    });\n\n    test('keys that are also properties', () => {\n      expect(\n        countBy(['one', 'two', 'three'], (val: string) => 'length'),\n      ).toEqual({\n        length: 3,\n      });\n    });\n  });\n\n  test('does not mutate the original array', () => {\n    const arr = [6.1, 4.2, 6.3];\n    const copy = arr.slice();\n    const result = countBy(arr, Math.floor);\n    expect(result).toEqual({ 4: 1, 6: 2 });\n    expect(arr).toEqual(copy); // Ensure original array is unchanged\n  });\n});\n",
    "/src/count-by.ts": "export default function countBy<T>(\n  array: Array<T>,\n  iteratee: (value: T) => number | string | undefined,\n): Record<string, number> {\n  const result: Record<string, number> = {};\n\n  for (const element of array) {\n    const key = String(iteratee(element));\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = 0;\n    }\n\n    result[key]++;\n  }\n\n  return result;\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": null,
    "companies": [],
    "created": 1690416000,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a function that counts the number of times a value appears in an array based on a function or property name",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/count-by",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "group-by"
    ],
    "slug": "count-by",
    "subtitle": null,
    "title": "Count By",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns the composed aggregate object.\n */\nexport default function countBy(array, iteratee) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function countBy<T>(\n  array: Array<T>,\n  iteratee: (value: T) => number | string,\n): Record<string, number> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var a=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var k=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var x=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),v=(r,e)=>{for(var n in e)a(r,n,{get:e[n],enumerable:!0})},s=(r,e,n,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of b(e))!j.call(r,o)&&o!==n&&a(r,o,{get:()=>e[o],enumerable:!(i=g(e,o))||i.enumerable});return r};var B=(r,e,n)=>(n=r!=null?f(k(r)):{},s(e||!r||!r.__esModule?a(n,\"default\",{value:r,enumerable:!0}):n,r)),O=r=>s(a({},\"__esModule\",{value:!0}),r);var u=x((D,l)=>{l.exports=_jsx_runtime});var C={};v(C,{default:()=>S});var t=B(u());var c=MDXCodeBlock;var h=`/**\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns the composed aggregate object.\n */\nexport default function countBy(array, iteratee) {\n  const result = {};\n\n  for (const element of array) {\n    const key = String(iteratee(element));\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = 0;\n    }\n\n    result[key]++;\n  }\n\n  return result;\n}\n`;var d=`export default function countBy<T>(\n  array: Array<T>,\n  iteratee: (value: T) => number | string | undefined,\n): Record<string, number> {\n  const result: Record<string, number> = {};\n\n  for (const element of array) {\n    const key = String(iteratee(element));\n    if (!Object.prototype.hasOwnProperty.call(result, key)) {\n      result[key] = 0;\n    }\n\n    result[key]++;\n  }\n\n  return result;\n}\n`;var y=`/**\n * @param {Array} array The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns the composed aggregate object.\n */\nexport default function countBy(array, iteratee) {\n  const result = Object.create(null);\n\n  for (const element of array) {\n    const key = String(iteratee(element));\n    result[key] ??= 0;\n    result[key]++;\n  }\n\n  return result;\n}\n`;var m=`export default function countBy<T>(\n  array: Array<T>,\n  iteratee: (value: T) => number | string | undefined,\n): Record<string, number> {\n  const result: Record<string, number> = Object.create(null);\n  for (const element of array) {\n    const key = String(iteratee(element));\n    result[key] ??= 0;\n    result[key]++;\n  }\n  return result;\n}\n`;function p(r){let e=Object.assign({h2:\"h2\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",p:\"p\",a:\"a\",ul:\"ul\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Approach 1: Standard method of basic functions\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Create an empty \",(0,t.jsx)(e.code,{children:\"result\"}),\" object to store the count of occurrences of each key.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through the array and determine the key for each element by calling \",(0,t.jsx)(e.code,{children:\"iteratee(element)\"}),\". If the key does not exist within the \",(0,t.jsx)(e.code,{children:\"result\"}),\" object, set the value for that key to 0. Next we can increment the value for that key.\"]}),`\n`]}),`\n`,(0,t.jsx)(c,{languages:{jsx:h,tsx:d}}),`\n`,(0,t.jsx)(e.h3,{children:\"Approach 2: Using nullish coalescing assignment operator\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"An alternative way to increment the \",(0,t.jsx)(e.code,{children:\"result\"}),\" counter is to use the \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_assignment\",children:\"nullish coalescing assignment operator\"}),\" to set the value to 0 if \",(0,t.jsx)(e.code,{children:\"key\"}),\" doesn't exist within \",(0,t.jsx)(e.code,{children:\"result\"}),\". Note that using nullish coalescing assignment operator means you might be accessing inherited properties, which is not desired, but since the object is created via \",(0,t.jsx)(e.code,{children:\"Object.create(null)\"}),\", there will not be inherited properties and is safe to use.\"]}),`\n`,(0,t.jsx)(c,{languages:{jsx:y,tsx:m}}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#countBy\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.countBy\"})]})}),`\n`]})]})}function R(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(p,r)})):p(r)}var S=R;return O(C);})();\n;return Component;",
  "workspace": {
    "main": "/src/count-by.ts",
    "run": "/src/count-by.run.test.ts",
    "submit": "/src/count-by.submit.test.ts"
  }
}