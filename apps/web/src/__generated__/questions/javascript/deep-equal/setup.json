{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/deep-equal\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/deep-equal.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/deep-equal.run.test.ts": "import deepEqual from './deep-equal';\n\ndescribe('deepEqual', () => {\n  test('primitive values', () => {\n    expect(deepEqual(0, 0)).toEqual(true);\n    expect(deepEqual(true, 1)).toEqual(false);\n    expect(deepEqual(false, false)).toEqual(true);\n    expect(deepEqual(null, null)).toEqual(true);\n  });\n\n  test('arrays', () => {\n    expect(deepEqual(['1'], ['1'])).toEqual(true);\n    expect(deepEqual([1, 2, 3], [1, 3, 2])).toEqual(false);\n  });\n\n  test('objects', () => {\n    expect(deepEqual({ foo: 'bar' }, { foo: 'bar' })).toEqual(true);\n    expect(deepEqual({ foo: 'bar', id: 1 }, { foo: 'bar', id: 1 })).toEqual(\n      true,\n    );\n  });\n});\n",
    "/src/deep-equal.submit.test.ts": "import deepEqual from './deep-equal';\n\ndescribe('deepEqual', () => {\n  test('primitive values', () => {\n    expect(deepEqual(0, 0)).toEqual(true);\n    expect(deepEqual('foo', 'foo')).toEqual(true);\n    expect(deepEqual(true, 1)).toEqual(false);\n    expect(deepEqual(true, true)).toEqual(true);\n    expect(deepEqual(false, false)).toEqual(true);\n    expect(deepEqual(null, null)).toEqual(true);\n  });\n\n  describe('arrays', () => {\n    test('empty', () => {\n      expect(deepEqual([], [])).toEqual(true);\n      expect(deepEqual({}, [])).toEqual(false);\n    });\n\n    test('number and strings', () => {\n      expect(deepEqual([1], [1])).toEqual(true);\n      expect(deepEqual(['1'], ['1'])).toEqual(true);\n      expect(deepEqual([1], ['1'])).toEqual(false);\n      expect(deepEqual([1, 2], [1, 2])).toEqual(true);\n      expect(deepEqual([1, 2, 3], [1, 2, 3])).toEqual(true);\n      expect(deepEqual([1, 2, 3], [1, 3, 2])).toEqual(false);\n    });\n\n    test('boolean', () => {\n      expect(deepEqual([true], [true])).toEqual(true);\n      expect(deepEqual([true], [1])).toEqual(false);\n      expect(deepEqual([false], [false])).toEqual(true);\n      expect(deepEqual([true], [false])).toEqual(false);\n      expect(deepEqual([0], [false])).toEqual(false);\n    });\n\n    test('null-ish', () => {\n      expect(deepEqual([null], [null])).toEqual(true);\n    });\n\n    test('objects', () => {\n      expect(deepEqual([{ foo: 1 }], [{ foo: 1 }])).toEqual(true);\n      expect(deepEqual([{ foo: 1 }], [{ foo: 2 }])).toEqual(false);\n    });\n  });\n\n  describe('objects', () => {\n    test('empty', () => {\n      expect(deepEqual({}, {})).toEqual(true);\n    });\n\n    test('basic', () => {\n      expect(deepEqual({}, {})).toEqual(true);\n      expect(deepEqual({ foo: 'bar' }, { foo: 'bar' })).toEqual(true);\n      expect(deepEqual({ foo: 'bar', id: 1 }, { foo: 'bar', id: 1 })).toEqual(\n        true,\n      );\n      expect(deepEqual({ foo: 'bar', id: 1 }, { foo: 'bar', id: '1' })).toEqual(\n        false,\n      );\n    });\n\n    test('different keys', () => {\n      expect(deepEqual({ foo: 'bar' }, { fob: 'bar' })).toEqual(false);\n    });\n\n    test('different values', () => {\n      expect(deepEqual({ foo: 'bar' }, { foo: 'baz' })).toEqual(false);\n    });\n\n    test('same keys but different types', () => {\n      expect(deepEqual({ 0: 'foo' }, ['foo'])).toEqual(false);\n    });\n\n    test('array', () => {\n      expect(\n        deepEqual(\n          { foo: 'bar', item: [1, 2, { baz: 'baz' }] },\n          { foo: 'bar', item: [1, 2, { baz: 'baz' }] },\n        ),\n      ).toEqual(true);\n    });\n\n    test('subset objects', () => {\n      expect(\n        deepEqual(\n          { foo: 'bar', item: [1, 2, { baz: 'baz' }] },\n          { foo: 'bar', item: [1, 2, { baz: 'baz' }], id: 1 },\n        ),\n      ).toEqual(false);\n    });\n\n    test('null-ish', () => {\n      expect(\n        deepEqual({ foo: null, baz: 'baz' }, { bar: 'bar', baz: 'baz' }),\n      ).toEqual(false);\n      expect(\n        deepEqual({ foo: null, bar: 'baz' }, { foo: null, bar: 'baz' }),\n      ).toEqual(true);\n    });\n  });\n});\n",
    "/src/deep-equal.ts": "function shouldDeepCompare(type: string) {\n  return type === '[object Object]' || type === '[object Array]';\n}\n\nfunction getType(value: unknown): string {\n  return Object.prototype.toString.call(value);\n}\n\nexport default function deepEqual(valueA: unknown, valueB: unknown): boolean {\n  // Check for arrays/objects equality.\n  const type1 = getType(valueA);\n  const type2 = getType(valueB);\n\n  // Only compare the contents if they're both arrays or both objects.\n  if (type1 === type2 && shouldDeepCompare(type1) && shouldDeepCompare(type2)) {\n    const entriesA = Object.entries(valueA as Array<unknown> | Object);\n    const entriesB = Object.entries(valueB as Array<unknown> | Object);\n\n    if (entriesA.length !== entriesB.length) {\n      return false;\n    }\n\n    return entriesA.every(\n      // Make sure the other object has the same properties defined.\n      ([key, value]) =>\n        Object.hasOwn(valueB as Array<unknown> | Object, key) &&\n        deepEqual(value, (valueB as any)[key]),\n    );\n  }\n\n  // Check for primitives + type equality.\n  return Object.is(valueA, valueB);\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {*} valueA\n * @param {*} valueB\n * @return {boolean}\n */\nexport default function deepEqual(valueA, valueB) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function deepEqual(valueA: unknown, valueB: unknown): boolean {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/deep-equal.ts",
    "run": "/src/deep-equal.run.test.ts",
    "submit": "/src/deep-equal.submit.test.ts"
  }
}