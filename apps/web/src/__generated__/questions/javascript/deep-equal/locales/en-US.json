{
  "description": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var j=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var r in e)a(n,r,{get:e[r],enumerable:!0})},o=(n,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of h(e))!f.call(n,l)&&l!==r&&a(n,l,{get:()=>e[l],enumerable:!(c=p(e,l))||c.enumerable});return n};var b=(n,e,r)=>(r=n!=null?d(m(n)):{},o(e||!n||!n.__esModule?a(r,\"default\",{value:n,enumerable:!0}):r,n)),q=n=>o(a({},\"__esModule\",{value:!0}),n);var i=j((y,s)=>{s.exports=_jsx_runtime});var _={};x(_,{default:()=>E,frontmatter:()=>g});var t=b(i()),g={title:\"Deep Equal\",excerpt:\"Implement a function that determines if two values are equal\"};function u(n){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a function \",(0,t.jsx)(e.code,{children:\"deepEqual\"}),\" that performs a deep comparison between two values. It returns \",(0,t.jsx)(e.code,{children:\"true\"}),\" if two input values are deemed equal, and returns \",(0,t.jsx)(e.code,{children:\"false\"}),\" if not.\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"You can assume there are only JSON-serializable values (numbers, strings, boolean, \",(0,t.jsx)(e.code,{children:\"null\"}),\", objects, arrays).\"]}),`\n`,(0,t.jsx)(e.li,{children:\"There wouldn't be cyclic objects, i.e. objects with circular references.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`deepEqual('foo', 'foo'); // true\ndeepEqual({ id: 1 }, { id: 1 }); // true\ndeepEqual([1, 2, 3], [1, 2, 3]); // true\ndeepEqual([{ id: '1' }], [{ id: '2' }]); // false\n`})})]})}function w(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var E=w;return q(_);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function that determines if two values are equal",
    "title": "Deep Equal"
  },
  "solution": "var Component=(()=>{var b=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),w=(r,e)=>{for(var n in e)a(r,n,{get:e[n],enumerable:!0})},s=(r,e,n,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of v(e))!j.call(r,o)&&o!==n&&a(r,o,{get:()=>e[o],enumerable:!(c=f(e,o))||c.enumerable});return r};var k=(r,e,n)=>(n=r!=null?b(m(r)):{},s(e||!r||!r.__esModule?a(n,\"default\",{value:r,enumerable:!0}):n,r)),A=r=>s(a({},\"__esModule\",{value:!0}),r);var h=g((E,l)=>{l.exports=_jsx_runtime});var x={};w(x,{default:()=>T});var t=k(h());var i=MDXCodeBlock;var d=`function shouldDeepCompare(type) {\n  return type === '[object Object]' || type === '[object Array]';\n}\n\nfunction getType(value) {\n  return Object.prototype.toString.call(value);\n}\n\n/**\n * @param {*} valueA\n * @param {*} valueB\n * @return {boolean}\n */\nexport default function deepEqual(valueA, valueB) {\n  // Check for arrays/objects equality.\n  const typeA = getType(valueA);\n  const typeB = getType(valueB);\n\n  // Only compare the contents if they're both arrays or both objects.\n  if (typeA === typeB && shouldDeepCompare(typeA) && shouldDeepCompare(typeB)) {\n    const entriesA = Object.entries(valueA);\n    const entriesB = Object.entries(valueB);\n\n    if (entriesA.length !== entriesB.length) {\n      return false;\n    }\n\n    return entriesA.every(\n      // Make sure the other object has the same properties defined.\n      ([k, v]) => Object.hasOwn(valueB, k) && deepEqual(v, valueB[k]),\n    );\n  }\n\n  // Check for primitives + type equality.\n  return Object.is(valueA, valueB);\n}\n`;var u=`function shouldDeepCompare(type: string) {\n  return type === '[object Object]' || type === '[object Array]';\n}\n\nfunction getType(value: unknown): string {\n  return Object.prototype.toString.call(value);\n}\n\nexport default function deepEqual(valueA: unknown, valueB: unknown): boolean {\n  // Check for arrays/objects equality.\n  const type1 = getType(valueA);\n  const type2 = getType(valueB);\n\n  // Only compare the contents if they're both arrays or both objects.\n  if (type1 === type2 && shouldDeepCompare(type1) && shouldDeepCompare(type2)) {\n    const entriesA = Object.entries(valueA as Array<unknown> | Object);\n    const entriesB = Object.entries(valueB as Array<unknown> | Object);\n\n    if (entriesA.length !== entriesB.length) {\n      return false;\n    }\n\n    return entriesA.every(\n      // Make sure the other object has the same properties defined.\n      ([key, value]) =>\n        Object.hasOwn(valueB as Array<unknown> | Object, key) &&\n        deepEqual(value, (valueB as any)[key]),\n    );\n  }\n\n  // Check for primitives + type equality.\n  return Object.is(valueA, valueB);\n}\n`;var p=`/**\n * @param {*} valueA\n * @param {*} valueB\n * @return {boolean}\n */\nexport default function deepEqual(valueA, valueB) {\n  // Check primitives for equality.\n  if (Object.is(valueA, valueB)) {\n    return true;\n  }\n\n  const bothObjects =\n    Object.prototype.toString.call(valueA) === '[object Object]' &&\n    Object.prototype.toString.call(valueB) === '[object Object]';\n  const bothArrays = Array.isArray(valueA) && Array.isArray(valueB);\n\n  // At this point, they can still be primitives but of different types.\n  // If they had the same value, they would have been handled earlier in Object.is().\n  // So if they're not both objects or both arrays, they're definitely not equal.\n  if (!bothObjects && !bothArrays) {\n    return false;\n  }\n\n  // Compare the keys of arrays and objects.\n  if (Object.keys(valueA).length !== Object.keys(valueB).length) {\n    return false;\n  }\n\n  for (const key in valueA) {\n    if (!deepEqual(valueA[key], valueB[key])) {\n      return false;\n    }\n  }\n\n  // All checks passed, the arrays/objects are equal.\n  return true;\n}\n`;function y(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ol:\"ol\",li:\"li\",a:\"a\",h3:\"h3\",em:\"em\",pre:\"pre\",ul:\"ul\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Value comparison in JavaScript can be deceptively simple. Normally a triple equal \",(0,t.jsx)(e.code,{children:\"===\"}),', i.e. strict equality, can do the job: for primitive values, it compares the actual values; for objects, it compares their identities/references, instead of their \"contents\". For example, ',(0,t.jsx)(e.code,{children:\"const a = {id: 1}; const b = {id: 1}\"}),\" are considered different objects by \",(0,t.jsx)(e.code,{children:\"===\"}),\" even if they contain the exactly same \",(0,t.jsx)(e.code,{children:\"id\"}),\" property. Most of the time this is what we want. For this question though, we are going to implement a function that can deeply compare objects. Therefore we can't solely rely on \",(0,t.jsx)(e.code,{children:\"===\"}),\" for comparison.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Outside its reference-checking nature, strict equality \",(0,t.jsx)(e.code,{children:\"===\"}),\" does have a few edge cases that it doesn't cover:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Two \",(0,t.jsx)(e.code,{children:\"NaN\"}),\" values are considered different \",(0,t.jsx)(e.code,{children:\"NaN === NaN // false\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Numerical values \",(0,t.jsx)(e.code,{children:\"-0 \"}),\"and \",(0,t.jsx)(e.code,{children:\"+0\"}),\" are considered as equal.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A better choice here is to use \",(0,t.jsx)(e.code,{children:\"Object.is\"}),\". This is also what React uses during its reconciliation phase to detect props change for a given component. Check out \",(0,t.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",children:[(0,t.jsx)(e.code,{children:\"Object.is\"}),\" on MDN\"]}),\" if you want to learn more about it and see how it differs from \",(0,t.jsx)(e.code,{children:\"===\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"We don't test for the above cases but you might want to point this out when explaining why you used \",(0,t.jsx)(e.code,{children:\"Object.is\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"There are two main ways to go about solving this question:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Handling arrays/objects first, primitives last.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Handling primitives first, arrays/objects last.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Approach 1: Handling arrays/objects first\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The tricky part of the question about deep-comparing objects and arrays. Firstly, we need to know how to detect their data types. The \",(0,t.jsx)(e.code,{children:\"typeof\"}),\" operator is probably the first solution that comes to mind but it is not enough for our use case here.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"typeof null\"}),\" gives you \",(0,t.jsx)(e.code,{children:\"object\"}),\", so we cannot use \",(0,t.jsx)(e.code,{children:\"typeof\"}),\" to distinguish between objects, arrays, and \",(0,t.jsx)(e.code,{children:\"null\"}),\"s. More importantly, it doesn't distinguish other built-in objects such as \",(0,t.jsx)(e.code,{children:\"Date\"}),\" and \",(0,t.jsx)(e.code,{children:\"Regex\"}),\" from plain objects and array. That is, it return \",(0,t.jsx)(e.code,{children:\"object\"}),\" for all of the built-in objects (except for functions). This is not useful because we can only sensibly traverse and deep-compare objects and arrays, and everything else should be compared by references via \",(0,t.jsx)(e.code,{children:\"Object.is\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To get around this, you can combine the \",(0,t.jsx)(e.code,{children:\"instanceof\"}),\" operator to check for the constructor of a given object. But an easier and cleaner way to detect data types is to use \",(0,t.jsx)(e.code,{children:\"Object.prototype.toString\"}),\". Check out \",(0,t.jsx)(e.a,{href:\"https://www.zhenghao.io/posts/js-data-type\",children:\"this article by Zhenghao\"}),\" if you want to dive deep into this topic.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A utility function \",(0,t.jsx)(e.code,{children:\"shouldDeepCompare\"}),\" will be useful for determining whether we should traverse down the current property of the input object based on the data type retrieved by \",(0,t.jsx)(e.code,{children:\"getType\"}),\". When the current property is \",(0,t.jsx)(e.em,{children:\"not\"}),\" an object or an array, we can proceed to compare their types and values via \",(0,t.jsx)(e.code,{children:\"Object.is\"}),\".\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`// Warning: Incomplete solution. Refer to below.\nfunction shouldDeepCompare(type) {\n  return type === '[object Object]' || type === '[object Array]';\n}\n\nfunction getType(value) {\n  return Object.prototype.toString.call(value);\n}\n\nexport default function deepEqual(valueA, valueB) {\n  const typeA = getType(valueA);\n  const typeB = getType(valueB);\n\n  if (typeA === typeB && shouldDeepCompare(typeA) && shouldDeepCompare(typeB)) {\n    // When both props are objects or arrays, we traverse into them by calling \\`isEqual\\` again.\n  }\n\n  return Object.is(valueA, valueB);\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Now let's work on the case where both input values are objects or arrays. Because we need to recurse into any objects/arrays we found in the input. If it is an array, we can just loop through the items. However if it is an object, we either use \",(0,t.jsx)(e.code,{children:\"for ... in\"}),\" statement to loop through all the keys (own keys \",(0,t.jsx)(e.em,{children:\"and\"}),\" inherited keys), or we can convert its own enumerable, non-symbol-keyed properties into an array of key-value pairs with \",(0,t.jsx)(e.code,{children:\"Object.entries\"}),\" and then we can loop through that array instead. The benefits with the second approach are:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"We only get its own properties, as opposed to inherited ones.\"}),`\n`,(0,t.jsx)(e.li,{children:\"We can bail out of comparison if the lengths of two arrays are different. That is, two objects/arrays have different numbers of properties/items.\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Here is the complete solution:\"}),`\n`,(0,t.jsx)(i,{languages:{jsx:d,tsx:u}}),`\n`,(0,t.jsx)(e.h3,{children:\"Approach 2: Handling primitives first\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We can also get primitives out of the way by handling them with \",(0,t.jsx)(e.code,{children:\"Object.is()\"}),\" first. If they fail the primitive equality check, then we can check if they're both arrays or objects. If it also fails that check, it means there's a mismatch between the type of values and we can \",(0,t.jsx)(e.code,{children:\"return false\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The next part is to check if both arrays/objects have the same entries (keys/values). The approach provided here is an alternative to the earlier solution but the idea is the same:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Check that both objects have the same keys:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Both objects have the same number of keys.\"}),`\n`,(0,t.jsx)(e.li,{children:\"All of the first object's keys exist in the other object.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively check that the each key's value are the same.\"}),`\n`]}),`\n`,(0,t.jsx)(i,{children:p}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Comparing \",(0,t.jsx)(e.code,{children:\"null\"}),\"s, \",(0,t.jsx)(e.code,{children:\"Object\"}),\"s, \",(0,t.jsx)(e.code,{children:\"Array\"}),\"s.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Equality of +0 and -0.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Cyclic objects, i.e. objects with circular references are not handled.\"}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors\",children:\"Property descriptors\"}),\" are not taken into account when comparing properties.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Non-enumerable properties and symbol-keyed properties are not compared.\"}),`\n`]})]})}function C(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(y,r)})):y(r)}var T=C;return A(x);})();\n;return Component;"
}