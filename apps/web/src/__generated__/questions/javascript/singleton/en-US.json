{
  "description": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var f=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),b=(t,n)=>{for(var a in n)i(t,a,{get:n[a],enumerable:!0})},s=(t,n,a,l)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let o of g(n))!m.call(t,o)&&o!==a&&i(t,o,{get:()=>n[o],enumerable:!(l=p(n,o))||l.enumerable});return t};var w=(t,n,a)=>(a=t!=null?d(u(t)):{},s(n||!t||!t.__esModule?i(a,\"default\",{value:t,enumerable:!0}):a,t)),j=t=>s(i({},\"__esModule\",{value:!0}),t);var r=f((G,c)=>{c.exports=_jsx_runtime});var y={};b(y,{default:()=>v,frontmatter:()=>M});var e=w(r()),M={title:\"Singleton\",excerpt:\"Implement a Singleton class that ensures a class has only one instance while providing a global point of access to that instance\"};function h(t){let n=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",strong:\"strong\",code:\"code\",h2:\"h2\",pre:\"pre\",a:\"a\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.p,{children:\"The Singleton pattern is used when you want to ensure that a class has only one instance and provide a global point of access to that instance. The Singleton pattern is useful for:\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Single point of control:\"}),\" When you need a single point of control for actions, such as managing a configuration object, logging, or controlling access to a shared resource.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Global state:\"}),\" When you want to maintain a global state that should be accessible from different parts of your application. This is especially useful when sharing common data across various components.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Preventing duplicate initialization:\"}),\" To ensure that only one instance of a class is created, preventing duplicate initialization and avoiding potential issues related to multiple instances.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Caching:\"}),\" For implementing a caching mechanism where you want to maintain a single cache instance throughout the application.\"]}),`\n`]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Implement the \",(0,e.jsx)(n.code,{children:\"GlobalMap\"}),\" module in JavaScript using the Singleton pattern. The \",(0,e.jsx)(n.code,{children:\"GlobalMap\"}),\" module exports an object that has a single \",(0,e.jsx)(n.code,{children:\"getInstance()\"}),\" method which returns a \",(0,e.jsx)(n.code,{children:\"Map\"}),\" object that can be used as a key/value store for global caching/memoization.\"]}),`\n`,(0,e.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// fileA.js\nimport GlobalMap from './GlobalMap';\n\nconst gbMap = GlobalMap.getInstance();\ngbMap.set('count', 42);\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"Somewhere else in another file, executed after the first:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// fileB.js\nimport GlobalMap from './GlobalMap';\n\nconst gbMap = GlobalMap.getInstance();\nconsole.log(gbMap.get('count')); // 42\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"Resources\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://www.patterns.dev/vanilla/singleton-pattern\",children:\"Singleton Pattern | patterns.dev\"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://www.digitalocean.com/community/tutorials/js-js-singletons\",children:\"How To Work With Singletons in JavaScript\"})}),`\n`]})]})}function x(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(h,t)})):h(t)}var v=x;return j(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/singleton\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/singleton.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/singleton.run.test.ts": "import Singleton from './singleton';\nimport Singleton2 from './singleton';\n\ndescribe('singleton', () => {\n  test('returns an object with the required method', () => {\n    expect(Singleton).toBeInstanceOf(Object);\n    expect(Singleton.getInstance).toBeInstanceOf(Function);\n  });\n\n  describe('instance', () => {\n    test('getInstance returns a Map', () => {\n      expect(Singleton.getInstance()).toBeInstanceOf(Map);\n    });\n\n    test('Map methods work', () => {\n      const globalMap = Singleton.getInstance();\n      globalMap.set('count', 42);\n      expect(globalMap.get('count')).toBe(42);\n    });\n\n    test('separate modules use the same instance', () => {\n      const globalMap = Singleton.getInstance();\n      globalMap.set('count', 42);\n\n      const globalMap2 = Singleton2.getInstance();\n      expect(globalMap2.get('count')).toBe(42);\n    });\n  });\n});\n",
    "/src/singleton.submit.test.ts": "import Singleton from './singleton';\nimport Singleton2 from './singleton';\n\ndescribe('singleton', () => {\n  test('returns an object with the required method', () => {\n    expect(Singleton).toBeInstanceOf(Object);\n    expect(Singleton.getInstance).toBeInstanceOf(Function);\n  });\n\n  describe('instance', () => {\n    test('getInstance returns a Map', () => {\n      expect(Singleton.getInstance()).toBeInstanceOf(Map);\n    });\n\n    test('Map methods work', () => {\n      const globalMap = Singleton.getInstance();\n      globalMap.set('count', 42);\n      expect(globalMap.get('count')).toBe(42);\n    });\n\n    test('separate modules use the same instance', () => {\n      const globalMap = Singleton.getInstance();\n      globalMap.set('count', 42);\n\n      const globalMap2 = Singleton2.getInstance();\n      expect(globalMap2.get('count')).toBe(42);\n    });\n  });\n});\n",
    "/src/singleton.ts": "const globalMap = new Map();\n\nexport default {\n  getInstance() {\n    return globalMap;\n  },\n};\n"
  },
  "format": "javascript",
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1699747200,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement a Singleton class that ensures a class has only one instance while providing a global point of access to that instance",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/singleton",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "singleton",
    "subtitle": null,
    "title": "Singleton",
    "topics": []
  },
  "skeleton": {
    "js": "// No skeleton is provided. Export an object that has a single `getInstance()` method.",
    "ts": "// No skeleton is provided. Export an object that has a single `getInstance()` method."
  },
  "solution": "var Component=(()=>{var g=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var M=Object.getPrototypeOf,I=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var a in e)o(t,a,{get:e[a],enumerable:!0})},l=(t,e,a,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of w(e))!I.call(t,i)&&i!==a&&o(t,i,{get:()=>e[i],enumerable:!(r=f(e,i))||r.enumerable});return t};var y=(t,e,a)=>(a=t!=null?g(M(t)):{},l(e||!t||!t.__esModule?o(a,\"default\",{value:t,enumerable:!0}):a,t)),x=t=>l(o({},\"__esModule\",{value:!0}),t);var d=b((z,c)=>{c.exports=_jsx_runtime});var F={};v(F,{default:()=>_});var n=y(d());var s=MDXCodeBlock;var h=`const globalMap = new Map();\n\nexport default {\n  getInstance() {\n    return globalMap;\n  },\n};\n`;var p=`let globalMap: Map<any, any>;\n\nexport default {\n  getInstance() {\n    if (globalMap === undefined) {\n      globalMap = new Map();\n    }\n\n    return globalMap;\n  },\n};\n`;var u=`const GlobalMap = (function () {\n  const _privateMap = new Map();\n\n  return {\n    getInstance: function () {\n      return _privateMap;\n    },\n  };\n})();\n\nexport default GlobalMap;\n`;function m(t){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Solution 1: ES6 Modules\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since each file in the coding workspace is a module, and ES6 modules are single instances of a module, we can use this to easily implement the Singleton pattern. This module exports an object with a single method, \",(0,n.jsx)(e.code,{children:\"getInstance\"}),\". The \",(0,n.jsx)(e.code,{children:\"getInstance\"}),\" method is responsible for providing access to the \",(0,n.jsx)(e.code,{children:\"globalMap\"}),\" instance. When other parts of the application import this module and call \",(0,n.jsx)(e.code,{children:\"getInstance\"}),\", they receive a reference to the same \",(0,n.jsx)(e.code,{children:\"globalMap\"}),\" instance.\"]}),`\n`,(0,n.jsx)(s,{children:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Solution 2: ES6 Modules with lazy instantiation\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the first solution, the \",(0,n.jsx)(e.code,{children:\"Map\"}),\" instance was instantiated from the start. However, in some cases where instantiation is expensive and there's a good chance you might never even need to use the instance at all, then a lazy instantiation approach is better.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this modified version, the \",(0,n.jsx)(e.code,{children:\"getInstance\"}),\" method checks if \",(0,n.jsx)(e.code,{children:\"globalMap\"}),\" has been instantiated before creating a new instance. If \",(0,n.jsx)(e.code,{children:\"globalMap\"}),\" is already instantiated, it simply returns the existing instance. This way, the map is created only when the \",(0,n.jsx)(e.code,{children:\"getInstance\"}),\" method is called for the first time, making the instantiation lazy. The usage remains the same.\"]}),`\n`,(0,n.jsx)(s,{children:p}),`\n`,(0,n.jsx)(e.h3,{children:\"Solution 3: Immediately-invoked Function Expression (IIFE)\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Before ES6 modules were a thing, Immediately-invoked Function Expressions (IIFEs) could be used to encapsulate data to get a module. In this version, the entire Singleton pattern is wrapped in an IIFE, creating a closure that encapsulates the \",(0,n.jsx)(e.code,{children:\"globalMap\"}),\" variable. The \",(0,n.jsx)(e.code,{children:\"getInstance\"}),\" method is exposed through the returned object, allowing access to the shared map instance.\"]}),`\n`,(0,n.jsx)(s,{children:u}),`\n`,(0,n.jsx)(e.p,{children:\"In general, the ES6 modules version is preferred since it's the future. However, if you are working in an environment that does not support ES6 modules (older browsers, Node.js without module support, etc.), then using an IIFE is a common way to encapsulate and structure your code.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.patterns.dev/vanilla/singleton-pattern\",children:\"Singleton Pattern | patterns.dev\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.digitalocean.com/community/tutorials/js-js-singletons\",children:\"How To Work With Singletons in JavaScript\"})}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var _=k;return x(F);})();\n;return Component;",
  "workspace": {
    "main": "/src/singleton.ts",
    "run": "/src/singleton.run.test.ts",
    "submit": "/src/singleton.submit.test.ts"
  }
}