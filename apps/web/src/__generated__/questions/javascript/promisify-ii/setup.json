{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promisify-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promisify-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/promisify-ii.run.test.ts": "import promisify from './promisify-ii';\n\ndescribe('promisify', () => {\n  function delayedResolve(cb: Function) {\n    setTimeout(() => {\n      cb(null, 42);\n    }, 10);\n  }\n\n  test('returns a function', () => {\n    const promisified = promisify(delayedResolve);\n    expect(promisified).toBeInstanceOf(Function);\n  });\n\n  test('calling promisified returns a promise', () => {\n    const promisified = promisify(delayedResolve);\n    expect(promisified()).toBeInstanceOf(Promise);\n  });\n\n  test('one argument', async () => {\n    function asyncIdentity(x: number, cb: Function) {\n      setTimeout(() => {\n        cb(null, x);\n      }, 10);\n    }\n\n    expect.assertions(1);\n    const promisified = promisify(asyncIdentity);\n    const res = await promisified(23);\n    expect(res).toBe(23);\n  });\n\n  test('custom promisify', async () => {\n    expect.assertions(1);\n    function asyncIdentityCustom<T>(cb: Function, x: T) {\n      setTimeout(() => {\n        cb(null, x);\n      }, 10);\n    }\n    const customPromisify = <T>(x: T) =>\n      new Promise((resolve) => {\n        asyncIdentityCustom((_: unknown, res: T) => resolve(res), x);\n      });\n    (asyncIdentityCustom as any)[Symbol.for('util.promisify.custom')] =\n      customPromisify;\n\n    const promisified = promisify(asyncIdentityCustom);\n    const res = await promisified(23);\n    expect(res).toBe(23);\n  });\n});\n",
    "/src/promisify-ii.submit.test.ts": "import promisify from './promisify-ii';\n\ndescribe('promisify', () => {\n  function delayedResolve(cb: Function) {\n    setTimeout(() => {\n      cb(null, 42);\n    }, 10);\n  }\n\n  function asyncError(x: number, cb: Function) {\n    setTimeout(() => {\n      cb(x);\n    }, 10);\n  }\n\n  describe('returns correct types', () => {\n    test('returns a function', () => {\n      const promisified = promisify(delayedResolve);\n      expect(promisified).toBeInstanceOf(Function);\n    });\n\n    test('calling promisified returns a promise', () => {\n      const promisified = promisify(delayedResolve);\n      expect(promisified()).toBeInstanceOf(Promise);\n    });\n  });\n\n  describe('use with await', () => {\n    describe('resolved', () => {\n      test('no arguments', async () => {\n        expect.assertions(1);\n        const promisified = promisify(delayedResolve);\n        const res = await promisified();\n        expect(res).toBe(42);\n      });\n\n      test('one argument', async () => {\n        function asyncIdentity(x: number, cb: Function) {\n          setTimeout(() => {\n            cb(null, x);\n          }, 10);\n        }\n\n        expect.assertions(1);\n        const promisified = promisify(asyncIdentity);\n        const res = await promisified(23);\n        expect(res).toBe(23);\n      });\n\n      test('two arguments', async () => {\n        function asyncAdd(a: number, b: number, cb: Function) {\n          setTimeout(() => {\n            cb(null, a + b);\n          }, 10);\n        }\n\n        expect.assertions(1);\n        const promisified = promisify(asyncAdd);\n        const res = await promisified(17, 19);\n        expect(res).toBe(36);\n      });\n    });\n\n    test('rejected', async () => {\n      expect.assertions(1);\n      try {\n        const promisified = promisify(asyncError);\n        await promisified(23);\n      } catch (err) {\n        expect(err).toBe(23);\n      }\n    });\n  });\n\n  test('can access `this`', async () => {\n    expect.assertions(1);\n    function asyncAdd(this: any, a: number, b: number, cb: Function) {\n      setTimeout(() => {\n        cb(null, a + b + this.base);\n      }, 10);\n    }\n\n    const promisifiedAdd = promisify(asyncAdd);\n    const obj = { base: 5, add: promisifiedAdd };\n    const res = await obj.add(17, 19);\n    expect(res).toBe(41);\n  });\n\n  describe('use without await', () => {\n    test('then', (done) => {\n      expect.assertions(1);\n      const promisified = promisify(delayedResolve);\n      promisified().then((res) => {\n        expect(res).toBe(42);\n        done();\n      });\n    });\n\n    test('catch', (done) => {\n      expect.assertions(1);\n      const promisified = promisify(asyncError);\n      promisified(23)\n        .then()\n        .catch((err) => {\n          expect(err).toBe(23);\n          done();\n        });\n    });\n  });\n\n  describe('custom', () => {\n    test('resolve', async () => {\n      expect.assertions(1);\n      function asyncIdentityCustom<T>(cb: Function, x: T) {\n        setTimeout(() => {\n          cb(null, x);\n        }, 10);\n      }\n      const customPromisify = <T>(x: T) =>\n        new Promise((resolve) => {\n          asyncIdentityCustom((_: unknown, res: T) => resolve(res), x);\n        });\n      (asyncIdentityCustom as any)[Symbol.for('util.promisify.custom')] =\n        customPromisify;\n\n      const promisified = promisify(asyncIdentityCustom);\n      const res = await promisified(23);\n      expect(res).toBe(23);\n    });\n\n    test('reject', async () => {\n      expect.assertions(1);\n      function asyncErrorCustom(cb: Function, x: number) {\n        setTimeout(() => {\n          cb(x);\n        }, 10);\n      }\n      const customPromisify = (x: number) =>\n        new Promise((_, reject) => {\n          asyncErrorCustom((err: any) => reject(err), x);\n        });\n      (asyncErrorCustom as any)[Symbol.for('util.promisify.custom')] =\n        customPromisify;\n\n      try {\n        const promisified = promisify(asyncErrorCustom);\n        await promisified(23);\n      } catch (err) {\n        expect(err).toBe(23);\n      }\n    });\n  });\n});\n",
    "/src/promisify-ii.ts": "const promisifyCustomSymbol = Symbol.for('util.promisify.custom');\n\ntype Func = (...args: any[]) => void;\ntype Return<T> = (this: any, ...args: any[]) => Promise<T>;\ntype WithSymbol<T> = { [promisifyCustomSymbol]: Return<T> };\ntype Param<T> = Func | WithSymbol<T>;\n\nexport default function promisify<T>(func: Param<T>): Return<T> {\n  if ((func as WithSymbol<T>)[promisifyCustomSymbol]) {\n    return (func as WithSymbol<T>)[promisifyCustomSymbol];\n  }\n\n  return function (...args) {\n    return new Promise<T>((resolve, reject) => {\n      (func as Func).call(this, ...args, (err: any, result: T) =>\n        err ? reject(err) : resolve(result),\n      );\n    });\n  };\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @callback func\n * @returns Function\n */\nexport default function promisify(func) {\n  throw 'Not implemented';\n}",
    "ts": "const promisifyCustomSymbol = Symbol.for('util.promisify.custom');\n\ntype Func = (...args: any[]) => void;\ntype Return<T> = (this: any, ...args: any[]) => Promise<T>;\ntype WithSymbol<T> = { [promisifyCustomSymbol]: Return<T> };\ntype Param<T> = Func | WithSymbol<T>;\n\nexport default function promisify<T>(func: Param<T>): Return<T> {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/promisify-ii.ts",
    "run": "/src/promisify-ii.run.test.ts",
    "submit": "/src/promisify-ii.submit.test.ts"
  }
}