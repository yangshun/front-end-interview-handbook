{
  "description": "var Component=(()=>{var s=Object.create;var a=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var p=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),f=(e,n)=>{for(var i in n)a(e,i,{get:n[i],enumerable:!0})},l=(e,n,i,d)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let o of u(n))!b.call(e,o)&&o!==i&&a(e,o,{get:()=>n[o],enumerable:!(d=g(n,o))||d.enumerable});return e};var H=(e,n,i)=>(i=e!=null?s(m(e)):{},l(n||!e||!e.__esModule?a(i,\"default\",{value:e,enumerable:!0}):i,e)),x=e=>l(a({},\"__esModule\",{value:!0}),e);var r=p((C,c)=>{c.exports=_jsx_runtime});var O={};f(O,{default:()=>j,frontmatter:()=>w});var t=H(r()),w={title:\"Table of Contents\",excerpt:\"Implement a function to construct a table of contents from an HTML document\"};function h(e){let n=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:\"On websites, heading tags give a hierarchy to the page and heading information can be used by user agents (including screen readers) to construct a table of contents for a document automatically.\"}),`\n`,(0,t.jsxs)(n.p,{children:[\"Given a \",(0,t.jsx)(n.code,{children:\"document\"}),\" node, write a function \",(0,t.jsx)(n.code,{children:\"tableOfContents\"}),\" that generates an HTML string representing a table of contents based on the headings (\",(0,t.jsx)(n.code,{children:\"<h1>\"}),\", \",(0,t.jsx)(n.code,{children:\"<h2>\"}),\", ..., \",(0,t.jsx)(n.code,{children:\"<h6>\"}),\") in the \",(0,t.jsx)(n.code,{children:\"document\"}),\". Following the best practices, heading levels won't be skipped, i.e. \",(0,t.jsx)(n.code,{children:\"<h1>\"}),\" will be followed by \",(0,t.jsx)(n.code,{children:\"<h2>\"}),\" and so on.\"]}),`\n`,(0,t.jsx)(n.p,{children:\"The returned string doesn't need to contain any indentation.\"}),`\n`,(0,t.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(n.p,{children:\"The example below is shown with indentation to make the output easier to understand.\"}),`\n`,(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:\"language-js\",children:`const doc = new DOMParser().parseFromString(\n  \\`<!DOCTYPE html>\n  <body>\n    <h1>Heading1</h1>\n    <h2>Heading2a</h2>\n    <h2>Heading2b</h2>\n    <h3>Heading3a</h3>\n    <h3>Heading3b</h3>\n    <h4>Heading4</h4>\n    <h2>Heading2c</h2>\n  </body>\\`,\n  'text/html',\n);\n\nconst htmlString = tableOfContents(doc);\nconsole.log(htmlString);\n// Pretty-printed for readability.\n\\`<ul>\n  <li>\n    Heading1\n    <ul>\n      <li>Heading2a</li>\n      <li>\n        Heading2b\n        <ul>\n          <li>Heading3a</li>\n          <li>\n            Heading3b\n            <ul>\n              <li>Heading4</li>\n            </ul>\n          </li>\n        </ul>\n      </li>\n      <li>Heading2c</li>\n    </ul>\n  </li>\n</ul>\\`;\n`})})]})}function y(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(h,e)})):h(e)}var j=y;return x(O);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/table-of-contents\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/table-of-contents.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/table-of-contents.run.test.ts": "import tableOfContents from './table-of-contents';\n\ndescribe('tableOfContents', () => {\n  test('empty', () => {\n    const doc = new DOMParser().parseFromString(\n      `\n<!DOCTYPE html>\n<html>\n<body>\n</body>\n</html>`,\n      'text/html',\n    );\n    expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(``);\n  });\n\n  test('only h1', () => {\n    const doc = new DOMParser().parseFromString(\n      `\n<!DOCTYPE html>\n<html>\n<body>\n  <h1>Blogpost</h1>\n</body>\n</html>`,\n      'text/html',\n    );\n    expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n      `<ul><li>Blogpost</li></ul>`,\n    );\n  });\n\n  test('nested', () => {\n    const doc = new DOMParser().parseFromString(\n      `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h2>Foo</h2>\n    <h3>Bar</h3>\n    <h4>Baz</h4>\n    <h5>Qux</h5>\n    <h6>Quxx</h6>\n  </body>\n  </html>`,\n      'text/html',\n    );\n    expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n      `<ul>\n          <li>Foo\n            <ul>\n              <li>\n                Bar\n                <ul>\n                  <li>\n                    Baz\n                    <ul>\n                      <li>\n                        Qux\n                        <ul>\n                          <li>Quxx</li>\n                        </ul>\n                      </li>\n                    </ul>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>`.replace(/\\s/g, ''),\n    );\n  });\n});\n",
    "/src/table-of-contents.submit.test.ts": "import tableOfContents from './table-of-contents';\n\ndescribe('tableOfContents', () => {\n  test('empty', () => {\n    const doc = new DOMParser().parseFromString(\n      `\n<!DOCTYPE html>\n<html>\n<body>\n</body>\n</html>`,\n      'text/html',\n    );\n    expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(``);\n  });\n\n  describe('only one tag type', () => {\n    test('only h1', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h1>Blogpost</h1>\n  </body>\n  </html>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul><li>Blogpost</li></ul>`,\n      );\n    });\n\n    test('only h2s', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n    <!DOCTYPE html>\n    <html>\n    <body>\n      <h1>Blogpost</h1>\n      <h2>Foo</h2>\n      <h2>Bar</h2>\n      <h2>Baz</h2>\n    </body>\n    </html>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul>\n          <li>\n            Blogpost\n            <ul>\n              <li>Foo</li>\n              <li>Bar</li>\n              <li>Baz</li>\n            </ul>\n          </li>\n        </ul>\n        `.replace(/\\s/g, ''),\n      );\n    });\n\n    test('only h3s', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h3>Foo</h3>\n    <h3>Bar</h3>\n    <h3>Baz</h3>\n  </body>\n  </html>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul>\n          <li>Foo</li>\n          <li>Bar</li>\n          <li>Baz</li>\n        </ul>`.replace(/\\s/g, ''),\n      );\n    });\n\n    test('nested DOM', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <div>\n      <h2>Foo</h2>\n    </div>\n    <h2>Bar</h2>\n    <div>\n      <div>\n        <h2>Baz</h2>\n      </div>\n    </div>\n  </body>\n  </html>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul>\n          <li>Foo</li>\n          <li>Bar</li>\n          <li>Baz</li>\n        </ul>`.replace(/\\s/g, ''),\n      );\n    });\n  });\n\n  describe('nested', () => {\n    test('strictly ascending', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h2>Foo</h2>\n    <h3>Bar</h3>\n    <h4>Baz</h4>\n    <h5>Qux</h5>\n    <h6>Quxx</h6>\n  </body>\n  </html>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul>\n          <li>Foo\n            <ul>\n              <li>\n                Bar\n                <ul>\n                  <li>\n                    Baz\n                    <ul>\n                      <li>\n                        Qux\n                        <ul>\n                          <li>Quxx</li>\n                        </ul>\n                      </li>\n                    </ul>\n                  </li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n        </ul>`.replace(/\\s/g, ''),\n      );\n    });\n\n    test('ascending and descending once', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h2>Foo</h2>\n    <h2>Bar</h2>\n    <h3>Baz</h3>\n    <h3>Qux</h3>\n    <h2>Quxx</h2>\n  </body>\n  </html>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul>\n          <li>Foo</li>\n          <li>\n            Bar\n            <ul>\n              <li>Baz</li>\n              <li>Qux</li>\n            </ul>\n          </li>\n          <li>Quxx</li>\n        </ul>`.replace(/\\s/g, ''),\n      );\n    });\n\n    test('ascending and descending many times', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n  <!DOCTYPE html>\n  <body>\n    <h1>Heading1</h1>\n    <h2>Heading2a</h2>\n    <h2>Heading2b</h2>\n    <h3>Heading3a</h3>\n    <h3>Heading3b</h3>\n    <h4>Heading4</h3>\n    <h2>Heading2c</h2>\n  </body>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul>\n          <li>\n            Heading1\n            <ul>\n              <li>Heading2a</li>\n              <li>\n                Heading2b\n                <ul>\n                  <li>Heading3a</li>\n                  <li>\n                    Heading3b\n                    <ul>\n                      <li>Heading4</li>\n                    </ul>\n                  </li>\n                </ul>\n              </li>\n              <li>Heading2c</li>\n            </ul>\n          </li>\n        </ul>`.replace(/\\s/g, ''),\n      );\n    });\n\n    test('ascending and descending all the way', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h2>Foo</h2>\n    <h2>Bar</h2>\n    <h3>Baz</h3>\n    <h4>Baz2</h4>\n    <h3>Qux</h3>\n    <h4>Baz3</h4>\n    <h4>Baz4</h4>\n    <h2>Quxx</h2>\n  </body>\n  </html>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul>\n          <li>Foo</li>\n          <li>\n            Bar\n            <ul>\n              <li>\n                Baz\n                <ul>\n                  <li>Baz2</li>\n                </ul>\n              </li>\n              <li>\n                Qux\n                <ul>\n                  <li>Baz3</li>\n                  <li>Baz4</li>\n                </ul>\n              </li>\n            </ul>\n          </li>\n          <li>Quxx</li>\n        </ul>`.replace(/\\s/g, ''),\n      );\n    });\n\n    test('ascending and descending with nesting', () => {\n      const doc = new DOMParser().parseFromString(\n        `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h2>Foo</h2>\n    <div>\n      <h2>Bar</h2>\n      <h3>Baz</h3>\n      <h3>Qux</h3>\n    </div>\n    <div>\n      <h2>Quxx</h2>\n    </div>\n  </body>\n  </html>`,\n        'text/html',\n      );\n      expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n        `<ul>\n          <li>Foo</li>\n          <li>\n            Bar\n            <ul>\n              <li>Baz</li>\n              <li>Qux</li>\n            </ul>\n          </li>\n          <li>Quxx</li>\n        </ul>`.replace(/\\s/g, ''),\n      );\n    });\n  });\n\n  test('ignores comment nodes', () => {\n    const doc = new DOMParser().parseFromString(\n      `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h2>Foo</h2>\n    <!-- Comment -->\n    <div>\n      <h2>Bar</h2>\n      <h3>Baz<!-- Comment --></h3>\n      <h3>Qux</h3>\n    </div>\n    <div>\n      <h2>Quxx</h2>\n      <!-- Comment -->\n    </div>\n  </body>\n  </html>`,\n      'text/html',\n    );\n    expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n      `<ul>\n          <li>Foo</li>\n          <li>\n            Bar\n            <ul>\n              <li>Baz</li>\n              <li>Qux</li>\n            </ul>\n          </li>\n          <li>Quxx</li>\n        </ul>`.replace(/\\s/g, ''),\n    );\n  });\n\n  test('ignores text nodes', () => {\n    const doc = new DOMParser().parseFromString(\n      `\n  <!DOCTYPE html>\n  <html>\n  <body>\n    <h2>Foo</h2>\n    <div>\n      Text node\n      <h2>Bar</h2>\n      <h3>Baz</h3>\n      <h3>Qux</h3>\n    </div>\n    Text node\n    <div>\n      <h2>Quxx</h2>\n      Text node\n    </div>\n  </body>\n  </html>`,\n      'text/html',\n    );\n    expect(tableOfContents(doc).replace(/\\s/g, '')).toBe(\n      `<ul>\n          <li>Foo</li>\n          <li>\n            Bar\n            <ul>\n              <li>Baz</li>\n              <li>Qux</li>\n            </ul>\n          </li>\n          <li>Quxx</li>\n        </ul>`.replace(/\\s/g, ''),\n    );\n  });\n});\n",
    "/src/table-of-contents.ts": "type Node = {\n  text: string | null;\n  children: Array<Node>;\n};\n\nfunction stringify(contents: Node): string {\n  function stringifyNode(node: Node): string {\n    return `<li>${node.text}${stringifyChildren(node.children)}</li>`;\n  }\n\n  function stringifyChildren(children: Array<Node>): string {\n    return children.length > 0\n      ? `<ul>${children.map(stringifyNode).join('')}</ul>`\n      : '';\n  }\n\n  return stringifyChildren(contents.children);\n}\n\nconst headingTags = new Set(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']);\n\nexport default function tableOfContents(doc: Document): string {\n  const rootNode = {\n    text: null,\n    children: [],\n  };\n  const stack: Array<Node> = [rootNode];\n  let currentLevel = 0;\n\n  function traverse(element: Element) {\n    if (element == null || element.tagName == null) {\n      return;\n    }\n\n    if (headingTags.has(element.tagName.toLowerCase())) {\n      const level = parseInt(element.tagName[1], 10);\n      const node = {\n        text: element.textContent,\n        children: [],\n      };\n\n      for (let i = level; i < currentLevel + 1; i++) {\n        stack.pop();\n      }\n\n      stack[stack.length - 1].children.push(node);\n      stack.push(node);\n      currentLevel = level;\n    }\n\n    for (const child of element.children) {\n      traverse(child);\n    }\n  }\n\n  traverse(doc.body);\n\n  return stringify(stack[0]);\n}\n"
  },
  "info": {
    "excerpt": "Implement a function to construct a table of contents from an HTML document",
    "title": "Table of Contents"
  },
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [
      "google"
    ],
    "created": 1649894400,
    "difficulty": "hard",
    "duration": 30,
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/table-of-contents",
    "importance": "medium",
    "languages": [
      "html",
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "table-of-contents",
    "subtitle": null,
    "topics": [
      "recursion",
      "tree",
      "web-api"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Document} doc\n * @return {string}\n */\nexport default function tableOfContents(doc) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function tableOfContents(doc: Document): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var r in e)l(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!v.call(t,i)&&i!==r&&l(t,i,{get:()=>e[i],enumerable:!(h=m(e,i))||h.enumerable});return t};var x=(t,e,r)=>(r=t!=null?f(y(t)):{},o(e||!t||!t.__esModule?l(r,\"default\",{value:t,enumerable:!0}):r,t)),N=t=>o(l({},\"__esModule\",{value:!0}),t);var d=w((O,c)=>{c.exports=_jsx_runtime});var M={};b(M,{default:()=>L});var n=x(d());var a=MDXCodeBlock;var s=`function stringify(contents) {\n  function stringifyNode(node) {\n    return \\`<li>\\${node.text}\\${stringifyChildren(node.children)}</li>\\`;\n  }\n\n  function stringifyChildren(children) {\n    return children.length > 0\n      ? \\`<ul>\\${children.map(stringifyNode).join('')}</ul>\\`\n      : '';\n  }\n\n  return stringifyChildren(contents.children);\n}\n\nconst headingTags = new Set(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']);\n\n/**\n * @param {Document} doc\n * @return {string}\n */\nexport default function tableOfContents(doc) {\n  const rootNode = {\n    text: null,\n    children: [],\n  };\n  const stack = [rootNode];\n  let currentLevel = 0;\n\n  function traverse(element) {\n    if (element == null || element.tagName == null) {\n      return;\n    }\n\n    if (headingTags.has(element.tagName.toLowerCase())) {\n      const level = parseInt(element.tagName[1], 10);\n      const node = {\n        text: element.textContent,\n        children: [],\n      };\n\n      for (let i = level; i < currentLevel + 1; i++) {\n        stack.pop();\n      }\n\n      stack[stack.length - 1].children.push(node);\n      stack.push(node);\n      currentLevel = level;\n    }\n\n    for (const child of element.children) {\n      traverse(child);\n    }\n  }\n\n  traverse(doc.body);\n\n  return stringify(stack[0]);\n}\n`;var g=`type Node = {\n  text: string | null;\n  children: Array<Node>;\n};\n\nfunction stringify(contents: Node): string {\n  function stringifyNode(node: Node): string {\n    return \\`<li>\\${node.text}\\${stringifyChildren(node.children)}</li>\\`;\n  }\n\n  function stringifyChildren(children: Array<Node>): string {\n    return children.length > 0\n      ? \\`<ul>\\${children.map(stringifyNode).join('')}</ul>\\`\n      : '';\n  }\n\n  return stringifyChildren(contents.children);\n}\n\nconst headingTags = new Set(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']);\n\nexport default function tableOfContents(doc: Document): string {\n  const rootNode = {\n    text: null,\n    children: [],\n  };\n  const stack: Array<Node> = [rootNode];\n  let currentLevel = 0;\n\n  function traverse(element: Element) {\n    if (element == null || element.tagName == null) {\n      return;\n    }\n\n    if (headingTags.has(element.tagName.toLowerCase())) {\n      const level = parseInt(element.tagName[1], 10);\n      const node = {\n        text: element.textContent,\n        children: [],\n      };\n\n      for (let i = level; i < currentLevel + 1; i++) {\n        stack.pop();\n      }\n\n      stack[stack.length - 1].children.push(node);\n      stack.push(node);\n      currentLevel = level;\n    }\n\n    for (const child of element.children) {\n      traverse(child);\n    }\n  }\n\n  traverse(doc.body);\n\n  return stringify(stack[0]);\n}\n`;function u(t){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",ol:\"ol\",code:\"code\",h3:\"h3\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"This is a practical question which is used in many content-heavy sites such as blogs, documentation websites, Google Docs, and as mentioned in the question, screen readers.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"What should be returned if there are no headings on the page?\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Return an empty string.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The solution can be split into two parts:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Traversing the \",(0,n.jsx)(e.code,{children:\"document\"}),\", identifying the heading tags and creating the hierarchy tree.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Stringifying the hierarchy tree as an HTML string.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Traversing the \",(0,n.jsx)(e.code,{children:\"document\"}),\" and creating the headings hierarchy tree\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since the DOM is a tree and we have to traverse it in a depth-first fashion, recursion works well here. Starting from the root element (the \",(0,n.jsx)(e.code,{children:\"<body>\"}),\"), we can process the current element, then traverse its children in a depth-first manner.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Use \",(0,n.jsx)(e.code,{children:\"Element.tagName\"}),\" to identify whether an element is a heading element. Remember that \",(0,n.jsx)(e.code,{children:\"tagName\"}),\"s are in uppercase.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The headings hierarchy also resembles a tree. Each node in the hierarchy tree contains two properties:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"text\"}),\": Label for the node.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"children\"}),\": An array of nodes.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The resulting headings hierarchy tree of a proper HTML document will follow the rule that a node's \",(0,n.jsx)(e.code,{children:\"children\"}),\", if present will always be \",(0,n.jsx)(e.strong,{children:\"one heading level lower than itself.\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We'll use a \",(0,n.jsx)(e.code,{children:\"stack\"}),\" to keep a reference to the most recent heading elements we have traversed and \",(0,n.jsx)(e.code,{children:\"currentLevel\"}),\", an integer variable to track the level of the most recent heading element. The level is important because it affects how we push elements into the headings hierarchy.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"As we traverse the tree, if the current element is not a heading tag, we can ignore it. Otherwise we create a hierarchy node, with the text being the element's \",(0,n.jsx)(e.code,{children:\"textContent\"}),\" and \",(0,n.jsx)(e.code,{children:\"children\"}),\" being an empty array. Then we look at the level of the current element:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the level is greater than the \",(0,n.jsx)(e.code,{children:\"currentLevel\"}),\", we add this node as a children of the most recent heading node (the top node of the stack).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the level is the same as the \",(0,n.jsx)(e.code,{children:\"currentLevel\"}),\", we need to add this node as a sibling of the most recent heading node. We can do this by popping from the stack to get access of the parent of the most recent heading node. Then \",(0,n.jsx)(e.code,{children:\".push()\"}),\" the node into the \",(0,n.jsx)(e.code,{children:\"children\"}),\" of the parent.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the level is smaller than the \",(0,n.jsx)(e.code,{children:\"currentLevel\"}),\", depending on the level difference, we might need to \",(0,n.jsx)(e.code,{children:\".pop()\"}),\" more than once. Heading levels won't be skipped when it is increasing, but it is perfectly valid for a \",(0,n.jsx)(e.code,{children:\"<h4>\"}),\" to be followed by a \",(0,n.jsx)(e.code,{children:\"<h2>\"}),\". Because of the headings hierarchy tree rules, the number of times we need to pop is the level difference + 1. After popping that number of times, we will have access to the right parent node and we can push the current node into the parent node's children.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Stringifying the hierarchy tree as an HTML string\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Again, we'll make use of recursion here. We'll define two helper functions, one to stringify a node, and another to stringify the \",(0,n.jsx)(e.code,{children:\"children\"}),\".\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"stringifyNode\"}),\": Each node will be rendered as an \",(0,n.jsx)(e.code,{children:\"<li>\"}),\" element. We render the \",(0,n.jsx)(e.code,{children:\"text\"}),\" and \",(0,n.jsx)(e.code,{children:\"children\"}),\", if present.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"stringifyChildren\"}),\": Each \",(0,n.jsx)(e.code,{children:\"children\"}),\" is an array, which is rendered as a \",(0,n.jsx)(e.code,{children:\"<ul>\"}),\". And we can call \",(0,n.jsx)(e.code,{children:\"stringifyNode\"}),\" on each node in the \",(0,n.jsx)(e.code,{children:\"children\"}),\". We shouldn't be rendering empty \",(0,n.jsx)(e.code,{children:\"<ul>\"}),\", so we should check whether \",(0,n.jsx)(e.code,{children:\"children.length\"}),\" is bigger than 0 before creating the string.\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{languages:{jsx:s,tsx:g}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Ignore irrelevant nodes in the DOM tree such as comment nodes and text nodes.\"}),`\n`,(0,n.jsx)(e.li,{children:\"DOM trees which have deep levels of nesting.\"}),`\n`,(0,n.jsx)(e.li,{children:\"DOM trees which do not have any headings at all.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Recursion.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"DOM traversal basics - \",(0,n.jsx)(e.code,{children:\"Element.textContent\"}),\", \",(0,n.jsx)(e.code,{children:\"Element.tagName\"}),\".\"]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var L=T;return N(M);})();\n;return Component;",
  "workspace": {
    "main": "/src/table-of-contents.ts",
    "run": "/src/table-of-contents.run.test.ts",
    "submit": "/src/table-of-contents.submit.test.ts"
  }
}