{
  "description": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),j=(r,e)=>{for(var t in e)s(r,t,{get:e[t],enumerable:!0})},i=(r,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of h(e))!f.call(r,o)&&o!==t&&s(r,o,{get:()=>e[o],enumerable:!(a=m(e,o))||a.enumerable});return r};var w=(r,e,t)=>(t=r!=null?d(u(r)):{},i(e||!r||!r.__esModule?s(t,\"default\",{value:r,enumerable:!0}):t,r)),v=r=>i(s({},\"__esModule\",{value:!0}),r);var c=g((A,l)=>{l.exports=_jsx_runtime});var y={};j(y,{default:()=>x,frontmatter:()=>P});var n=w(c()),P={title:\"Promise.all\",excerpt:\"Implement the Promise.all() function that resolves to an array of results if all the input elements are resolved or rejects otherwise\"};function p(r){let e=Object.assign({blockquote:\"blockquote\",p:\"p\",code:\"code\",em:\"em\",a:\"a\",pre:\"pre\",h2:\"h2\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Promise.all()\"}),\" is a method that takes an iterable of elements (usually \",(0,n.jsx)(e.code,{children:\"Promises\"}),\") as an input, and returns a single \",(0,n.jsx)(e.code,{children:\"Promise\"}),\" that resolves to an array of the results of the input promises. This returned promise will resolve when all of the input's promises have resolved, or if the input iterable contains no promises. It rejects immediately upon any of the input promises rejecting or non-promises throwing an error, and will reject with this first rejection message / error.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.em,{children:[\"Source: \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\",children:\"Promise.all() - JavaScript | MDN\"})]})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Promise.all()\"}),\" is frequently used when there are multiple concurrent API requests and we want to wait for all of them to have completed to continue with code execution, usually because we depend on data from both responses.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const [userData, postsData, tagsData] = await Promise.all([\n  fetch('/api/user'),\n  fetch('/api/posts'),\n  fetch('/api/tags'),\n]);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's implement our own version of \",(0,n.jsx)(e.code,{children:\"Promise.all()\"}),\", a \",(0,n.jsx)(e.code,{children:\"promiseAll\"}),\" function, with the difference being the function takes in an array instead of an iterable. Be sure to read the description carefully and implement accordingly!\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Resolved example.\nconst p0 = Promise.resolve(3);\nconst p1 = 42;\nconst p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('foo');\n  }, 100);\n});\n\nawait promiseAll([p0, p1, p2]); // [3, 42, 'foo']\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Rejection example.\nconst p0 = Promise.resolve(30);\nconst p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('An error occurred!');\n  }, 100);\n});\n\ntry {\n  await promiseAll([p0, p1]);\n} catch (err) {\n  console.log(err); // 'An error occurred!'\n}\n`})})]})}function b(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(p,r)})):p(r)}var x=b;return v(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/promise-all\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/promise-all.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/promise-all.run.test.ts": "import promiseAll from './promise-all';\n\ndescribe('promiseAll', () => {\n  test('returns promise', () => {\n    const p = promiseAll([]);\n    expect(p).toBeInstanceOf(Promise);\n  });\n\n  test('empty input array', async () => {\n    expect.assertions(1);\n    const res = await promiseAll([]);\n    expect(res).toEqual([]);\n  });\n\n  test('resolved', async () => {\n    expect.assertions(1);\n    const p0 = Promise.resolve(2);\n    const p1 = new Promise((resolve) => {\n      setTimeout(() => {\n        resolve(3);\n      }, 10);\n    });\n\n    const res = await promiseAll([p0, p1]);\n    expect(res).toEqual([2, 3]);\n  });\n\n  test('rejected', async () => {\n    expect.assertions(1);\n    const p0 = Promise.reject(2);\n    const p1 = Promise.reject(3);\n\n    await expect(promiseAll([p0, p1])).rejects.toBe(2);\n  });\n});\n",
    "/src/promise-all.submit.test.ts": "import promiseAll from './promise-all';\n\ndescribe('promiseAll', () => {\n  test('returns promise', () => {\n    const p = promiseAll([]);\n    expect(p).toBeInstanceOf(Promise);\n  });\n\n  test('empty input array', async () => {\n    expect.assertions(1);\n    const res = await promiseAll([]);\n    expect(res).toEqual([]);\n  });\n\n  describe('one promise', () => {\n    describe('resolve', () => {\n      test('value', async () => {\n        expect.assertions(1);\n        const p0 = 2;\n\n        const res = await promiseAll([p0]);\n        expect(res).toEqual([2]);\n      });\n\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n\n        const res = await promiseAll([p0]);\n        expect(res).toEqual([2]);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 10);\n        });\n\n        const res = await promiseAll([p0]);\n        expect(res).toEqual([2]);\n      });\n    });\n\n    describe('reject', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(2);\n\n        await expect(promiseAll([p0])).rejects.toBe(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseAll([p0])).rejects.toBe(2);\n      });\n    });\n  });\n\n  describe('multiple promises', () => {\n    describe('all resolve', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n        const p1 = Promise.resolve(3);\n\n        const res = await promiseAll([p0, p1]);\n        expect(res).toEqual([2, 3]);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(2);\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 10);\n        });\n\n        const res = await promiseAll([p0, p1]);\n        expect(res).toEqual([2, 3]);\n      });\n\n      test('mixture', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 10);\n        });\n        const p1 = Promise.resolve(3);\n        const p2 = 4;\n\n        const res = await promiseAll([p0, p1, p2]);\n        expect(res).toEqual([2, 3, 4]);\n      });\n\n      test('many delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(1);\n          }, 200);\n        });\n        const p1 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(2);\n          }, 100);\n        });\n        const p2 = new Promise((resolve) => {\n          setTimeout(() => {\n            resolve(3);\n          }, 10);\n        });\n\n        const res = await promiseAll([p0, p1, p2]);\n        expect(res).toEqual([1, 2, 3]);\n      });\n    });\n\n    describe('all reject', () => {\n      test('instant', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(2);\n        const p1 = Promise.reject(3);\n\n        await expect(promiseAll([p0, p1])).rejects.toBe(2);\n      });\n\n      test('delayed', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(3);\n          }, 1);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseAll([p0, p1])).rejects.toBe(3);\n      });\n\n      test('mixture', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseAll([p0, p1])).rejects.toBe(42);\n      });\n    });\n\n    describe('mix of resolve and reject', () => {\n      test('instant resolve delayed reject', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(42);\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 10);\n        });\n\n        await expect(promiseAll([p0, p1])).rejects.toBe(2);\n      });\n\n      test('instant resolve instant reject', async () => {\n        expect.assertions(1);\n        const p0 = Promise.resolve(42);\n        const p1 = Promise.reject(2);\n\n        await expect(promiseAll([p0, p1])).rejects.toBe(2);\n      });\n\n      test('instant rejects', async () => {\n        expect.assertions(1);\n        const p0 = Promise.reject(42);\n        const p1 = Promise.reject(43);\n\n        await expect(promiseAll([p0, p1])).rejects.toBe(42);\n      });\n\n      test('many promises', async () => {\n        expect.assertions(1);\n        const p0 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(1);\n          }, 200);\n        });\n        const p1 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(2);\n          }, 100);\n        });\n        const p2 = new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(3);\n          }, 10);\n        });\n\n        await expect(promiseAll([p0, p1, p2])).rejects.toBe(3);\n      });\n    });\n  });\n});\n",
    "/src/promise-all.ts": "type ReturnValue<T> = { -readonly [P in keyof T]: Awaited<T[P]> };\n\nexport default function promiseAll<T extends readonly unknown[] | []>(\n  iterable: T,\n): Promise<ReturnValue<T>> {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results as ReturnValue<T>);\n      return;\n    }\n\n    iterable.forEach(async (item, index) => {\n      try {\n        const value = await item;\n        results[index] = value;\n        unresolved -= 1;\n\n        if (unresolved === 0) {\n          resolve(results as ReturnValue<T>);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n}\n"
  },
  "metadata": {
    "access": "free",
    "author": "yangshun",
    "companies": [
      "amazon",
      "bytedance",
      "google",
      "lyft",
      "tiktok",
      "microsoft",
      "qualcomm"
    ],
    "created": 1655337600,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement the Promise.all() function that resolves to an array of results if all the input elements are resolved or rejects otherwise",
    "featured": true,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/promise-all",
    "importance": "high",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "flatten",
      "promise-any",
      "todo-list"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "promise-all-settled",
      "promise-any",
      "promise-race"
    ],
    "slug": "promise-all",
    "subtitle": null,
    "title": "Promise.all",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Array} iterable\n * @return {Promise<Array>}\n */\nexport default function promiseAll(iterable) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function promiseAll<T extends readonly unknown[] | []>(\n  iterable: T,\n): Promise<{ -readonly [P in keyof T]: Awaited<T[P]> }> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var v=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),P=(n,e)=>{for(var t in e)o(n,t,{get:e[t],enumerable:!0})},s=(n,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!g.call(n,i)&&i!==t&&o(n,i,{get:()=>e[i],enumerable:!(a=f(e,i))||a.enumerable});return n};var j=(n,e,t)=>(t=n!=null?v(w(n)):{},s(e||!n||!n.__esModule?o(t,\"default\",{value:n,enumerable:!0}):t,n)),x=n=>s(o({},\"__esModule\",{value:!0}),n);var d=b((E,c)=>{c.exports=_jsx_runtime});var C={};P(C,{default:()=>_});var r=j(d());var l=MDXCodeBlock;var h=`/**\n * @param {Array} iterable\n * @return {Promise<Array>}\n */\nexport default function promiseAll(iterable) {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach(async (item, index) => {\n      try {\n        const value = await item;\n        results[index] = value;\n        unresolved -= 1;\n\n        if (unresolved === 0) {\n          resolve(results);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n}\n`;var u=`type ReturnValue<T> = { -readonly [P in keyof T]: Awaited<T[P]> };\n\nexport default function promiseAll<T extends readonly unknown[] | []>(\n  iterable: T,\n): Promise<ReturnValue<T>> {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results as ReturnValue<T>);\n      return;\n    }\n\n    iterable.forEach(async (item, index) => {\n      try {\n        const value = await item;\n        results[index] = value;\n        unresolved -= 1;\n\n        if (unresolved === 0) {\n          resolve(results as ReturnValue<T>);\n        }\n      } catch (err) {\n        reject(err);\n      }\n    });\n  });\n}\n`;var m=`/**\n * @param {Array} iterable\n * @return {Promise<Array>}\n */\nexport default function promiseAll(iterable) {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach((item, index) => {\n      Promise.resolve(item).then(\n        (value) => {\n          results[index] = value;\n          unresolved -= 1;\n\n          if (unresolved === 0) {\n            resolve(results);\n          }\n        },\n        (reason) => {\n          reject(reason);\n        },\n      );\n    });\n  });\n}\n`;function p(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",h3:\"h3\",ul:\"ul\",a:\"a\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"This is a pretty important question to practice because async programming is frequently tested during interviews. Understanding how \",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\" works under the hood will help you in understanding the mechanisms behind similar \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"-related functions like \",(0,r.jsx)(e.code,{children:\"Promise.race\"}),\",\",(0,r.jsx)(e.code,{children:\"Promise.any\"}),\", \",(0,r.jsx)(e.code,{children:\"Promise.allSettled\"}),\", etc.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsx)(e.p,{children:\"There are a few aspects to this question we need to bear in mind and handle:\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"Promise\"}),\"s are meant to be chained, so the function needs to return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the input array is empty, the returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" resolves with an empty array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" contains an array of resolved values in the same order as the input if all of them are fulfilled.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" rejects immediately if any of the input values are rejected or throw an error.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s.\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Solution 1: Count unresolved promises using \",(0,r.jsx)(e.code,{children:\"async\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Since the function needs to return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\", we can construct a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" at the top level of the function and return it. The bulk of the code will be written within the constructor parameter.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"We first check if the input array is empty, and resolve with an empty array if so.\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"We then need to attempt resolving every item in the input array. This can be achieved using \",(0,r.jsx)(e.code,{children:\"Array.prototype.forEach\"}),\" or \",(0,r.jsx)(e.code,{children:\"Array.prototype.map\"}),\". As the returned values will need to preserve the order of the input array, we create a \",(0,r.jsx)(e.code,{children:\"results\"}),\" array and slot the value in the right place using its \",(0,r.jsx)(e.code,{children:\"index\"}),\" within the input array. To know when all the input array values have been resolved, we keep track of how many unresolved promises there are by initializing a counter of unresolved values and decrementing it whenever a value is resolved. When the counter reaches 0, we can return the \",(0,r.jsx)(e.code,{children:\"results\"}),\" array.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"One thing to note here is that because the input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, if we are not \",(0,r.jsx)(e.code,{children:\"await\"}),\"-ing them, we need to wrap each value with \",(0,r.jsx)(e.code,{children:\"Promise.resolve()\"}),\" which allows us to use \",(0,r.jsx)(e.code,{children:\".then()\"}),\" on each of them and we don't have to differentiate between \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" vs non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values and whether they need to be resolved.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Lastly, if any of the values are rejected, we reject the top-level \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" immediately without waiting for any other pending promises.\"]}),`\n`,(0,r.jsx)(l,{languages:{jsx:h,tsx:u}}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Solution 2: Count unresolved promises using \",(0,r.jsx)(e.code,{children:\"Promise.then\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Here's an alternative version which uses \",(0,r.jsx)(e.code,{children:\"Promise.then()\"}),\" if you prefer not to use \",(0,r.jsx)(e.code,{children:\"async\"}),\"/\",(0,r.jsx)(e.code,{children:\"await\"}),\".\"]}),`\n`,(0,r.jsx)(l,{children:m}),`\n`,(0,r.jsxs)(e.p,{children:[\"Once one of the \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"'s resolving functions (\",(0,r.jsx)(e.code,{children:\"resolve\"}),\" or \",(0,r.jsx)(e.code,{children:\"reject\"}),') is called, the promise is in the \"settled\" state, and subsequent calls to either function can neither change the fulfillment value or rejection reason nor change the eventual state from \"fulfilled\" to \"rejected\" or vice versa.']}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Empty input array. An empty array should be returned.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the array contains non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, they will still be part of the returned array if all the input values are fulfilled.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"If the outcome is a rejection, the value of the first rejection should be returned.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Knowledge of \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s, how to construct one, how to use them.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Async programming.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"The evaluator does not verify that your input array is resolved concurrently rather than sequentially.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all\",children:\"Promise.all() - JavaScript | MDN\"})}),`\n`]})]})}function S(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(p,n)})):p(n)}var _=S;return x(C);})();\n;return Component;",
  "workspace": {
    "main": "/src/promise-all.ts",
    "run": "/src/promise-all.run.test.ts",
    "submit": "/src/promise-all.submit.test.ts"
  }
}