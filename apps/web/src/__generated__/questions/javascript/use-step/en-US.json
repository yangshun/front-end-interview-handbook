{
  "description": "var Component=(()=>{var a=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var o in e)s(n,o,{get:e[o],enumerable:!0})},c=(n,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!b.call(n,i)&&i!==o&&s(n,i,{get:()=>e[i],enumerable:!(r=u(e,i))||r.enumerable});return n};var v=(n,e,o)=>(o=n!=null?a(m(n)):{},c(e||!n||!n.__esModule?s(o,\"default\",{value:n,enumerable:!0}):o,n)),g=n=>c(s({},\"__esModule\",{value:!0}),n);var h=x((_,d)=>{d.exports=_jsx_runtime});var A={};f(A,{default:()=>k,frontmatter:()=>S});var t=v(h()),S={title:\"useStep\",excerpt:\"Implement a hook that manages a step counter for a multi-step process\"};function l(n){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Implement a \",(0,t.jsx)(e.code,{children:\"useStep\"}),\" hook that manages a step counter for a multi-step process.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The hook should provide utility methods to go to the next and previous steps, and allow resetting of the step counter. The step number is 1-indexed and goes up at most to \",(0,t.jsx)(e.code,{children:\"maxStep\"}),\".\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`export default function Component() {\n  const { step, next, previous, reset, setStep, hasNext, hasPrevious } =\n    useStep(3);\n\n  return (\n    <div>\n      <p>Step {step}</p>\n      <button onClick={previous} disabled={!hasPrevious}>\n        Previous\n      </button>\n      <button onClick={next} disabled={!hasNext}>\n        Next\n      </button>\n      <button onClick={reset}>Reset</button>\n      <button onClick={() => setStep(3)}>Go to step 3</button>\n    </div>\n  );\n}\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"maxStep: number\"}),\": The maximum step number, i.e., the last step\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,t.jsx)(e.p,{children:\"The hook returns an object with the following properties/methods:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"step\"}),\": The current step number. It is initialized to \",(0,t.jsx)(e.code,{children:\"1\"})]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"next: () => void\"}),\": A function that increments the step number\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"previous: () => void\"}),\": A function that decrements the step number\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"hasNext: boolean\"}),\": A boolean that indicates if there is a next step\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"hasPrevious: boolean\"}),\": A boolean that indicates if there is a previous step\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"reset: () => void\"}),\": A function that resets the step number to \",(0,t.jsx)(e.code,{children:\"1\"})]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"setStep\"}),\": A function that sets the step number to a specific step. This should accept both a \",(0,t.jsx)(e.code,{children:\"number\"}),\" and an updater function \",(0,t.jsx)(e.code,{children:\"(currentStep: number) => void\"}),\", similar to what the setter function of \",(0,t.jsx)(e.code,{children:\"useState\"}),\" accepts\"]}),`\n`]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var k=j;return g(A);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-step\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-step.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/src/use-step.run.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useStep from './use-step';\n\ndescribe('useStep', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useStep(1));\n\n    expect(typeof result.current.step).toBe('number');\n    expect(typeof result.current.next).toBe('function');\n    expect(typeof result.current.previous).toBe('function');\n    expect(typeof result.current.setStep).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n    expect(typeof result.current.hasNext).toBe('boolean');\n    expect(typeof result.current.hasPrevious).toBe('boolean');\n  });\n\n  test('initial value', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('next step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.next());\n\n    expect(result.current.step).toBe(2);\n  });\n\n  test('previous step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n    act(() => result.current.previous());\n\n    expect(result.current.step).toBe(2);\n  });\n\n  test('set step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n\n    expect(result.current.step).toBe(3);\n  });\n\n  test('reset step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n    act(() => result.current.reset());\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('has next if step is first', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.hasNext).toBe(true);\n  });\n\n  test('has previous if step is last', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(5));\n\n    expect(result.current.hasPrevious).toBe(true);\n  });\n});\n",
    "/src/use-step.submit.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useStep from './use-step';\n\ndescribe('useStep', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useStep(1));\n\n    expect(typeof result.current.step).toBe('number');\n    expect(typeof result.current.next).toBe('function');\n    expect(typeof result.current.previous).toBe('function');\n    expect(typeof result.current.setStep).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n    expect(typeof result.current.hasNext).toBe('boolean');\n    expect(typeof result.current.hasPrevious).toBe('boolean');\n  });\n\n  test('initial value', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('next step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.next());\n\n    expect(result.current.step).toBe(2);\n  });\n\n  test('previous step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n    act(() => result.current.previous());\n\n    expect(result.current.step).toBe(2);\n  });\n\n  test('set step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n\n    expect(result.current.step).toBe(3);\n  });\n\n  test('reset step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n    act(() => result.current.reset());\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('has next if step is first', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.hasNext).toBe(true);\n  });\n\n  test('not has previous if step is first', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.hasPrevious).toBe(false);\n  });\n\n  test('not has next if step is last', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(5));\n\n    expect(result.current.hasNext).toBe(false);\n  });\n\n  test('has previous if step is last', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(5));\n\n    expect(result.current.hasPrevious).toBe(true);\n  });\n\n  test('has next and has previous if step is not first or last', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n\n    expect(result.current.hasNext).toBe(true);\n    expect(result.current.hasPrevious).toBe(true);\n  });\n\n  test(\"next doesn't go beyond max step\", () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(5));\n    act(() => result.current.next());\n\n    expect(result.current.step).toBe(5);\n  });\n\n  test(\"previous doesn't go beyond min step\", () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(1));\n    act(() => result.current.previous());\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test(\"setStep doesn't go beyond max step\", () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(6));\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test(\"setStep doesn't go beyond min step\", () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(0));\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('setStep works with an updater function', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep((step) => step + 2));\n\n    expect(result.current.step).toBe(3);\n  });\n});\n",
    "/src/use-step.ts": "import { Dispatch, SetStateAction, useCallback, useState } from 'react';\n\ninterface UseStepReturn {\n  step: number;\n  next: () => void;\n  previous: () => void;\n  reset: () => void;\n  hasNext: boolean;\n  hasPrevious: boolean;\n  setStep: Dispatch<SetStateAction<number>>;\n}\n\nexport default function useStep(maxStep: number): UseStepReturn {\n  const [currentStep, setCurrentStep] = useState(1);\n\n  const setStep: UseStepReturn['setStep'] = useCallback(\n    (step) => {\n      const newStep = typeof step === 'function' ? step(currentStep) : step;\n      if (newStep < 1 || newStep > maxStep) return;\n\n      setCurrentStep(newStep);\n    },\n    [maxStep, currentStep],\n  );\n\n  const next: UseStepReturn['next'] = useCallback(() => {\n    setCurrentStep((step) => Math.min(step + 1, maxStep));\n  }, [maxStep]);\n\n  const previous: UseStepReturn['previous'] = useCallback(() => {\n    setCurrentStep((step) => Math.max(step - 1, 1));\n  }, []);\n\n  const reset: UseStepReturn['reset'] = useCallback(() => {\n    setCurrentStep(1);\n  }, []);\n\n  return {\n    step: currentStep,\n    next,\n    previous,\n    hasNext: currentStep < maxStep,\n    hasPrevious: currentStep > 1,\n    setStep,\n    reset,\n  };\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "phillmont",
    "companies": [],
    "created": 1742169600,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a hook that manages a step counter for a multi-step process",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": "react",
    "frameworks": [
      {
        "framework": "react",
        "href": "/questions/javascript/use-step"
      }
    ],
    "href": "/questions/javascript/use-step",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "use-step",
    "subtitle": null,
    "title": "useStep",
    "topics": [
      "react-hooks"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {number} maxStep\n */\nexport default function useStep(maxStep) {\n  throw 'Not implemented';\n}",
    "ts": "import { Dispatch, SetStateAction } from 'react';\n\ninterface UseStepReturn {\n  step: number;\n  next: () => void;\n  previous: () => void;\n  reset: () => void;\n  hasNext: boolean;\n  hasPrevious: boolean;\n  setStep: Dispatch<SetStateAction<number>>;\n}\n\nexport default function useStep(maxStep: number): UseStepReturn {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var l=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),C=(t,e)=>{for(var s in e)o(t,s,{get:e[s],enumerable:!0})},u=(t,e,s,p)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of h(e))!b.call(t,r)&&r!==s&&o(t,r,{get:()=>e[r],enumerable:!(p=l(e,r))||p.enumerable});return t};var v=(t,e,s)=>(s=t!=null?m(x(t)):{},u(e||!t||!t.__esModule?o(s,\"default\",{value:t,enumerable:!0}):s,t)),k=t=>u(o({},\"__esModule\",{value:!0}),t);var c=f((_,a)=>{a.exports=_jsx_runtime});var M={};C(M,{default:()=>w});var n=v(c());var i=MDXCodeBlock;var S=`import { Dispatch, SetStateAction, useCallback, useState } from 'react';\n\ninterface UseStepReturn {\n  step: number;\n  next: () => void;\n  previous: () => void;\n  reset: () => void;\n  hasNext: boolean;\n  hasPrevious: boolean;\n  setStep: Dispatch<SetStateAction<number>>;\n}\n\nexport default function useStep(maxStep: number): UseStepReturn {\n  const [currentStep, setCurrentStep] = useState(1);\n\n  const setStep: UseStepReturn['setStep'] = useCallback(\n    (step) => {\n      const newStep = typeof step === 'function' ? step(currentStep) : step;\n      if (newStep < 1 || newStep > maxStep) return;\n\n      setCurrentStep(newStep);\n    },\n    [maxStep, currentStep],\n  );\n\n  const next: UseStepReturn['next'] = useCallback(() => {\n    setCurrentStep((step) => Math.min(step + 1, maxStep));\n  }, [maxStep]);\n\n  const previous: UseStepReturn['previous'] = useCallback(() => {\n    setCurrentStep((step) => Math.max(step - 1, 1));\n  }, []);\n\n  const reset: UseStepReturn['reset'] = useCallback(() => {\n    setCurrentStep(1);\n  }, []);\n\n  return {\n    step: currentStep,\n    next,\n    previous,\n    hasNext: currentStep < maxStep,\n    hasPrevious: currentStep > 1,\n    setStep,\n    reset,\n  };\n}\n`;function d(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"useStep\"}),\" hook can be implemented by storing the step number in a \",(0,n.jsx)(e.code,{children:\"useState\"}),\" state and defining the utility methods to manipulate the step number in terms of the state's setter function. We bound the step updates between \",(0,n.jsx)(e.code,{children:\"1\"}),\" and \",(0,n.jsx)(e.code,{children:\"maxStep\"}),\" to ensure the step number does not go out of bounds.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Remember to wrap the utility methods in \",(0,n.jsx)(e.code,{children:\"useCallback\"}),\" to prevent unnecessary re-renders of the calling component.\"]}),`\n`,(0,n.jsx)(i,{children:S})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var w=j;return k(M);})();\n;return Component;",
  "workspace": {
    "main": "/src/use-step.ts",
    "run": "/src/use-step.run.test.ts",
    "submit": "/src/use-step.submit.test.ts"
  }
}