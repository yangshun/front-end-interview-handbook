{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-step\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-step.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/use-step.run.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useStep from './use-step';\n\ndescribe('useStep', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useStep(1));\n\n    expect(typeof result.current.step).toBe('number');\n    expect(typeof result.current.next).toBe('function');\n    expect(typeof result.current.previous).toBe('function');\n    expect(typeof result.current.setStep).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n    expect(typeof result.current.hasNext).toBe('boolean');\n    expect(typeof result.current.hasPrevious).toBe('boolean');\n  });\n\n  test('initial value', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('next step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.next());\n\n    expect(result.current.step).toBe(2);\n  });\n\n  test('previous step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n    act(() => result.current.previous());\n\n    expect(result.current.step).toBe(2);\n  });\n\n  test('set step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n\n    expect(result.current.step).toBe(3);\n  });\n\n  test('reset step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n    act(() => result.current.reset());\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('has next if step is first', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.hasNext).toBe(true);\n  });\n\n  test('has previous if step is last', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(5));\n\n    expect(result.current.hasPrevious).toBe(true);\n  });\n});\n",
    "/src/use-step.submit.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useStep from './use-step';\n\ndescribe('useStep', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useStep(1));\n\n    expect(typeof result.current.step).toBe('number');\n    expect(typeof result.current.next).toBe('function');\n    expect(typeof result.current.previous).toBe('function');\n    expect(typeof result.current.setStep).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n    expect(typeof result.current.hasNext).toBe('boolean');\n    expect(typeof result.current.hasPrevious).toBe('boolean');\n  });\n\n  test('initial value', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('next step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.next());\n\n    expect(result.current.step).toBe(2);\n  });\n\n  test('previous step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n    act(() => result.current.previous());\n\n    expect(result.current.step).toBe(2);\n  });\n\n  test('set step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n\n    expect(result.current.step).toBe(3);\n  });\n\n  test('reset step', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n    act(() => result.current.reset());\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('has next if step is first', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.hasNext).toBe(true);\n  });\n\n  test('not has previous if step is first', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    expect(result.current.hasPrevious).toBe(false);\n  });\n\n  test('not has next if step is last', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(5));\n\n    expect(result.current.hasNext).toBe(false);\n  });\n\n  test('has previous if step is last', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(5));\n\n    expect(result.current.hasPrevious).toBe(true);\n  });\n\n  test('has next and has previous if step is not first or last', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(3));\n\n    expect(result.current.hasNext).toBe(true);\n    expect(result.current.hasPrevious).toBe(true);\n  });\n\n  test(\"next doesn't go beyond max step\", () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(5));\n    act(() => result.current.next());\n\n    expect(result.current.step).toBe(5);\n  });\n\n  test(\"previous doesn't go beyond min step\", () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(1));\n    act(() => result.current.previous());\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test(\"setStep doesn't go beyond max step\", () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(6));\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test(\"setStep doesn't go beyond min step\", () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep(0));\n\n    expect(result.current.step).toBe(1);\n  });\n\n  test('setStep works with an updater function', () => {\n    const { result } = renderHook(() => useStep(5));\n\n    act(() => result.current.setStep((step) => step + 2));\n\n    expect(result.current.step).toBe(3);\n  });\n});\n",
    "/src/use-step.ts": "import { Dispatch, SetStateAction, useCallback, useState } from 'react';\n\ninterface UseStepReturn {\n  step: number;\n  next: () => void;\n  previous: () => void;\n  reset: () => void;\n  hasNext: boolean;\n  hasPrevious: boolean;\n  setStep: Dispatch<SetStateAction<number>>;\n}\n\nexport default function useStep(maxStep: number): UseStepReturn {\n  const [currentStep, setCurrentStep] = useState(1);\n\n  const setStep: UseStepReturn['setStep'] = useCallback(\n    (step) => {\n      const newStep = typeof step === 'function' ? step(currentStep) : step;\n      if (newStep < 1 || newStep > maxStep) return;\n\n      setCurrentStep(newStep);\n    },\n    [maxStep, currentStep],\n  );\n\n  const next: UseStepReturn['next'] = useCallback(() => {\n    setCurrentStep((step) => Math.min(step + 1, maxStep));\n  }, [maxStep]);\n\n  const previous: UseStepReturn['previous'] = useCallback(() => {\n    setCurrentStep((step) => Math.max(step - 1, 1));\n  }, []);\n\n  const reset: UseStepReturn['reset'] = useCallback(() => {\n    setCurrentStep(1);\n  }, []);\n\n  return {\n    step: currentStep,\n    next,\n    previous,\n    hasNext: currentStep < maxStep,\n    hasPrevious: currentStep > 1,\n    setStep,\n    reset,\n  };\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {number} maxStep\n */\nexport default function useStep(maxStep) {\n  throw 'Not implemented';\n}",
    "ts": "import { Dispatch, SetStateAction } from 'react';\n\ninterface UseStepReturn {\n  step: number;\n  next: () => void;\n  previous: () => void;\n  reset: () => void;\n  hasNext: boolean;\n  hasPrevious: boolean;\n  setStep: Dispatch<SetStateAction<number>>;\n}\n\nexport default function useStep(maxStep: number): UseStepReturn {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/use-step.ts",
    "run": "/src/use-step.run.test.ts",
    "submit": "/src/use-step.submit.test.ts"
  }
}