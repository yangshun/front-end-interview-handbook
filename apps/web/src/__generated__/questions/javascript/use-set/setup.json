{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-set\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-set.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/use-set.run.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useSet from './use-set';\n\ndescribe('useSet', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useSet());\n\n    expect(result.current.set).toBeInstanceOf(Set);\n    expect(typeof result.current.add).toBe('function');\n    expect(typeof result.current.remove).toBe('function');\n    expect(typeof result.current.toggle).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n    expect(typeof result.current.clear).toBe('function');\n  });\n\n  test('initial value', () => {\n    const initialValue = new Set([1, 2, 3]);\n\n    const { result } = renderHook(() => useSet(initialValue));\n\n    expect(result.current.set).toEqual(initialValue);\n  });\n\n  test('add element', () => {\n    const { result } = renderHook(() => useSet());\n\n    act(() => {\n      result.current.add(1);\n    });\n\n    expect(result.current.set).toEqual(new Set([1]));\n  });\n\n  test('remove element', () => {\n    const { result } = renderHook(() => useSet(new Set([1, 2, 3])));\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.set).toEqual(new Set([2, 3]));\n  });\n\n  test('toggle element', () => {\n    const { result } = renderHook(() => useSet(new Set([1, 2, 3])));\n\n    act(() => {\n      result.current.toggle(1);\n    });\n\n    expect(result.current.set).toEqual(new Set([2, 3]));\n\n    act(() => {\n      result.current.toggle(1);\n    });\n\n    expect(result.current.set).toEqual(new Set([2, 3, 1]));\n  });\n\n  test('reset elements', () => {\n    const { result } = renderHook(() => useSet(new Set([1, 2, 3])));\n\n    act(() => {\n      result.current.add(4);\n    });\n\n    expect(result.current.set).toEqual(new Set([1, 2, 3, 4]));\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.set).toEqual(new Set([1, 2, 3]));\n  });\n\n  test('clear elements', () => {\n    const { result } = renderHook(() => useSet(new Set([1, 2, 3])));\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.set).toEqual(new Set());\n  });\n});\n",
    "/src/use-set.submit.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useSet from './use-set';\n\ndescribe('useSet', () => {\n  test('return values', () => {\n    const { result } = renderHook(() => useSet());\n\n    expect(result.current.set).toBeInstanceOf(Set);\n    expect(typeof result.current.add).toBe('function');\n    expect(typeof result.current.remove).toBe('function');\n    expect(typeof result.current.toggle).toBe('function');\n    expect(typeof result.current.reset).toBe('function');\n    expect(typeof result.current.clear).toBe('function');\n  });\n\n  test('initial value', () => {\n    const initialValue = new Set([1, 2, 3]);\n\n    const { result } = renderHook(() => useSet(initialValue));\n\n    expect(result.current.set).toEqual(initialValue);\n  });\n\n  test('add element', () => {\n    const { result } = renderHook(() => useSet());\n\n    act(() => {\n      result.current.add(1);\n    });\n\n    expect(result.current.set).toEqual(new Set([1]));\n  });\n\n  test('remove element', () => {\n    const { result } = renderHook(() => useSet(new Set([1, 2, 3])));\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.set).toEqual(new Set([2, 3]));\n  });\n\n  test('toggle element', () => {\n    const { result } = renderHook(() => useSet(new Set([1, 2, 3])));\n\n    act(() => {\n      result.current.toggle(1);\n    });\n\n    expect(result.current.set).toEqual(new Set([2, 3]));\n\n    act(() => {\n      result.current.toggle(1);\n    });\n\n    expect(result.current.set).toEqual(new Set([2, 3, 1]));\n  });\n\n  test('reset elements', () => {\n    const { result } = renderHook(() => useSet(new Set([1, 2, 3])));\n\n    act(() => {\n      result.current.add(4);\n    });\n\n    expect(result.current.set).toEqual(new Set([1, 2, 3, 4]));\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.set).toEqual(new Set([1, 2, 3]));\n  });\n\n  test('clear elements', () => {\n    const { result } = renderHook(() => useSet(new Set([1, 2, 3])));\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.set).toEqual(new Set());\n  });\n\n  test('add must be immutable', () => {\n    const initialValue = new Set([1, 2, 3]);\n\n    const { result } = renderHook(() => useSet(initialValue));\n\n    act(() => {\n      result.current.add(4);\n    });\n\n    expect(result.current.set).not.toBe(initialValue);\n  });\n\n  test('remove must be immutable', () => {\n    const initialValue = new Set([1, 2, 3]);\n\n    const { result } = renderHook(() => useSet(initialValue));\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.set).not.toBe(initialValue);\n  });\n\n  test('toggle must be immutable', () => {\n    const initialValue = new Set([1, 2, 3]);\n\n    const { result } = renderHook(() => useSet(initialValue));\n\n    act(() => {\n      result.current.toggle(1);\n    });\n\n    expect(result.current.set).not.toBe(initialValue);\n  });\n\n  test('reset must reset to the initial set object', () => {\n    const initialValue = new Set([1, 2, 3]);\n\n    const { result } = renderHook(() => useSet(initialValue));\n\n    act(() => {\n      result.current.reset();\n    });\n\n    expect(result.current.set).toBe(initialValue);\n  });\n\n  test('clear must be immutable', () => {\n    const initialValue = new Set([1, 2, 3]);\n\n    const { result } = renderHook(() => useSet(initialValue));\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.set).not.toBe(initialValue);\n  });\n});\n",
    "/src/use-set.ts": "import { useCallback, useState } from 'react';\n\nexport interface UseSetReturn<T> {\n  set: Readonly<Set<T>>;\n  add: (key: T) => void;\n  remove: (key: T) => void;\n  toggle: (key: T) => void;\n  reset: () => void;\n  clear: () => void;\n}\n\nexport default function useSet<T>(\n  initialState = new Set<T>(),\n): UseSetReturn<T> {\n  const [set, setSet] = useState(initialState);\n\n  const add: UseSetReturn<T>['add'] = useCallback(\n    (item: T) => setSet((prev) => new Set([...Array.from(prev), item])),\n    [],\n  );\n\n  const remove: UseSetReturn<T>['remove'] = useCallback(\n    (item: T) =>\n      setSet((prev) => new Set(Array.from(prev).filter((i) => i !== item))),\n    [],\n  );\n\n  const toggle: UseSetReturn<T>['toggle'] = useCallback(\n    (item: T) =>\n      setSet((prev) =>\n        prev.has(item)\n          ? new Set(Array.from(prev).filter((i) => i !== item))\n          : new Set([...Array.from(prev), item]),\n      ),\n    [],\n  );\n\n  const reset: UseSetReturn<T>['reset'] = useCallback(\n    () => setSet(initialState),\n    [initialState],\n  );\n\n  const clear: UseSetReturn<T>['clear'] = useCallback(\n    () => setSet(new Set()),\n    [],\n  );\n\n  return { set, add, remove, toggle, reset, clear };\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {Set<T>} initialState\n */\nexport default function useSet(initialState = new Set()) {\n  throw 'Not implemented';\n}",
    "ts": "export interface UseSetReturn<T> {\n  set: Readonly<Set<T>>;\n  add: (key: T) => void;\n  remove: (key: T) => void;\n  toggle: (key: T) => void;\n  reset: () => void;\n  clear: () => void;\n}\n\nexport default function useSet<T>(\n  initialState = new Set<T>(),\n): UseSetReturn<T> {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/use-set.ts",
    "run": "/src/use-set.run.test.ts",
    "submit": "/src/use-set.submit.test.ts"
  }
}