{
  "description": "var Component=(()=>{var l=Object.create;var c=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var d=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var o in e)c(n,o,{get:e[o],enumerable:!0})},a=(n,e,o,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of d(e))!f.call(n,i)&&i!==o&&c(n,i,{get:()=>e[i],enumerable:!(s=h(e,i))||s.enumerable});return n};var v=(n,e,o)=>(o=n!=null?l(p(n)):{},a(e||!n||!n.__esModule?c(o,\"default\",{value:n,enumerable:!0}):o,n)),z=n=>a(c({},\"__esModule\",{value:!0}),n);var u=g((C,r)=>{r.exports=_jsx_runtime});var y={};x(y,{default:()=>w,frontmatter:()=>F});var t=v(u()),F={title:\"Memoize\",excerpt:\"Implement a function that returns a memoized version of a function which accepts a single argument\"};function m(n){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"A memoize function is a higher-order function that takes in a function and returns a memoized version of it. The memoized function caches the results of expensive function calls and returns the cached result when it receives the same inputs again. This can significantly improve the performance of functions that involve complex processing / significant latency and are called with the same arguments repeatedly.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement a function \",(0,t.jsx)(e.code,{children:\"memoize(func)\"}),\" that takes in a function parameter \",(0,t.jsx)(e.code,{children:\"func\"}),\" and returns a memoized version of the function. You may assume that \",(0,t.jsx)(e.code,{children:\"func\"}),\" only accepts a string or number as its only argument.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function expensiveFunction(n) {\n  console.log('Computing...');\n  return n * 2;\n}\n\n// Create a memoized version of the function.\nconst memoizedExpensiveFunction = memoize(expensiveFunction);\n\n// First call (computes and caches the result).\nconsole.log(memoizedExpensiveFunction(5)); // Output: Computing... 10\n\n// Second call with the same argument (returns the cached result).\nconsole.log(memoizedExpensiveFunction(5)); // Output: 10\n\n// Third call with a different argument (computes and caches the new result).\nconsole.log(memoizedExpensiveFunction(10)); // Output: Computing... 20\n\n// Fourth call with the same argument as the third call (returns the cached result).\nconsole.log(memoizedExpensiveFunction(10)); // Output: 20\n`})})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var w=j;return z(y);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function that returns a memoized version of a function which accepts a single argument",
    "title": "Memoize"
  },
  "solution": "var Component=(()=>{var f=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var c in e)r(t,c,{get:e[c],enumerable:!0})},a=(t,e,c,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!w.call(t,i)&&i!==c&&r(t,i,{get:()=>e[i],enumerable:!(o=g(e,i))||o.enumerable});return t};var k=(t,e,c)=>(c=t!=null?f(y(t)):{},a(e||!t||!t.__esModule?r(c,\"default\",{value:t,enumerable:!0}):c,t)),x=t=>a(r({},\"__esModule\",{value:!0}),t);var h=b((D,s)=>{s.exports=_jsx_runtime});var M={};v(M,{default:()=>j});var n=k(h());var l=MDXCodeBlock;var u=`/**\n * @param {Function} func\n * @returns Function\n */\nexport default function memoize(func) {\n  const cache = new Map();\n\n  return function (arg) {\n    if (cache.has(arg)) {\n      return cache.get(arg);\n    }\n\n    const result = func.call(this, arg);\n    cache.set(arg, result);\n\n    return result;\n  };\n}\n`;var d=`type Fn<T> = (this: any, arg: T) => unknown;\n\nexport default function memoize<T>(func: Fn<T>): Fn<T> {\n  const cache = new Map();\n\n  return function (arg) {\n    if (cache.has(arg)) {\n      return cache.get(arg);\n    }\n\n    const result = func.call(this, arg);\n    cache.set(arg, result);\n\n    return result;\n  };\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",code:\"code\",ol:\"ol\",li:\"li\",ul:\"ul\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The key to solving this question is to use a cache that stores the results for an input argument. If a cache entry exists for the input argument, return the cached result. Otherwise, call the function as per normal, put the result into the cache with the input argument as the key so that subsequent calls to the function with the same parameter will be a cache hit and return the value directly without calling the original function. This question can be broken down into three parts:\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Determining the cache key\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The cache key is a value that has a one-one relationship with the arguments that \",(0,n.jsx)(e.code,{children:\"func\"}),\" can be called with. Since there's a restriction on the input types and \",(0,n.jsx)(e.code,{children:\"func\"}),\" only has a single input argument, we can directly use the argument directly as the key.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Deciding on a structure for the cache\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Cache lookups have to be fast, ideally with a O(1) time complexity. In JavaScript, objects and \",(0,n.jsx)(e.code,{children:\"Map\"}),\"s are able to serve the purpose of a fast lookup for a key and a corresponding value. However, we cannot use JavaScript objects here because it only allows string keys, numbers will be converted into strings when used as keys of the object. However, we can use a \",(0,n.jsx)(e.code,{children:\"Map\"}),\", which differentiates between string keys and number keys of the same value (e.g. \",(0,n.jsx)(e.code,{children:\"1\"}),\" vs \",(0,n.jsx)(e.code,{children:\"'1'\"}),\").\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The returned function has access to the cache via closures. With closures, each unique memoized function instance will have its own cache.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Using the cache\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Before invoking the original function \",(0,n.jsx)(e.code,{children:\"func\"}),\", the memoized function first checks if the \",(0,n.jsx)(e.code,{children:\"cache\"}),\" already contains an entry for the current \",(0,n.jsx)(e.code,{children:\"arg\"}),\". This will result in one of the following two scenarios:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The cache contains an entry for \",(0,n.jsx)(e.code,{children:\"arg\"}),\". A cached result exists, it means that the function has been called with the same argument before, and there is no need to recompute the result. In this case, the memoized function simply returns the cached result using \",(0,n.jsx)(e.code,{children:\"cache.get(arg)\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The cache does not contain an entry for \",(0,n.jsx)(e.code,{children:\"arg\"}),\". If the cache does not contain a result for the current \",(0,n.jsx)(e.code,{children:\"arg\"}),\", it means that the function is called with a new argument. The memoized function then invokes the original function func using the \",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" method. \",(0,n.jsx)(e.code,{children:\"Function.prototype.apply()\"}),\" can be used as well but \",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" is simpler to use given there's only one argument. The \",(0,n.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" method is used to ensure that the context (\",(0,n.jsx)(e.code,{children:\"this\"}),\") of the original function is preserved when called from the memoized function. The argument \",(0,n.jsx)(e.code,{children:\"arg\"}),\" is passed to the original function \",(0,n.jsx)(e.code,{children:\"func\"}),\". After computing the result using the original function, the memoized function stores the result in the cache by associating it with the corresponding \",(0,n.jsx)(e.code,{children:\"arg\"}),\" key using \",(0,n.jsx)(e.code,{children:\"cache.set(arg, result)\"}),\". Finally the memoized function returns the computed result.\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{languages:{jsx:u,tsx:d}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"In practice, functions can take in multiple arguments of varying types beyond strings and numbers, so the current \",(0,n.jsx)(e.code,{children:\"memoize\"}),\" implementation wouldn't be sufficient for those cases.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"While \",(0,n.jsx)(e.code,{children:\"this\"}),\" can be accessed without issues, the results are memoized solely on the input arguments, the same memoized result is returned for the same input arguments even if the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value is different between calls.\"]}),`\n`]})]})}function F(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var j=F;return x(M);})();\n;return Component;"
}