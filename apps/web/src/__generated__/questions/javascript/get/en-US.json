{
  "description": "var Component=(()=>{var h=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},i=(t,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!f.call(t,o)&&o!==r&&a(t,o,{get:()=>e[o],enumerable:!(c=p(e,o))||c.enumerable});return t};var b=(t,e,r)=>(r=t!=null?h(m(t)):{},i(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),x=t=>i(a({},\"__esModule\",{value:!0}),t);var d=g((F,s)=>{s.exports=_jsx_runtime});var y={};j(y,{default:()=>w,frontmatter:()=>N});var n=b(d()),N={title:\"Get\",excerpt:\"Implement a function to safely access deeply-nested properties in JavaScript objects\"};function l(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Before the optional chaining operator (\",(0,n.jsx)(e.code,{children:\"?.\"}),\") existed, it was sometimes troublesome to access deeply-nested properties in huge JavaScript objects when some of the intermediate properties might not be present.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const john = {\n  profile: {\n    name: { firstName: 'John', lastName: 'Doe' },\n    age: 20,\n    gender: 'Male',\n  },\n};\n\nconst jane = {\n  profile: {\n    age: 19,\n    gender: 'Female',\n  },\n};\n\nfunction getFirstName(user) {\n  return user.profile.name.firstName;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Doing \",(0,n.jsx)(e.code,{children:\"getFirstName(john)\"}),\" works but \",(0,n.jsx)(e.code,{children:\"getFirstName(jane)\"}),\" will error because the \",(0,n.jsx)(e.code,{children:\"name\"}),\" property doesn't exist for \",(0,n.jsx)(e.code,{children:\"jane.profile\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Lodash's Get method\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Lodash's \",(0,n.jsx)(e.code,{children:\"_.get\"}),\" method was created as a solution for such use cases.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's write our own version as a \",(0,n.jsx)(e.code,{children:\"get\"}),\" function. The function gets the value at \",(0,n.jsx)(e.code,{children:\"path\"}),\" of \",(0,n.jsx)(e.code,{children:\"object\"}),\". If the resolved value is \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", the \",(0,n.jsx)(e.code,{children:\"defaultValue\"}),\" is returned in its place. The function signature is as such:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`get(object, path, [defaultValue]);\n`})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"object\"}),\": The object to query.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"path\"}),\": The path of the property to get. It can be a string with \",(0,n.jsx)(e.code,{children:\".\"}),\" as the separator between fields, or an array of path strings.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"defaultValue\"}),\": Optional parameter. The value returned if the resolved value is \",(0,n.jsx)(e.code,{children:\"undefined\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`get(john, 'profile.name.firstName'); // 'John'\nget(john, 'profile.gender'); // 'Male'\nget(jane, 'profile.name.firstName'); // undefined\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Arrays can also be accessed if numerical indices are provided.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`get({ a: [{ b: { c: 3 } }] }, 'a.0.b.c'); // 3\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"There's no need to support syntax resembling \",(0,n.jsx)(e.code,{children:\"get(object, 'a[0].b.c')\"}),\".\"]})]})}function v(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(l,t)})):l(t)}var w=v;return x(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/get\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/get.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/get.run.test.ts": "import get from './get';\n\ndescribe('get', () => {\n  test('empty object', () => {\n    expect(get({}, 'a')).toEqual(undefined);\n  });\n\n  test('simple object', () => {\n    expect(get({ a: 1 }, 'a')).toEqual(1);\n  });\n\n  test('nested object', () => {\n    expect(get({ a: { b: 2 }, c: 1 }, 'a.b')).toEqual(2);\n  });\n});\n",
    "/src/get.submit.test.ts": "import get from './get';\n\ndescribe('get', () => {\n  test('empty object', () => {\n    expect(get({}, 'a')).toEqual(undefined);\n    expect(get({}, 'a.b')).toEqual(undefined);\n  });\n\n  test('path contains one segment', () => {\n    expect(get({ a: 1 }, 'a')).toEqual(1);\n    expect(get({ c: 2 }, 'b')).toEqual(undefined);\n    expect(get({ c: { foo: 1 } }, 'c')).toEqual({ foo: 1 });\n  });\n\n  test('path contains two segments', () => {\n    expect(get({ a: { b: 2 }, c: 1 }, 'a.b')).toEqual(2);\n    expect(get({ a: { b: 2 }, c: 1 }, 'a.c')).toEqual(undefined);\n    expect(get({ a: { b: 2, c: { foo: 2 } } }, 'a.c')).toEqual({\n      foo: 2,\n    });\n  });\n\n  test('path contains multiple segments', () => {\n    expect(get({ a: { b: 2, c: { d: 0 } }, c: 1 }, 'a.c.d')).toEqual(0);\n    expect(get({ a: { b: 2 }, c: 1 }, 'a.c.e.f')).toEqual(undefined);\n    expect(\n      get({ a: { b: 2, c: { d: { e: { foo: 3 } } } }, c: 1 }, 'a.c.d.e'),\n    ).toEqual({ foo: 3 });\n  });\n\n  test('array values', () => {\n    expect(get({ a: { b: [1, 2, 3], c: { d: 0 } }, c: 1 }, 'a.b.2')).toEqual(3);\n    expect(\n      get({ a: { b: [1, 2, 3, { c: 'bar' }], c: { d: 0 } }, c: 1 }, 'a.b.3.c'),\n    ).toEqual('bar');\n  });\n\n  test('uses default value', () => {\n    expect(get({}, 'a', 1)).toEqual(1);\n    expect(get({}, 'a.b', 2)).toEqual(2);\n    expect(get({ c: 2 }, 'b', 3)).toEqual(3);\n  });\n\n  test('correctly returns null values', () => {\n    expect(get({ b: null }, 'b')).toEqual(null);\n    expect(get({ a: { b: 2, c: null }, c: 1 }, 'a.c')).toEqual(null);\n    expect(\n      get({ a: { b: 2, c: { d: { e: null } } }, c: 1 }, 'a.c.d.e'),\n    ).toEqual(null);\n  });\n\n  test('path as an array', () => {\n    expect(get({ a: { b: 2 }, c: 1 }, ['c'])).toEqual(1);\n    expect(get({ a: { b: 2 }, c: 1 }, ['a', 'c'])).toEqual(undefined);\n    expect(get({ a: { b: 2, c: { foo: 2 } } }, ['a', 'c'])).toEqual({\n      foo: 2,\n    });\n    expect(\n      get({ a: { b: [1, 2, 3, { c: 'bar' }], c: { d: 0 } }, c: 1 }, [\n        'a',\n        'b',\n        '3',\n        'c',\n      ]),\n    ).toEqual('bar');\n  });\n\n  test('access index of non-primitives', () => {\n    expect(get({ a: { b: true } }, 'a.b.c')).toEqual(undefined);\n    expect(get({ a: { b: null } }, 'a.b.c')).toEqual(undefined);\n    expect(get({ a: { b: undefined } }, 'a.b.c')).toEqual(undefined);\n    expect(get({ a: { b: 2 } }, 'a.b.c')).toEqual(undefined);\n    expect(get({ a: { b: 'foo' } }, 'a.b.c')).toEqual(undefined);\n  });\n});\n",
    "/src/get.ts": "export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string>,\n  defaultValue?: T,\n): T {\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  while (object != null && index < length) {\n    object = object[String(path[index])];\n    index++;\n  }\n\n  const value = index && index === length ? object : undefined;\n  return (value !== undefined ? value : defaultValue) as T;\n}\n"
  },
  "format": "javascript",
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [
      "tiktok"
    ],
    "created": 1649894400,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement a function to safely access deeply-nested properties in JavaScript objects",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/get",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "squash-object"
    ],
    "slug": "get",
    "subtitle": null,
    "title": "Get",
    "topics": [
      "recursion"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Object} objectParam\n * @param {string|Array<string>} pathParam\n * @param {*} [defaultValue]\n * @return {*}\n */\nexport default function get(objectParam, pathParam, defaultValue) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string>,\n  defaultValue?: T,\n): T {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of g(e))!j.call(t,a)&&a!==r&&i(t,a,{get:()=>e[a],enumerable:!(l=m(e,a))||l.enumerable});return t};var v=(t,e,r)=>(r=t!=null?f(b(t)):{},o(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),y=t=>o(i({},\"__esModule\",{value:!0}),t);var c=x((M,d)=>{d.exports=_jsx_runtime});var A={};w(A,{default:()=>_});var n=v(c());var h=MDXCodeBlock;var s=`/**\n * @param {Object} objectParam\n * @param {string|Array<string>} pathParam\n * @param {*} [defaultValue]\n * @return {*}\n */\nexport default function get(objectParam, pathParam, defaultValue) {\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  while (object != null && index < length) {\n    object = object[String(path[index])];\n    index++;\n  }\n\n  const value = index && index === length ? object : undefined;\n  return value !== undefined ? value : defaultValue;\n}\n`;var u=`export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string>,\n  defaultValue?: T,\n): T {\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  while (object != null && index < length) {\n    object = object[String(path[index])];\n    index++;\n  }\n\n  const value = index && index === length ? object : undefined;\n  return (value !== undefined ? value : defaultValue) as T;\n}\n`;function p(t){let e=Object.assign({p:\"p\",h2:\"h2\",code:\"code\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"The tricky part of the question is to see that some form of iteration/recursion has to be done on the object to access nested fields.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The first step is to split up the path by the delimiter, which is a period. Then we have to recursively traverse the object given each token in the path, which can be done either with \",(0,n.jsx)(e.code,{children:\"while\"}),\"/\",(0,n.jsx)(e.code,{children:\"for\"}),\" loops or recursions. The looping should stop when a \",(0,n.jsx)(e.code,{children:\"null\"}),\"-ish value is encountered.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Array index accessing doesn't require special handling and can be treated like accessing string-based fields on objects.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const arr = [10, 20, 30];\narr[1] === 20; // true\narr['1'] === 20; // true\n`})}),`\n`,(0,n.jsx)(h,{languages:{jsx:s,tsx:u}}),`\n`,(0,n.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Bad path inputs like \",(0,n.jsx)(e.code,{children:\"get(obj, 'a.b..c')\"}),\" and \",(0,n.jsx)(e.code,{children:\"get(obj, '')\"}),\" are unresolved and the \",(0,n.jsx)(e.code,{children:\"defaultValue\"}),\" should be returned.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The solution only works for simple objects. It doesn't work with objects with\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s as keys.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Map\"}),\" and \",(0,n.jsx)(e.code,{children:\"Set\"}),\" as values.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"For these cases you can (and should) clarify the expected behavior with the interviewer.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"null\"}),\" should be differentiated from \",(0,n.jsx)(e.code,{children:\"undefined\"}),\". Hence we should not use \",(0,n.jsx)(e.code,{children:\"value != undefined\"}),\" (which is \",(0,n.jsx)(e.code,{children:\"false\"}),\" when \",(0,n.jsx)(e.code,{children:\"value = null\"}),\") to check whether to return the \",(0,n.jsx)(e.code,{children:\"defaultValue\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#get\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.get\"})]})}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var _=T;return y(A);})();\n;return Component;",
  "workspace": {
    "main": "/src/get.ts",
    "run": "/src/get.run.test.ts",
    "submit": "/src/get.submit.test.ts"
  }
}