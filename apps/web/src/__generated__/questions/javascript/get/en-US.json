{
  "description": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),j=(r,e)=>{for(var t in e)c(r,t,{get:e[t],enumerable:!0})},a=(r,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!m.call(r,i)&&i!==t&&c(r,i,{get:()=>e[i],enumerable:!(o=p(e,i))||o.enumerable});return r};var b=(r,e,t)=>(t=r!=null?h(f(r)):{},a(e||!r||!r.__esModule?c(t,\"default\",{value:r,enumerable:!0}):t,r)),x=r=>a(c({},\"__esModule\",{value:!0}),r);var l=g((F,d)=>{d.exports=_jsx_runtime});var y={};j(y,{default:()=>w,frontmatter:()=>v});var n=b(l()),v={title:\"Get\",excerpt:\"Implement a function to safely access deeply-nested properties in JavaScript objects\"};function s(r){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Before the optional chaining operator (\",(0,n.jsx)(e.code,{children:\"?.\"}),\") existed, it was sometimes troublesome to access deeply-nested properties in huge JavaScript objects when some of the intermediate properties might not be present.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const john = {\n  profile: {\n    name: { firstName: 'John', lastName: 'Doe' },\n    age: 20,\n    gender: 'Male',\n  },\n};\n\nconst jane = {\n  profile: {\n    age: 19,\n    gender: 'Female',\n  },\n};\n\nfunction getFirstName(user) {\n  return user.profile.name.firstName;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Doing \",(0,n.jsx)(e.code,{children:\"getFirstName(john)\"}),\" works but \",(0,n.jsx)(e.code,{children:\"getFirstName(jane)\"}),\" will error because the \",(0,n.jsx)(e.code,{children:\"name\"}),\" property doesn't exist for \",(0,n.jsx)(e.code,{children:\"jane.profile\"}),\".\"]}),`\n`,(0,n.jsxs)(e.h2,{children:[\"Lodash's \",(0,n.jsx)(e.code,{children:\"_.get\"}),\" method\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Lodash's \",(0,n.jsx)(e.code,{children:\"_.get\"}),\" method was created as a solution for such use cases.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's write our own version as a \",(0,n.jsx)(e.code,{children:\"get\"}),\" function. The function gets the value at \",(0,n.jsx)(e.code,{children:\"path\"}),\" of \",(0,n.jsx)(e.code,{children:\"object\"}),\". If the resolved value is \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", the \",(0,n.jsx)(e.code,{children:\"defaultValue\"}),\" is returned in its place. The function signature is as such:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`get(object, path, [defaultValue]);\n`})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"object\"}),\": The object to query.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"path\"}),\": The path of the property to get.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"It can be a single string with \",(0,n.jsx)(e.code,{children:\".\"}),\" as the separator between object fields (e.g. \",(0,n.jsx)(e.code,{children:\"profile.name.firstName\"}),\"),\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Or it can be an array like this: \",(0,n.jsx)(e.code,{children:\"['profile', 'name', 'firstName']\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"defaultValue\"}),\": Optional parameter. The value returned if the resolved value is \",(0,n.jsx)(e.code,{children:\"undefined\"}),\". If \",(0,n.jsx)(e.code,{children:\"defaultValue\"}),\" is not provided and the resolved value is \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", simply return \",(0,n.jsx)(e.code,{children:\"undefined\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Using the \\`john\\` and \\`jane\\` objects from above\nget(john, 'profile.name.firstName'); // 'John'\nget(john, 'profile.gender'); // 'Male'\nget(jane, 'profile.name.firstName'); // undefined\n\n// An example where path is provided as an array\nget({ a: { b: 2, c: { foo: 2 } } }, ['a', 'c']); // foo: 2,\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Arrays inside the \",(0,n.jsx)(e.code,{children:\"object\"}),\" can also be accessed if numerical indices are provided in the \",(0,n.jsx)(e.code,{children:\"path\"}),\". See the examples below.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`get({ a: [{ b: { c: 3 } }] }, 'a.0.b.c'); // 3\nget({ a: [{ b: { c: 3 } }] }, ['a', 0, 'b', 'c']); // 3\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"There's no need to support mixed syntax of \",(0,n.jsx)(e.code,{children:\"path\"}),\" such as \",(0,n.jsx)(e.code,{children:\"get(object, 'a[0].b.c')\"}),\".\"]})]})}function N(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(s,r)})):s(r)}var w=N;return x(y);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/get\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/get.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/get.run.test.ts": "import get from './get';\n\ndescribe('get', () => {\n  test('empty object', () => {\n    expect(get({}, 'a')).toEqual(undefined);\n  });\n\n  test('simple object', () => {\n    expect(get({ a: 1 }, 'a')).toEqual(1);\n  });\n\n  test('nested object', () => {\n    expect(get({ a: { b: 2 }, c: 1 }, 'a.b')).toEqual(2);\n  });\n});\n",
    "/src/get.submit.test.ts": "import get from './get';\n\ndescribe('get', () => {\n  describe('when the object is empty', () => {\n    test('should return undefined for a simple path', () => {\n      expect(get({}, 'a')).toEqual(undefined);\n    });\n\n    test('should return undefined for a nested path', () => {\n      expect(get({}, 'a.b')).toEqual(undefined);\n    });\n  });\n\n  describe('when the path contains one segment', () => {\n    test('should return the value if the path exists', () => {\n      expect(get({ a: 1 }, 'a')).toEqual(1);\n    });\n\n    test('should return undefined if the path does not exist', () => {\n      expect(get({ c: 2 }, 'b')).toEqual(undefined);\n    });\n\n    test('should return an object if the path leads to an object', () => {\n      expect(get({ c: { foo: 1 } }, 'c')).toEqual({ foo: 1 });\n    });\n  });\n\n  describe('when the path contains two segments', () => {\n    test('should return the nested value if the path exists', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, 'a.b')).toEqual(2);\n    });\n\n    test('should return undefined if an intermediate path segment does not exist', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, 'a.c')).toEqual(undefined);\n    });\n\n    test('should return a nested object if the path leads to an object', () => {\n      expect(get({ a: { b: 2, c: { foo: 2 } } }, 'a.c')).toEqual({\n        foo: 2,\n      });\n    });\n  });\n\n  describe('when the path contains multiple segments', () => {\n    test('should return the deeply nested value if the path exists', () => {\n      expect(get({ a: { b: 2, c: { d: 0 } }, c: 1 }, 'a.c.d')).toEqual(0);\n    });\n\n    test('should return undefined if a later path segment does not exist', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, 'a.c.e.f')).toEqual(undefined);\n    });\n\n    test('should return a deeply nested object if the path leads to an object', () => {\n      expect(\n        get({ a: { b: 2, c: { d: { e: { foo: 3 } } } }, c: 1 }, 'a.c.d.e'),\n      ).toEqual({ foo: 3 });\n    });\n  });\n\n  describe('when accessing array values via path', () => {\n    test('should return the value at the specified array index', () => {\n      expect(get({ a: { b: [1, 2, 3], c: { d: 0 } }, c: 1 }, 'a.b.2')).toEqual(\n        3,\n      );\n    });\n\n    test('should return nested values within objects inside arrays', () => {\n      expect(\n        get(\n          { a: { b: [1, 2, 3, { c: 'bar' }], c: { d: 0 } }, c: 1 },\n          'a.b.3.c',\n        ),\n      ).toEqual('bar');\n    });\n\n    test('should return nested values within objects inside arrays using array as a path', () => {\n      expect(\n        get({ a: { b: [1, 2, 3, { c: 'bar' }], c: { d: 0 } }, c: 1 }, [\n          'a',\n          'b',\n          3,\n          'c',\n        ]),\n      ).toEqual('bar');\n    });\n  });\n\n  describe('when a default value is provided', () => {\n    test('should return the default value for an empty object and simple path', () => {\n      expect(get({}, 'a', 1)).toEqual(1);\n    });\n\n    test('should return the default value for an empty object and nested path', () => {\n      expect(get({}, 'a.b', 2)).toEqual(2);\n    });\n\n    test('should return the default value when the path does not exist in a non-empty object', () => {\n      expect(get({ c: 2 }, 'b', 3)).toEqual(3);\n    });\n  });\n\n  describe('when the path resolves to a null value', () => {\n    test('should return null for a top-level null value', () => {\n      expect(get({ b: null }, 'b')).toEqual(null);\n    });\n\n    test('should return null for a nested null value', () => {\n      expect(get({ a: { b: 2, c: null }, c: 1 }, 'a.c')).toEqual(null);\n    });\n\n    test('should return null for a deeply nested null value', () => {\n      expect(\n        get({ a: { b: 2, c: { d: { e: null } } }, c: 1 }, 'a.c.d.e'),\n      ).toEqual(null);\n    });\n  });\n\n  describe('when the path is provided as an array', () => {\n    test('should return the value for a single-element path array', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, ['c'])).toEqual(1);\n    });\n\n    test('should return undefined if an intermediate path segment does not exist', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, ['a', 'c'])).toEqual(undefined);\n    });\n\n    test('should return a nested object if the path leads to an object', () => {\n      expect(get({ a: { b: 2, c: { foo: 2 } } }, ['a', 'c'])).toEqual({\n        foo: 2,\n      });\n    });\n\n    test('should handle array indices within the path array correctly', () => {\n      expect(\n        get({ a: { b: [1, 2, 3, { c: 'bar' }], c: { d: 0 } }, c: 1 }, [\n          'a',\n          'b',\n          '3',\n          'c',\n        ]),\n      ).toEqual('bar');\n    });\n  });\n\n  describe('when attempting to access properties on non-object/array values', () => {\n    test('should return undefined when accessing property on boolean', () => {\n      expect(get({ a: { b: true } }, 'a.b.c')).toEqual(undefined);\n    });\n\n    test('should return undefined when accessing property on null', () => {\n      expect(get({ a: { b: null } }, 'a.b.c')).toEqual(undefined);\n    });\n\n    test('should return undefined when accessing property on undefined', () => {\n      expect(get({ a: { b: undefined } }, 'a.b.c')).toEqual(undefined);\n    });\n\n    test('should return undefined when accessing property on number', () => {\n      expect(get({ a: { b: 2 } }, 'a.b.c')).toEqual(undefined);\n    });\n\n    test('should return undefined when accessing property on string', () => {\n      expect(get({ a: { b: 'foo' } }, 'a.b.c')).toEqual(undefined);\n    });\n  });\n});\n",
    "/src/get.ts": "export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string | number>,\n  defaultValue?: T,\n): T | undefined {\n  // If the path is a `.` seperated string, use split to convert it to an array.\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  // Traverse path in the object, stopping early if a value is null/undefined.\n  while (object != null && index < length) {\n    // We use != null instead of !== null to handle undefined objects too\n    // Access next level in the object using string key (handles numeric indices too).\n    object = object[String(path[index++])];\n  }\n\n  // Check if the entire path was successfully traversed. If not, the path is invalid.\n  const value = index && index === length ? object : undefined;\n\n  // Return the found value, or the default if the value resolved to undefined.\n  return (value !== undefined ? value : defaultValue) as T;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "yangshun",
    "companies": [
      "tiktok",
      "amazon",
      "tiktok"
    ],
    "created": 1649894400,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement a function to safely access deeply-nested properties in JavaScript objects",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/get",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "squash-object"
    ],
    "slug": "get",
    "subtitle": null,
    "title": "Get",
    "topics": [
      "recursion"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Object} objectParam\n * @param {string|Array<string>} pathParam\n * @param {*} [defaultValue]\n * @return {*}\n */\nexport default function get(objectParam, pathParam, defaultValue) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string | number>,\n  defaultValue?: T,\n): T | undefined {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var a in e)i(n,a,{get:e[a],enumerable:!0})},o=(n,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!j.call(n,r)&&r!==a&&i(n,r,{get:()=>e[r],enumerable:!(l=g(e,r))||l.enumerable});return n};var y=(n,e,a)=>(a=n!=null?f(m(n)):{},o(e||!n||!n.__esModule?i(a,\"default\",{value:n,enumerable:!0}):a,n)),w=n=>o(i({},\"__esModule\",{value:!0}),n);var s=v((C,d)=>{d.exports=_jsx_runtime});var _={};x(_,{default:()=>A});var t=y(s());var c=MDXCodeBlock;var h=`/**\n * @param {Object} objectParam\n * @param {string|Array<string>} pathParam\n * @param {*} [defaultValue]\n * @return {*}\n */\nexport default function get(objectParam, pathParam, defaultValue) {\n  // If the path is a \\`.\\` seperated string, use split to convert it to an array.\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  // Traverse path in the object, stopping early if a value is null/undefined.\n  while (object != null && index < length) {\n    // We use != null instead of !== null to handle undefined objects too\n    // Access next level in the object using string key (handles numeric indices too).\n    object = object[String(path[index])];\n    index++;\n  }\n\n  // Check if the entire path was successfully traversed. If not, the path is invalid.\n  const value = index && index === length ? object : undefined;\n\n  // Return the found value, or the default if the value resolved to undefined.\n  return value !== undefined ? value : defaultValue;\n}\n`;var u=`export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string | number>,\n  defaultValue?: T,\n): T | undefined {\n  // If the path is a \\`.\\` seperated string, use split to convert it to an array.\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  // Traverse path in the object, stopping early if a value is null/undefined.\n  while (object != null && index < length) {\n    // We use != null instead of !== null to handle undefined objects too\n    // Access next level in the object using string key (handles numeric indices too).\n    object = object[String(path[index++])];\n  }\n\n  // Check if the entire path was successfully traversed. If not, the path is invalid.\n  const value = index && index === length ? object : undefined;\n\n  // Return the found value, or the default if the value resolved to undefined.\n  return (value !== undefined ? value : defaultValue) as T;\n}\n`;function p(n){let e=Object.assign({p:\"p\",h2:\"h2\",code:\"code\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"The tricky part of the question is to see that some form of iteration/recursion has to be done on the object to access nested fields.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The first step is to split up the path by the delimiter, which is a period. Then we have to recursively traverse the object given each token in the path, which can be done either with \",(0,t.jsx)(e.code,{children:\"while\"}),\"/\",(0,t.jsx)(e.code,{children:\"for\"}),\" loops or recursions. The looping should stop when a \",(0,t.jsx)(e.code,{children:\"null\"}),\"-ish value is encountered.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Array index accessing doesn't require special handling and can be treated like accessing string-based fields on objects.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const arr = [10, 20, 30];\narr[1] === 20; // true\narr['1'] === 20; // true\n`})}),`\n`,(0,t.jsx)(c,{languages:{jsx:h,tsx:u}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Bad path inputs like \",(0,t.jsx)(e.code,{children:\"get(obj, 'a.b..c')\"}),\" and \",(0,t.jsx)(e.code,{children:\"get(obj, '')\"}),\" are unresolved and the \",(0,t.jsx)(e.code,{children:\"defaultValue\"}),\" should be returned.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The solution only works for simple objects. It doesn't work with objects with\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Symbol\"}),\"s as keys.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Map\"}),\" and \",(0,t.jsx)(e.code,{children:\"Set\"}),\" as values.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"For these cases you can (and should) clarify the expected behavior with the interviewer.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"null\"}),\" should be differentiated from \",(0,t.jsx)(e.code,{children:\"undefined\"}),\". Hence we should not use \",(0,t.jsx)(e.code,{children:\"value != undefined\"}),\" (which is \",(0,t.jsx)(e.code,{children:\"false\"}),\" when \",(0,t.jsx)(e.code,{children:\"value = null\"}),\") to check whether to return the \",(0,t.jsx)(e.code,{children:\"defaultValue\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#get\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.get\"})]})}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var A=T;return w(_);})();\n;return Component;",
  "workspace": {
    "main": "/src/get.ts",
    "run": "/src/get.run.test.ts",
    "submit": "/src/get.submit.test.ts"
  }
}