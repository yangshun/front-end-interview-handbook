{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/get\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/get.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/get.run.test.ts": "import get from './get';\n\ndescribe('get', () => {\n  test('empty object', () => {\n    expect(get({}, 'a')).toEqual(undefined);\n  });\n\n  test('simple object', () => {\n    expect(get({ a: 1 }, 'a')).toEqual(1);\n  });\n\n  test('nested object', () => {\n    expect(get({ a: { b: 2 }, c: 1 }, 'a.b')).toEqual(2);\n  });\n});\n",
    "/src/get.submit.test.ts": "import get from './get';\n\ndescribe('get', () => {\n  describe('when the object is empty', () => {\n    test('should return undefined for a simple path', () => {\n      expect(get({}, 'a')).toEqual(undefined);\n    });\n\n    test('should return undefined for a nested path', () => {\n      expect(get({}, 'a.b')).toEqual(undefined);\n    });\n  });\n\n  describe('when the path contains one segment', () => {\n    test('should return the value if the path exists', () => {\n      expect(get({ a: 1 }, 'a')).toEqual(1);\n    });\n\n    test('should return undefined if the path does not exist', () => {\n      expect(get({ c: 2 }, 'b')).toEqual(undefined);\n    });\n\n    test('should return an object if the path leads to an object', () => {\n      expect(get({ c: { foo: 1 } }, 'c')).toEqual({ foo: 1 });\n    });\n  });\n\n  describe('when the path contains two segments', () => {\n    test('should return the nested value if the path exists', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, 'a.b')).toEqual(2);\n    });\n\n    test('should return undefined if an intermediate path segment does not exist', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, 'a.c')).toEqual(undefined);\n    });\n\n    test('should return a nested object if the path leads to an object', () => {\n      expect(get({ a: { b: 2, c: { foo: 2 } } }, 'a.c')).toEqual({\n        foo: 2,\n      });\n    });\n  });\n\n  describe('when the path contains multiple segments', () => {\n    test('should return the deeply nested value if the path exists', () => {\n      expect(get({ a: { b: 2, c: { d: 0 } }, c: 1 }, 'a.c.d')).toEqual(0);\n    });\n\n    test('should return undefined if a later path segment does not exist', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, 'a.c.e.f')).toEqual(undefined);\n    });\n\n    test('should return a deeply nested object if the path leads to an object', () => {\n      expect(\n        get({ a: { b: 2, c: { d: { e: { foo: 3 } } } }, c: 1 }, 'a.c.d.e'),\n      ).toEqual({ foo: 3 });\n    });\n  });\n\n  describe('when accessing array values via path', () => {\n    test('should return the value at the specified array index', () => {\n      expect(get({ a: { b: [1, 2, 3], c: { d: 0 } }, c: 1 }, 'a.b.2')).toEqual(\n        3,\n      );\n    });\n\n    test('should return nested values within objects inside arrays', () => {\n      expect(\n        get(\n          { a: { b: [1, 2, 3, { c: 'bar' }], c: { d: 0 } }, c: 1 },\n          'a.b.3.c',\n        ),\n      ).toEqual('bar');\n    });\n\n    test('should return nested values within objects inside arrays using array as a path', () => {\n      expect(\n        get({ a: { b: [1, 2, 3, { c: 'bar' }], c: { d: 0 } }, c: 1 }, [\n          'a',\n          'b',\n          3,\n          'c',\n        ]),\n      ).toEqual('bar');\n    });\n  });\n\n  describe('when a default value is provided', () => {\n    test('should return the default value for an empty object and simple path', () => {\n      expect(get({}, 'a', 1)).toEqual(1);\n    });\n\n    test('should return the default value for an empty object and nested path', () => {\n      expect(get({}, 'a.b', 2)).toEqual(2);\n    });\n\n    test('should return the default value when the path does not exist in a non-empty object', () => {\n      expect(get({ c: 2 }, 'b', 3)).toEqual(3);\n    });\n  });\n\n  describe('when the path resolves to a null value', () => {\n    test('should return null for a top-level null value', () => {\n      expect(get({ b: null }, 'b')).toEqual(null);\n    });\n\n    test('should return null for a nested null value', () => {\n      expect(get({ a: { b: 2, c: null }, c: 1 }, 'a.c')).toEqual(null);\n    });\n\n    test('should return null for a deeply nested null value', () => {\n      expect(\n        get({ a: { b: 2, c: { d: { e: null } } }, c: 1 }, 'a.c.d.e'),\n      ).toEqual(null);\n    });\n  });\n\n  describe('when the path is provided as an array', () => {\n    test('should return the value for a single-element path array', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, ['c'])).toEqual(1);\n    });\n\n    test('should return undefined if an intermediate path segment does not exist', () => {\n      expect(get({ a: { b: 2 }, c: 1 }, ['a', 'c'])).toEqual(undefined);\n    });\n\n    test('should return a nested object if the path leads to an object', () => {\n      expect(get({ a: { b: 2, c: { foo: 2 } } }, ['a', 'c'])).toEqual({\n        foo: 2,\n      });\n    });\n\n    test('should handle array indices within the path array correctly', () => {\n      expect(\n        get({ a: { b: [1, 2, 3, { c: 'bar' }], c: { d: 0 } }, c: 1 }, [\n          'a',\n          'b',\n          '3',\n          'c',\n        ]),\n      ).toEqual('bar');\n    });\n  });\n\n  describe('when attempting to access properties on non-object/array values', () => {\n    test('should return undefined when accessing property on boolean', () => {\n      expect(get({ a: { b: true } }, 'a.b.c')).toEqual(undefined);\n    });\n\n    test('should return undefined when accessing property on null', () => {\n      expect(get({ a: { b: null } }, 'a.b.c')).toEqual(undefined);\n    });\n\n    test('should return undefined when accessing property on undefined', () => {\n      expect(get({ a: { b: undefined } }, 'a.b.c')).toEqual(undefined);\n    });\n\n    test('should return undefined when accessing property on number', () => {\n      expect(get({ a: { b: 2 } }, 'a.b.c')).toEqual(undefined);\n    });\n\n    test('should return undefined when accessing property on string', () => {\n      expect(get({ a: { b: 'foo' } }, 'a.b.c')).toEqual(undefined);\n    });\n  });\n});\n",
    "/src/get.ts": "export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string | number>,\n  defaultValue?: T,\n): T | undefined {\n  // If the path is a `.` seperated string, use split to convert it to an array.\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  // Traverse path in the object, stopping early if a value is null/undefined.\n  while (object != null && index < length) {\n    // We use != null instead of !== null to handle undefined objects too\n    // Access next level in the object using string key (handles numeric indices too).\n    object = object[String(path[index++])];\n  }\n\n  // Check if the entire path was successfully traversed. If not, the path is invalid.\n  const value = index && index === length ? object : undefined;\n\n  // Return the found value, or the default if the value resolved to undefined.\n  return (value !== undefined ? value : defaultValue) as T;\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Object} objectParam\n * @param {string|Array<string>} pathParam\n * @param {*} [defaultValue]\n * @return {*}\n */\nexport default function get(objectParam, pathParam, defaultValue) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string | number>,\n  defaultValue?: T,\n): T | undefined {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/get.ts",
    "run": "/src/get.run.test.ts",
    "submit": "/src/get.submit.test.ts"
  }
}