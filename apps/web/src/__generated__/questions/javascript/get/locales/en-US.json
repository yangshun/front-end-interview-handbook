{
  "description": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),j=(r,e)=>{for(var t in e)c(r,t,{get:e[t],enumerable:!0})},a=(r,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!m.call(r,i)&&i!==t&&c(r,i,{get:()=>e[i],enumerable:!(o=p(e,i))||o.enumerable});return r};var b=(r,e,t)=>(t=r!=null?h(f(r)):{},a(e||!r||!r.__esModule?c(t,\"default\",{value:r,enumerable:!0}):t,r)),x=r=>a(c({},\"__esModule\",{value:!0}),r);var l=g((F,d)=>{d.exports=_jsx_runtime});var y={};j(y,{default:()=>w,frontmatter:()=>v});var n=b(l()),v={title:\"Get\",excerpt:\"Implement a function to safely access deeply-nested properties in JavaScript objects\"};function s(r){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Before the optional chaining operator (\",(0,n.jsx)(e.code,{children:\"?.\"}),\") existed, it was sometimes troublesome to access deeply-nested properties in huge JavaScript objects when some of the intermediate properties might not be present.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const john = {\n  profile: {\n    name: { firstName: 'John', lastName: 'Doe' },\n    age: 20,\n    gender: 'Male',\n  },\n};\n\nconst jane = {\n  profile: {\n    age: 19,\n    gender: 'Female',\n  },\n};\n\nfunction getFirstName(user) {\n  return user.profile.name.firstName;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Doing \",(0,n.jsx)(e.code,{children:\"getFirstName(john)\"}),\" works but \",(0,n.jsx)(e.code,{children:\"getFirstName(jane)\"}),\" will error because the \",(0,n.jsx)(e.code,{children:\"name\"}),\" property doesn't exist for \",(0,n.jsx)(e.code,{children:\"jane.profile\"}),\".\"]}),`\n`,(0,n.jsxs)(e.h2,{children:[\"Lodash's \",(0,n.jsx)(e.code,{children:\"_.get\"}),\" method\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Lodash's \",(0,n.jsx)(e.code,{children:\"_.get\"}),\" method was created as a solution for such use cases.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's write our own version as a \",(0,n.jsx)(e.code,{children:\"get\"}),\" function. The function gets the value at \",(0,n.jsx)(e.code,{children:\"path\"}),\" of \",(0,n.jsx)(e.code,{children:\"object\"}),\". If the resolved value is \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", the \",(0,n.jsx)(e.code,{children:\"defaultValue\"}),\" is returned in its place. The function signature is as such:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`get(object, path, [defaultValue]);\n`})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"object\"}),\": The object to query.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"path\"}),\": The path of the property to get.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"It can be a single string with \",(0,n.jsx)(e.code,{children:\".\"}),\" as the separator between object fields (e.g. \",(0,n.jsx)(e.code,{children:\"profile.name.firstName\"}),\"),\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Or it can be an array like this: \",(0,n.jsx)(e.code,{children:\"['profile', 'name', 'firstName']\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"defaultValue\"}),\": Optional parameter. The value returned if the resolved value is \",(0,n.jsx)(e.code,{children:\"undefined\"}),\". If \",(0,n.jsx)(e.code,{children:\"defaultValue\"}),\" is not provided and the resolved value is \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", simply return \",(0,n.jsx)(e.code,{children:\"undefined\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Using the \\`john\\` and \\`jane\\` objects from above\nget(john, 'profile.name.firstName'); // 'John'\nget(john, 'profile.gender'); // 'Male'\nget(jane, 'profile.name.firstName'); // undefined\n\n// An example where path is provided as an array\nget({ a: { b: 2, c: { foo: 2 } } }, ['a', 'c']); // foo: 2,\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Arrays inside the \",(0,n.jsx)(e.code,{children:\"object\"}),\" can also be accessed if numerical indices are provided in the \",(0,n.jsx)(e.code,{children:\"path\"}),\". See the examples below.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`get({ a: [{ b: { c: 3 } }] }, 'a.0.b.c'); // 3\nget({ a: [{ b: { c: 3 } }] }, ['a', 0, 'b', 'c']); // 3\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"There's no need to support mixed syntax of \",(0,n.jsx)(e.code,{children:\"path\"}),\" such as \",(0,n.jsx)(e.code,{children:\"get(object, 'a[0].b.c')\"}),\".\"]})]})}function N(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(s,r)})):s(r)}var w=N;return x(y);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to safely access deeply-nested properties in JavaScript objects",
    "title": "Get"
  },
  "solution": "var Component=(()=>{var f=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var a in e)i(n,a,{get:e[a],enumerable:!0})},o=(n,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!j.call(n,r)&&r!==a&&i(n,r,{get:()=>e[r],enumerable:!(l=g(e,r))||l.enumerable});return n};var y=(n,e,a)=>(a=n!=null?f(m(n)):{},o(e||!n||!n.__esModule?i(a,\"default\",{value:n,enumerable:!0}):a,n)),w=n=>o(i({},\"__esModule\",{value:!0}),n);var s=v((C,d)=>{d.exports=_jsx_runtime});var _={};x(_,{default:()=>A});var t=y(s());var c=MDXCodeBlock;var h=`/**\n * @param {Object} objectParam\n * @param {string|Array<string>} pathParam\n * @param {*} [defaultValue]\n * @return {*}\n */\nexport default function get(objectParam, pathParam, defaultValue) {\n  // If the path is a \\`.\\` seperated string, use split to convert it to an array.\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  // Traverse path in the object, stopping early if a value is null/undefined.\n  while (object != null && index < length) {\n    // We use != null instead of !== null to handle undefined objects too\n    // Access next level in the object using string key (handles numeric indices too).\n    object = object[String(path[index])];\n    index++;\n  }\n\n  // Check if the entire path was successfully traversed. If not, the path is invalid.\n  const value = index && index === length ? object : undefined;\n\n  // Return the found value, or the default if the value resolved to undefined.\n  return value !== undefined ? value : defaultValue;\n}\n`;var u=`export default function get<T>(\n  objectParam: Record<string, any>,\n  pathParam: string | Array<string | number>,\n  defaultValue?: T,\n): T | undefined {\n  // If the path is a \\`.\\` seperated string, use split to convert it to an array.\n  const path = Array.isArray(pathParam) ? pathParam : pathParam.split('.');\n\n  let index = 0;\n  let length = path.length;\n  let object = objectParam;\n\n  // Traverse path in the object, stopping early if a value is null/undefined.\n  while (object != null && index < length) {\n    // We use != null instead of !== null to handle undefined objects too\n    // Access next level in the object using string key (handles numeric indices too).\n    object = object[String(path[index++])];\n  }\n\n  // Check if the entire path was successfully traversed. If not, the path is invalid.\n  const value = index && index === length ? object : undefined;\n\n  // Return the found value, or the default if the value resolved to undefined.\n  return (value !== undefined ? value : defaultValue) as T;\n}\n`;function p(n){let e=Object.assign({p:\"p\",h2:\"h2\",code:\"code\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"The tricky part of the question is to see that some form of iteration/recursion has to be done on the object to access nested fields.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The first step is to split up the path by the delimiter, which is a period. Then we have to recursively traverse the object given each token in the path, which can be done either with \",(0,t.jsx)(e.code,{children:\"while\"}),\"/\",(0,t.jsx)(e.code,{children:\"for\"}),\" loops or recursions. The looping should stop when a \",(0,t.jsx)(e.code,{children:\"null\"}),\"-ish value is encountered.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Array index accessing doesn't require special handling and can be treated like accessing string-based fields on objects.\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const arr = [10, 20, 30];\narr[1] === 20; // true\narr['1'] === 20; // true\n`})}),`\n`,(0,t.jsx)(c,{languages:{jsx:h,tsx:u}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Bad path inputs like \",(0,t.jsx)(e.code,{children:\"get(obj, 'a.b..c')\"}),\" and \",(0,t.jsx)(e.code,{children:\"get(obj, '')\"}),\" are unresolved and the \",(0,t.jsx)(e.code,{children:\"defaultValue\"}),\" should be returned.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The solution only works for simple objects. It doesn't work with objects with\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Symbol\"}),\"s as keys.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Map\"}),\" and \",(0,t.jsx)(e.code,{children:\"Set\"}),\" as values.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"For these cases you can (and should) clarify the expected behavior with the interviewer.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"null\"}),\" should be differentiated from \",(0,t.jsx)(e.code,{children:\"undefined\"}),\". Hence we should not use \",(0,t.jsx)(e.code,{children:\"value != undefined\"}),\" (which is \",(0,t.jsx)(e.code,{children:\"false\"}),\" when \",(0,t.jsx)(e.code,{children:\"value = null\"}),\") to check whether to return the \",(0,t.jsx)(e.code,{children:\"defaultValue\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsxs)(e.a,{href:\"https://lodash.com/docs/#get\",children:[\"Lodash \",(0,t.jsx)(e.code,{children:\"_.get\"})]})}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var A=T;return w(_);})();\n;return Component;"
}