{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/event-emitter\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/event-emitter.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/event-emitter.run.test.ts": "import EventEmitter from './event-emitter';\n\ndescribe('EventEmitter', () => {\n  test('constructor', () => {\n    const emitter = new EventEmitter();\n    expect(emitter).toBeInstanceOf(EventEmitter);\n  });\n\n  test('subscribe', () => {\n    const emitter = new EventEmitter();\n    let a = 0;\n    emitter.on('foo', () => {\n      a = 1;\n    });\n    emitter.emit('foo');\n\n    expect(a).toBe(1);\n  });\n\n  test('emit', () => {\n    const emitter = new EventEmitter();\n\n    let sum = 0;\n    emitter.on('foo', (a: number) => {\n      sum = a;\n    });\n    emitter.emit('foo', 3);\n    expect(sum).toBe(3);\n\n    emitter.emit('foo', 5);\n    expect(sum).toBe(5);\n  });\n});\n",
    "/src/event-emitter.submit.test.ts": "import EventEmitter from './event-emitter';\n\ndescribe('EventEmitter', () => {\n  test('constructor', () => {\n    const emitter = new EventEmitter();\n    expect(emitter).toBeInstanceOf(EventEmitter);\n  });\n\n  describe('methods can be chained', () => {\n    test('on() can be chained', () => {\n      const emitter = new EventEmitter();\n      emitter.on('foo', () => {}).on('foo', () => {});\n    });\n\n    test('off() can be chained', () => {\n      const emitter = new EventEmitter();\n      emitter.off('foo', () => {}).off('foo', () => {});\n    });\n  });\n\n  describe('subscribe', () => {\n    test('single listener', () => {\n      const emitter = new EventEmitter();\n      let a = 0;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.emit('foo');\n\n      expect(a).toBe(1);\n    });\n\n    test('multiple listeners', () => {\n      const emitter = new EventEmitter();\n      let a = 0,\n        b = 1;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.on('foo', () => {\n        b = 3;\n      });\n      emitter.emit('foo');\n\n      expect(a).toBe(1);\n      expect(b).toBe(3);\n    });\n\n    test('multiple events', () => {\n      const emitter = new EventEmitter();\n      let a = 0,\n        b = 1;\n      emitter.on('foo', () => {\n        a = 1;\n      });\n      emitter.on('bar', () => {\n        b = 3;\n      });\n      emitter.emit('foo');\n      expect(a).toBe(1);\n      expect(b).toBe(1);\n\n      emitter.emit('bar');\n      expect(b).toBe(3);\n    });\n\n    test('same listener added multiple times', () => {\n      const emitter = new EventEmitter();\n\n      let num = 1;\n      function double() {\n        num *= 2;\n      }\n\n      emitter.on('double', double);\n      emitter.emit('double');\n      expect(num).toBe(2);\n\n      emitter.on('double', double);\n      emitter.emit('double');\n      expect(num).toBe(8);\n    });\n  });\n\n  describe('emit', () => {\n    test('existing event returns true', () => {\n      const emitter = new EventEmitter();\n\n      emitter.on('foo', () => {});\n      expect(emitter.emit('foo')).toBe(true);\n    });\n\n    describe('listeners are invoked with arguments', () => {\n      test('single argument', () => {\n        const emitter = new EventEmitter();\n\n        let sum = 0;\n        emitter.on('foo', (a: number) => {\n          sum = a;\n        });\n        emitter.emit('foo', 3);\n        expect(sum).toBe(3);\n\n        emitter.emit('foo', 5);\n        expect(sum).toBe(5);\n      });\n\n      test('two arguments', () => {\n        const emitter = new EventEmitter();\n\n        let sum = 0;\n        emitter.on('foo', (a: number, b: number) => {\n          sum = a + b;\n        });\n        emitter.emit('foo', 3, 5);\n        expect(sum).toBe(8);\n\n        emitter.emit('foo', 4, 13);\n        expect(sum).toBe(17);\n      });\n\n      test('three arguments', () => {\n        const emitter = new EventEmitter();\n\n        let product = 0;\n        emitter.on('foo', (a: number, b: number, c: number) => {\n          product = a * b * c;\n        });\n        emitter.emit('foo', 3, 5, 6);\n        expect(product).toBe(90);\n\n        emitter.emit('foo', 4, 13, 9);\n        expect(product).toBe(468);\n      });\n    });\n\n    describe('non-existing event name returns false', () => {\n      test('custom event', () => {\n        const emitter = new EventEmitter();\n\n        expect(emitter.emit('foo')).toBe(false);\n      });\n\n      test('same name as built-in event', () => {\n        const emitter = new EventEmitter();\n\n        expect(emitter.emit('toString')).toBe(false);\n      });\n    });\n  });\n\n  describe('unsubscribe', () => {\n    test('single listener', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      emitter.on('foo', addTwoNumbers);\n      expect(emitter.emit('foo', 2, 5)).toBe(true);\n      expect(sum).toBe(7);\n\n      emitter.off('foo', addTwoNumbers);\n      expect(emitter.emit('foo', -3, 9)).toBe(false);\n      expect(sum).toBe(7);\n    });\n\n    test('multiple listeners', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      emitter.on('foo', addTwoNumbers);\n      expect(emitter.emit('foo', 2, 5)).toBe(true);\n      expect(sum).toBe(7);\n\n      let product = 0;\n      function multiplyTwoNumbers(a: number, b: number) {\n        product = a * b;\n      }\n      emitter.on('foo', multiplyTwoNumbers);\n      expect(emitter.emit('foo', 4, 5)).toBe(true);\n      expect(sum).toBe(9);\n      expect(product).toBe(20);\n\n      emitter.off('foo', addTwoNumbers);\n      expect(emitter.emit('foo', -3, 9)).toBe(true);\n      expect(sum).toBe(9);\n      expect(product).toBe(-27);\n\n      emitter.off('foo', multiplyTwoNumbers);\n      expect(emitter.emit('foo', 3, 7)).toBe(false);\n      expect(sum).toBe(9);\n      expect(product).toBe(-27);\n    });\n\n    test('multiple events', () => {\n      const emitter = new EventEmitter();\n\n      let sum = 0;\n      function addTwoNumbers(a: number, b: number) {\n        sum = a + b;\n      }\n      emitter.on('foo', addTwoNumbers);\n      expect(emitter.emit('foo', 2, 5)).toBe(true);\n      expect(sum).toBe(7);\n\n      expect(emitter.emit('bar', 3, 7)).toBe(false);\n      emitter.on('bar', addTwoNumbers);\n      expect(emitter.emit('bar', 3, 7)).toBe(true);\n      expect(sum).toBe(10);\n\n      emitter.off('foo', addTwoNumbers);\n      expect(emitter.emit('foo', -3, 9)).toBe(false);\n      expect(sum).toBe(10);\n\n      emitter.off('bar', addTwoNumbers);\n      expect(emitter.emit('bar', -3, 9)).toBe(false);\n      expect(sum).toBe(10);\n    });\n\n    test('same listener added multiple times removed correctly', () => {\n      const emitter = new EventEmitter();\n\n      let num = 1;\n      function double() {\n        num *= 2;\n      }\n\n      emitter.on('double', double);\n      emitter.emit('double');\n      expect(num).toBe(2);\n\n      emitter.on('double', double);\n      emitter.emit('double');\n      expect(num).toBe(8);\n\n      emitter.off('double', double);\n      emitter.emit('double');\n      expect(num).toBe(16);\n\n      emitter.off('double', double);\n      emitter.emit('double');\n      expect(num).toBe(16);\n    });\n  });\n});\n",
    "/src/event-emitter.ts": "interface IEventEmitter {\n  on(eventName: string, listener: Function): IEventEmitter;\n  off(eventName: string, listener: Function): IEventEmitter;\n  emit(eventName: string, ...args: Array<any>): boolean;\n}\n\nexport default class EventEmitter implements IEventEmitter {\n  _events: Record<string, Array<Function>>;\n\n  constructor() {\n    // Avoid creating objects via `{}` to exclude unwanted properties\n    // on the prototype (such as `.toString`).\n    this._events = Object.create(null);\n  }\n\n  on(eventName: string, listener: Function): IEventEmitter {\n    if (!Object.hasOwn(this._events, eventName)) {\n      this._events[eventName] = [];\n    }\n\n    this._events[eventName].push(listener);\n    return this;\n  }\n\n  off(eventName: string, listener: Function): IEventEmitter {\n    // Ignore non-existing eventNames.\n    if (!Object.hasOwn(this._events, eventName)) {\n      return this;\n    }\n\n    const listeners = this._events[eventName];\n\n    // Find only first instance of the listener.\n    const index = listeners.findIndex(\n      (listenerItem) => listenerItem === listener,\n    );\n\n    if (index < 0) {\n      return this;\n    }\n\n    this._events[eventName].splice(index, 1);\n    return this;\n  }\n\n  emit(eventName: string, ...args: Array<any>): boolean {\n    // Return false for non-existing eventNames or events without listeners.\n    if (\n      !Object.hasOwn(this._events, eventName) ||\n      this._events[eventName].length === 0\n    ) {\n      return false;\n    }\n\n    // Make a clone of the listeners in case one of the listeners\n    // mutates this listener array.\n    const listeners = this._events[eventName].slice();\n    listeners.forEach((listener) => {\n      listener.apply(null, args);\n    });\n\n    return true;\n  }\n}\n"
  },
  "skeleton": {
    "js": "// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export has the same interface.\n\nexport default class EventEmitter {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {Function} listener\n   * @returns {EventEmitter}\n   */\n  on(eventName, listener) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {Function} listener\n   * @returns {EventEmitter}\n   */\n  off(eventName, listener) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n  emit(eventName, ...args) {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "interface IEventEmitter {\n  on(eventName: string, listener: Function): IEventEmitter;\n  off(eventName: string, listener: Function): IEventEmitter;\n  emit(eventName: string, ...args: Array<any>): boolean;\n}\n\n// You are free to use alternative approaches of\n// instantiating the EventEmitter as long as the\n// default export has the same interface.\nexport default class EventEmitter implements IEventEmitter {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  on(eventName: string, listener: Function): IEventEmitter {\n    throw 'Not implemented!';\n  }\n\n  off(eventName: string, listener: Function): IEventEmitter {\n    throw 'Not implemented!';\n  }\n\n  emit(eventName: string, ...args: Array<any>): boolean {\n    throw 'Not implemented!';\n  }\n}"
  },
  "workspace": {
    "main": "/src/event-emitter.ts",
    "run": "/src/event-emitter.run.test.ts",
    "submit": "/src/event-emitter.submit.test.ts"
  }
}