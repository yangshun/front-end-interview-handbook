{
  "description": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var t in e)a(r,t,{get:e[t],enumerable:!0})},c=(r,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!y.call(r,i)&&i!==t&&a(r,i,{get:()=>e[i],enumerable:!(o=m(e,i))||o.enumerable});return r};var x=(r,e,t)=>(t=r!=null?d(p(r)):{},c(e||!r||!r.__esModule?a(t,\"default\",{value:r,enumerable:!0}):t,r)),w=r=>c(a({},\"__esModule\",{value:!0}),r);var l=f((T,s)=>{s.exports=_jsx_runtime});var q={};g(q,{default:()=>_,frontmatter:()=>b});var n=x(l()),b={title:\"Intersection With\",excerpt:\"Computes the intersection of arrays using a custom comparator function to determine equality between elements\"};function h(r){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ol:\"ol\",li:\"li\",em:\"em\",ul:\"ul\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"intersectionWith\"}),\" function takes a custom \",(0,n.jsx)(e.code,{children:\"comparator\"}),\" function and multiple arrays as arguments. It compares the elements of the arrays using the \",(0,n.jsx)(e.code,{children:\"comparator\"}),\" function to determine equality. The function returns a new array containing the elements that are present in all given arrays.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`intersectionWith(comparator, ...arrays);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"comparator\"}),\" \",(0,n.jsx)(e.em,{children:\"(Function)\"}),\": The comparator function used to determine equality between elements. The function will be invoked with two arguments \",(0,n.jsx)(e.code,{children:\"(arrVal, othVal)\"}),\" representing the two elements being compared. It should return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the elements are considered equal, and \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"arrays\"}),\" \",(0,n.jsx)(e.em,{children:\"(...Array)\"}),\": The arrays to inspect.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.em,{children:\"(Array)\"}),\": Returns the array after intersection of arrays.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const arr1 = [\n  { x: 1, y: 2 },\n  { x: 2, y: 3 },\n];\nconst arr2 = [\n  { y: 2, x: 1 },\n  { x: 3, y: 4 },\n];\n\nconst result = intersectionWith(\n  (a, b) => a.x === b.x && a.y === b.y,\n  arr1,\n  arr2,\n); // => [{ x: 1, y: 2 }]\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"In Lodash, \",(0,n.jsx)(e.code,{children:\"comparator\"}),\" is optional and is the last parameter, but in this question it is a required parameter for simplicity.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"The order of elements in the resulting array is determined by the order in which they appear in the first array.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If no arrays are provided, the function will return an empty array.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If any of the arrays are empty, the function will return an empty array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://lodash.com/docs/#intersectionWith\",children:[\"Lodash \",(0,n.jsx)(e.code,{children:\"_.intersectionWith\"})]})}),`\n`]})]})}function j(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var _=j;return w(q);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/intersection-with\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/intersection-with.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/intersection-with.run.test.ts": "import intersectionWith from './intersection-with';\n\ndescribe('intersectionWith', () => {\n  test('empty arrays', () => {\n    const actual = intersectionWith((x, y) => true, [], [1, 2, 3], [4, 5, 6]);\n    expect(actual).toEqual([]);\n  });\n\n  test('no common elements', () => {\n    const actual = intersectionWith(\n      (x, y) => x === y,\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9],\n    );\n    expect(actual).toEqual([]);\n  });\n\n  test('two arrays', () => {\n    const arr1 = [\n      { x: 1, y: 2 },\n      { x: 2, y: 3 },\n      { x: 3, y: 4 },\n    ];\n    const arr2 = [\n      { x: 2, y: 3 },\n      { x: 4, y: 5 },\n      { x: 5, y: 6 },\n    ];\n\n    const comparator = (\n      a: { x: number; y: number },\n      b: { x: number; y: number },\n    ) => a.x === b.x && a.y === b.y;\n\n    const actual = intersectionWith(comparator, arr1, arr2);\n    const expected = [{ x: 2, y: 3 }];\n\n    expect(actual).toEqual(expected);\n  });\n});\n",
    "/src/intersection-with.submit.test.ts": "import intersectionWith from './intersection-with';\n\ndescribe('intersectionWith', () => {\n  test('no arrays are provided', () => {\n    const actual = intersectionWith((x, y) => true);\n    expect(actual).toEqual([]);\n  });\n\n  test('empty arrays', () => {\n    const actual = intersectionWith((x, y) => true, [], [1, 2, 3], [4, 5, 6]);\n    expect(actual).toEqual([]);\n  });\n\n  test('no common elements', () => {\n    const actual = intersectionWith(\n      (x, y) => x === y,\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 9],\n    );\n    expect(actual).toEqual([]);\n  });\n\n  test('two arrays', () => {\n    const arr1 = [\n      { x: 1, y: 2 },\n      { x: 2, y: 3 },\n      { x: 3, y: 4 },\n    ];\n    const arr2 = [\n      { x: 2, y: 3 },\n      { x: 4, y: 5 },\n      { x: 5, y: 6 },\n    ];\n\n    const comparator = (\n      a: { x: number; y: number },\n      b: { x: number; y: number },\n    ) => a.x === b.x && a.y === b.y;\n\n    const actual = intersectionWith(comparator, arr1, arr2);\n    const expected = [{ x: 2, y: 3 }];\n\n    expect(actual).toEqual(expected);\n  });\n\n  test('multiple arrays using a comparator', () => {\n    const arr1 = [\n      { x: 1, y: 2 },\n      { x: 2, y: 3 },\n      { x: 3, y: 4 },\n    ];\n    const arr2 = [\n      { x: 2, y: 3 },\n      { x: 4, y: 5 },\n      { x: 5, y: 6 },\n    ];\n    const arr3 = [\n      { x: 2, y: 3 },\n      { x: 3, y: 4 },\n      { x: 5, y: 6 },\n      { x: 6, y: 7 },\n    ];\n\n    const comparator = (\n      a: { x: number; y: number },\n      b: { x: number; y: number },\n    ) => a.x === b.x && a.y === b.y;\n\n    const actual = intersectionWith(comparator, arr1, arr2, arr3);\n    const expected = [{ x: 2, y: 3 }];\n\n    expect(actual).toEqual(expected);\n  });\n\n  test('arrays with different lengths', () => {\n    const arr1 = [1, 2, 3];\n    const arr2 = [2, 3, 4, 5];\n    const arr3 = [3, 4, 5, 6, 7];\n\n    const actual = intersectionWith((x, y) => x == y, arr1, arr2, arr3);\n    const expected = [3];\n\n    expect(actual).toEqual(expected);\n  });\n\n  test('arrays with single elements', () => {\n    const arr1 = [{ x: 1, y: 2 }];\n    const arr2 = [{ x: 2, y: 3 }];\n    const arr3 = [{ x: 3, y: 4 }];\n\n    const comparator = (\n      a: { x: number; y: number },\n      b: { x: number; y: number },\n    ) => a.x === b.x && a.y === b.y;\n    const actual = intersectionWith(comparator, arr1, arr2, arr3);\n    expect(actual).toEqual([]);\n  });\n});\n",
    "/src/intersection-with.ts": "export default function intersectionWith<T>(\n  comparator: (a: T, b: T) => boolean,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  if (!arrays.length) {\n    return [];\n  }\n\n  const firstArray = arrays[0];\n\n  // Perform intersection\n  return firstArray.filter((value) =>\n    arrays\n      .slice(1)\n      .every((arr) => arr.some((otherValue) => comparator(value, otherValue))),\n  );\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [],
    "created": 1687651200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Computes the intersection of arrays using a custom comparator function to determine equality between elements",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/intersection-with",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "intersection",
      "intersection-with"
    ],
    "slug": "intersection-with",
    "subtitle": null,
    "title": "Intersection With",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Function} comparator - The comparator function used to determine equality between elements.\n * @param {...Array} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the elements that are present in all given arrays.\n */\nexport default function intersectionWith(comparator, ...arrays) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function intersectionWith<T>(\n  comparator: (a: T, b: T) => boolean,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var g=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),A=(e,r)=>{for(var a in r)o(e,a,{get:r[a],enumerable:!0})},s=(e,r,a,i)=>{if(r&&typeof r==\"object\"||typeof r==\"function\")for(let n of p(r))!x.call(e,n)&&n!==a&&o(e,n,{get:()=>r[n],enumerable:!(i=y(r,n))||i.enumerable});return e};var T=(e,r,a)=>(a=e!=null?d(v(e)):{},s(r||!e||!e.__esModule?o(a,\"default\",{value:e,enumerable:!0}):a,e)),j=e=>s(o({},\"__esModule\",{value:!0}),e);var l=g((D,c)=>{c.exports=_jsx_runtime});var w={};A(w,{default:()=>M});var t=T(l());var h=MDXCodeBlock;var u=`/**\n * @param {Function} comparator - The comparator function used to determine equality between elements.\n * @param {...Array} arrays - The arrays to perform the intersection on.\n * @returns {Array} - A new array containing the elements that are present in all given arrays.\n */\nexport default function intersectionWith(comparator, ...arrays) {\n  if (!arrays.length) {\n    return [];\n  }\n\n  const firstArray = arrays[0];\n\n  // Perform intersection\n  return firstArray.filter((value) =>\n    arrays\n      .slice(1)\n      .every((arr) => arr.some((otherValue) => comparator(value, otherValue))),\n  );\n}\n`;var m=`export default function intersectionWith<T>(\n  comparator: (a: T, b: T) => boolean,\n  ...arrays: Array<Array<T>>\n): Array<T> {\n  if (!arrays.length) {\n    return [];\n  }\n\n  const firstArray = arrays[0];\n\n  // Perform intersection\n  return firstArray.filter((value) =>\n    arrays\n      .slice(1)\n      .every((arr) => arr.some((otherValue) => comparator(value, otherValue))),\n  );\n}\n`;function f(e){let r=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",a:\"a\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(h,{languages:{jsx:u,tsx:m}}),`\n`,(0,t.jsxs)(r.p,{children:[\"The solution iterates over the values of the first array using \",(0,t.jsx)(r.code,{children:\".filter\"}),\". For each value, it checks whether in every other array there is some value such that the comparator function returns true. If so, then the value passes the filter and is included in the returned array.\"]}),`\n`,(0,t.jsx)(r.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(r.ul,{children:[`\n`,(0,t.jsx)(r.li,{children:(0,t.jsxs)(r.a,{href:\"https://lodash.com/docs/#intersectionWith\",children:[\"Lodash \",(0,t.jsx)(r.code,{children:\"_.intersectionWith\"})]})}),`\n`]})]})}function b(e={}){let{wrapper:r}=e.components||{};return r?(0,t.jsx)(r,Object.assign({},e,{children:(0,t.jsx)(f,e)})):f(e)}var M=b;return j(w);})();\n;return Component;",
  "workspace": {
    "main": "/src/intersection-with.ts",
    "run": "/src/intersection-with.run.test.ts",
    "submit": "/src/intersection-with.submit.test.ts"
  }
}