{
  "description": "var Component=(()=>{var l=Object.create;var r=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),x=(e,n)=>{for(var a in n)r(e,a,{get:n[a],enumerable:!0})},i=(e,n,a,s)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let o of u(n))!f.call(e,o)&&o!==a&&r(e,o,{get:()=>n[o],enumerable:!(s=h(n,o))||s.enumerable});return e};var g=(e,n,a)=>(a=e!=null?l(d(e)):{},i(n||!e||!e.__esModule?r(a,\"default\",{value:e,enumerable:!0}):a,e)),w=e=>i(r({},\"__esModule\",{value:!0}),e);var p=y((D,c)=>{c.exports=_jsx_runtime});var A={};x(A,{default:()=>_,frontmatter:()=>j});var t=g(p()),j={title:\"Map Async\",excerpt:\"Implement a function that maps an array of items with an asynchronous mapping function\"};function m(e){let n=Object.assign({p:\"p\",a:\"a\",code:\"code\",h2:\"h2\",pre:\"pre\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[\"By now you'd be familiar with mapping of elements in an array. If you aren't, please first do the \",(0,t.jsx)(n.a,{href:\"/questions/javascript/array-map\",children:\"Array.prototype.map\"}),\" question first.\"]}),`\n`,(0,t.jsxs)(n.p,{children:[\"What if the mapping function is not a synchronous function i.e. it returns a promise? \",(0,t.jsx)(n.code,{children:\"Array.prototype.map\"}),\" assumes the mapping function is synchronous and will fail to work properly.\"]}),`\n`,(0,t.jsxs)(n.p,{children:[\"Implement a function \",(0,t.jsx)(n.code,{children:\"mapAsync\"}),\" that accepts an array of items and maps each element with an asynchronous mapping function. The function should return a \",(0,t.jsx)(n.code,{children:\"Promise\"}),\" which resolves to the mapped results.\"]}),`\n`,(0,t.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:\"language-js\",children:`const asyncDouble = (x: number) =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(x * 2);\n    }, 10);\n  });\n\nconst doubled = await mapAsync([1, 2], asyncDouble);\nconsole.log(doubled); // [2, 4]\n`})})]})}function b(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(m,e)})):m(e)}var _=b;return w(A);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function that maps an array of items with an asynchronous mapping function",
    "title": "Map Async"
  },
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),A=(n,e)=>{for(var a in e)l(n,a,{get:e[a],enumerable:!0})},o=(n,e,a,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of y(e))!g.call(n,t)&&t!==a&&l(n,t,{get:()=>e[t],enumerable:!(i=v(e,t))||i.enumerable});return n};var j=(n,e,a)=>(a=n!=null?f(b(n)):{},o(e||!n||!n.__esModule?l(a,\"default\",{value:n,enumerable:!0}):a,n)),P=n=>o(l({},\"__esModule\",{value:!0}),n);var u=x((C,c)=>{c.exports=_jsx_runtime});var U={};A(U,{default:()=>_});var r=j(u());var s=MDXCodeBlock;var d=`/**\n * @param {Array<any>} iterable\n * @param {Function} callbackFn\n *\n * @return {Promise}\n */\nexport default function mapAsync(iterable, callbackFn) {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach((item, index) => {\n      callbackFn(item)\n        .then((value) => {\n          results[index] = value;\n          unresolved -= 1;\n\n          if (unresolved === 0) {\n            resolve(results);\n          }\n        })\n        .catch((err) => reject(err));\n    });\n  });\n}\n`;var h=`export default function mapAsync<T, U>(\n  iterable: Array<T>,\n  callbackFn: (value: T) => Promise<U>,\n): Promise<Array<U>> {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach((item, index) => {\n      callbackFn(item)\n        .then((value) => {\n          results[index] = value;\n          unresolved -= 1;\n\n          if (unresolved === 0) {\n            resolve(results);\n          }\n        })\n        .catch((err) => reject(err));\n    });\n  });\n}\n`;var m=`export default function mapAsync<T, U>(\n  iterable: Array<T>,\n  callbackFn: (value: T) => Promise<U>,\n): Promise<Array<U>> {\n  return Promise.all(iterable.map(callbackFn));\n}\n`;function p(n){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",code:\"code\",h3:\"h3\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"This question is very similar to the \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,r.jsx)(e.code,{children:\"Promise.all\"})}),\" question and since this question can be reduced to \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,r.jsx)(e.code,{children:\"Promise.all\"})}),\", the same approaches can be used.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Approach 1: Count unresolved promises\"}),`\n`,(0,r.jsx)(e.p,{children:\"The only difference is that instead of just an array of iterables, you have to map the array yourself using a mapping function, then resolve the mapped results.\"}),`\n`,(0,r.jsx)(s,{languages:{jsx:d,tsx:h}}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Approach 2: \",(0,r.jsx)(e.code,{children:\"Promise.all\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We can also use \",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\" as mapping each item with the mapping function will produce an array of \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s to be resolved.\"]}),`\n`,(0,r.jsx)(s,{children:m}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"We did not specify what parameters the asynchronous mapping function will be passed, so it is up to you to clarify with the interviewer whether the mapping callback function will be passed additional arguments like in \",(0,r.jsx)(e.code,{children:\"Array.prototype.map\"}),\".\"]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(p,n)})):p(n)}var _=T;return P(U);})();\n;return Component;"
}