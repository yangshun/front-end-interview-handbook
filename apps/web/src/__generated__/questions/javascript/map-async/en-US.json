{
  "description": "var Component=(()=>{var l=Object.create;var r=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var d=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),x=(e,n)=>{for(var a in n)r(e,a,{get:n[a],enumerable:!0})},i=(e,n,a,s)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let o of u(n))!f.call(e,o)&&o!==a&&r(e,o,{get:()=>n[o],enumerable:!(s=h(n,o))||s.enumerable});return e};var g=(e,n,a)=>(a=e!=null?l(d(e)):{},i(n||!e||!e.__esModule?r(a,\"default\",{value:e,enumerable:!0}):a,e)),w=e=>i(r({},\"__esModule\",{value:!0}),e);var p=y((D,c)=>{c.exports=_jsx_runtime});var A={};x(A,{default:()=>_,frontmatter:()=>j});var t=g(p()),j={title:\"Map Async\",excerpt:\"Implement a function that maps an array of items with an asynchronous mapping function\"};function m(e){let n=Object.assign({p:\"p\",a:\"a\",code:\"code\",h2:\"h2\",pre:\"pre\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[\"By now you'd be familiar with mapping of elements in an array. If you aren't, please first do the \",(0,t.jsx)(n.a,{href:\"/questions/javascript/array-map\",children:\"Array.prototype.map\"}),\" question first.\"]}),`\n`,(0,t.jsxs)(n.p,{children:[\"What if the mapping function is not a synchronous function i.e. it returns a promise? \",(0,t.jsx)(n.code,{children:\"Array.prototype.map\"}),\" assumes the mapping function is synchronous and will fail to work properly.\"]}),`\n`,(0,t.jsxs)(n.p,{children:[\"Implement a function \",(0,t.jsx)(n.code,{children:\"mapAsync\"}),\" that accepts an array of items and maps each element with an asynchronous mapping function. The function should return a \",(0,t.jsx)(n.code,{children:\"Promise\"}),\" which resolves to the mapped results.\"]}),`\n`,(0,t.jsx)(n.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:\"language-js\",children:`const asyncDouble = (x: number) =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(x * 2);\n    }, 10);\n  });\n\nconst doubled = await mapAsync([1, 2], asyncDouble);\nconsole.log(doubled); // [2, 4]\n`})})]})}function b(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(m,e)})):m(e)}var _=b;return w(A);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/map-async\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/map-async.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/map-async.run.test.ts": "import mapAsync from './map-async';\n\nconst asyncIdentity = (x: number) => Promise.resolve(x);\nconst asyncDouble = (x: number) =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(x * 2);\n    }, 10);\n  });\n\ndescribe('mapAsync', () => {\n  test('returns promise', () => {\n    const p = mapAsync([], asyncIdentity);\n    expect(p).toBeInstanceOf(Promise);\n  });\n\n  test('empty input array', async () => {\n    expect.assertions(1);\n    const res = await mapAsync([], asyncIdentity);\n    expect(res).toEqual([]);\n  });\n\n  test('resolved', async () => {\n    expect.assertions(1);\n    const res = await mapAsync([1, 2], asyncDouble);\n    expect(res).toEqual([2, 4]);\n  });\n});\n",
    "/src/map-async.submit.test.ts": "import mapAsync from './map-async';\n\nconst asyncIdentity = (x: number) => Promise.resolve(x);\nconst asyncDouble = (x: number) =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(x * 2);\n    }, 10);\n  });\nconst asyncSquare = (x: number) =>\n  new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(x * x);\n    }, 10);\n  });\nconst asyncRejectOdd = (x: number) =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (x % 2 === 1) {\n        reject(x * 3);\n      }\n\n      resolve(x * 2);\n    }, 10);\n  });\n\ndescribe('mapAsync', () => {\n  test('returns promise', () => {\n    const p = mapAsync([], asyncIdentity);\n    expect(p).toBeInstanceOf(Promise);\n  });\n\n  test('empty input array', async () => {\n    expect.assertions(1);\n    const res = await mapAsync([], asyncIdentity);\n    expect(res).toEqual([]);\n  });\n\n  test('single item', async () => {\n    expect.assertions(1);\n    const res = await mapAsync([3], asyncDouble);\n    expect(res).toEqual([6]);\n  });\n\n  describe('multiple items', () => {\n    test('two items', async () => {\n      expect.assertions(1);\n      const res = await mapAsync([1, 2], asyncDouble);\n      expect(res).toEqual([2, 4]);\n    });\n\n    test('three items', async () => {\n      expect.assertions(1);\n      const res = await mapAsync([2, 3, 4], asyncSquare);\n      expect(res).toEqual([4, 9, 16]);\n    });\n\n    test('some rejected', async () => {\n      expect.assertions(1);\n      await expect(mapAsync([2, 3], asyncRejectOdd)).rejects.toBe(9);\n    });\n  });\n});\n",
    "/src/map-async.ts": "export default function mapAsync<T, U>(\n  iterable: Array<T>,\n  callbackFn: (value: T) => Promise<U>,\n): Promise<Array<U>> {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach((item, index) => {\n      callbackFn(item)\n        .then((value) => {\n          results[index] = value;\n          unresolved -= 1;\n\n          if (unresolved === 0) {\n            resolve(results);\n          }\n        })\n        .catch((err) => reject(err));\n    });\n  });\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [
      "google",
      "lyft",
      "uber",
      "apple",
      "tiktok",
      "bytedance"
    ],
    "created": 1699401600,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that maps an array of items with an asynchronous mapping function",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/map-async",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "map-async-limit"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "promise-all"
    ],
    "slug": "map-async",
    "subtitle": null,
    "title": "Map Async",
    "topics": [
      "async"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Array<any>} iterable\n * @param {Function} callbackFn\n *\n * @return {Promise}\n */\nexport default function mapAsync(iterable, callbackFn) {\n  throw 'Not implemented';\n}",
    "ts": "export default function mapAsync<T, U>(\n  iterable: Array<T>,\n  callbackFn: (value: T) => Promise<U>,\n): Promise<Array<U>> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),A=(n,e)=>{for(var a in e)l(n,a,{get:e[a],enumerable:!0})},o=(n,e,a,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of y(e))!g.call(n,t)&&t!==a&&l(n,t,{get:()=>e[t],enumerable:!(i=v(e,t))||i.enumerable});return n};var j=(n,e,a)=>(a=n!=null?f(b(n)):{},o(e||!n||!n.__esModule?l(a,\"default\",{value:n,enumerable:!0}):a,n)),P=n=>o(l({},\"__esModule\",{value:!0}),n);var u=x((C,c)=>{c.exports=_jsx_runtime});var U={};A(U,{default:()=>_});var r=j(u());var s=MDXCodeBlock;var d=`/**\n * @param {Array<any>} iterable\n * @param {Function} callbackFn\n *\n * @return {Promise}\n */\nexport default function mapAsync(iterable, callbackFn) {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach((item, index) => {\n      callbackFn(item)\n        .then((value) => {\n          results[index] = value;\n          unresolved -= 1;\n\n          if (unresolved === 0) {\n            resolve(results);\n          }\n        })\n        .catch((err) => reject(err));\n    });\n  });\n}\n`;var h=`export default function mapAsync<T, U>(\n  iterable: Array<T>,\n  callbackFn: (value: T) => Promise<U>,\n): Promise<Array<U>> {\n  return new Promise((resolve, reject) => {\n    const results = new Array(iterable.length);\n    let unresolved = iterable.length;\n\n    if (unresolved === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach((item, index) => {\n      callbackFn(item)\n        .then((value) => {\n          results[index] = value;\n          unresolved -= 1;\n\n          if (unresolved === 0) {\n            resolve(results);\n          }\n        })\n        .catch((err) => reject(err));\n    });\n  });\n}\n`;var m=`export default function mapAsync<T, U>(\n  iterable: Array<T>,\n  callbackFn: (value: T) => Promise<U>,\n): Promise<Array<U>> {\n  return Promise.all(iterable.map(callbackFn));\n}\n`;function p(n){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",code:\"code\",h3:\"h3\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"This question is very similar to the \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,r.jsx)(e.code,{children:\"Promise.all\"})}),\" question and since this question can be reduced to \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,r.jsx)(e.code,{children:\"Promise.all\"})}),\", the same approaches can be used.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Approach 1: Count unresolved promises\"}),`\n`,(0,r.jsx)(e.p,{children:\"The only difference is that instead of just an array of iterables, you have to map the array yourself using a mapping function, then resolve the mapped results.\"}),`\n`,(0,r.jsx)(s,{languages:{jsx:d,tsx:h}}),`\n`,(0,r.jsxs)(e.h3,{children:[\"Approach 2: \",(0,r.jsx)(e.code,{children:\"Promise.all\"})]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We can also use \",(0,r.jsx)(e.code,{children:\"Promise.all\"}),\" as mapping each item with the mapping function will produce an array of \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s to be resolved.\"]}),`\n`,(0,r.jsx)(s,{children:m}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"We did not specify what parameters the asynchronous mapping function will be passed, so it is up to you to clarify with the interviewer whether the mapping callback function will be passed additional arguments like in \",(0,r.jsx)(e.code,{children:\"Array.prototype.map\"}),\".\"]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(p,n)})):p(n)}var _=T;return P(U);})();\n;return Component;",
  "workspace": {
    "main": "/src/map-async.ts",
    "run": "/src/map-async.run.test.ts",
    "submit": "/src/map-async.submit.test.ts"
  }
}