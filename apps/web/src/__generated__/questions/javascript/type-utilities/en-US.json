{
  "description": "var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var m=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),y=(n,e)=>{for(var l in e)r(n,l,{get:e[l],enumerable:!0})},d=(n,e,l,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of f(e))!p.call(n,c)&&c!==l&&r(n,c,{get:()=>e[c],enumerable:!(t=u(e,c))||t.enumerable});return n};var g=(n,e,l)=>(l=n!=null?h(v(n)):{},d(e||!n||!n.__esModule?r(l,\"default\",{value:n,enumerable:!0}):l,n)),b=n=>d(r({},\"__esModule\",{value:!0}),n);var a=m((_,o)=>{o.exports=_jsx_runtime});var q={};y(q,{default:()=>x,frontmatter:()=>w});var i=g(a()),w={title:\"Type Utilities\",excerpt:\"Implement utilities to determine primitive variable types in JavaScript\"};function s(n){let e=Object.assign({p:\"p\",a:\"a\",ul:\"ul\",li:\"li\",code:\"code\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:[\"JavaScript is a dynamically typed language, which means the types of variable can be changed during runtime. Many interview questions involve recursion of values that contain values of different types and how to handle each value type (e.g. different code is needed to iterate over an array vs an object). Knowledge of handling the JavaScript types is crucial to solving questions like \",(0,i.jsx)(e.a,{href:\"/questions/javascript/deep-clone\",children:\"Deep Clone\"}),\" and \",(0,i.jsx)(e.a,{href:\"/questions/javascript/deep-equal\",children:\"Deep Equal\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"In this question, we will implement the following utility functions to determine the types of primitive values.\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"isBoolean(value)\"}),\": Return \",(0,i.jsx)(e.code,{children:\"true\"}),\" if \",(0,i.jsx)(e.code,{children:\"value\"}),\" is a boolean, \",(0,i.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"isNumber(value)\"}),\": Return \",(0,i.jsx)(e.code,{children:\"true\"}),\" if \",(0,i.jsx)(e.code,{children:\"value\"}),\" is a number, \",(0,i.jsx)(e.code,{children:\"false\"}),\" otherwise. Note that \",(0,i.jsx)(e.code,{children:\"NaN\"}),\" is considered a number.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"isNull(value)\"}),\": Return \",(0,i.jsx)(e.code,{children:\"true\"}),\" if \",(0,i.jsx)(e.code,{children:\"value\"}),\" is \",(0,i.jsx)(e.code,{children:\"null\"}),\", \",(0,i.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"isString(value)\"}),\": Return \",(0,i.jsx)(e.code,{children:\"true\"}),\" if \",(0,i.jsx)(e.code,{children:\"value\"}),\" is a \",(0,i.jsx)(e.code,{children:\"String\"}),\", else \",(0,i.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"isSymbol(value)\"}),\": Return \",(0,i.jsx)(e.code,{children:\"true\"}),\" if \",(0,i.jsx)(e.code,{children:\"value\"}),\" is a \",(0,i.jsx)(e.code,{children:\"Symbol\"}),\" primitive, else \",(0,i.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"isUndefined(value)\"}),\": Return \",(0,i.jsx)(e.code,{children:\"true\"}),\" if \",(0,i.jsx)(e.code,{children:\"value\"}),\" is \",(0,i.jsx)(e.code,{children:\"undefined\"}),\", else \",(0,i.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(s,n)})):s(n)}var x=j;return b(q);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/type-utilities\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/type-utilities.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/type-utilities.run.test.ts": "import {\n  isBoolean,\n  isNumber,\n  isNull,\n  isString,\n  isSymbol,\n  isUndefined,\n} from './type-utilities';\n\ndescribe('type-utilities', () => {\n  test('isBoolean', () => {\n    expect(isBoolean(true)).toBe(true);\n  });\n\n  test('isNumber', () => {\n    expect(isNumber(1)).toBe(true);\n  });\n\n  test('isNull', () => {\n    expect(isNull(null)).toBe(true);\n  });\n\n  test('isString', () => {\n    expect(isString('hello')).toBe(true);\n  });\n\n  test('isSymbol', () => {\n    expect(isSymbol(Symbol('hello'))).toBe(true);\n  });\n\n  test('isUndefined', () => {\n    expect(isUndefined(undefined)).toBe(true);\n  });\n});\n",
    "/src/type-utilities.submit.test.ts": "import {\n  isBoolean,\n  isNumber,\n  isNull,\n  isString,\n  isSymbol,\n  isUndefined,\n} from './type-utilities';\n\ndescribe('type-utilities', () => {\n  describe('isBoolean', () => {\n    test('true', () => {\n      expect(isBoolean(true)).toBe(true);\n    });\n\n    test('false', () => {\n      expect(isBoolean(false)).toBe(true);\n    });\n\n    test('non-boolean', () => {\n      expect(isBoolean('true')).toBe(false);\n      expect(isBoolean([1, 2, 3])).toBe(false);\n      expect(isBoolean(new Date())).toBe(false);\n      expect(isBoolean(new Error())).toBe(false);\n      expect(isBoolean({ a: 1 })).toBe(false);\n      expect(isBoolean(/x/)).toBe(false);\n      expect(isBoolean('a')).toBe(false);\n      expect(isBoolean(null)).toBe(false);\n      expect(isBoolean(undefined)).toBe(false);\n      expect(isBoolean(1)).toBe(false);\n      expect(isBoolean(NaN)).toBe(false);\n      expect(isBoolean(Symbol('symbol'))).toBe(false);\n    });\n  });\n\n  describe('isNumber', () => {\n    test('numbers', () => {\n      expect(isNumber(1)).toBe(true);\n      expect(isNumber(0)).toBe(true);\n      expect(isNumber(-2)).toBe(true);\n      expect(isNumber(5)).toBe(true);\n    });\n\n    test('NaN', () => {\n      expect(isNumber(NaN)).toBe(true);\n    });\n\n    test('non-numbers', () => {\n      expect(isNumber('true')).toBe(false);\n      expect(isNumber([1, 2, 3])).toBe(false);\n      expect(isNumber(true)).toBe(false);\n      expect(isNumber(false)).toBe(false);\n      expect(isNumber(new Date())).toBe(false);\n      expect(isNumber(new Error())).toBe(false);\n      expect(isNumber({ a: 1 })).toBe(false);\n      expect(isNumber(/x/)).toBe(false);\n      expect(isNumber('a')).toBe(false);\n      expect(isNumber(null)).toBe(false);\n      expect(isNumber(undefined)).toBe(false);\n      expect(isNumber(Symbol('symbol'))).toBe(false);\n    });\n  });\n\n  describe('isNull', () => {\n    test('null', () => {\n      expect(isNull(null)).toBe(true);\n    });\n\n    test('undefined', () => {\n      expect(isNull(undefined)).toBe(false);\n    });\n\n    test('non-null', () => {\n      expect(isNull('true')).toBe(false);\n      expect(isNull([1, 2, 3])).toBe(false);\n      expect(isNull(true)).toBe(false);\n      expect(isNull(false)).toBe(false);\n      expect(isNull(new Date())).toBe(false);\n      expect(isNull(new Error())).toBe(false);\n      expect(isNull({ a: 1 })).toBe(false);\n      expect(isNull(/x/)).toBe(false);\n      expect(isNull('a')).toBe(false);\n      expect(isNull(undefined)).toBe(false);\n      expect(isNull(1)).toBe(false);\n      expect(isNull(NaN)).toBe(false);\n      expect(isNull(Symbol('symbol'))).toBe(false);\n    });\n  });\n\n  describe('isString', () => {\n    test('strings', () => {\n      expect(isString('hello')).toBe(true);\n      expect(isString('')).toBe(true);\n      expect(isString('1234')).toBe(true);\n    });\n\n    test('non-string', () => {\n      expect(isString([1, 2, 3])).toBe(false);\n      expect(isString(true)).toBe(false);\n      expect(isString(false)).toBe(false);\n      expect(isString(new Date())).toBe(false);\n      expect(isString(new Error())).toBe(false);\n      expect(isString({ a: 1 })).toBe(false);\n      expect(isString(/x/)).toBe(false);\n      expect(isString(null)).toBe(false);\n      expect(isString(undefined)).toBe(false);\n      expect(isString(1)).toBe(false);\n      expect(isString(NaN)).toBe(false);\n      expect(isString(Symbol('symbol'))).toBe(false);\n    });\n  });\n\n  describe('isSymbol', () => {\n    test('symbols', () => {\n      expect(isSymbol(Symbol('hello'))).toBe(true);\n      expect(isSymbol(Symbol(2))).toBe(true);\n    });\n\n    test('non-symbols', () => {\n      expect(isSymbol('true')).toBe(false);\n      expect(isSymbol([1, 2, 3])).toBe(false);\n      expect(isSymbol(true)).toBe(false);\n      expect(isSymbol(false)).toBe(false);\n      expect(isSymbol(new Date())).toBe(false);\n      expect(isSymbol(new Error())).toBe(false);\n      expect(isSymbol({ a: 1 })).toBe(false);\n      expect(isSymbol(/x/)).toBe(false);\n      expect(isSymbol('a')).toBe(false);\n      expect(isSymbol(null)).toBe(false);\n      expect(isSymbol(undefined)).toBe(false);\n      expect(isSymbol(1)).toBe(false);\n      expect(isSymbol(NaN)).toBe(false);\n    });\n  });\n\n  describe('isUndefined', () => {\n    test('undefined', () => {\n      expect(isUndefined(undefined)).toBe(true);\n    });\n\n    test('null', () => {\n      expect(isUndefined(null)).toBe(false);\n    });\n\n    test('non-undefined', () => {\n      expect(isUndefined('true')).toBe(false);\n      expect(isUndefined([1, 2, 3])).toBe(false);\n      expect(isUndefined(true)).toBe(false);\n      expect(isUndefined(false)).toBe(false);\n      expect(isUndefined(new Date())).toBe(false);\n      expect(isUndefined(new Error())).toBe(false);\n      expect(isUndefined({ a: 1 })).toBe(false);\n      expect(isUndefined(/x/)).toBe(false);\n      expect(isUndefined('a')).toBe(false);\n      expect(isUndefined(null)).toBe(false);\n      expect(isUndefined(1)).toBe(false);\n      expect(isUndefined(NaN)).toBe(false);\n      expect(isUndefined(Symbol('symbol'))).toBe(false);\n    });\n  });\n});\n",
    "/src/type-utilities.ts": "export function isBoolean(value: unknown): boolean {\n  return value === true || value === false;\n}\n\nexport function isNumber(value: unknown): boolean {\n  return typeof value === 'number';\n}\n\nexport function isNull(value: unknown): boolean {\n  return value === null;\n}\n\nexport function isString(value: unknown): boolean {\n  return typeof value === 'string';\n}\n\nexport function isSymbol(value: unknown): boolean {\n  return typeof value === 'symbol';\n}\n\nexport function isUndefined(value: unknown): boolean {\n  return value === undefined;\n}\n"
  },
  "info": {
    "excerpt": "Implement utilities to determine primitive variable types in JavaScript",
    "title": "Type Utilities"
  },
  "metadata": {
    "access": "free",
    "author": "yangshun",
    "companies": [],
    "created": 1649894400,
    "difficulty": "easy",
    "duration": 10,
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/type-utilities",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "type-utilities-ii"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "type-utilities",
    "subtitle": null,
    "topics": []
  },
  "skeleton": {
    "js": "export function isBoolean(value) {\n  throw 'Not implemented!';\n}\n\nexport function isNumber(value) {\n  throw 'Not implemented!';\n}\n\nexport function isNull(value) {\n  throw 'Not implemented!';\n}\n\nexport function isString(value) {\n  throw 'Not implemented!';\n}\n\nexport function isSymbol(value) {\n  throw 'Not implemented!';\n}\n\nexport function isUndefined(value) {\n  throw 'Not implemented!';\n}",
    "ts": "export function isBoolean(value: unknown): boolean {\n  throw 'Not implemented!';\n}\n\nexport function isNumber(value: unknown): boolean {\n  throw 'Not implemented!';\n}\n\nexport function isNull(value: unknown): boolean {\n  throw 'Not implemented!';\n}\n\nexport function isString(value: unknown): boolean {\n  throw 'Not implemented!';\n}\n\nexport function isSymbol(value: unknown): boolean {\n  throw 'Not implemented!';\n}\n\nexport function isUndefined(value: unknown): boolean {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var h=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var o in e)l(n,o,{get:e[o],enumerable:!0})},r=(n,e,o,u)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!y.call(n,i)&&i!==o&&l(n,i,{get:()=>e[i],enumerable:!(u=m(e,i))||u.enumerable});return n};var w=(n,e,o)=>(o=n!=null?h(x(n)):{},r(e||!n||!n.__esModule?l(o,\"default\",{value:n,enumerable:!0}):o,n)),k=n=>r(l({},\"__esModule\",{value:!0}),n);var s=b((D,a)=>{a.exports=_jsx_runtime});var B={};g(B,{default:()=>S});var t=w(s());var c=MDXCodeBlock;var d=`export function isBoolean(value) {\n  return value === true || value === false;\n}\n\nexport function isNumber(value) {\n  return typeof value === 'number';\n}\n\nexport function isNull(value) {\n  return value === null;\n}\n\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\nexport function isSymbol(value) {\n  return typeof value === 'symbol';\n}\n\nexport function isUndefined(value) {\n  return value === undefined;\n}\n`;var f=`export function isBoolean(value: unknown): boolean {\n  return value === true || value === false;\n}\n\nexport function isNumber(value: unknown): boolean {\n  return typeof value === 'number';\n}\n\nexport function isNull(value: unknown): boolean {\n  return value === null;\n}\n\nexport function isString(value: unknown): boolean {\n  return typeof value === 'string';\n}\n\nexport function isSymbol(value: unknown): boolean {\n  return typeof value === 'symbol';\n}\n\nexport function isUndefined(value: unknown): boolean {\n  return value === undefined;\n}\n`;function p(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"Implementing these utility functions won't be an entire interview question itself, but you likely need to implement some of these utility functions as part of solving more complex interview questions.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Most of the functions involve only one line and you might not even need to write a separate function for a single line of logic. The more important thing here is to know how to check for each data type.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"It's also important to note the difference between \",(0,t.jsx)(e.code,{children:\"null\"}),\" and \",(0,t.jsx)(e.code,{children:\"undefined\"}),\". \",(0,t.jsx)(e.code,{children:\"null == undefined\"}),\" is \",(0,t.jsx)(e.code,{children:\"true\"}),\", so we need to use \",(0,t.jsx)(e.code,{children:\"===\"}),\" if the intention is to check for exact \",(0,t.jsx)(e.code,{children:\"null\"}),\" and \",(0,t.jsx)(e.code,{children:\"undefined\"}),\" values.\"]}),`\n`,(0,t.jsx)(c,{languages:{jsx:d,tsx:f}}),`\n`,(0,t.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Familiarity with JavaScript types.\"}),`\n`]})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var S=M;return k(B);})();\n;return Component;",
  "workspace": {
    "main": "/src/type-utilities.ts",
    "run": "/src/type-utilities.run.test.ts",
    "submit": "/src/type-utilities.submit.test.ts"
  }
}