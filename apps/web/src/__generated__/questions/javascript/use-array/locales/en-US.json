{
  "description": "var Component=(()=>{var s=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!f.call(t,a)&&a!==r&&i(t,a,{get:()=>e[a],enumerable:!(o=u(e,a))||o.enumerable});return t};var g=(t,e,r)=>(r=t!=null?s(p(t)):{},c(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),v=t=>c(i({},\"__esModule\",{value:!0}),t);var d=y((j,l)=>{l.exports=_jsx_runtime});var k={};b(k,{default:()=>w,frontmatter:()=>x});var n=g(d()),x={title:\"useArray\",excerpt:\"Implement a hook that manages an array of items\"};function h(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"useArray\"}),\" hook that manages an array of items with additional utility methods.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"It is more convenient to use \",(0,n.jsx)(e.code,{children:\"useArray\"}),\" over plain \",(0,n.jsx)(e.code,{children:\"useState\"}),\" because in the latter case, you would always have to create a new array, mutate it, then set state to use the new array, which can be quite cumbersome.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The hook should work generically with arrays of any types.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`const defaultValue = ['apple', 'banana'];\n\nexport default function Component() {\n  const { array, push, update, remove, filter, set, clear } = useArray();\n\n  return (\n    <div>\n      <p>Fruits: {array.join(', ')}</p>\n      <button onClick={() => push('orange')}>Add orange</button>\n      <button onClick={() => update(1, 'grape')}>\n        Change second item to grape\n      </button>\n      <button onClick={() => remove(0)}>Remove first</button>\n      <button onClick={() => filter((fruit) => fruit.includes('a'))}>\n        Keep fruits containing 'a'\n      </button>\n      <button onClick={() => set(defaultValue)}>Reset</button>\n      <button onClick={clear}>Clear list</button>\n    </div>\n  );\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"defaultValue\"}),\": The initial array of items\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsx)(e.p,{children:\"The hook returns an object with the following properties:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"array\"}),\": The current array of items\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"set: (newArray) => void\"}),\": A function that sets the array of items. This must be the same type as the setter function of \",(0,n.jsx)(e.code,{children:\"useState\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"push: (item) => void\"}),\": A function that adds an item to the end of the array\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"remove: (index: number) => void\"}),\": A function that removes an item from the array by \",(0,n.jsx)(e.code,{children:\"index\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"filter: (predicate) => void\"}),\": A function that filters the array based on a predicate function. \",(0,n.jsx)(e.code,{children:\"predicate\"}),\" must be the same type as the argument of \",(0,n.jsx)(e.code,{children:\"Array.prototype.filter\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"update: (index: number, newItem) => void\"}),\": A function that replaces an item in the array at \",(0,n.jsx)(e.code,{children:\"index\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"clear: () => void\"}),\": A function that clears the array\"]}),`\n`]})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var w=A;return v(k);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a hook that manages an array of items",
    "title": "useArray"
  },
  "solution": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),A=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of p(e))!b.call(t,n)&&n!==r&&s(t,n,{get:()=>e[n],enumerable:!(i=y(e,n))||i.enumerable});return t};var T=(t,e,r)=>(r=t!=null?h(f(t)):{},l(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),k=t=>l(s({},\"__esModule\",{value:!0}),t);var c=x((j,o)=>{o.exports=_jsx_runtime});var R={};A(R,{default:()=>g});var a=T(c());var u=MDXCodeBlock;var d=`import { Dispatch, SetStateAction, useCallback, useState } from 'react';\n\ninterface UseArrayReturn<T> {\n  array: T[];\n  set: Dispatch<SetStateAction<T[]>>;\n  push: (element: T) => void;\n  filter: (callback: (value: T, index: number, array: T[]) => boolean) => void;\n  update: (index: number, newElement: T) => void;\n  remove: (index: number) => void;\n  clear: () => void;\n}\n\nexport default function useArray<T>(defaultValue: T[]): UseArrayReturn<T> {\n  const [array, setArray] = useState(defaultValue);\n\n  const push: UseArrayReturn<T>['push'] = useCallback(\n    (element) => setArray((a) => [...a, element]),\n    [],\n  );\n\n  const filter: UseArrayReturn<T>['filter'] = useCallback(\n    (callback) => setArray((a) => a.filter(callback)),\n    [],\n  );\n\n  const update: UseArrayReturn<T>['update'] = useCallback(\n    (index, newElement) =>\n      setArray((a) => [\n        ...a.slice(0, index),\n        newElement,\n        ...a.slice(index + 1, a.length),\n      ]),\n    [],\n  );\n\n  const remove: UseArrayReturn<T>['remove'] = useCallback(\n    (index) =>\n      setArray((a) => [...a.slice(0, index), ...a.slice(index + 1, a.length)]),\n    [],\n  );\n\n  const clear: UseArrayReturn<T>['clear'] = useCallback(() => setArray([]), []);\n\n  return { array, set: setArray, push, filter, update, remove, clear };\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},t.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,a.jsxs)(e.p,{children:[\"The \",(0,a.jsx)(e.code,{children:\"useArray\"}),\" hook can be implemented by storing the array in a \",(0,a.jsx)(e.code,{children:\"useState\"}),\" state and defining the utility methods to manipulate the array in terms of the state's setter function with JavaScript's built-in array methods.\"]}),`\n`,(0,a.jsxs)(e.p,{children:[\"Remember to wrap the utility methods in \",(0,a.jsx)(e.code,{children:\"useCallback\"}),\" to prevent unnecessary re-renders of the calling component.\"]}),`\n`,(0,a.jsx)(u,{children:d}),`\n`,(0,a.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,a.jsx)(e.p,{children:\"Ensure that the utility methods you implement modify the array in an immutable way since states in React should not be mutated.\"})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,a.jsx)(e,Object.assign({},t,{children:(0,a.jsx)(m,t)})):m(t)}var g=C;return k(R);})();\n;return Component;"
}