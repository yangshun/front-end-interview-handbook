{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-array\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-array.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/use-array.run.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useArray from './use-array';\n\ndescribe('useArray', () => {\n  test('return types', () => {\n    const { result } = renderHook(() => useArray([]));\n\n    expect(result.current.array).toBeInstanceOf(Array);\n    expect(typeof result.current.set).toBe('function');\n    expect(typeof result.current.push).toBe('function');\n    expect(typeof result.current.filter).toBe('function');\n    expect(typeof result.current.update).toBe('function');\n    expect(typeof result.current.remove).toBe('function');\n    expect(typeof result.current.clear).toBe('function');\n  });\n\n  test('initial state', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    expect(result.current.array).toEqual(initialValue);\n  });\n\n  test('push element', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    act(() => {\n      result.current.push(4);\n    });\n\n    expect(result.current.array).toEqual(initialValue.concat(4));\n  });\n\n  test('filter elements', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3, 4]));\n\n    act(() => {\n      result.current.filter((n) => n % 2 === 0);\n    });\n\n    expect(result.current.array).toEqual([2, 4]);\n  });\n\n  test('update element', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.update(1, 4);\n    });\n\n    expect(result.current.array).toEqual([1, 4, 3]);\n  });\n\n  test('remove element', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.array).toEqual([1, 3]);\n  });\n\n  test('clear array', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.array).toEqual([]);\n  });\n});\n",
    "/src/use-array.submit.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useArray from './use-array';\n\ndescribe('useArray', () => {\n  test('return types', () => {\n    const { result } = renderHook(() => useArray([]));\n\n    expect(result.current.array).toBeInstanceOf(Array);\n    expect(typeof result.current.set).toBe('function');\n    expect(typeof result.current.push).toBe('function');\n    expect(typeof result.current.filter).toBe('function');\n    expect(typeof result.current.update).toBe('function');\n    expect(typeof result.current.remove).toBe('function');\n    expect(typeof result.current.clear).toBe('function');\n  });\n\n  test('initial state', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    expect(result.current.array).toEqual(initialValue);\n  });\n\n  test('push element', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    act(() => {\n      result.current.push(4);\n    });\n\n    expect(result.current.array).toEqual(initialValue.concat(4));\n  });\n\n  test('filter elements', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3, 4]));\n\n    act(() => {\n      result.current.filter((n) => n % 2 === 0);\n    });\n\n    expect(result.current.array).toEqual([2, 4]);\n  });\n\n  test('update element', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.update(1, 4);\n    });\n\n    expect(result.current.array).toEqual([1, 4, 3]);\n  });\n\n  test('remove element', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.array).toEqual([1, 3]);\n  });\n\n  test('clear array', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.array).toEqual([]);\n  });\n\n  test('push must be immutable', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.push(4);\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('filter must be immutable', () => {\n    const initialValue = [1, 2, 3, 4];\n\n    const { result } = renderHook(() => useArray([1, 2, 3, 4]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.filter((n) => n % 2 === 0);\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('update must be immutable', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.update(1, 4);\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('remove must be immutable', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('clear must be immutable', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('works with strings', () => {\n    const initialValue = ['a', 'b', 'c'];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    act(() => {\n      result.current.push('d');\n    });\n\n    expect(result.current.array).toEqual(initialValue.concat('d'));\n  });\n});\n",
    "/src/use-array.ts": "import { Dispatch, SetStateAction, useCallback, useState } from 'react';\n\ninterface UseArrayReturn<T> {\n  array: T[];\n  set: Dispatch<SetStateAction<T[]>>;\n  push: (element: T) => void;\n  filter: (callback: (value: T, index: number, array: T[]) => boolean) => void;\n  update: (index: number, newElement: T) => void;\n  remove: (index: number) => void;\n  clear: () => void;\n}\n\nexport default function useArray<T>(defaultValue: T[]): UseArrayReturn<T> {\n  const [array, setArray] = useState(defaultValue);\n\n  const push: UseArrayReturn<T>['push'] = useCallback(\n    (element) => setArray((a) => [...a, element]),\n    [],\n  );\n\n  const filter: UseArrayReturn<T>['filter'] = useCallback(\n    (callback) => setArray((a) => a.filter(callback)),\n    [],\n  );\n\n  const update: UseArrayReturn<T>['update'] = useCallback(\n    (index, newElement) =>\n      setArray((a) => [\n        ...a.slice(0, index),\n        newElement,\n        ...a.slice(index + 1, a.length),\n      ]),\n    [],\n  );\n\n  const remove: UseArrayReturn<T>['remove'] = useCallback(\n    (index) =>\n      setArray((a) => [...a.slice(0, index), ...a.slice(index + 1, a.length)]),\n    [],\n  );\n\n  const clear: UseArrayReturn<T>['clear'] = useCallback(() => setArray([]), []);\n\n  return { array, set: setArray, push, filter, update, remove, clear };\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {T[]} defaultValue\n */\nexport default function useArray(defaultValue) {\n  throw 'Not implemented';\n}",
    "ts": "import { Dispatch, SetStateAction } from 'react';\n\ninterface UseArrayReturn<T> {\n  array: T[];\n  set: Dispatch<SetStateAction<T[]>>;\n  push: (element: T) => void;\n  filter: (callback: (value: T, index: number, array: T[]) => boolean) => void;\n  update: (index: number, newElement: T) => void;\n  remove: (index: number) => void;\n  clear: () => void;\n}\n\nexport default function useArray<T>(defaultValue: T[]): UseArrayReturn<T> {\n  throw 'Not implemented';\n}"
  },
  "workspace": {
    "main": "/src/use-array.ts",
    "run": "/src/use-array.run.test.ts",
    "submit": "/src/use-array.submit.test.ts"
  }
}