{
  "description": "var Component=(()=>{var s=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!f.call(t,a)&&a!==r&&i(t,a,{get:()=>e[a],enumerable:!(o=u(e,a))||o.enumerable});return t};var g=(t,e,r)=>(r=t!=null?s(p(t)):{},c(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),v=t=>c(i({},\"__esModule\",{value:!0}),t);var d=y((j,l)=>{l.exports=_jsx_runtime});var k={};b(k,{default:()=>w,frontmatter:()=>x});var n=g(d()),x={title:\"useArray\",excerpt:\"Implement a hook that manages an array of items\"};function h(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"useArray\"}),\" hook that manages an array of items with additional utility methods.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"It is more convenient to use \",(0,n.jsx)(e.code,{children:\"useArray\"}),\" over plain \",(0,n.jsx)(e.code,{children:\"useState\"}),\" because in the latter case, you would always have to create a new array, mutate it, then set state to use the new array, which can be quite cumbersome.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The hook should work generically with arrays of any types.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`const defaultValue = ['apple', 'banana'];\n\nexport default function Component() {\n  const { array, push, update, remove, filter, set, clear } = useArray();\n\n  return (\n    <div>\n      <p>Fruits: {array.join(', ')}</p>\n      <button onClick={() => push('orange')}>Add orange</button>\n      <button onClick={() => update(1, 'grape')}>\n        Change second item to grape\n      </button>\n      <button onClick={() => remove(0)}>Remove first</button>\n      <button onClick={() => filter((fruit) => fruit.includes('a'))}>\n        Keep fruits containing 'a'\n      </button>\n      <button onClick={() => set(defaultValue)}>Reset</button>\n      <button onClick={clear}>Clear list</button>\n    </div>\n  );\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Arguments\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"defaultValue\"}),\": The initial array of items\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Returns\"}),`\n`,(0,n.jsx)(e.p,{children:\"The hook returns an object with the following properties:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"array\"}),\": The current array of items\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"set: (newArray) => void\"}),\": A function that sets the array of items. This must be the same type as the setter function of \",(0,n.jsx)(e.code,{children:\"useState\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"push: (item) => void\"}),\": A function that adds an item to the end of the array\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"remove: (index: number) => void\"}),\": A function that removes an item from the array by \",(0,n.jsx)(e.code,{children:\"index\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"filter: (predicate) => void\"}),\": A function that filters the array based on a predicate function. \",(0,n.jsx)(e.code,{children:\"predicate\"}),\" must be the same type as the argument of \",(0,n.jsx)(e.code,{children:\"Array.prototype.filter\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"update: (index: number, newItem) => void\"}),\": A function that replaces an item in the array at \",(0,n.jsx)(e.code,{children:\"index\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"clear: () => void\"}),\": A function that clears the array\"]}),`\n`]})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var w=A;return v(k);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/use-array\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/use-array.ts\",\n  \"dependencies\": {\n    \"@testing-library/react\": \"14.0.0\",\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"@types/react\": \"18.2.25\",\n    \"@types/react-dom\": \"18.2.10\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/src/use-array.run.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useArray from './use-array';\n\ndescribe('useArray', () => {\n  test('return types', () => {\n    const { result } = renderHook(() => useArray([]));\n\n    expect(result.current.array).toBeInstanceOf(Array);\n    expect(typeof result.current.set).toBe('function');\n    expect(typeof result.current.push).toBe('function');\n    expect(typeof result.current.filter).toBe('function');\n    expect(typeof result.current.update).toBe('function');\n    expect(typeof result.current.remove).toBe('function');\n    expect(typeof result.current.clear).toBe('function');\n  });\n\n  test('initial state', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    expect(result.current.array).toEqual(initialValue);\n  });\n\n  test('push element', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    act(() => {\n      result.current.push(4);\n    });\n\n    expect(result.current.array).toEqual(initialValue.concat(4));\n  });\n\n  test('filter elements', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3, 4]));\n\n    act(() => {\n      result.current.filter((n) => n % 2 === 0);\n    });\n\n    expect(result.current.array).toEqual([2, 4]);\n  });\n\n  test('update element', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.update(1, 4);\n    });\n\n    expect(result.current.array).toEqual([1, 4, 3]);\n  });\n\n  test('remove element', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.array).toEqual([1, 3]);\n  });\n\n  test('clear array', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.array).toEqual([]);\n  });\n});\n",
    "/src/use-array.submit.test.ts": "import { act, renderHook } from '@testing-library/react';\n\nimport useArray from './use-array';\n\ndescribe('useArray', () => {\n  test('return types', () => {\n    const { result } = renderHook(() => useArray([]));\n\n    expect(result.current.array).toBeInstanceOf(Array);\n    expect(typeof result.current.set).toBe('function');\n    expect(typeof result.current.push).toBe('function');\n    expect(typeof result.current.filter).toBe('function');\n    expect(typeof result.current.update).toBe('function');\n    expect(typeof result.current.remove).toBe('function');\n    expect(typeof result.current.clear).toBe('function');\n  });\n\n  test('initial state', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    expect(result.current.array).toEqual(initialValue);\n  });\n\n  test('push element', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    act(() => {\n      result.current.push(4);\n    });\n\n    expect(result.current.array).toEqual(initialValue.concat(4));\n  });\n\n  test('filter elements', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3, 4]));\n\n    act(() => {\n      result.current.filter((n) => n % 2 === 0);\n    });\n\n    expect(result.current.array).toEqual([2, 4]);\n  });\n\n  test('update element', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.update(1, 4);\n    });\n\n    expect(result.current.array).toEqual([1, 4, 3]);\n  });\n\n  test('remove element', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.array).toEqual([1, 3]);\n  });\n\n  test('clear array', () => {\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.array).toEqual([]);\n  });\n\n  test('push must be immutable', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.push(4);\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('filter must be immutable', () => {\n    const initialValue = [1, 2, 3, 4];\n\n    const { result } = renderHook(() => useArray([1, 2, 3, 4]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.filter((n) => n % 2 === 0);\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('update must be immutable', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.update(1, 4);\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('remove must be immutable', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.remove(1);\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('clear must be immutable', () => {\n    const initialValue = [1, 2, 3];\n\n    const { result } = renderHook(() => useArray([1, 2, 3]));\n\n    expect(result.current.array).not.toBe(initialValue);\n\n    act(() => {\n      result.current.clear();\n    });\n\n    expect(result.current.array).not.toBe(initialValue);\n    expect(result.current.array).not.toEqual(initialValue);\n  });\n\n  test('works with strings', () => {\n    const initialValue = ['a', 'b', 'c'];\n\n    const { result } = renderHook(() => useArray(initialValue));\n\n    act(() => {\n      result.current.push('d');\n    });\n\n    expect(result.current.array).toEqual(initialValue.concat('d'));\n  });\n});\n",
    "/src/use-array.ts": "import { Dispatch, SetStateAction, useCallback, useState } from 'react';\n\ninterface UseArrayReturn<T> {\n  array: T[];\n  set: Dispatch<SetStateAction<T[]>>;\n  push: (element: T) => void;\n  filter: (callback: (value: T, index: number, array: T[]) => boolean) => void;\n  update: (index: number, newElement: T) => void;\n  remove: (index: number) => void;\n  clear: () => void;\n}\n\nexport default function useArray<T>(defaultValue: T[]): UseArrayReturn<T> {\n  const [array, setArray] = useState(defaultValue);\n\n  const push: UseArrayReturn<T>['push'] = useCallback(\n    (element) => setArray((a) => [...a, element]),\n    [],\n  );\n\n  const filter: UseArrayReturn<T>['filter'] = useCallback(\n    (callback) => setArray((a) => a.filter(callback)),\n    [],\n  );\n\n  const update: UseArrayReturn<T>['update'] = useCallback(\n    (index, newElement) =>\n      setArray((a) => [\n        ...a.slice(0, index),\n        newElement,\n        ...a.slice(index + 1, a.length),\n      ]),\n    [],\n  );\n\n  const remove: UseArrayReturn<T>['remove'] = useCallback(\n    (index) =>\n      setArray((a) => [...a.slice(0, index), ...a.slice(index + 1, a.length)]),\n    [],\n  );\n\n  const clear: UseArrayReturn<T>['clear'] = useCallback(() => setArray([]), []);\n\n  return { array, set: setArray, push, filter, update, remove, clear };\n}\n"
  },
  "metadata": {
    "access": "free",
    "author": "phillmont",
    "companies": [],
    "created": 1742169600,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a hook that manages an array of items",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": "react",
    "frameworks": [
      {
        "framework": "react",
        "href": "/questions/javascript/use-array"
      }
    ],
    "href": "/questions/javascript/use-array",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "use-map",
      "use-set",
      "use-object"
    ],
    "slug": "use-array",
    "subtitle": null,
    "title": "useArray",
    "topics": [
      "react-hooks"
    ]
  },
  "skeleton": {
    "js": "/**\n * @template T\n * @param {T[]} defaultValue\n */\nexport default function useArray(defaultValue) {\n  throw 'Not implemented';\n}",
    "ts": "import { Dispatch, SetStateAction } from 'react';\n\ninterface UseArrayReturn<T> {\n  array: T[];\n  set: Dispatch<SetStateAction<T[]>>;\n  push: (element: T) => void;\n  filter: (callback: (value: T, index: number, array: T[]) => boolean) => void;\n  update: (index: number, newElement: T) => void;\n  remove: (index: number) => void;\n  clear: () => void;\n}\n\nexport default function useArray<T>(defaultValue: T[]): UseArrayReturn<T> {\n  throw 'Not implemented';\n}"
  },
  "solution": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),A=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of p(e))!b.call(t,n)&&n!==r&&s(t,n,{get:()=>e[n],enumerable:!(i=y(e,n))||i.enumerable});return t};var T=(t,e,r)=>(r=t!=null?h(f(t)):{},l(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),k=t=>l(s({},\"__esModule\",{value:!0}),t);var c=x((j,o)=>{o.exports=_jsx_runtime});var R={};A(R,{default:()=>g});var a=T(c());var u=MDXCodeBlock;var d=`import { Dispatch, SetStateAction, useCallback, useState } from 'react';\n\ninterface UseArrayReturn<T> {\n  array: T[];\n  set: Dispatch<SetStateAction<T[]>>;\n  push: (element: T) => void;\n  filter: (callback: (value: T, index: number, array: T[]) => boolean) => void;\n  update: (index: number, newElement: T) => void;\n  remove: (index: number) => void;\n  clear: () => void;\n}\n\nexport default function useArray<T>(defaultValue: T[]): UseArrayReturn<T> {\n  const [array, setArray] = useState(defaultValue);\n\n  const push: UseArrayReturn<T>['push'] = useCallback(\n    (element) => setArray((a) => [...a, element]),\n    [],\n  );\n\n  const filter: UseArrayReturn<T>['filter'] = useCallback(\n    (callback) => setArray((a) => a.filter(callback)),\n    [],\n  );\n\n  const update: UseArrayReturn<T>['update'] = useCallback(\n    (index, newElement) =>\n      setArray((a) => [\n        ...a.slice(0, index),\n        newElement,\n        ...a.slice(index + 1, a.length),\n      ]),\n    [],\n  );\n\n  const remove: UseArrayReturn<T>['remove'] = useCallback(\n    (index) =>\n      setArray((a) => [...a.slice(0, index), ...a.slice(index + 1, a.length)]),\n    [],\n  );\n\n  const clear: UseArrayReturn<T>['clear'] = useCallback(() => setArray([]), []);\n\n  return { array, set: setArray, push, filter, update, remove, clear };\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},t.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,a.jsxs)(e.p,{children:[\"The \",(0,a.jsx)(e.code,{children:\"useArray\"}),\" hook can be implemented by storing the array in a \",(0,a.jsx)(e.code,{children:\"useState\"}),\" state and defining the utility methods to manipulate the array in terms of the state's setter function with JavaScript's built-in array methods.\"]}),`\n`,(0,a.jsxs)(e.p,{children:[\"Remember to wrap the utility methods in \",(0,a.jsx)(e.code,{children:\"useCallback\"}),\" to prevent unnecessary re-renders of the calling component.\"]}),`\n`,(0,a.jsx)(u,{children:d}),`\n`,(0,a.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,a.jsx)(e.p,{children:\"Ensure that the utility methods you implement modify the array in an immutable way since states in React should not be mutated.\"})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,a.jsx)(e,Object.assign({},t,{children:(0,a.jsx)(m,t)})):m(t)}var g=C;return k(R);})();\n;return Component;",
  "workspace": {
    "main": "/src/use-array.ts",
    "run": "/src/use-array.run.test.ts",
    "submit": "/src/use-array.submit.test.ts"
  }
}