{
  "description": "var Component=(()=>{var h=Object.create;var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var j=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var r in e)l(n,r,{get:e[r],enumerable:!0})},a=(n,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!f.call(n,o)&&o!==r&&l(n,o,{get:()=>e[o],enumerable:!(s=u(e,o))||s.enumerable});return n};var b=(n,e,r)=>(r=n!=null?h(p(n)):{},a(e||!n||!n.__esModule?l(r,\"default\",{value:n,enumerable:!0}):r,n)),w=n=>a(l({},\"__esModule\",{value:!0}),n);var c=j((k,i)=>{i.exports=_jsx_runtime});var P={};v(P,{default:()=>S,frontmatter:()=>g});var t=b(c()),g={title:\"Promise.allSettled\",excerpt:\"Implement the Promise.allSettled() function that resolves to an array of outcomes when all the input elements are either resolved or rejected\"};function d(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",blockquote:\"blockquote\",em:\"em\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" If you haven't completed the \",(0,t.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,t.jsx)(e.code,{children:\"Promise.all\"})}),\" question, you should attempt that first.\"]}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"Promise.allSettled()\"}),\" method returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"However, if and only if an empty iterable is passed as an argument, \",(0,t.jsx)(e.code,{children:\"Promise.allSettled()\"}),\" returns a \",(0,t.jsx)(e.code,{children:\"Promise\"}),\" object that has already been resolved as an empty array.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"For each outcome object, a \",(0,t.jsx)(e.code,{children:\"status\"}),\" string is present. If the status is \",(0,t.jsx)(e.code,{children:\"'fulfilled'\"}),\", then a \",(0,t.jsx)(e.code,{children:\"value\"}),\" is present. If the status is \",(0,t.jsx)(e.code,{children:\"'rejected'\"}),\", then a \",(0,t.jsx)(e.code,{children:\"reason\"}),\" is present. The value (or reason) reflects what value each promise was fulfilled (or rejected) with.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsxs)(e.em,{children:[\"Source: \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\",children:\"Promise.allSettled() - JavaScript | MDN\"})]})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"Promise.allSettled()\"}),\" is frequently used when there are multiple independent asynchronous tasks and we want to know the result of each promise, regardless of whether they were fulfilled or rejected.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let's implement our own version of \",(0,t.jsx)(e.code,{children:\"Promise.allSettled()\"}),\", a \",(0,t.jsx)(e.code,{children:\"promiseAllSettled\"}),\" function, with the difference being the function takes in an array instead of an iterable. Be sure to read the description carefully and implement accordingly!\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const p0 = Promise.resolve(3);\nconst p1 = 42;\nconst p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('foo');\n  }, 100);\n});\n\nawait promiseAllSettled([p0, p1, p2]);\n// [\n//   { status: 'fulfilled', value: 3 },\n//   { status: 'fulfilled', value: 42 },\n//   { status: 'rejected', reason: 'foo' },\n// ];\n`})})]})}function y(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var S=y;return w(P);})();\n;return Component;",
  "info": {
    "excerpt": "Implement the Promise.allSettled() function that resolves to an array of outcomes when all the input elements are either resolved or rejected",
    "title": "Promise.allSettled"
  },
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),P=(n,e)=>{for(var t in e)l(n,t,{get:e[t],enumerable:!0})},o=(n,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!w.call(n,i)&&i!==t&&l(n,i,{get:()=>e[i],enumerable:!(a=y(e,i))||a.enumerable});return n};var j=(n,e,t)=>(t=n!=null?f(g(n)):{},o(e||!n||!n.__esModule?l(t,\"default\",{value:n,enumerable:!0}):t,n)),x=n=>o(l({},\"__esModule\",{value:!0}),n);var c=b((E,d)=>{d.exports=_jsx_runtime});var R={};P(R,{default:()=>k});var r=j(c());var s=MDXCodeBlock;var h=`/**\n * @param {Array} iterable\n * @return {Promise<Array<{status: 'fulfilled', value: *}|{status: 'rejected', reason: *}>>}\n */\nexport default function promiseAllSettled(iterable) {\n  return new Promise((resolve) => {\n    const results = new Array(iterable.length);\n    let pending = iterable.length;\n\n    if (pending === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach(async (item, index) => {\n      try {\n        const value = await item;\n        results[index] = {\n          status: 'fulfilled',\n          value,\n        };\n      } catch (err) {\n        results[index] = {\n          status: 'rejected',\n          reason: err,\n        };\n      }\n\n      pending -= 1;\n      if (pending === 0) {\n        resolve(results);\n      }\n    });\n  });\n}\n`;var u=`interface PromiseFulfilledResult<T> {\n  status: 'fulfilled';\n  value: T;\n}\n\ninterface PromiseRejectedResult {\n  status: 'rejected';\n  reason: any;\n}\n\nexport default function promiseAllSettled<T>(\n  iterable: Array<T>,\n): Promise<Array<PromiseFulfilledResult<T> | PromiseRejectedResult>> {\n  return new Promise((resolve) => {\n    const results = new Array(iterable.length);\n    let pending = iterable.length;\n\n    if (pending === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach(async (item, index) => {\n      try {\n        const value = await item;\n        results[index] = {\n          status: 'fulfilled',\n          value,\n        };\n      } catch (err) {\n        results[index] = {\n          status: 'rejected',\n          reason: err,\n        };\n      }\n\n      pending -= 1;\n      if (pending === 0) {\n        resolve(results);\n      }\n    });\n  });\n}\n`;var m=`/**\n * @param {Array} iterable\n * @return {Promise<Array<{status: 'fulfilled', value: *}|{status: 'rejected', reason: *}>>}\n */\nexport default function promiseAllSettled(iterable) {\n  return new Promise((resolve) => {\n    const results = new Array(iterable.length);\n    let pending = iterable.length;\n\n    if (pending === 0) {\n      resolve(results);\n      return;\n    }\n\n    iterable.forEach((item, index) => {\n      Promise.resolve(item)\n        .then(\n          (value) => {\n            results[index] = {\n              status: 'fulfilled',\n              value,\n            };\n          },\n          (reason) => {\n            results[index] = {\n              status: 'rejected',\n              reason,\n            };\n          },\n        )\n        .finally(() => {\n          pending -= 1;\n          if (pending === 0) {\n            resolve(results);\n          }\n        });\n    });\n  });\n}\n`;function p(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"Note:\"}),\" If you haven't completed the \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,r.jsx)(e.code,{children:\"Promise.all\"})}),\" question, you should attempt that first.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Async programming is frequently tested during interviews. Understanding how \",(0,r.jsx)(e.code,{children:\"Promise.allSettled\"}),\" works under the hood will help you in understanding the mechanisms behind similar \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"-related functions like \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-race\",children:(0,r.jsx)(e.code,{children:\"Promise.race\"})}),\", \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-any\",children:(0,r.jsx)(e.code,{children:\"Promise.any\"})}),\", \",(0,r.jsx)(e.a,{href:\"/questions/javascript/promise-all\",children:(0,r.jsx)(e.code,{children:\"Promise.all\"})}),\", etc.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsx)(e.p,{children:\"There are a few aspects to this question we need to bear in mind and handle:\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"Promise\"}),\"s are meant to be chained, so the function needs to return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the input array is empty, the returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" resolves with an empty array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The returned \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" contains an array of outcome objects in the \",(0,r.jsx)(e.strong,{children:\"same order as the input\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s.\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We'll return a \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" at the top level of the function. Firstly check if the input array is empty and resolve with an empty array if so.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We then attempt to resolve every item in the input array. This can be achieved using \",(0,r.jsx)(e.code,{children:\"Array.prototype.forEach\"}),\" or \",(0,r.jsx)(e.code,{children:\"Array.prototype.map\"}),\". As the returned values will need to preserve the order of the input array, create a \",(0,r.jsx)(e.code,{children:\"results\"}),\" array and slot the value in the right place using its \",(0,r.jsx)(e.code,{children:\"index\"}),\" within the input array.\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If a value is resolved, the outcome object has the \",(0,r.jsx)(e.code,{children:\"{ status: 'fulfilled', value }\"}),\" shape.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If a value is rejected, the outcome object has the \",(0,r.jsx)(e.code,{children:\"{ status: 'rejected', reason }\"}),\" shape.\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.p,{children:[\"To know when all the input array values have an outcome, keep track of how many pending promises there are by initializing a counter of pending values and decrementing it whenever a value is resolved or rejected. When the \",(0,r.jsx)(e.code,{children:\"pending\"}),\" counter reaches 0, return the \",(0,r.jsx)(e.code,{children:\"results\"}),\" array.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"One thing to note here is that because the input array can contain non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, if we are not \",(0,r.jsx)(e.code,{children:\"await\"}),\"-ing them, we need to wrap each value with \",(0,r.jsx)(e.code,{children:\"Promise.resolve()\"}),\" which allows us to use \",(0,r.jsx)(e.code,{children:\".then()\"}),\" on each of them and we don't have to differentiate between \",(0,r.jsx)(e.code,{children:\"Promise\"}),\" vs non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values and whether they need to be resolved.\"]}),`\n`,(0,r.jsx)(s,{languages:{jsx:h,tsx:u}}),`\n`,(0,r.jsxs)(e.p,{children:[\"Here's an alternative version which uses \",(0,r.jsx)(e.code,{children:\"Promise.then()\"}),\" if you prefer not to use \",(0,r.jsx)(e.code,{children:\"async\"}),\"/\",(0,r.jsx)(e.code,{children:\"await\"}),\".\"]}),`\n`,(0,r.jsx)(s,{children:m}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Empty input array. An empty array should be returned.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the array contains non-\",(0,r.jsx)(e.code,{children:\"Promise\"}),\" values, they will still be part of the returned array if all the input values are fulfilled.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Knowledge of \",(0,r.jsx)(e.code,{children:\"Promise\"}),\"s, how to construct one, how to use them.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Async programming.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"The evaluator does not verify that your input array is resolved concurrently rather than sequentially.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled\",children:\"Promise.allSettled() - JavaScript | MDN\"})}),`\n`]})]})}function q(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(p,n)})):p(n)}var k=q;return x(R);})();\n;return Component;"
}