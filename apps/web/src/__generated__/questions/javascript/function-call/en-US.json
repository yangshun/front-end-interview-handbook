{
  "description": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var s=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var o in e)c(n,o,{get:e[o],enumerable:!0})},r=(n,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!g.call(n,l)&&l!==o&&c(n,l,{get:()=>e[l],enumerable:!(i=u(e,l))||i.enumerable});return n};var f=(n,e,o)=>(o=n!=null?h(s(n)):{},r(e||!n||!n.__esModule?c(o,\"default\",{value:n,enumerable:!0}):o,n)),j=n=>r(c({},\"__esModule\",{value:!0}),n);var d=y((C,a)=>{a.exports=_jsx_runtime});var _={};v(_,{default:()=>b,frontmatter:()=>x});var t=f(d()),x={title:\"Function.prototype.call\",excerpt:\"Implement the Function.prototype.call() function that calls the function with a given `this` value and provided arguments\"};function p(n){let e=Object.assign({blockquote:\"blockquote\",p:\"p\",code:\"code\",em:\"em\",a:\"a\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.blockquote,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"Function.prototype.call()\"}),\" method calls the function with a given \",(0,t.jsx)(e.code,{children:\"this\"}),\" value and arguments provided individually.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsxs)(e.em,{children:[\"Source: \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/call\",children:\"Function.prototype.call() - JavaScript | MDN\"})]})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Implement your own \",(0,t.jsx)(e.code,{children:\"Function.prototype.call\"}),\" without calling the native \",(0,t.jsx)(e.code,{children:\"call\"}),\" method. To avoid overwriting the actual \",(0,t.jsx)(e.code,{children:\"Function.prototype.call\"}),\", implement the function as \",(0,t.jsx)(e.code,{children:\"Function.prototype.myCall\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`function multiplyAge(multiplier = 1) {\n  return this.age * multiplier;\n}\n\nconst mary = {\n  age: 21,\n};\n\nconst john = {\n  age: 42,\n};\n\nmultiplyAge.myCall(mary); // 21\nmultiplyAge.myCall(john, 2); // 84\n`})})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var b=F;return j(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/function-call\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/function-call.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/function-call.run.test.ts": "import './function-call';\n\ndescribe('Function.prototype.myCall', () => {\n  const person = {\n    name: 'John',\n  };\n\n  function getName(this: any) {\n    return this.name;\n  }\n\n  function sum(...args: Array<number>) {\n    return args.reduce((acc, num) => acc + num, 0);\n  }\n\n  test('Function.prototype.myCall is a function', () => {\n    expect(typeof Function.prototype.myCall).toBe('function');\n  });\n\n  test('`this` is bound', () => {\n    expect(getName.myCall(person)).toStrictEqual('John');\n  });\n\n  test('with a parameter', () => {\n    expect(sum.myCall(null, 1)).toBe(1);\n  });\n});\n",
    "/src/function-call.submit.test.ts": "import './function-call';\n\ndescribe('Function.prototype.myCall', () => {\n  const person = {\n    name: 'John',\n  };\n\n  function getName(this: any) {\n    return this.name;\n  }\n\n  function sum(...args: Array<number>) {\n    return args.reduce((acc, num) => acc + num, 0);\n  }\n\n  function greeting(this: any, prefix: string, message: string) {\n    return `${prefix} ${this.name}, ${message}`;\n  }\n\n  test('Function.prototype.myCall is a function', () => {\n    expect(typeof Function.prototype.myCall).toBe('function');\n  });\n\n  test('`this` is bound', () => {\n    expect(getName.myCall(person)).toStrictEqual('John');\n  });\n\n  describe('without `this`', () => {\n    test('single parameter', () => {\n      expect(sum.myCall(null, 1)).toBe(1);\n    });\n\n    test('two parameters', () => {\n      expect(sum.myCall(null, 1, 2)).toBe(3);\n    });\n\n    test('three parameters', () => {\n      expect(sum.myCall(null, 1, 2, 3)).toBe(6);\n    });\n  });\n\n  test('`this` and parameters', () => {\n    expect(greeting.myCall(person, 'Hello', 'how are you?')).toStrictEqual(\n      'Hello John, how are you?',\n    );\n  });\n});\n",
    "/src/function-call.ts": "interface Function {\n  myCall(this: Function, thisArg: any, ...argArray: any[]): any;\n}\n\nFunction.prototype.myCall = function (thisArg, ...argArray) {\n  return this.bind(thisArg)(...argArray);\n};\n"
  },
  "metadata": {
    "access": "standard",
    "author": null,
    "companies": [],
    "created": 1690329600,
    "difficulty": "easy",
    "duration": 10,
    "excerpt": "Implement the Function.prototype.call() function that calls the function with a given `this` value and provided arguments",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/function-call",
    "importance": "medium",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "function-bind",
      "function-apply"
    ],
    "slug": "function-call",
    "subtitle": null,
    "title": "Function.prototype.call",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {any} thisArg\n * @param {...*} argArray\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...argArray) {\n  throw 'Not implemented!';\n};",
    "ts": "interface Function {\n  myCall(this: Function, thisArg: any, ...argArray: any[]): any;\n}\n\nFunction.prototype.myCall = function (thisArg, ...argArray) {\n  throw 'Not implemented!';\n};"
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,F=Object.prototype.hasOwnProperty;var x=(r,n)=>()=>(n||r((n={exports:{}}).exports,n),n.exports),C=(r,n)=>{for(var t in n)o(r,t,{get:n[t],enumerable:!0})},l=(r,n,t,c)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let i of b(n))!F.call(r,i)&&i!==t&&o(r,i,{get:()=>n[i],enumerable:!(c=A(n,i))||c.enumerable});return r};var j=(r,n,t)=>(t=r!=null?f(w(r)):{},l(n||!r||!r.__esModule?o(t,\"default\",{value:r,enumerable:!0}):t,r)),v=r=>l(o({},\"__esModule\",{value:!0}),r);var d=x((U,s)=>{s.exports=_jsx_runtime});var X={};C(X,{default:()=>D});var e=j(d());var a=MDXCodeBlock;var h=`/**\n * @param {any} thisArg\n * @param {...*} argArray\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...argArray) {\n  return this.bind(thisArg)(...argArray);\n};\n`;var p=`interface Function {\n  myCall(this: Function, thisArg: any, ...argArray: any[]): any;\n}\n\nFunction.prototype.myCall = function (thisArg, ...argArray) {\n  return this.bind(thisArg)(...argArray);\n};\n`;var u=`/**\n * @param {any} thisArg\n * @param {...*} argArray\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...argArray) {\n  return this.bind(thisArg, ...argArray)();\n};\n`;var y=`/**\n * @param {any} thisArg\n * @param {...*} argArray\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...argArray) {\n  return this.apply(thisArg, argArray);\n};\n`;var g=`/**\n * @param {any} thisArg\n * @param {...*} argArray\n * @return {any}\n */\nFunction.prototype.myCall = function (thisArg, ...argArray) {\n  const sym = Symbol();\n  const wrapperObj = Object(thisArg);\n  Object.defineProperty(wrapperObj, sym, {\n    enumerable: false,\n    value: this,\n  });\n\n  return wrapperObj[sym](...argArray);\n};\n`;function m(r){let n=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",h3:\"h3\",pre:\"pre\",ul:\"ul\",li:\"li\",strong:\"strong\",a:\"a\"},r.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"The \",(0,e.jsx)(n.code,{children:\"Function.prototype.call()\"}),\" function is a built-in method in JavaScript that allows you to call a function with a specified this value and a set of arguments, passed individually (not as an array like \",(0,e.jsx)(n.code,{children:\"Function.prototype.apply\"}),\"). It allows you to explicitly define the context (\",(0,e.jsx)(n.code,{children:\"this\"}),\" value) in which the function will be executed.\"]}),`\n`,(0,e.jsx)(n.h2,{children:\"Solution\"}),`\n`,(0,e.jsxs)(n.h3,{children:[\"Approach 1: Using \",(0,e.jsx)(n.code,{children:\"bind\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"bind\"}),\", \",(0,e.jsx)(n.code,{children:\"apply\"}),\", and \",(0,e.jsx)(n.code,{children:\"call\"}),\" can be viewed as sibling functions. They're highly similar in terms of function signature and usage. Within \",(0,e.jsx)(n.code,{children:\"Function.prototype\"}),\" methods, \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the \",(0,e.jsx)(n.code,{children:\"Function\"}),\" object itself. If the \",(0,e.jsx)(n.code,{children:\"this\"}),\" context is not used at all, the following will work:\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`Function.prototype.myCall = function (thisArg, ...argArray) {\n  return this(...argArray);\n};\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"However, \",(0,e.jsx)(n.code,{children:\"thisArg\"}),\" is still used widely in modern code, so we need another way to do this. \",(0,e.jsx)(n.code,{children:\"Function.prototype.bind\"}),\" creates a new function with a specified \",(0,e.jsx)(n.code,{children:\"this\"}),\" value and initial arguments, without executing the original function immediately. It allows you to permanently bind a specific context (\",(0,e.jsx)(n.code,{children:\"this\"}),\" value) to the function and partially apply arguments if needed. This is exactly what we need to bridge the gap in the solution above.\"]}),`\n`,(0,e.jsx)(a,{languages:{jsx:h,tsx:p}}),`\n`,(0,e.jsxs)(n.p,{children:[\"Or you can also pass the \",(0,e.jsx)(n.code,{children:\"argArray\"}),\" into \",(0,e.jsx)(n.code,{children:\"bind()\"}),\" before executing it.\"]}),`\n`,(0,e.jsx)(a,{children:u}),`\n`,(0,e.jsxs)(n.h3,{children:[\"Approach 2: Using \",(0,e.jsx)(n.code,{children:\"apply\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"Function.prototype.call\"}),\" and \",(0,e.jsx)(n.code,{children:\"Function.prototype.apply\"}),\" are very similar. Here's an easy way to remember each function's signature:\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"Function.prototype.call\"}),' starts with \"C\" and takes in a ',(0,e.jsx)(n.strong,{children:\"C\"}),\"omma-separated list of arguments\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"Function.prototype.apply\"}),' starts with \"A\" and takes in an ',(0,e.jsx)(n.strong,{children:\"A\"}),\"rray of arguments\"]}),`\n`]}),`\n`,(0,e.jsx)(a,{children:y}),`\n`,(0,e.jsxs)(n.h3,{children:[\"Approach 3: Using \",(0,e.jsx)(n.code,{children:\"Symbol\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Another approach is to create a \",(0,e.jsx)(n.code,{children:\"Symbol\"}),\" and add it as a property to a newly-created \",(0,e.jsx)(n.code,{children:\"Object\"}),\" with \",(0,e.jsx)(n.code,{children:\"thisArg\"}),\" bound to it. This is very similar to one of the solutions to the \",(0,e.jsx)(n.a,{href:\"/questions/javascript/function-bind\",children:(0,e.jsx)(n.code,{children:\"Function.prototype.bind\"})}),\" question.\"]}),`\n`,(0,e.jsx)(a,{children:g})]})}function T(r={}){let{wrapper:n}=r.components||{};return n?(0,e.jsx)(n,Object.assign({},r,{children:(0,e.jsx)(m,r)})):m(r)}var D=T;return v(X);})();\n;return Component;",
  "workspace": {
    "main": "/src/function-call.ts",
    "run": "/src/function-call.run.test.ts",
    "submit": "/src/function-call.submit.test.ts"
  }
}