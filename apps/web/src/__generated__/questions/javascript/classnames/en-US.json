{
  "description": "var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var p=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),g=(a,e)=>{for(var s in e)l(a,s,{get:e[s],enumerable:!0})},o=(a,e,s,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!b.call(a,r)&&r!==s&&l(a,r,{get:()=>e[r],enumerable:!(c=h(e,r))||c.enumerable});return a};var x=(a,e,s)=>(s=a!=null?u(f(a)):{},o(e||!a||!a.__esModule?l(s,\"default\",{value:a,enumerable:!0}):s,a)),y=a=>o(l({},\"__esModule\",{value:!0}),a);var i=p((C,t)=>{t.exports=_jsx_runtime});var _={};g(_,{default:()=>v,frontmatter:()=>N});var n=x(i()),N={title:\"Classnames\",excerpt:\"Implement a function that conditionally joins CSS class names together\"};function d(a){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",h2:\"h2\",pre:\"pre\",ul:\"ul\",li:\"li\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:(0,n.jsx)(e.code,{children:\"classnames\"})}),\" is a commonly-used utility in modern front end applications to conditionally join CSS class names together. If you've written React applications, you likely have used a similar library.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement the \",(0,n.jsx)(e.code,{children:\"classnames\"}),\" function.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`classNames('foo', 'bar'); // 'foo bar'\nclassNames('foo', { bar: true }); // 'foo bar'\nclassNames({ 'foo-bar': true }); // 'foo-bar'\nclassNames({ 'foo-bar': false }); // ''\nclassNames({ foo: true }, { bar: true }); // 'foo bar'\nclassNames({ foo: true, bar: true }); // 'foo bar'\nclassNames({ foo: true, bar: false, qux: true }); // 'foo qux'\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Arrays will be recursively flattened as per the rules above.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`classNames('a', ['b', { c: true, d: false }]); // 'a b c'\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Values can be mixed.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`classNames(\n  'foo',\n  {\n    bar: true,\n    duck: false,\n  },\n  'baz',\n  { quux: true },\n); // 'foo bar baz quux'\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Falsey values are ignored.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`classNames(null, false, 'bar', undefined, { baz: null }, ''); // 'bar'\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In addition, the returned string should not have any leading or trailing whitespace.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:[(0,n.jsx)(e.code,{children:\"classnames\"}),\" library on GitHub\"]})}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.a,{href:\"https://github.com/lukeed/clsx\",children:[(0,n.jsx)(e.code,{children:\"clsx\"}),\" library on GitHub\"]}),\": A newer version which serves as a faster and smaller drop-in replacement for \",(0,n.jsx)(e.code,{children:\"classnames\"}),\".\"]}),`\n`]})]})}function j(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var v=j;return y(_);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/classnames\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/classnames.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/classnames.run.test.ts": "import classNames from './classnames';\n\ndescribe('classNames', () => {\n  test('empty values', () => {\n    expect(classNames([])).toEqual('');\n  });\n\n  test('single value', () => {\n    expect(classNames('foo')).toEqual('foo');\n  });\n\n  test('two values', () => {\n    expect(classNames('foo', 'bar')).toEqual('foo bar');\n  });\n\n  test('array values', () => {\n    expect(classNames(['foo', 'bar', 'baz'])).toEqual('foo bar baz');\n  });\n});\n",
    "/src/classnames.submit.test.ts": "import classNames from './classnames';\n\ndescribe('classNames', () => {\n  test('empty values', () => {\n    expect(classNames([])).toEqual('');\n  });\n\n  test('single value', () => {\n    expect(classNames('foo')).toEqual('foo');\n  });\n\n  test('two values', () => {\n    expect(classNames('foo', 'bar')).toEqual('foo bar');\n  });\n\n  test('array values', () => {\n    expect(classNames(['foo', 'bar', 'baz'])).toEqual('foo bar baz');\n  });\n\n  test('object values', () => {\n    expect(classNames({ 'foo-bar': true })).toEqual('foo-bar');\n    expect(classNames({ 'foo-bar': false })).toEqual('');\n    expect(classNames({ foo: true }, { bar: true })).toEqual('foo bar');\n    expect(classNames({ foo: true, bar: false, qux: true })).toEqual('foo qux');\n  });\n\n  test('mixed values', () => {\n    expect(\n      classNames(\n        'foo',\n        {\n          bar: true,\n          duck: false,\n        },\n        'baz',\n        { quux: true },\n      ),\n    ).toEqual('foo bar baz quux');\n    expect(\n      classNames('boo', true && 'loo', false && 'booz', {\n        foo: true,\n        bar: false,\n        baz: 1,\n      }),\n    ).toEqual('boo loo foo baz');\n  });\n\n  test('ignores falsey values', () => {\n    expect(\n      classNames(null, false, 'bar', undefined, 0, 1, { baz: null }, ''),\n    ).toEqual('bar 1');\n  });\n\n  test('recursively flattens arrays', () => {\n    expect(classNames('a', ['b', { c: true, d: false }])).toEqual('a b c');\n    expect(classNames('a', ['b', ['c', ['d']]])).toEqual('a b c d');\n  });\n});\n",
    "/src/classnames.ts": "export type ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassDictionary = Record<string, any>;\nexport type ClassArray = Array<ClassValue>;\n\nexport default function classNames(...args: Array<ClassValue>): string {\n  const classes: Array<string> = [];\n\n  args.forEach((arg) => {\n    // Ignore falsey values.\n    if (!arg) {\n      return;\n    }\n\n    const argType = typeof arg;\n\n    // Handle string and numbers.\n    if (argType === 'string' || argType === 'number') {\n      classes.push(String(arg));\n      return;\n    }\n\n    // Handle arrays.\n    if (Array.isArray(arg)) {\n      classes.push(classNames(...arg));\n      return;\n    }\n\n    // Handle objects.\n    if (argType === 'object') {\n      const objArg = arg as ClassDictionary;\n      for (const key in objArg) {\n        // Only process non-inherited keys.\n        if (Object.hasOwn(objArg, key) && objArg[key]) {\n          classes.push(key);\n        }\n      }\n\n      return;\n    }\n  });\n\n  return classes.join(' ');\n}\n"
  },
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1651449600,
    "difficulty": "medium",
    "duration": 20,
    "excerpt": "Implement a function that conditionally joins CSS class names together",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/classnames",
    "importance": "medium",
    "languages": [
      "css",
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "classnames",
    "subtitle": null,
    "title": "Classnames",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {...(any|Object|Array<any|Object|Array>)} args\n * @return {string}\n */\nexport default function classNames(...args) {\n  throw 'Not implemented!';\n}",
    "ts": "export type ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassDictionary = Record<string, any>;\nexport type ClassArray = Array<ClassValue>;\n\nexport default function classNames(...args: Array<ClassValue>): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var j=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports),k=(s,e)=>{for(var n in e)i(s,n,{get:e[n],enumerable:!0})},o=(s,e,n,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of v(e))!w.call(s,a)&&a!==n&&i(s,a,{get:()=>e[a],enumerable:!(t=b(e,a))||t.enumerable});return s};var C=(s,e,n)=>(n=s!=null?m(A(s)):{},o(e||!s||!s.__esModule?i(n,\"default\",{value:s,enumerable:!0}):n,s)),T=s=>o(i({},\"__esModule\",{value:!0}),s);var h=j((R,c)=>{c.exports=_jsx_runtime});var V={};k(V,{default:()=>S});var r=C(h());var l=MDXCodeBlock;var d=`/**\n * @param {...(any|Object|Array<any|Object|Array>)} args\n * @return {string}\n */\nexport default function classNames(...args) {\n  const classes = [];\n\n  args.forEach((arg) => {\n    // Ignore falsey values.\n    if (!arg) {\n      return;\n    }\n\n    const argType = typeof arg;\n\n    // Handle string and numbers.\n    if (argType === 'string' || argType === 'number') {\n      classes.push(arg);\n      return;\n    }\n\n    // Handle arrays.\n    if (Array.isArray(arg)) {\n      classes.push(classNames(...arg));\n      return;\n    }\n\n    // Handle objects.\n    if (argType === 'object') {\n      for (const key in arg) {\n        // Only process non-inherited keys.\n        if (Object.hasOwn(arg, key) && arg[key]) {\n          classes.push(key);\n        }\n      }\n\n      return;\n    }\n  });\n\n  return classes.join(' ');\n}\n`;var u=`export type ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassDictionary = Record<string, any>;\nexport type ClassArray = Array<ClassValue>;\n\nexport default function classNames(...args: Array<ClassValue>): string {\n  const classes: Array<string> = [];\n\n  args.forEach((arg) => {\n    // Ignore falsey values.\n    if (!arg) {\n      return;\n    }\n\n    const argType = typeof arg;\n\n    // Handle string and numbers.\n    if (argType === 'string' || argType === 'number') {\n      classes.push(String(arg));\n      return;\n    }\n\n    // Handle arrays.\n    if (Array.isArray(arg)) {\n      classes.push(classNames(...arg));\n      return;\n    }\n\n    // Handle objects.\n    if (argType === 'object') {\n      const objArg = arg as ClassDictionary;\n      for (const key in objArg) {\n        // Only process non-inherited keys.\n        if (Object.hasOwn(objArg, key) && objArg[key]) {\n          classes.push(key);\n        }\n      }\n\n      return;\n    }\n  });\n\n  return classes.join(' ');\n}\n`;var p=`export type ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassDictionary = Record<string, any>;\nexport type ClassArray = Array<ClassValue>;\n\nexport default function classNames(...args: Array<ClassValue>): string {\n  const classes: Array<string> = [];\n\n  function classNamesImpl(\n    classesArr: Array<string>,\n    ...args: Array<ClassValue>\n  ) {\n    args.forEach((arg) => {\n      // Ignore falsey values.\n      if (!arg) {\n        return;\n      }\n\n      const argType = typeof arg;\n\n      // Handle string and numbers.\n      if (argType === 'string' || argType === 'number') {\n        classesArr.push(String(arg));\n        return;\n      }\n\n      // Handle arrays.\n      if (Array.isArray(arg)) {\n        for (const cls of arg) {\n          classNamesImpl(classesArr, cls);\n        }\n\n        return;\n      }\n\n      // Handle objects.\n      if (argType === 'object') {\n        const objArg = arg as ClassDictionary;\n        for (const key in objArg) {\n          // Only process non-inherited keys.\n          if (Object.hasOwn(objArg, key) && objArg[key]) {\n            classesArr.push(key);\n          }\n        }\n\n        return;\n      }\n    });\n  }\n\n  classNamesImpl(classes, ...args);\n\n  return classes.join(' ');\n}\n`;var g=`export type ClassValue =\n  | ClassArray\n  | ClassDictionary\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassDictionary = Record<string, any>;\nexport type ClassArray = Array<ClassValue>;\n\nexport default function classNames(...args: Array<ClassValue>): string {\n  const classes: Array<string> = [];\n\n  function classNamesImpl(...args: Array<ClassValue>) {\n    args.forEach((arg) => {\n      // Ignore falsey values.\n      if (!arg) {\n        return;\n      }\n\n      const argType = typeof arg;\n\n      // Handle string and numbers.\n      if (argType === 'string' || argType === 'number') {\n        classes.push(String(arg));\n        return;\n      }\n\n      // Handle arrays.\n      if (Array.isArray(arg)) {\n        for (const cls of arg) {\n          classNamesImpl(cls);\n        }\n\n        return;\n      }\n\n      // Handle objects.\n      if (argType === 'object') {\n        const objArg = arg as ClassDictionary;\n        for (const key in objArg) {\n          // Only process non-inherited keys.\n          if (Object.hasOwn(objArg, key) && objArg[key]) {\n            classes.push(key);\n          }\n        }\n\n        return;\n      }\n    });\n  }\n\n  classNamesImpl(...args);\n\n  return classes.join(' ');\n}\n`;var f=`var hasOwn = {}.hasOwnProperty;\n\nexport default function classNames() {\n  var classes = [];\n\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n    if (!arg) continue;\n\n    var argType = typeof arg;\n\n    if (argType === 'string' || argType === 'number') {\n      classes.push(arg);\n    } else if (Array.isArray(arg)) {\n      if (arg.length) {\n        var inner = classNames.apply(null, arg);\n        if (inner) {\n          classes.push(inner);\n        }\n      }\n    } else if (argType === 'object') {\n      if (arg.toString === Object.prototype.toString) {\n        for (var key in arg) {\n          if (hasOwn.call(arg, key) && arg[key]) {\n            classes.push(key);\n          }\n        }\n      } else {\n        classes.push(arg.toString());\n      }\n    }\n  }\n\n  return classes.join(' ');\n}\n`;function y(s){let e=Object.assign({h2:\"h2\",p:\"p\",blockquote:\"blockquote\",code:\"code\",ol:\"ol\",li:\"li\",strong:\"strong\",ul:\"ul\",h3:\"h3\",a:\"a\"},s.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,r.jsx)(e.p,{children:\"The following are good questions to ask the interviewer to demonstrate your thoughtfulness. Depending on their response, you might need to adjust the implementation accordingly.\"}),`\n`,(0,r.jsxs)(e.blockquote,{children:[`\n`,(0,r.jsx)(e.p,{children:\"Can there be duplicated classes in the input? Should the output contain duplicated classes?\"}),`\n`]}),`\n`,(0,r.jsx)(e.p,{children:\"Yes, there can be. In this case the output will contain duplicated classes. However, we will not test for this case.\"}),`\n`,(0,r.jsxs)(e.blockquote,{children:[`\n`,(0,r.jsxs)(e.p,{children:[\"What if a class was added and then later turned off? E.g. \",(0,r.jsx)(e.code,{children:\"classNames('foo', { foo: false })\"}),\"?\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.p,{children:[\"In the library implementations, the final result will be \",(0,r.jsx)(e.code,{children:\"'foo'\"}),\". However, we will not test for this case.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsx)(e.p,{children:\"The tricky part of this solution is the recursive nature of the function. Hence we can separate out the solution into two parts:\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Handling of each data type.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Recursing for array type.\"}),`\n`]}),`\n`,(0,r.jsxs)(e.p,{children:[\"We will need a data structure, \",(0,r.jsx)(e.code,{children:\"classes\"}),\" to collect all the classes for the lifetime of the function that the recursive calls have access to. In our solution we use an \",(0,r.jsx)(e.code,{children:\"Array\"}),\" for the collection, but you can also use a \",(0,r.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`,(0,r.jsx)(e.p,{children:\"To recursively process each argument and collect the classes, a few approaches come to mind:\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Pure recursive function\"}),\": Recursive calls do not depend on external values nor modify the arguments.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Inner recursive helper that modifies an external value\"}),\": The collection is defined at the top level of the function. Inner recursive functions modify the external top-level collection by adding to that collection.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Inner recursive helper that modifies the argument\"}),\": The collection is defined at the top level of the function, passed as an argument into recursive calls, and recursive calls add to the argument.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.p,{children:\"Here's how we will handle each data type:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Falsey values\"}),\": Ignore.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"String\"}),\": Add it to the \",(0,r.jsx)(e.code,{children:\"classes\"}),\" collection.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Number\"}),\": Add it to the \",(0,r.jsx)(e.code,{children:\"classes\"}),\" collection.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Array\"}),\": Recursively invoke the \",(0,r.jsx)(e.code,{children:\"classNames\"}),\" function or inner recursive function.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Object\"}),\": Loop through the key/value pairs and add the keys with truthy values into the \",(0,r.jsx)(e.code,{children:\"classes\"}),\" collection.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h3,{children:\"Approach 1: Pure recursive function\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"In this approach, the \",(0,r.jsx)(e.code,{children:\"classNames\"}),\" function calls itself and its return value is a string that can be composed by parent recursive calls.\"]}),`\n`,(0,r.jsx)(l,{languages:{jsx:d,tsx:u}}),`\n`,(0,r.jsx)(e.h3,{children:\"Approach 2: Inner recursive helper that modifies an external value\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"In this approach, an inner \",(0,r.jsx)(e.code,{children:\"classNamesImpl\"}),\" helper function is defined and it accesses the top-level \",(0,r.jsx)(e.code,{children:\"classes\"}),\" collection within recursive calls. The helper function does not return anything, it's main purpose is to process each argument and add them to \",(0,r.jsx)(e.code,{children:\"classes\"}),\".\"]}),`\n`,(0,r.jsx)(l,{children:g}),`\n`,(0,r.jsx)(e.h3,{children:\"Approach 3: Inner recursive helper that modifies the argument\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"In this approach, an inner \",(0,r.jsx)(e.code,{children:\"classNamesImpl\"}),\" helper function is defined and it accepts a \",(0,r.jsx)(e.code,{children:\"classesArr\"}),\" argument. The \",(0,r.jsx)(e.code,{children:\"classesArr\"}),\" is modified and passed along within recursive calls and all \",(0,r.jsx)(e.code,{children:\"classNamesImpl\"}),\" calls reference the same instance of \",(0,r.jsx)(e.code,{children:\"classesArr\"}),\". The helper function does not return anything, it's main purpose is to process each argument and add them to the \",(0,r.jsx)(e.code,{children:\"classesArr\"}),\" argument.\"]}),`\n`,(0,r.jsx)(l,{children:p}),`\n`,(0,r.jsx)(e.h2,{children:\"Follow-up: De-duplicating classes\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The provided solution doesn't handle de-duplicating classes, which would be a nice optimization. Without de-duplication, \",(0,r.jsx)(e.code,{children:\"classNames('foo', 'foo')\"}),\" will give you \",(0,r.jsx)(e.code,{children:\"'foo foo'\"}),\" which is unnecessary as far as the browser result is concerned.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"In some cases, de-duplication can also affect the result, e.g. in the case of \",(0,r.jsx)(e.code,{children:\"classNames('foo', { foo: false })\"}),\", \",(0,r.jsx)(e.code,{children:\"{ foo: false }\"}),\" appears later in the arguments, so the user probably did not mean for \",(0,r.jsx)(e.code,{children:\"'foo'\"}),\" to appear in the final result.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"This can be handled by using \",(0,r.jsx)(e.code,{children:\"Set\"}),\" to collect the classes from the start, adding or removing classes where necessary.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"De-duplicating classes is usually out of the scope for interviews but is a possible follow-up question. You can practice the de-duplicating functionality in \",(0,r.jsx)(e.a,{href:\"/questions/javascript/classnames-ii\",children:\"Classnames II\"}),\".\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Familiar with JavaScript value types and how to check for them\"}),`\n`,(0,r.jsx)(e.li,{children:\"Recursion\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"Converting from \",(0,r.jsx)(e.code,{children:\"Array\"}),\"s to \",(0,r.jsx)(e.code,{children:\"Set\"}),\"s and vice versa (for the unique classes follow-up)\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Handling of variadic arguments\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"typeof []\"}),\" gives \",(0,r.jsx)(e.code,{children:\"'object'\"}),\", so you need to handle arrays before objects.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"You likely don't have to handle these scenarios, but you should mention them:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Stack overflow\"}),\": Possibility of stack overflow. This applies to any recursive solution\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Circular references\"}),\": Possibility of circular references for arrays and objects. This applies to any input which has arbitrary depth\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Library implementation\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"For your reference, this is how the \",(0,r.jsxs)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:[(0,r.jsx)(e.code,{children:\"classnames\"}),\" npm package\"]}),\" is implemented:\"]}),`\n`,(0,r.jsx)(l,{children:f}),`\n`,(0,r.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:(0,r.jsxs)(e.a,{href:\"https://github.com/JedWatson/classnames\",children:[(0,r.jsx)(e.code,{children:\"classnames\"}),\" library on GitHub\"]})}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.a,{href:\"https://github.com/lukeed/clsx\",children:[(0,r.jsx)(e.code,{children:\"clsx\"}),\" library on GitHub\"]}),\": A newer version which serves as a faster and smaller drop-in replacement for \",(0,r.jsx)(e.code,{children:\"classnames\"}),\".\"]}),`\n`]})]})}function D(s={}){let{wrapper:e}=s.components||{};return e?(0,r.jsx)(e,Object.assign({},s,{children:(0,r.jsx)(y,s)})):y(s)}var S=D;return T(V);})();\n;return Component;",
  "workspace": {
    "main": "/src/classnames.ts",
    "run": "/src/classnames.run.test.ts",
    "submit": "/src/classnames.submit.test.ts"
  }
}