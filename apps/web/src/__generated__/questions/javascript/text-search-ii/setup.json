{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/text-search-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/text-search-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/text-search-ii.run.test.ts": "import textSearch from './text-search-ii';\n\ndescribe('textSearch', () => {\n  test('empty string', () => {\n    expect(textSearch('', [])).toBe('');\n  });\n\n  test('no matching queries', () => {\n    expect(textSearch('The quick brown fox jumps over the lazy dog', [])).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n  });\n\n  test('single query match', () => {\n    expect(\n      textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', ['fox']),\n    ).toBe('The Quick Brown <b>Fox</b> Jumps Over The Lazy Dog');\n  });\n\n  test('consecutive matches have combined tags', () => {\n    expect(textSearch('aabbcc', ['a'])).toBe('<b>aa</b>bbcc');\n  });\n});\n",
    "/src/text-search-ii.submit.test.ts": "import textSearch from './text-search-ii';\n\ndescribe('textSearch', () => {\n  test('empty string', () => {\n    expect(textSearch('', [])).toBe('');\n    expect(textSearch('', [''])).toBe('');\n    expect(textSearch('', ['xyz'])).toBe('');\n    expect(textSearch('', ['xyz', '456'])).toBe('');\n  });\n\n  test('empty queries', () => {\n    expect(textSearch('', [])).toBe('');\n    expect(textSearch('The quick brown fox jumps over the lazy dog', [])).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', ['']),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n  });\n\n  test('no matching queries', () => {\n    expect(textSearch('The quick brown fox jumps over the lazy dog', [])).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', ['aaa']),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', ['abc']),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n  });\n\n  describe('matching queries', () => {\n    test('case-insensitive match', () => {\n      expect(\n        textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', ['fox']),\n      ).toBe('The Quick Brown <b>Fox</b> Jumps Over The Lazy Dog');\n      expect(\n        textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', [\n          'fox',\n          'quick',\n        ]),\n      ).toBe('The <b>Quick</b> Brown <b>Fox</b> Jumps Over The Lazy Dog');\n      expect(\n        textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', ['QUICK']),\n      ).toBe('The <b>Quick</b> Brown Fox Jumps Over The Lazy Dog');\n    });\n\n    test('single whole queries', () => {\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', ['quick']),\n      ).toBe('The <b>quick</b> brown fox jumps over the lazy dog');\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', [\n          'jumps',\n          'quick',\n        ]),\n      ).toBe('The <b>quick</b> brown fox <b>jumps</b> over the lazy dog');\n    });\n\n    test('single partial queries', () => {\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', ['jump']),\n      ).toBe('The quick brown fox <b>jump</b>s over the lazy dog');\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', [\n          'jump',\n          'he',\n          'own',\n        ]),\n      ).toBe(\n        'T<b>he</b> quick br<b>own</b> fox <b>jump</b>s over t<b>he</b> lazy dog',\n      );\n    });\n\n    test('consecutive matches have combined tags', () => {\n      expect(textSearch('aabbcc', ['a'])).toBe('<b>aa</b>bbcc');\n      expect(textSearch('aabbbbcc', ['bb'])).toBe('aa<b>bbbb</b>cc');\n      expect(textSearch('aabbcc', ['aa', 'bb'])).toBe('<b>aabb</b>cc');\n      expect(textSearch('This is Uncopyrightable!', ['copy', 'right'])).toBe(\n        'This is Un<b>copyright</b>able!',\n      );\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', [\n          'jumps ',\n          ' over',\n        ]),\n      ).toBe('The quick brown fox <b>jumps over</b> the lazy dog');\n    });\n\n    describe('complex queries', () => {\n      test('characters do not match the same word more than once', () => {\n        expect(textSearch('aaabbcc', ['aa'])).toBe('<b>aa</b>abbcc');\n      });\n\n      test('overlapping queries', () => {\n        expect(textSearch('aaabbcc', ['aaa', 'aab'])).toBe('<b>aaab</b>bcc');\n        expect(textSearch('aaabbcc', ['aa', 'ab'])).toBe('<b>aaab</b>bcc');\n        expect(textSearch('I am a rexpert', ['rex', 'expert'])).toBe(\n          'I am a <b>rexpert</b>',\n        );\n      });\n\n      test('query within another query', () => {\n        expect(textSearch('This lock is Unlockable', ['lock', 'unlock'])).toBe(\n          'This <b>lock</b> is <b>Unlock</b>able',\n        );\n      });\n    });\n\n    test('integration', () => {\n      expect(\n        textSearch('This is Uncopyrightable!', ['COPY', 'right', 'tAbLe']),\n      ).toBe('This is Un<b>copyrightable</b>!');\n    });\n  });\n});\n",
    "/src/text-search-ii.ts": "export default function textSearch(\n  text: string,\n  queries: Array<string>,\n): string {\n  if (text.trim() === '') {\n    return text;\n  }\n\n  const boldChars = Array.from({ length: text.length }, () => 0);\n\n  for (const query of queries) {\n    if (query.trim() === '') continue;\n    for (let i = 0; i < text.length; ) {\n      const substr = text.slice(i, i + query.length);\n      if (substr.toLowerCase() === query.toLowerCase()) {\n        boldChars.fill(1, i, i + query.length);\n        // Start from next character if there's a match since one\n        // character cannot match the same query more than once.\n        i = i + query.length;\n      } else {\n        i++;\n      }\n    }\n  }\n\n  let highlightedString = '';\n  for (let i = 0; i < text.length; i++) {\n    // When the current character should be bolded\n    // and the previous character should not be bolded,\n    // append an opening tag to the final string.\n    const shouldAddOpeningTag = boldChars[i] === 1 && boldChars[i - 1] !== 1;\n    // When the current character should be bolded\n    // and the next character should not be bolded,\n    // append a closing tag to the final string.\n    const shouldAddClosingTag = boldChars[i] === 1 && boldChars[i + 1] !== 1;\n    let char = text[i];\n\n    if (shouldAddOpeningTag) {\n      char = '<b>' + char;\n    }\n\n    if (shouldAddClosingTag) {\n      char = char + '</b>';\n    }\n    highlightedString += char;\n  }\n\n  return highlightedString;\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {string} text\n * @param {Array<string>} queries\n * @return {string}\n */\nexport default function textSearch(text, queries) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function textSearch(\n  text: string,\n  queries: Array<string>,\n): string {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/text-search-ii.ts",
    "run": "/src/text-search-ii.run.test.ts",
    "submit": "/src/text-search-ii.submit.test.ts"
  }
}