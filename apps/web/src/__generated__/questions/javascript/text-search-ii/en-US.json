{
  "description": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var u=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),x=(a,e)=>{for(var r in e)i(a,r,{get:e[r],enumerable:!0})},s=(a,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of g(e))!m.call(a,t)&&t!==r&&i(a,t,{get:()=>e[t],enumerable:!(c=p(e,t))||c.enumerable});return a};var w=(a,e,r)=>(r=a!=null?d(b(a)):{},s(e||!a||!a.__esModule?i(r,\"default\",{value:a,enumerable:!0}):r,a)),f=a=>s(i({},\"__esModule\",{value:!0}),a);var o=u((S,h)=>{h.exports=_jsx_runtime});var v={};x(v,{default:()=>j,frontmatter:()=>y});var n=w(o()),y={title:\"Text Search II\",excerpt:\"Implement a function to highlight text if searched terms appear within it\"};function l(a){let e=Object.assign({p:\"p\",strong:\"strong\",code:\"code\",h2:\"h2\",pre:\"pre\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"In browsers, we are able to find specific words or phrases within a webpage by using \",(0,n.jsx)(\"kbd\",{children:\"Ctrl\"}),\" + \",(0,n.jsx)(\"kbd\",{children:\"F\"}),\" (Windows, Linux) or \",(0,n.jsx)(\"kbd\",{children:\"\\u2318\"}),\" + \",(0,n.jsx)(\"kbd\",{children:\"F\"}),\" (Mac) and entering the search term. Matches which appear will be highlighted in yellow.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's implement a simple version of a browser's in-webpage search with the difference being we're given a string (as opposed to HTML) and search matches appear \",(0,n.jsx)(e.strong,{children:\"bolded\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Given a string and an array of queries, implement a function \",(0,n.jsx)(e.code,{children:\"textSearch\"}),\" that finds all case-insensitive matches from the \",(0,n.jsx)(e.code,{children:\"queries\"}),\" array within the string, wrapping the matches in \",(0,n.jsx)(e.code,{children:\"<b>...</b>\"}),\" tags.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', ['fox']);\n// 'The Quick Brown <b>Fox</b> Jumps Over The Lazy Dog'\ntextSearch('The quick brown fox jumps over the lazy dog', ['fox', 'dog']);\n// 'The quick brown <b>fox</b> jumps over the lazy <b>dog</b>'\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"If two such queries overlap or are consecutive, they should be wrapped in a single pair of \",(0,n.jsx)(e.code,{children:\"<b>\"}),\" tags.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`textSearch('This is Uncopyrightable!', ['copy', 'right']);\n// 'This is Un<b>copyright</b>able!'\ntextSearch('This is Uncopyrightable!', ['copy', 'right', 'table']);\n// 'This is Un<b>copyrightable</b>!'\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"A character will not match the same query more than once, with earlier letters taking priority.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`textSearch('aaa', ['aa']);\n// '<b>aa</b>a'\n// This is because the second character cannot be used as a match again.\ntextSearch('aaaa', ['aa']);\n// '<b>aaaa</b>'\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"You can assume there are no duplicate strings in the \",(0,n.jsx)(e.code,{children:\"queries\"}),\" array.\"]})]})}function T(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(l,a)})):l(a)}var j=T;return f(v);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/text-search-ii\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/text-search-ii.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/text-search-ii.run.test.ts": "import textSearch from './text-search-ii';\n\ndescribe('textSearch', () => {\n  test('empty string', () => {\n    expect(textSearch('', [])).toBe('');\n  });\n\n  test('no matching queries', () => {\n    expect(textSearch('The quick brown fox jumps over the lazy dog', [])).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n  });\n\n  test('single query match', () => {\n    expect(\n      textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', ['fox']),\n    ).toBe('The Quick Brown <b>Fox</b> Jumps Over The Lazy Dog');\n  });\n\n  test('consecutive matches have combined tags', () => {\n    expect(textSearch('aabbcc', ['a'])).toBe('<b>aa</b>bbcc');\n  });\n});\n",
    "/src/text-search-ii.submit.test.ts": "import textSearch from './text-search-ii';\n\ndescribe('textSearch', () => {\n  test('empty string', () => {\n    expect(textSearch('', [])).toBe('');\n    expect(textSearch('', [''])).toBe('');\n    expect(textSearch('', ['xyz'])).toBe('');\n    expect(textSearch('', ['xyz', '456'])).toBe('');\n  });\n\n  test('empty queries', () => {\n    expect(textSearch('', [])).toBe('');\n    expect(textSearch('The quick brown fox jumps over the lazy dog', [])).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', ['']),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n  });\n\n  test('no matching queries', () => {\n    expect(textSearch('The quick brown fox jumps over the lazy dog', [])).toBe(\n      'The quick brown fox jumps over the lazy dog',\n    );\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', ['aaa']),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n    expect(\n      textSearch('The quick brown fox jumps over the lazy dog', ['abc']),\n    ).toBe('The quick brown fox jumps over the lazy dog');\n  });\n\n  describe('matching queries', () => {\n    test('case-insensitive match', () => {\n      expect(\n        textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', ['fox']),\n      ).toBe('The Quick Brown <b>Fox</b> Jumps Over The Lazy Dog');\n      expect(\n        textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', [\n          'fox',\n          'quick',\n        ]),\n      ).toBe('The <b>Quick</b> Brown <b>Fox</b> Jumps Over The Lazy Dog');\n      expect(\n        textSearch('The Quick Brown Fox Jumps Over The Lazy Dog', ['QUICK']),\n      ).toBe('The <b>Quick</b> Brown Fox Jumps Over The Lazy Dog');\n    });\n\n    test('single whole queries', () => {\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', ['quick']),\n      ).toBe('The <b>quick</b> brown fox jumps over the lazy dog');\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', [\n          'jumps',\n          'quick',\n        ]),\n      ).toBe('The <b>quick</b> brown fox <b>jumps</b> over the lazy dog');\n    });\n\n    test('single partial queries', () => {\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', ['jump']),\n      ).toBe('The quick brown fox <b>jump</b>s over the lazy dog');\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', [\n          'jump',\n          'he',\n          'own',\n        ]),\n      ).toBe(\n        'T<b>he</b> quick br<b>own</b> fox <b>jump</b>s over t<b>he</b> lazy dog',\n      );\n    });\n\n    test('consecutive matches have combined tags', () => {\n      expect(textSearch('aabbcc', ['a'])).toBe('<b>aa</b>bbcc');\n      expect(textSearch('aabbbbcc', ['bb'])).toBe('aa<b>bbbb</b>cc');\n      expect(textSearch('aabbcc', ['aa', 'bb'])).toBe('<b>aabb</b>cc');\n      expect(textSearch('This is Uncopyrightable!', ['copy', 'right'])).toBe(\n        'This is Un<b>copyright</b>able!',\n      );\n      expect(\n        textSearch('The quick brown fox jumps over the lazy dog', [\n          'jumps ',\n          ' over',\n        ]),\n      ).toBe('The quick brown fox <b>jumps over</b> the lazy dog');\n    });\n\n    describe('complex queries', () => {\n      test('characters do not match the same word more than once', () => {\n        expect(textSearch('aaabbcc', ['aa'])).toBe('<b>aa</b>abbcc');\n      });\n\n      test('overlapping queries', () => {\n        expect(textSearch('aaabbcc', ['aaa', 'aab'])).toBe('<b>aaab</b>bcc');\n        expect(textSearch('aaabbcc', ['aa', 'ab'])).toBe('<b>aaab</b>bcc');\n        expect(textSearch('I am a rexpert', ['rex', 'expert'])).toBe(\n          'I am a <b>rexpert</b>',\n        );\n      });\n\n      test('query within another query', () => {\n        expect(textSearch('This lock is Unlockable', ['lock', 'unlock'])).toBe(\n          'This <b>lock</b> is <b>Unlock</b>able',\n        );\n      });\n    });\n\n    test('integration', () => {\n      expect(\n        textSearch('This is Uncopyrightable!', ['COPY', 'right', 'tAbLe']),\n      ).toBe('This is Un<b>copyrightable</b>!');\n    });\n  });\n});\n",
    "/src/text-search-ii.ts": "export default function textSearch(\n  text: string,\n  queries: Array<string>,\n): string {\n  if (text.trim() === '') {\n    return text;\n  }\n\n  const boldChars = Array.from({ length: text.length }, () => 0);\n\n  for (const query of queries) {\n    if (query.trim() === '') continue;\n    for (let i = 0; i < text.length; ) {\n      const substr = text.slice(i, i + query.length);\n      if (substr.toLowerCase() === query.toLowerCase()) {\n        boldChars.fill(1, i, i + query.length);\n        // Start from next character if there's a match since one\n        // character cannot match the same query more than once.\n        i = i + query.length;\n      } else {\n        i++;\n      }\n    }\n  }\n\n  let highlightedString = '';\n  for (let i = 0; i < text.length; i++) {\n    // When the current character should be bolded\n    // and the previous character should not be bolded,\n    // append an opening tag to the final string.\n    const shouldAddOpeningTag = boldChars[i] === 1 && boldChars[i - 1] !== 1;\n    // When the current character should be bolded\n    // and the next character should not be bolded,\n    // append a closing tag to the final string.\n    const shouldAddClosingTag = boldChars[i] === 1 && boldChars[i + 1] !== 1;\n    let char = text[i];\n\n    if (shouldAddOpeningTag) {\n      char = '<b>' + char;\n    }\n\n    if (shouldAddClosingTag) {\n      char = char + '</b>';\n    }\n    highlightedString += char;\n  }\n\n  return highlightedString;\n}\n"
  },
  "metadata": {
    "access": "premium",
    "author": "zhenghao",
    "companies": [],
    "created": 1656288000,
    "difficulty": "medium",
    "duration": 25,
    "excerpt": "Implement a function to highlight text if searched terms appear within it",
    "featured": false,
    "format": "javascript",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/javascript/text-search-ii",
    "importance": "low",
    "languages": [
      "html",
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "text-search"
    ],
    "slug": "text-search-ii",
    "subtitle": null,
    "title": "Text Search II",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {string} text\n * @param {Array<string>} queries\n * @return {string}\n */\nexport default function textSearch(text, queries) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function textSearch(\n  text: string,\n  queries: Array<string>,\n): string {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var b=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var x=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),w=(r,e)=>{for(var n in e)i(r,n,{get:e[n],enumerable:!0})},o=(r,e,n,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!y.call(r,a)&&a!==n&&i(r,a,{get:()=>e[a],enumerable:!(h=f(e,a))||h.enumerable});return r};var q=(r,e,n)=>(n=r!=null?b(m(r)):{},o(e||!r||!r.__esModule?i(n,\"default\",{value:r,enumerable:!0}):n,r)),C=r=>o(i({},\"__esModule\",{value:!0}),r);var s=x((O,c)=>{c.exports=_jsx_runtime});var k={};w(k,{default:()=>A});var t=q(s());var l=MDXCodeBlock;var d=`/**\n * @param {string} text\n * @param {Array<string>} queries\n * @return {string}\n */\nexport default function textSearch(text, queries) {\n  if (text.trim() === '') {\n    return text;\n  }\n\n  const boldChars = Array.from({ length: text.length }, () => 0);\n\n  for (const query of queries) {\n    if (query.trim() === '') continue;\n    for (let i = 0; i < text.length; ) {\n      const substr = text.slice(i, i + query.length);\n      if (substr.toLowerCase() === query.toLowerCase()) {\n        boldChars.fill(1, i, i + query.length);\n        // Start from next character if there's a match since one\n        // character cannot match the same query more than once.\n        i = i + query.length;\n      } else {\n        i++;\n      }\n    }\n  }\n\n  let highlightedString = '';\n  for (let i = 0; i < text.length; i++) {\n    // When the current character should be bolded\n    // and the previous character should not be bolded,\n    // append an opening tag to the final string.\n    const shouldAddOpeningTag = boldChars[i] === 1 && boldChars[i - 1] !== 1;\n    // When the current character should be bolded\n    // and the next character should not be bolded,\n    // append a closing tag to the final string.\n    const shouldAddClosingTag = boldChars[i] === 1 && boldChars[i + 1] !== 1;\n    let char = text[i];\n\n    if (shouldAddOpeningTag) {\n      char = '<b>' + char;\n    }\n\n    if (shouldAddClosingTag) {\n      char = char + '</b>';\n    }\n    highlightedString += char;\n  }\n\n  return highlightedString;\n}\n`;var u=`export default function textSearch(\n  text: string,\n  queries: Array<string>,\n): string {\n  if (text.trim() === '') {\n    return text;\n  }\n\n  const boldChars = Array.from({ length: text.length }, () => 0);\n\n  for (const query of queries) {\n    if (query.trim() === '') continue;\n    for (let i = 0; i < text.length; ) {\n      const substr = text.slice(i, i + query.length);\n      if (substr.toLowerCase() === query.toLowerCase()) {\n        boldChars.fill(1, i, i + query.length);\n        // Start from next character if there's a match since one\n        // character cannot match the same query more than once.\n        i = i + query.length;\n      } else {\n        i++;\n      }\n    }\n  }\n\n  let highlightedString = '';\n  for (let i = 0; i < text.length; i++) {\n    // When the current character should be bolded\n    // and the previous character should not be bolded,\n    // append an opening tag to the final string.\n    const shouldAddOpeningTag = boldChars[i] === 1 && boldChars[i - 1] !== 1;\n    // When the current character should be bolded\n    // and the next character should not be bolded,\n    // append a closing tag to the final string.\n    const shouldAddClosingTag = boldChars[i] === 1 && boldChars[i + 1] !== 1;\n    let char = text[i];\n\n    if (shouldAddOpeningTag) {\n      char = '<b>' + char;\n    }\n\n    if (shouldAddClosingTag) {\n      char = char + '</b>';\n    }\n    highlightedString += char;\n  }\n\n  return highlightedString;\n}\n`;function g(r){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",pre:\"pre\",h3:\"h3\",a:\"a\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"This question evaluates one's ability to manipulate arrays and strings in JavaScript, which is certainly an essential skill for Front End development.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,t.jsx)(e.p,{children:\"Your interviewer might not necessarily spell out all the requirements for you upfront. Ideally you start by thinking about all the possible situations and edge cases.\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"What if the \",(0,t.jsx)(e.code,{children:\"queries\"}),\" array is an empty array? Or the input string \",(0,t.jsx)(e.code,{children:\"text\"}),\" is an empty string?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Return the string as-is.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"What if any \",(0,t.jsx)(e.code,{children:\"query\"}),\" inside the \",(0,t.jsx)(e.code,{children:\"queries\"}),\" array is an empty string?\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Skip that query.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"One might think of leveraging regular expressions (regex), via \",(0,t.jsx)(e.code,{children:\"RegExp\"}),\". Regex is very hard to use here but because the characters within the string can match multiple queries. There are ways to get around that but it's non-trivial.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"One idea is to process one query at a time, adding the \",(0,t.jsx)(e.code,{children:\"<b>\"}),\" tag for the current query, but this will ruin the string for subsequent queries. Imagine this scenario:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`textSearch('aaabc', ['aaa', 'abc']);\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"After processing \",(0,t.jsx)(e.code,{children:\"'aaa'\"}),\", the string is now \",(0,t.jsx)(e.code,{children:\"<b>aaa</b>bc\"}),\", which won't match \",(0,t.jsx)(e.code,{children:\"'abc'\"}),\". Hence this approach is not feasible too.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Working backwards\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Let's try to think backwards from the desired output: we want to output a string with the substrings that exist in the \",(0,t.jsx)(e.code,{children:\"queries\"}),\" array wrapped in \",(0,t.jsx)(e.code,{children:\"<b>\"}),\" tags. Therefore we need to know where exactly to insert the opening \",(0,t.jsx)(e.code,{children:\"<b>\"}),\" tags and closing \",(0,t.jsx)(e.code,{children:\"</b>\"}),\" tags. We can create a boolean array of same length as the \",(0,t.jsx)(e.code,{children:\"text\"}),\" with every value defaulting to \",(0,t.jsx)(e.code,{children:\"false\"}),\". The value of \",(0,t.jsx)(e.code,{children:\"boldChars[index]\"}),\" indicates whether the character at that index in the original string needs to be bold.\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`// #1: Basic case.\n// text: \"aaabcaa\", queries: ['abc']\n// boldChars: [false, false, true, true, true, false, false]\n// result: \"aa<b>abc</b>aa\"\n\n// #2: Non-overlapping case.\n// text: \"aaabcaabc\", queries: ['abc']\n// boldChars: [false, false, true, true, true, false, true, true, true]\n// result: \"aa<b>abc</b>a<b>abc</b>\"\n\n// #3: Overlapping case.\n// text: \"baabcaa\", queries: ['abc', 'aa']\n// boldChars: [false, true, true, true, true, true true]\n// result: \"a<b>aabcaa</b>\"\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"The beginning of a span of consecutive chunks of \",(0,t.jsx)(e.code,{children:\"true\"}),\" is where we insert the opening tag \",(0,t.jsx)(e.code,{children:\"<b>\"}),\" and the end is where we add a closing \",(0,t.jsx)(e.code,{children:\"</b>\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To identify which characters need to be bold, we do a naive substring match at each character in \",(0,t.jsx)(e.code,{children:\"text\"}),\" for each query. Flipping the boolean value at each matching character's index to \",(0,t.jsx)(e.code,{children:\"true\"}),'. However, because of the \"one character can only match the same query once\" condition, we have to increment ',(0,t.jsx)(e.code,{children:\"i\"}),\" to go past the current query when there's a match.\"]}),`\n`,(0,t.jsx)(l,{languages:{jsx:d,tsx:u}}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"We use \",(0,t.jsx)(e.code,{children:\"Array.prototype.fill()\"}),\" to mutate the boolean array conveniently when we find a substring match. The method \",(0,t.jsx)(e.code,{children:\"fill\"}),\" is one of the few methods that mutate arrays. As of writing, there are 9 methods in total that mutates arrays: \",(0,t.jsx)(e.code,{children:\"pop\"}),\", \",(0,t.jsx)(e.code,{children:\"push\"}),\", \",(0,t.jsx)(e.code,{children:\"reverse\"}),\", \",(0,t.jsx)(e.code,{children:\"shift\"}),\", \",(0,t.jsx)(e.code,{children:\"sort\"}),\", \",(0,t.jsx)(e.code,{children:\"splice\"}),\", \",(0,t.jsx)(e.code,{children:\"unshift\"}),\", \",(0,t.jsx)(e.code,{children:\"copyWithin\"}),\" and \",(0,t.jsx)(e.code,{children:\"fill\"}),\". Check out \",(0,t.jsx)(e.a,{href:\"https://doesitmutate.xyz\",children:\"Does it mutate\"}),\" where there is a nice list of mutating array methods with more details.\"]}),`\n`]})]})}function T(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(g,r)})):g(r)}var A=T;return C(k);})();\n;return Component;",
  "workspace": {
    "main": "/src/text-search-ii.ts",
    "run": "/src/text-search-ii.run.test.ts",
    "submit": "/src/text-search-ii.submit.test.ts"
  }
}