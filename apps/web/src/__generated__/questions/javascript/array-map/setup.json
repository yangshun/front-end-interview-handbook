{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/array-map\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/array-map.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/array-map.run.test.ts": "import './array-map';\n\nconst identity = <T>(element: T) => element;\nconst square = (element: number) => element * element;\n\ndescribe('Array.prototype.myMap', () => {\n  test('identity', () => {\n    expect([10].myMap(identity)).toEqual([10]);\n    expect([10, 20].myMap(identity)).toEqual([10, 20]);\n  });\n\n  test('square', () => {\n    expect([-4].myMap(square)).toEqual([16]);\n    expect([5].myMap(square)).toEqual([25]);\n  });\n});\n",
    "/src/array-map.submit.test.ts": "import './array-map';\n\nconst identity = <T>(element: T) => element;\nconst square = (element: any) => element * element;\nconst multiplyByIndex = (element: number, index: number) => element * index;\nconst squareAlt = (element: number, index: number, array: Array<number>) =>\n  element * array[index];\nconst usesThis = function (this: any, element: number) {\n  return element * this;\n};\nconst usesThisArrowFn = (element: number) => element * this!;\n\ndescribe('Array.prototype.myMap', () => {\n  test('empty array', () => {\n    expect([].myMap(identity)).toEqual([]);\n    expect([].myMap(square)).toEqual([]);\n  });\n\n  test('one value', () => {\n    expect([10].myMap(identity)).toEqual([10]);\n    expect([10].myMap(square)).toEqual([100]);\n  });\n\n  test('two values', () => {\n    expect([-4, 10].myMap(identity)).toEqual([-4, 10]);\n    expect([-4, 10].myMap(square)).toEqual([16, 100]);\n  });\n\n  test('multiple values', () => {\n    expect([1, 2, 3, 4].myMap(identity)).toEqual([1, 2, 3, 4]);\n    expect([1, 2, 3, 4, 5].myMap(square)).toEqual([1, 4, 9, 16, 25]);\n  });\n\n  test('reducer uses index argument when provided', () => {\n    expect([1, 2, 3].myMap(multiplyByIndex)).toEqual([0, 2, 6]);\n    expect([-1, -3, 4].myMap(multiplyByIndex)).toEqual([-0, -3, 8]);\n  });\n\n  test('reducer uses array argument when provided', () => {\n    expect([1, 2, 3, 4].myMap(squareAlt)).toEqual([1, 4, 9, 16]);\n    expect([-1, -3, 4].myMap(squareAlt)).toEqual([1, 9, 16]);\n  });\n\n  test('uses this argument', () => {\n    expect([1, 2, 3, 4].myMap(usesThis)).toEqual([NaN, NaN, NaN, NaN]);\n    expect([1, 2, 3, 4].myMap(usesThis, 10)).toEqual([10, 20, 30, 40]);\n    expect([1, 2, 3, 4].myMap(usesThisArrowFn)).toEqual([NaN, NaN, NaN, NaN]);\n    expect([1, 2, 3, 4].myMap(usesThisArrowFn, 10)).toEqual([\n      NaN,\n      NaN,\n      NaN,\n      NaN,\n    ]);\n  });\n\n  test('sparse arrays', () => {\n    // eslint-disable-next-line no-sparse-arrays\n    expect([1, 2, , 4].myMap(identity)).toEqual([1, 2, , 4]);\n    // eslint-disable-next-line no-sparse-arrays\n    expect([1, 2, , 4].myMap(square)).toEqual([1, 4, , 16]);\n  });\n\n  test('arrays with undefined values', () => {\n    expect([1, 2, undefined, 4].myMap(identity)).toEqual([1, 2, undefined, 4]);\n    expect([1, 2, undefined, 4].myMap(square)).toEqual([1, 4, NaN, 16]);\n  });\n});\n",
    "/src/array-map.ts": "interface Array<T> {\n  myMap<U>(\n    callbackFn: (value: T, index: number, array: Array<T>) => U,\n    thisArg?: any,\n  ): Array<U>;\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  const len = this.length;\n  const array = new Array(len);\n\n  for (let k = 0; k < len; k++) {\n    // Ignore index if value is not defined for index (e.g. in sparse arrays).\n    if (Object.hasOwn(this, k)) {\n      array[k] = callbackFn.call(thisArg, this[k], k, this);\n    }\n  }\n\n  return array;\n};\n"
  },
  "skeleton": {
    "js": "/**\n * @template T, U\n * @param { (value: T, index: number, array: Array<T>) => U } callbackFn\n * @param {any} [thisArg]\n * @return {Array<U>}\n */\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};",
    "ts": "interface Array<T> {\n  myMap<U>(\n    callbackFn: (value: T, index: number, array: Array<T>) => U,\n    thisArg?: any,\n  ): Array<U>;\n}\n\nArray.prototype.myMap = function (callbackFn, thisArg) {\n  throw 'Not implemented!';\n};"
  },
  "workspace": {
    "main": "/src/array-map.ts",
    "run": "/src/array-map.run.test.ts",
    "submit": "/src/array-map.submit.test.ts"
  }
}