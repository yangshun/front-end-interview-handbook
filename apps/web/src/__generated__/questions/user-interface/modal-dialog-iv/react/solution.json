{
  "author": "yangshun",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/modal-dialog-iv-react-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.0\",\n    \"@types/react-dom\": \"18.2.0\",\n    \"typescript\": \"5.0.2\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.tsx": {
      "code": "import { useState } from 'react';\nimport ModalDialog from './ModalDialog';\n\nexport default function App() {\n  const [open, setOpen] = useState(false);\n\n  return (\n    <div>\n      <button onClick={() => setOpen(true)}>\n        Show modal\n      </button>\n      <ModalDialog\n        open={open}\n        title=\"Feedback\"\n        onClose={() => {\n          setOpen(false);\n        }}>\n        <div className=\"contents\">\n          <div>\n            Provide your feedback, we will get back in 3-5\n            business days.\n          </div>\n          <input placeholder=\"john@gmail.com\" />\n          <textarea\n            placeholder=\"Your message here\"\n            rows={5}></textarea>\n          <button type=\"button\">Submit</button>\n        </div>\n      </ModalDialog>\n    </div>\n  );\n}\n"
    },
    "/src/index.tsx": {
      "code": "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root')!);\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/ModalDialog.tsx": {
      "code": "import {\n  ComponentProps,\n  RefObject,\n  useEffect,\n  useId,\n  useRef,\n} from 'react';\nimport { createPortal } from 'react-dom';\n\nexport default function ModalDialog({\n  open = false,\n  ...props\n}: Readonly<{\n  open?: boolean;\n}> &\n  ComponentProps<typeof ModalDialogImpl>) {\n  if (!open) {\n    return null;\n  }\n\n  return <ModalDialogImpl {...props} />;\n}\n\n/**\n * Invokes a function when a key is pressed.\n */\nfunction useOnKeyDown(\n  key: string,\n  fn: (event: KeyboardEvent) => void,\n) {\n  useEffect(() => {\n    function onKeyDown(event: KeyboardEvent) {\n      if (event.key === key) {\n        fn(event);\n      }\n    }\n\n    document.addEventListener('keydown', onKeyDown);\n\n    return () => {\n      document.removeEventListener('keydown', onKeyDown);\n    };\n  }, [fn]);\n}\n\n/**\n * Invokes a function when clicking outside an element.\n */\nfunction useOnClickOutside(\n  elRef: RefObject<HTMLDivElement>,\n  fn: () => void,\n) {\n  // Add event handling for close when clicking outside.\n  useEffect(() => {\n    function onClickOutside(\n      event: MouseEvent | TouchEvent,\n    ) {\n      // No-op if clicked element is a descendant of element's contents.\n      if (\n        event.target instanceof Node &&\n        elRef.current != null &&\n        !elRef.current?.contains(event.target)\n      ) {\n        fn();\n      }\n    }\n\n    document.addEventListener('mousedown', onClickOutside);\n    document.addEventListener('touchstart', onClickOutside);\n\n    return () => {\n      document.removeEventListener(\n        'mousedown',\n        onClickOutside,\n      );\n      document.removeEventListener(\n        'touchstart',\n        onClickOutside,\n      );\n    };\n  }, [fn]);\n}\n\nfunction getTabbableElements(\n  elRef: RefObject<HTMLDivElement>,\n) {\n  if (elRef.current == null) {\n    return [];\n  }\n\n  return elRef.current.querySelectorAll(\n    'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])',\n  );\n}\n\n/**\n * Focus on the first tabbable element on mount.\n */\nfunction useFocusOnFirstTabbableElement(\n  elRef: RefObject<HTMLDivElement>,\n) {\n  useEffect(() => {\n    const tabbableElements = getTabbableElements(elRef);\n    const firstElement = tabbableElements[0];\n    if (firstElement instanceof HTMLElement) {\n      firstElement.focus();\n    }\n  }, []);\n}\n\n/**\n * Trap focus within an element.\n */\nfunction useFocusTrap(elRef: RefObject<HTMLDivElement>) {\n  function trapFocus(event: KeyboardEvent) {\n    if (elRef.current == null) {\n      return;\n    }\n\n    const tabbableElements = getTabbableElements(elRef);\n    const firstElement = tabbableElements[0];\n    const lastElement =\n      tabbableElements[tabbableElements.length - 1];\n\n    if (event.shiftKey) {\n      // Shift + Tab event\n      if (\n        document.activeElement === firstElement &&\n        lastElement instanceof HTMLElement\n      ) {\n        event.preventDefault();\n        lastElement.focus();\n      }\n    } else {\n      // Tab event\n      if (\n        document.activeElement === lastElement &&\n        firstElement instanceof HTMLElement\n      ) {\n        event.preventDefault();\n        firstElement.focus();\n      }\n    }\n  }\n\n  useOnKeyDown('Tab', trapFocus);\n}\n\n/**\n * Retain reference to trigger element and focus that element when closed.\n */\nfunction useReturnFocusToTrigger() {\n  const triggerElRef = useRef<Element | null>(null);\n\n  useEffect(() => {\n    // Save a reference to the focused element when mounted.\n    triggerElRef.current = document.activeElement;\n\n    return () => {\n      if (triggerElRef.current instanceof HTMLElement) {\n        // Focuses on element when unmounted.\n        triggerElRef.current.focus();\n      }\n    };\n  }, []);\n}\n\nfunction ModalDialogImpl({\n  children,\n  title,\n  onClose,\n}: Readonly<{\n  children: React.ReactNode;\n  title: string;\n  onClose: () => void;\n}>) {\n  const titleId = useId();\n  const contentId = useId();\n  const dialogRef = useRef<HTMLDivElement>(null);\n\n  // Closing-related hooks.\n  useOnKeyDown('Escape', onClose);\n  useOnClickOutside(dialogRef, onClose);\n\n  // Focus-related hooks.\n  useReturnFocusToTrigger(); // Has to be called before useFocusOnFirstTabbableElement otherwise the focus is lost.\n  useFocusOnFirstTabbableElement(dialogRef);\n  useFocusTrap(dialogRef);\n\n  return createPortal(\n    <div className=\"modal-overlay\">\n      <div\n        aria-describedby={contentId}\n        aria-labelledby={titleId}\n        className=\"modal\"\n        role=\"dialog\"\n        ref={dialogRef}>\n        <h1 className=\"modal-title\" id={titleId}>\n          {title}\n        </h1>\n        <div id={contentId}>{children}</div>\n        <button onClick={onClose}>Close</button>\n      </div>\n    </div>,\n    document.body,\n  );\n}\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\ninput,\ntextarea {\n  display: block;\n  font-family: sans-serif;\n  padding: 8px;\n}\n\n*:focus {\n  outline: 2px solid red;\n  outline-offset: 1px;\n}\n\n.modal-overlay {\n  background-color: rgba(0, 0, 0, 0.7);\n  inset: 0;\n  position: fixed;\n\n  align-items: center;\n  display: flex;\n  justify-content: center;\n\n  padding: 20px;\n}\n\n.modal {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  align-items: center;\n  gap: 16px;\n\n  background-color: white;\n  padding: 24px;\n}\n\n.modal-title {\n  margin: 0;\n}\n\n.contents {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n}\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.tsx",
      "/src/ModalDialog.tsx",
      "/src/styles.css"
    ],
    "activeFile": "/src/ModalDialog.tsx",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var T=Object.create;var d=Object.defineProperty;var _=Object.getOwnPropertyDescriptor;var D=Object.getOwnPropertyNames;var F=Object.getPrototypeOf,M=Object.prototype.hasOwnProperty;var A=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),I=(t,e)=>{for(var r in e)d(t,r,{get:e[r],enumerable:!0})},u=(t,e,r,m)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let h of D(e))!M.call(t,h)&&h!==r&&d(t,h,{get:()=>e[h],enumerable:!(m=_(e,h))||m.enumerable});return t};var c=(t,e,r)=>(r=t!=null?T(F(t)):{},u(e||!t||!t.__esModule?d(r,\"default\",{value:t,enumerable:!0}):r,t)),C=t=>u(d({},\"__esModule\",{value:!0}),t);var s=A((L,b)=>{b.exports=_jsx_runtime});var S={};I(S,{default:()=>q});var a=c(s());var n=c(s());function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",ol:\"ol\",li:\"li\",h3:\"h3\",pre:\"pre\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We'll build on top of \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/modal-dialog-iii/solution\",children:\"Modal Dialog III's solution\"}),\". Like in Modal Dialog III, only interactions need to be added; the styling and structure can remain the same.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The following behaviors need to be implemented:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Upon dialog open, focus on the first tabbable element\"}),`\n`,(0,n.jsx)(e.li,{children:\"Focus trapping \\u2013 the focus is trapped within the dialog and cannot escape the dialog\"}),`\n`,(0,n.jsx)(e.li,{children:\"Upon dialog close, focus returns to the element that invoked the dialog\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"1. Upon dialog open, focus on the first tabbable element\"}),`\n`,(0,n.jsx)(e.p,{children:\"This functionality is quite straightforward to implement. Upon mounting of the component, query all the elements and focus on the first tabbable element. The tabbable elements within the dialog can be selected with the following selector:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`dialogEl.querySelectorAll(\n  'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])',\n);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is implemented as the \",(0,n.jsx)(e.code,{children:\"useFocusOnFirstTabbableElement\"}),\" hook.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"2. Focus trapping\"}),`\n`,(0,n.jsx)(e.p,{children:\"Focus trapping is a technique used to control and manage keyboard focus within a specific area or component of a webpage or application (e.g. modal dialogs, dropdown menus).\"}),`\n`,(0,n.jsx)(e.p,{children:\"Practically, the following behavior is implemented:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"When focus reaches the last element, \",(0,n.jsx)(\"kbd\",{children:\"Tab\"}),\" moves focus to the first tabbable element\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"When focus is on the first element, \",(0,n.jsx)(\"kbd\",{children:\"Shift\"}),\" + \",(0,n.jsx)(\"kbd\",{children:\"Tab\"}),\" moves focus to the last tabbable element\"]}),`\n`,(0,n.jsx)(e.li,{children:\"All interactive elements within the trapped area remain focusable\"}),`\n`,(0,n.jsx)(e.li,{children:\"Elements outside the trapped area are temporarily made unfocusable\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Tabbing between the non-boundary elements can remain as per normal. Only the first and last elements need special handling. We need to hijack the tabbing events on these boundary elements and programmatically focus on the required elements instead of allowing the browser to decide (which relies on DOM order).\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can add a \",(0,n.jsx)(e.code,{children:\"keydown\"}),\" event listener to the dialog and filter for \",(0,n.jsx)(\"kbd\",{children:\"Tab\"}),\" event presses. In the callback:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the currently focused element (via \",(0,n.jsx)(e.code,{children:\"document.activeElement\"}),\") is the last tabbable element and the \",(0,n.jsx)(\"kbd\",{children:\"Tab\"}),\" key is pressed, focus on the first tabbable element instead.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the currently focused element (via \",(0,n.jsx)(e.code,{children:\"document.activeElement\"}),\") is the first tabbable element and the \",(0,n.jsx)(\"kbd\",{children:\"Shift\"}),\" + \",(0,n.jsx)(\"kbd\",{children:\"Tab\"}),\" keys are pressed (by checking the \",(0,n.jsx)(e.code,{children:\"event.shiftKey\"}),\" property), focus on the last tabbable element instead.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To find all the tabbable elements, the same selector as per part 1 can be used. Note that it is advisable to find all the tabbable elements on-demand, during the \",(0,n.jsx)(\"kbd\",{children:\"Tab\"}),\" key event, rather than at the start when the dialog is mounted and retaining a reference to the list. This is because the contents of the dialog can be modified anytime; the list of tabbable elements on mount might not be the same as when the user actually tabs through them.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Before changing the focus programmatically, remember to call \",(0,n.jsx)(e.code,{children:\"event.preventDefault()\"}),\", otherwise the browser will proceed with the default behavior \\u2013 focus on the next element determined by the DOM order.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is implemented as the \",(0,n.jsx)(e.code,{children:\"useFocusTrap\"}),\" hook.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"3. Upon dialog close, focus returns to the element that invoked the dialog\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The currently focused element on the page can be obtained using \",(0,n.jsx)(e.code,{children:\"document.activeElement\"}),\". When the dialog is mounted, save a reference to that element (if it exists). On unmounting, programmatically focus on that element.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is implemented as the \",(0,n.jsx)(e.code,{children:\"useReturnFocusToTrigger\"}),\" hook. An important thing to note is that this hook has to be \",(0,n.jsxs)(e.strong,{children:[\"called before \",(0,n.jsx)(e.code,{children:\"useFocusOnFirstTabbableElement\"})]}),\", otherwise the focus would have been set on the first tabbable element, even before the hook gets a chance to save the reference to the focus trigger.\"]})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var g=O;var i=c(s());function f(t){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test Cases\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Dialog opening\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Verify that focus moves to the first focusable element in the dialog when it opens\"}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure that focus is trapped within the dialog\"}),`\n`,(0,i.jsx)(e.li,{children:\"Check that elements outside the dialog are not focusable\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Focus order\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Confirm that \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" key moves focus through elements in a logical order\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Verify that \",(0,i.jsx)(\"kbd\",{children:\"Shift\"}),\" + \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" reverses the focus order\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure that all interactive elements within the dialog are focusable\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Focus trapping\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Test that focus wraps from the last to the first element when tabbing\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Verify that focus wraps from the first to the last element when using \",(0,i.jsx)(\"kbd\",{children:\"Shift\"}),\" + \",(0,i.jsx)(\"kbd\",{children:\"Tab\"})]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Dialog closing\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Confirm that pressing \",(0,i.jsx)(\"kbd\",{children:\"Esc\"}),\" key closes the dialog\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that clicking outside the dialog closes it\"}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure that focus returns to the element that opened the dialog\"}),`\n`]}),`\n`]}),`\n`]})]})}function E(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(f,t)})):f(t)}var w=E;var o=c(s());function y(t){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",code:\"code\",ul:\"ul\",li:\"li\"},t.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,o.jsxs)(e.p,{children:[\"Congratulations, we have implement almost everything on \",(0,o.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/\",children:\"Dialog (Modal) | ARIA Authoring Practices Guide\"}),\". Do read the page, there are some nuances related to the usage of \",(0,o.jsx)(e.code,{children:\"aria-describedby\"}),\" attribute and automatic focus placements.\"]}),`\n`,(0,o.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/\",children:\"Dialog (Modal) | ARIA Authoring Practices Guide\"})}),`\n`,(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:\"https://www.radix-ui.com/primitives/docs/components/dialog\",children:\"Dialog \\u2013 Radix Primitives\"})}),`\n`,(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:\"https://reach.tech/dialog\",children:\"Dialog | Reach UI\"})}),`\n`,(0,o.jsx)(e.li,{children:(0,o.jsx)(e.a,{href:\"https://headlessui.com/react/dialog\",children:\"Dialog - Headless UI\"})}),`\n`]})]})}function X(t={}){let{wrapper:e}=t.components||{};return e?(0,o.jsx)(e,Object.assign({},t,{children:(0,o.jsx)(y,t)})):y(t)}var v=X;var l=c(s());function x(t){let e=Object.assign({h2:\"h2\",p:\"p\"},t.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.h2,{children:\"Follow up\"}),`\n`,(0,l.jsx)(e.p,{children:\"A possible problematic scenario is having multiple dialogs open at once / stacked because the open dialog's contents allow opening of another dialog.\"}),`\n`,(0,l.jsxs)(e.p,{children:[\"A limitation of our current implementation is surfaced \\u2013 since most of the event listeners are added on the global level, all the open dialogs might respond to a \",(0,l.jsx)(\"kbd\",{children:\"Escape\"}),\" event and close at the same time, when the expected behavior is that only the topmost dialog closes.\"]}),`\n`,(0,l.jsx)(e.p,{children:\"Fixing this will require code to track the stack of open dialogs and only close the topmost dialog. However, implementing this is non-trivial and usually beyond the scope of interviews. That said, mentioning this scenario to the interviewer will probably give you brownie points!\"})]})}function R(t={}){let{wrapper:e}=t.components||{};return e?(0,l.jsx)(e,Object.assign({},t,{children:(0,l.jsx)(x,t)})):x(t)}var k=R;function j(t){return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(g,{}),`\n`,(0,a.jsx)(w,{}),`\n`,(0,a.jsx)(v,{}),`\n`,(0,a.jsx)(k,{})]})}function W(t={}){let{wrapper:e}=t.components||{};return e?(0,a.jsx)(e,Object.assign({},t,{children:(0,a.jsx)(j,t)})):j(t)}var q=W;return C(S);})();\n;return Component;"
}