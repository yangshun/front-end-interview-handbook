{
  "author": "tanhauhau",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/tic-tac-toe-svelte-solution\",\n  \"author\": \"tanhauhau\",\n  \"version\": \"0.0.1\",\n  \"main\": \"src/index.js\",\n  \"dependencies\": {\n    \"svelte\": \"^3.58.0\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Svelte</title>\n    <link rel=\"stylesheet\" href=\"public/bundle.css\" />\n  </head>\n\n  <body>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n"
    },
    "/src/App.svelte": {
      "code": "<script>\n  import Cell from './Cell.svelte';\n  import './styles.css';\n\n  // List of cell indices that are 3-in-a-row.\n  const CELLS_IN_A_LINE = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n\n  // Determine if there's a winner for the board.\n  function determineWinner(board) {\n    for (let i = 0; i < CELLS_IN_A_LINE.length; i++) {\n      const [x, y, z] = CELLS_IN_A_LINE[i];\n      // Determine if the cells in a line have the same mark.\n      if (\n        board[x] != null &&\n        board[x] === board[y] &&\n        board[y] === board[z]\n      ) {\n        return board[x];\n      }\n    }\n\n    // No winner yet.\n    return null;\n  }\n\n  let board = Array(9).fill(null);\n  let xIsPlaying = true;\n  $: winner = determineWinner(board);\n\n  function onReset() {\n    board = Array(9).fill(null);\n    xIsPlaying = true;\n  }\n\n  function getStatusMessage(winner, board, xIsPlaying) {\n    if (winner != null) {\n      return `Player ${winner} wins!`;\n    }\n\n    // All cells have been filled up.\n    if (!board.includes(null)) {\n      return `It's a draw!`;\n    }\n\n    return `Player ${xIsPlaying ? 'X' : 'O'} turn`;\n  }\n</script>\n\n<div class=\"app\">\n  <div aria-live=\"polite\">\n    {getStatusMessage(winner, board, xIsPlaying)}\n  </div>\n  <div class=\"board\">\n    {#each { length: 9 } as _, cellIndex (cellIndex)}\n      {@const turn = xIsPlaying ? 'X' : 'O'}\n      <Cell\n        disabled={board[cellIndex] != null ||\n          winner != null}\n        index={cellIndex}\n        mark={board[cellIndex]}\n        {turn}\n        on:click={() => {\n          const newBoard = board.slice();\n          newBoard[cellIndex] = turn;\n          board = newBoard;\n          xIsPlaying = !xIsPlaying;\n        }} />\n    {/each}\n  </div>\n  <button\n    on:click={() => {\n      if (winner == null) {\n        // Confirm whether to reset the game.\n        const confirm = window.confirm(\n          'Are you sure you want to reset the game?',\n        );\n        if (!confirm) {\n          return;\n        }\n      }\n\n      onReset();\n    }}>\n    Reset\n  </button>\n</div>\n\n<style>\n  .app {\n    align-items: center;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    max-width: 320px;\n    margin: 0 auto;\n    row-gap: 16px;\n  }\n\n  .board {\n    display: grid;\n    width: 100%;\n    grid-template-columns: repeat(3, 1fr);\n  }\n</style>\n"
    },
    "/src/Cell.svelte": {
      "code": "<script>\n  export let index;\n  export let disabled;\n  export let mark;\n  export let turn;\n\n  import { createEventDispatcher } from 'svelte';\n  const dispatch = createEventDispatcher();\n</script>\n\n<button\n  aria-label={mark == null\n    ? `Mark cell ${index} as ${turn}`\n    : undefined}\n  class=\"cell\"\n  {disabled}\n  on:click={() => {\n    dispatch('click');\n  }}>\n  <span aria-hidden={true}>{mark ?? ''}</span>\n</button>\n\n<style>\n  .cell {\n    background-color: #fff;\n    border: 1px solid #ccc;\n    color: #000;\n    font-size: min(48px, 10vw);\n    font-weight: bold;\n    vertical-align: middle;\n    aspect-ratio: 1 / 1;\n  }\n\n  .cell:not(:disabled) {\n    cursor: pointer;\n  }\n\n  .cell:not(:disabled):hover {\n    background-color: #fafafa;\n  }\n</style>\n"
    },
    "/src/index.js": {
      "code": "import App from './App.svelte';\nimport './styles.css';\n\nconst app = new App({\n  target: document.body,\n});\n\nexport default app;\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.svelte",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.svelte",
    "environment": "svelte"
  },
  "writeup": "var Component=(()=>{var g=Object.create;var l=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),k=(t,e)=>{for(var r in e)l(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of y(e))!w.call(t,a)&&a!==r&&l(t,a,{get:()=>e[a],enumerable:!(c=f(e,a))||c.enumerable});return t};var h=(t,e,r)=>(r=t!=null?g(b(t)):{},o(e||!t||!t.__esModule?l(r,\"default\",{value:t,enumerable:!0}):r,t)),C=t=>o(l({},\"__esModule\",{value:!0}),t);var s=v((I,d)=>{d.exports=_jsx_runtime});var S={};k(S,{default:()=>z});var n=h(s());var i=h(s());function m(t){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initial Board State\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Verify that the game board is displayed correctly with 9 empty cells.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the status message indicates it's player X's turn.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Marking Cells\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Click on an empty cell.\"}),`\n`,(0,i.jsx)(e.li,{children:'Verify that the cell is marked with an \"X\" and the turn switches to player O.'}),`\n`,(0,i.jsx)(e.li,{children:\"Click on another empty cell.\"}),`\n`,(0,i.jsx)(e.li,{children:'Verify that the second cell is marked with an \"O\" and the turn switches back to player X.'}),`\n`,(0,i.jsx)(e.li,{children:\"Repeat this process for a few more cells to ensure the marks are placed correctly and the turn alternates between players.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Winning Conditions\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Create a winning line for player X or player O by marking three cells in a row, column, or diagonal.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the status message displays the winning player's message correctly.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that no further marks can be made after the game is won.\"}),`\n`,(0,i.jsx)(e.li,{children:'Click on the \"Reset\" button.'}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the board is cleared and the game restarts with player X's turn.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Draw Condition\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Fill all the cells on the board without creating a winning line.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the status message displays a draw message correctly.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that no further marks can be made after the draw.\"}),`\n`,(0,i.jsx)(e.li,{children:'Click on the \"Reset\" button.'}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the board is cleared, and the game restarts with player X's turn.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Accessibility\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Use a screen reader to navigate and interact with the game.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the status message, cell markings, and buttons are announced correctly by the screen reader.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the game can be played and reset using only keyboard navigation.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Responsive Design\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Test the game on different screen sizes, such as desktop, tablet, and mobile devices.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the game board and cells adjust correctly to different screen sizes.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure that the game remains playable and visually appealing on smaller screens.\"}),`\n`]}),`\n`]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(m,t)})):m(t)}var u=T;function p(t){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",ol:\"ol\",li:\"li\",strong:\"strong\",code:\"code\",ul:\"ul\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsx)(e.p,{children:\"To make the board responsive, CSS Grid was utilized in the code. CSS Grid is a powerful layout system that allows for the creation of two-dimensional grid layouts. Here's how CSS Grid was used to make the game board responsive:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Grid Container\"}),\": The game board is enclosed within a \",(0,n.jsx)(e.code,{children:\"<div>\"}),\" element carrying the class name \",(0,n.jsx)(e.code,{children:\"board\"}),\". This element serves as our grid container for the cells.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Grid Template Columns\"}),\": The grid container is designated with \",(0,n.jsx)(e.code,{children:\"display: grid\"}),\" and the property \",(0,n.jsx)(e.code,{children:\"grid-template-columns: repeat(3, 1fr)\"}),\" is applied. This specifies that the grid should have three columns, each with equal width. The notation \",(0,n.jsx)(e.code,{children:\"repeat(3, 1fr)\"}),' is a concise way of saying, \"three columns, each taking up one fraction (or 1/3) of the available space.\"']}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Cell Sizing\"}),\": Each grid cell is represented by a button element from the \",(0,n.jsx)(e.code,{children:\"Cell\"}),` component with the class name \"cell\". For the cell's appearance:`,`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"font-size\"}),\" is set using the \",(0,n.jsx)(e.code,{children:\"min()\"}),\" function, ensuring that the text scales adaptively based on the viewport's width. A fallback size of \",(0,n.jsx)(e.code,{children:\"48px\"}),\" is specified, but it can also use up to \",(0,n.jsx)(e.code,{children:\"10vw\"}),\" (or 10% of the viewport width).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The property \",(0,n.jsx)(e.code,{children:\"aspect-ratio: 1 / 1\"}),\" makes sure each cell remains square-shaped regardless of the content.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Responsive Behavior\"}),\": By using CSS Grid and defining the cell sizing based on the viewport width, the game board becomes responsive. As the viewport width decreases, the grid layout adapts, and the cells adjust their size accordingly. The \",(0,n.jsx)(e.code,{children:\"min()\"}),\" function in the \",(0,n.jsx)(e.code,{children:\"font-size\"}),\" property ensures that the font size does not become too large on smaller screens, providing a better user experience.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Overall, CSS Grid provides a flexible and responsive layout for the game board by defining the number of columns and adjusting the cell size based on the available space. This allows the game board to maintain its structure and usability across different screen sizes and devices.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsx)(e.p,{children:\"The game's logic is held together by two main state variables:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"board\"}),\": An array representing the game board's current state. Initialized as an array filled with \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" with a length of 9, each array element corresponds to a board cell. The possible values each element can hold are either \",(0,n.jsx)(e.code,{children:\"'X'\"}),\", \",(0,n.jsx)(e.code,{children:\"'O'\"}),\", or \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", representing the marks made by players X and O or an empty cell.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"xIsPlaying\"}),\": A boolean to track which player's turn it is, initially set to \",(0,n.jsx)(e.code,{children:\"true\"}),\" (indicating Player X).\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"determineWinner\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"determineWinner\"}),\" function is at the heart of the game's logic, determining if a player has won. By iterating over every possible winning line combination, this function checks if all cells in a given line have the same mark. If a winning line is found, the function returns the victorious player's mark (\",(0,n.jsx)(e.code,{children:\"'X'\"}),\" or \",(0,n.jsx)(e.code,{children:\"'O'\"}),\"), otherwise it returns \",(0,n.jsx)(e.code,{children:\"null\"}),\" (indicating no winner yet).\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The function takes a \",(0,n.jsx)(e.code,{children:\"board\"}),\" parameter, which is an array representing the state of the game board. It iterates over the \",(0,n.jsx)(e.code,{children:\"CELLS_IN_A_LINE\"}),\" array, which contains all the possible combinations of cell indices that form a winning line in the Tic-Tac-Toe game. Each combination consists of three indices representing the cells in a row, column, or diagonal. Since the board size is relatively small, it is possible to enumerate all the possible combinations. If the board size is larger then this approach won't scale well.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Inside the loop, the current combination of cell indices is destructured into three variables: \",(0,n.jsx)(e.code,{children:\"x\"}),\", \",(0,n.jsx)(e.code,{children:\"y\"}),\", and \",(0,n.jsx)(e.code,{children:\"z\"}),\". These variables represent the indices of the cells that need to be checked for equality.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The function then checks if the values in the \",(0,n.jsx)(e.code,{children:\"board\"}),\" array at indices \",(0,n.jsx)(e.code,{children:\"x\"}),\", \",(0,n.jsx)(e.code,{children:\"y\"}),\", and \",(0,n.jsx)(e.code,{children:\"z\"}),\" are not \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" (indicating that the cells are not empty) and are all equal to each other. If this condition is satisfied, it means that there is a winning line formed by the marks in the cells. If a winning line is found, the function returns the value of the mark (either \",(0,n.jsx)(e.code,{children:\"'X'\"}),\" or \",(0,n.jsx)(e.code,{children:\"'O'\"}),\") that is present in the winning line. This indicates which player has won the game.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If no winning line is found after checking all the combinations, the function returns \",(0,n.jsx)(e.code,{children:\"null\"}),\", indicating that there is no winner yet.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Components and Interactivity\"}),`\n`,(0,n.jsx)(e.p,{children:\"The game's functionality and user interactivity are encapsulated within two Svelte components:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"App Component\"}),\": It manages the game's overall state and logic. This is where we determine whose turn it is, whether there's a winner, and handle the game reset. We also iterate over the \",(0,n.jsx)(e.code,{children:\"board\"}),\" state to render each cell using the \",(0,n.jsx)(e.code,{children:\"Cell\"}),\" component.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Cell Component\"}),\": It represents individual game cells. It accepts props to determine its appearance and behavior, such as whether it should be disabled or what mark it currently holds. The component emits a 'click' event to notify the parent component (\",(0,n.jsx)(e.code,{children:\"App\"}),\") when a cell is clicked.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Using these two components, we can efficiently manage the game's state and ensure smooth interactions for the players.\"}),`\n`,(0,n.jsx)(u,{})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var z=x;return C(S);})();\n;return Component;"
}