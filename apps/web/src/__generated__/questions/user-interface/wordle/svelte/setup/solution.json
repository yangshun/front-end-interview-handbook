{
  "author": "tanhauhau",
  "files": {
    "/greatfrontend.json": {
      "code": "{\n  \"visibleFiles\": [\n    \"/src/App.svelte\",\n    \"/src/Keyboard.svelte\",\n    \"/src/LetterGrid.svelte\",\n    \"/src/styles.css\"\n  ],\n  \"activeFile\": \"/src/App.svelte\",\n  \"environment\": \"svelte\"\n}\n"
    },
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/wordle-svelte-solution\",\n  \"author\": \"tanhauhau\",\n  \"version\": \"0.0.1\",\n  \"main\": \"src/index.js\",\n  \"dependencies\": {\n    \"svelte\": \"^3.58.0\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Svelte</title>\n    <link rel=\"stylesheet\" href=\"public/bundle.css\" />\n  </head>\n\n  <body>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n"
    },
    "/src/App.svelte": {
      "code": "<script>\n  import './styles.css';\n  import LetterGrid from './LetterGrid.svelte';\n  import Keyboard from './Keyboard.svelte';\n  import { onMount } from 'svelte';\n  import {\n    LETTER_GUESS_STATE,\n    LETTER_GUESS_STATE_PRIORITY,\n    GAME_STATE,\n  } from './constants';\n\n  export let maxAttempts = 6;\n  export let lettersPerWord = 5;\n\n  const INITIAL_CURSOR_POSITION = [0, -1];\n\n  const WORDS = Object.freeze([\n    'APPLE',\n    'BEAST',\n    'FAINT',\n    'FEAST',\n    'FRUIT',\n    'GAMES',\n    'PAINT',\n    'PASTE',\n    'TOWER',\n    'REACT',\n  ]);\n\n  const A_KEYCODE = 65;\n  const Z_KEYCODE = 90;\n\n  function isValidKey(key) {\n    return (\n      key === 'Enter' ||\n      key === 'Backspace' ||\n      (key.length === 1 &&\n        key.toUpperCase().charCodeAt() >= A_KEYCODE &&\n        key.toUpperCase().charCodeAt() <= Z_KEYCODE)\n    );\n  }\n\n  // Count the frequency of letters in a word.\n  function countLetterFreqInWord(word) {\n    const freq = new Map();\n\n    for (let i = 0; i < word.length; ++i) {\n      if (!freq.has(word[i])) {\n        freq.set(word[i], 0);\n      }\n\n      freq.set(word[i], freq.get(word[i]) + 1);\n    }\n\n    return freq;\n  }\n\n  function getInitialGridState(\n    maxAttempts,\n    lettersPerWord,\n  ) {\n    return Array.from({ length: maxAttempts }, () =>\n      Array.from({ length: lettersPerWord }, () => ({\n        char: '',\n        state: LETTER_GUESS_STATE.INDETERMINATE,\n      })),\n    );\n  }\n\n  function getInitialLetterGuessState() {\n    return {};\n  }\n\n  // Initialize word of the day.\n  let wordOfTheDay = generateRandomWord();\n  // Represent overall game state.\n  let gameState = GAME_STATE.IN_PROGRESS;\n\n  // User attempts and the states of each letter guess.\n  let gridState = getInitialGridState(\n    maxAttempts,\n    lettersPerWord,\n  );\n  // Current position in the grid.\n  let position = INITIAL_CURSOR_POSITION;\n  // Tracks the state of letter guesses.\n  let letterGuessState = getInitialLetterGuessState();\n\n  $: console.log(\n    `[DEBUG]: Word of the day is: ${wordOfTheDay}`,\n  );\n  $: maxAttempts, lettersPerWord, resetGame();\n\n  function resetGame() {\n    wordOfTheDay = generateRandomWord();\n    gridState = getInitialGridState(\n      maxAttempts,\n      lettersPerWord,\n    );\n    position = INITIAL_CURSOR_POSITION;\n    gameState = GAME_STATE.IN_PROGRESS;\n    letterGuessState = getInitialLetterGuessState();\n  }\n\n  function addLetter(char) {\n    const [row, col] = position;\n\n    // Row is already fully filled.\n    if (col + 1 === lettersPerWord) {\n      return;\n    }\n\n    // Clone the grid to avoid mutating the existing one.\n    const newGridState = Array.from(gridState);\n    newGridState[row][col + 1].char = char.toUpperCase();\n    position = [row, col + 1];\n    gridState = newGridState;\n  }\n\n  function deleteLetter() {\n    const [row, col] = position;\n    const newGridState = Array.from(gridState);\n\n    if (col === -1) {\n      return;\n    }\n\n    newGridState[row][col].char = '';\n    position = [row, col - 1];\n    gridState = newGridState;\n  }\n\n  function checkWord() {\n    const [row, col] = position;\n\n    // Not enough letters in the row yet.\n    if (col + 1 < lettersPerWord) {\n      return;\n    }\n\n    const newGridState = Array.from(gridState);\n    const newLetterGuessState = { ...letterGuessState };\n    const word = gridState[row]\n      .map(({ char }) => char)\n      .join('');\n    // Create a map of count of letters in original word to compare\n    // with the word entered by user.\n    const letterFreq = countLetterFreqInWord(wordOfTheDay);\n    const nonMatchingIndices = [];\n    let matchCount = 0;\n\n    // Update state for matching chars first.\n    for (let i = 0; i < word.length; i++) {\n      const currentChar = word[i];\n      const currentActualChar = wordOfTheDay[i];\n\n      if (currentChar === currentActualChar) {\n        newGridState[row][i].state =\n          LETTER_GUESS_STATE.CORRECT;\n        newLetterGuessState[currentChar] =\n          LETTER_GUESS_STATE.CORRECT;\n        letterFreq.set(\n          currentChar,\n          letterFreq.get(currentChar) - 1,\n        );\n        matchCount++;\n      } else {\n        nonMatchingIndices.push(i);\n      }\n    }\n\n    // Guessed correctly.\n    if (matchCount === lettersPerWord) {\n      letterGuessState = newLetterGuessState;\n      gridState = newGridState;\n      gameState = GAME_STATE.GUESSED_CORRECTLY;\n      return;\n    }\n\n    // Update state for rest of the chars.\n    nonMatchingIndices.forEach((idx) => {\n      const char = word[idx];\n      if (\n        letterFreq.has(char) &&\n        letterFreq.get(char) > 0\n      ) {\n        letterFreq.set(char, letterFreq.get(char) - 1);\n        newGridState[row][idx].state =\n          LETTER_GUESS_STATE.PRESENT;\n        // Only change state if the new state is higher priority\n        // than the current state.\n        if (\n          LETTER_GUESS_STATE_PRIORITY[\n            LETTER_GUESS_STATE.PRESENT\n          ] >\n          LETTER_GUESS_STATE_PRIORITY[\n            newLetterGuessState[char] ??\n              LETTER_GUESS_STATE.INDETERMINATE\n          ]\n        ) {\n          newLetterGuessState[char] =\n            LETTER_GUESS_STATE.PRESENT;\n        }\n      } else {\n        newGridState[row][idx].state =\n          LETTER_GUESS_STATE.ABSENT;\n        // Only change state if the new state is higher priority\n        // than the current state.\n        if (\n          LETTER_GUESS_STATE_PRIORITY[\n            LETTER_GUESS_STATE.ABSENT\n          ] >\n          LETTER_GUESS_STATE_PRIORITY[\n            newLetterGuessState[char] ??\n              LETTER_GUESS_STATE.INDETERMINATE\n          ]\n        ) {\n          newLetterGuessState[char] =\n            LETTER_GUESS_STATE.ABSENT;\n        }\n      }\n    });\n\n    letterGuessState = newLetterGuessState;\n    gridState = newGridState;\n\n    // User did not manage to guess the correct answer.\n    if (row + 1 === maxAttempts) {\n      gameState = GAME_STATE.NO_MORE_GUESSES;\n      return;\n    }\n\n    // Move to next row.\n    position = [row + 1, -1];\n  }\n\n  function onPressKey(key) {\n    // Game has a conclusion.\n    if (gameState !== GAME_STATE.IN_PROGRESS) {\n      return;\n    }\n\n    // Ignore invalid input from user.\n    if (!isValidKey(key)) {\n      return;\n    }\n\n    switch (key) {\n      case 'Enter':\n        checkWord();\n        break;\n      case 'Backspace':\n        deleteLetter();\n        break;\n      default:\n        addLetter(key);\n    }\n  }\n\n  onMount(() => {\n    function onKeyDown(event) {\n      // Only respond to single key presses.\n      if (\n        event.altKey ||\n        event.ctrlKey ||\n        event.metaKey ||\n        event.shiftKey\n      ) {\n        return;\n      }\n\n      // Ignore enter and space events not triggered on the page level\n      // as there could be lower level elements handling them\n      // and we don't want to double-handle them.\n      if (\n        event.target !== document.body &&\n        (event.key === 'Enter' || event.key === ' ')\n      ) {\n        return;\n      }\n\n      onPressKey(event.key);\n    }\n\n    document.addEventListener('keydown', onKeyDown);\n    return () => {\n      document.removeEventListener('keydown', onKeyDown);\n    };\n  });\n\n  function generateRandomWord() {\n    return WORDS[Math.floor(Math.random() * WORDS.length)];\n  }\n</script>\n\n<main class=\"root\">\n  <h1 class=\"title\">Wordle</h1>\n  {#if gameState !== GAME_STATE.IN_PROGRESS}\n    <div class=\"result-row\">\n      <strong>\n        {#if gameState === GAME_STATE.GUESSED_CORRECTLY}\n          Congratulations ðŸŽ‰\n        {:else if gameState === GAME_STATE.NO_MORE_GUESSES}\n          {`Word: ${wordOfTheDay}`}\n        {/if}\n      </strong>\n      <button\n        type=\"button\"\n        class=\"reset-button\"\n        on:click={resetGame}>\n        Reset\n      </button>\n    </div>\n  {/if}\n  <LetterGrid letters={gridState} />\n  <Keyboard\n    on:press-key={(event) => onPressKey(event.detail.char)}\n    {letterGuessState} />\n</main>\n\n<style>\n  .root {\n    display: grid;\n    outline: none;\n    row-gap: 16px;\n  }\n\n  .title {\n    font-size: 2rem;\n    font-weight: bold;\n    margin-bottom: 0;\n    text-align: center;\n  }\n\n  .result-row {\n    display: flex;\n    column-gap: 8px;\n    justify-content: center;\n  }\n\n  .reset-button {\n    cursor: pointer;\n  }\n</style>\n"
    },
    "/src/constants.js": {
      "code": "export const LETTER_GUESS_STATE = Object.freeze({\n  INDETERMINATE: 'INDETERMINATE',\n  ABSENT: 'ABSENT',\n  PRESENT: 'PRESENT',\n  CORRECT: 'CORRECT',\n});\n\nexport const LETTER_GUESS_STATE_PRIORITY = Object.freeze({\n  INDETERMINATE: 1,\n  ABSENT: 2,\n  PRESENT: 3,\n  CORRECT: 4,\n});\n\nexport const GAME_STATE = Object.freeze({\n  IN_PROGRESS: 'IN_PROGRESS',\n  GUESSED_CORRECTLY: 'GUESSED_CORRECTLY',\n  NO_MORE_GUESSES: 'NO_MORE_GUESSES',\n});\n"
    },
    "/src/index.js": {
      "code": "import App from './App.svelte';\nimport './styles.css';\n\nconst app = new App({\n  target: document.body,\n});\n\nexport default app;\n"
    },
    "/src/Keyboard.svelte": {
      "code": "<script>\n  import { createEventDispatcher } from 'svelte';\n  const KEYBOARD_LAYOUT = Object.freeze([\n    ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],\n    ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],\n    [\n      'Enter',\n      'Z',\n      'X',\n      'C',\n      'V',\n      'B',\n      'N',\n      'M',\n      'Backspace',\n    ],\n  ]);\n\n  export let letterGuessState;\n  const dispatch = createEventDispatcher();\n</script>\n\n<section class=\"keyboard-section\">\n  {#each KEYBOARD_LAYOUT as row, rowIndex (rowIndex)}\n    <div class=\"keyboard-row\">\n      {#each row as char (char)}\n        <button\n          on:click={() => {\n            dispatch('press-key', { char });\n          }}\n          class=\"keyboard-row__button\"\n          class:absent={letterGuessState[char] === 'ABSENT'}\n          class:correct={letterGuessState[char] ===\n            'CORRECT'}\n          class:present={letterGuessState[char] ===\n            'PRESENT'}>\n          {(() => {\n            switch (char) {\n              case 'Enter':\n                return 'ENTER';\n              case 'Backspace':\n                return 'DEL';\n              default:\n                return char;\n            }\n          })()}\n        </button>\n      {/each}\n    </div>\n  {/each}\n</section>\n\n<style>\n  .keyboard-section {\n    display: flex;\n    flex-direction: column;\n    row-gap: 0.5rem;\n  }\n\n  .keyboard-row {\n    display: flex;\n    justify-content: center;\n  }\n\n  .keyboard-row__button {\n    --background-color: var(--indeterminate);\n    --color: #000;\n\n    border: none;\n    background-color: var(--background-color);\n    color: var(--color);\n    height: 40px;\n    border-radius: 4px;\n    font-weight: 600;\n    cursor: pointer;\n    min-width: 30px;\n    margin-inline: 0.25rem;\n  }\n\n  .absent {\n    --background-color: var(--absent);\n    --border-color: var(--absent);\n    --color: #fff;\n  }\n\n  .correct {\n    --background-color: var(--correct);\n    --border-color: var(--correct);\n    --color: #fff;\n  }\n\n  .present {\n    --background-color: var(--present);\n    --border-color: var(--present);\n    --color: #fff;\n  }\n</style>\n"
    },
    "/src/LetterGrid.svelte": {
      "code": "<script>\n  export let letters;\n  import { LETTER_GUESS_STATE } from './constants';\n</script>\n\n<section\n  class=\"grid-section\"\n  style=\"\n    grid-template-columns: repeat({letters[0]\n    .length}, var(--size));\n    grid-template-rows: repeat({letters.length}, var(--size));\n  \">\n  {#each letters as lettersRow}\n    {#each lettersRow as { char, state }, colIndex}\n      {@const notIntermediateState =\n        state !== LETTER_GUESS_STATE.INDETERMINATE}\n      <div\n        class=\"grid-cell\"\n        class:absent={notIntermediateState &&\n          state === 'ABSENT'}\n        class:correct={notIntermediateState &&\n          state === 'CORRECT'}\n        class:present={notIntermediateState &&\n          state === 'PRESENT'}\n        class:grid-cell--filled={Boolean(char)}\n        class:grid-cell--final={notIntermediateState}\n        style:transition-delay={notIntermediateState\n          ? `${colIndex * 50}ms`\n          : undefined}>\n        {char}\n      </div>\n    {/each}\n  {/each}\n</section>\n\n<style>\n  .grid-section {\n    --size: 50px;\n\n    display: grid;\n    gap: 5px;\n    justify-content: center;\n  }\n\n  .grid-cell {\n    --fill-color: transparent;\n    --background-color: #fff;\n    --border-color: var(--indeterminate);\n    --color: #000;\n\n    border-color: var(--border-color);\n    background-color: var(--background-color);\n    border-width: 2px;\n    border-style: solid;\n    font-size: 1.5rem;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-weight: bold;\n  }\n\n  .grid-cell--filled {\n    animation: scale-on-fill 50ms ease-in;\n  }\n\n  @keyframes scale-on-fill {\n    70% {\n      transform: scale(1.1);\n    }\n    100% {\n      transform: scale(1);\n    }\n  }\n\n  .grid-cell--final {\n    color: var(--color);\n    transition-property: color background-color border-color;\n    transition-duration: 50ms;\n  }\n\n  .absent {\n    --background-color: var(--absent);\n    --border-color: var(--absent);\n    --color: #fff;\n  }\n\n  .correct {\n    --background-color: var(--correct);\n    --border-color: var(--correct);\n    --color: #fff;\n  }\n\n  .present {\n    --background-color: var(--present);\n    --border-color: var(--present);\n    --color: #fff;\n  }\n</style>\n"
    },
    "/src/styles.css": {
      "code": "body {\n  --indeterminate: #d3d6da;\n  --correct: #6aaa64;\n  --present: #c9b458;\n  --absent: #787c7e;\n\n  margin: 0;\n  font-family: 'Ubuntu', sans-serif;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.svelte",
      "/src/Keyboard.svelte",
      "/src/LetterGrid.svelte",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.svelte",
    "environment": "svelte"
  }
}