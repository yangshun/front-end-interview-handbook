{
  "skeleton": "var Component=(()=>{var f=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var i in e)r(t,i,{get:e[i],enumerable:!0})},u=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of x(e))!w.call(t,o)&&o!==i&&r(t,o,{get:()=>e[o],enumerable:!(l=p(e,o))||l.enumerable});return t};var c=(t,e,i)=>(i=t!=null?f(b(t)):{},u(e||!t||!t.__esModule?r(i,\"default\",{value:t,enumerable:!0}):i,t)),q=t=>u(r({},\"__esModule\",{value:!0}),t);var a=y((D,h)=>{h.exports=_jsx_runtime});var I={};j(I,{default:()=>v});var s=c(a());var n=c(a());function m(t){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is a follow up to the \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel\",children:\"Image Carousel\"}),\" question, you should complete that question first before attempting this question.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Build an image carousel that displays a sequence of images, smoothly transitioning when navigating between images.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"All requirements of \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel\",children:\"Image Carousel\"}),\" question should be supported.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Upon clicking the Prev/Next buttons, the current image should smoothly translate out while the next image enters. Translation direction is left/right respectively.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Transitions when clicking on the page buttons is optional but highly encouraged. Aim to reuse the transitioning code for the Prev/Next buttons.\"}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Recommendation\"}),\": Render all the images in a horizontal row within a container and manipulate the horizontal offset of the container to achieve the transitions.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:'Click on the \"See what you are building\" button to see a preview of the result.'}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The skeleton code uses the solution of \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel\",children:\"Image Carousel\"}),\", but you are free to use your own solution as a starting point.\"]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var d=C;function g(t){return(0,s.jsx)(d,{})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,s.jsx)(e,Object.assign({},t,{children:(0,s.jsx)(g,t)})):g(t)}var v=_;return q(I);})();\n;return Component;",
  "solution": "var Component=(()=>{var x=Object.create;var l=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var S=Object.getPrototypeOf,C=Object.prototype.hasOwnProperty;var z=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),T=(t,e)=>{for(var r in e)l(t,r,{get:e[r],enumerable:!0})},m=(t,e,r,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of _(e))!C.call(t,s)&&s!==r&&l(t,s,{get:()=>e[s],enumerable:!(d=j(e,s))||d.enumerable});return t};var c=(t,e,r)=>(r=t!=null?x(S(t)):{},m(e||!t||!t.__esModule?l(r,\"default\",{value:t,enumerable:!0}):r,t)),O=t=>m(l({},\"__esModule\",{value:!0}),t);var h=z((k,g)=>{g.exports=_jsx_runtime});var W={};T(W,{default:()=>I});var o=c(h());var n=c(h());function u(t){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",h4:\"h4\",code:\"code\",a:\"a\",pre:\"pre\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",ol:\"ol\",li:\"li\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Structure\"}),`\n`,(0,n.jsx)(e.p,{children:\"One of the easiest way to implement an image carousel is rendering all the images in a horizontal fashion within a container (the images will overflow horizontally) and changing the horizontal offset.\"}),`\n`,(0,n.jsx)(e.p,{children:\"With this structure, navigating between images can be done in two ways: (1) changing the container's scroll position and (2) CSS transforms on the container.\"}),`\n`,(0,n.jsx)(e.h4,{children:\"1. Scroll position\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"By placing the images in a row and restricting the container to be the same size as the image carousel dimensions, the images will take up a longer horizontal space than the container and to view the various images, the \",(0,n.jsx)(e.code,{children:\"scrollOffset\"}),\" of the container can be modified. Combined with the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll_snap\",children:\"CSS scroll snap\"}),\" property, touchpad and touchscreen users can scroll/swipe through the images horizontally. This method doesn't involve JavaScript at all and is highly recommended if all you need is a basic horizontal image carousel.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To support pagination button interactions, you can programmatically set the scroll position by using the \",(0,n.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scroll\",children:[(0,n.jsx)(e.code,{children:\"Element.scroll()\"}),\" method\"]}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`containerEl.scroll({\n  left: 100, // Calculate this offset value based on size of the image.\n  behavior: 'smooth', // Smooth transitions for free!\n});\n`})}),`\n`,(0,n.jsx)(e.h4,{children:\"2. CSS transforms\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The other way to change the displayed image is to add \",(0,n.jsx)(e.code,{children:\"transform: translateX(100px)\"}),\" on the container. The value to translate by depends on the size of the image. The solution implements this method since it is slightly more complex to implement and provides more learning value.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Determining how much to scroll/translate by\"}),`\n`,(0,n.jsx)(e.p,{children:\"Using this offset technique, for the various images:\"}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Image no.\"}),(0,n.jsx)(e.th,{children:\"Offset\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"1\"}),(0,n.jsx)(e.td,{children:\"0\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"2\"}),(0,n.jsx)(e.td,{children:\"One image width\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"3\"}),(0,n.jsx)(e.td,{children:\"Two image width\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"4\"}),(0,n.jsx)(e.td,{children:\"Three image width\"})]})]})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Observe that the offset can be determined with \",(0,n.jsx)(e.code,{children:\"(index - 1) * imageWidth\"}),\". However, because the images have a dynamic width (when the screen is narrower than 600px), the image width value is not available ahead of time and has to be calculated during runtime.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can obtain a reference to the image carousel's root element and use \",(0,n.jsx)(e.code,{children:\"el.getBoundingClientRect().width\"}),\" to get an image's width.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Transitions\"}),`\n`,(0,n.jsx)(e.p,{children:\"With the CSS transform method, transitions can be easily enabled by the following CSS:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-css\",children:`transition: transform 0.5s linear;\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Just by setting the \",(0,n.jsx)(e.code,{children:\"transform\"}),\" property to a new \",(0,n.jsx)(e.code,{children:\"translateX()\"}),\" value, the browser will transition the container smoothly to the new position, displaying the new image.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Resizing\"}),`\n`,(0,n.jsx)(e.p,{children:\"One issue with using an offset-based approach for transitions is that if the width of the image carousel changes, the current offset (which is based on the image dimensions) will no longer be accurate.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Therefore we need to listen for window \",(0,n.jsx)(e.code,{children:\"resize\"}),\" events and make the \",(0,n.jsx)(e.code,{children:\"imageWidth\"}),\" as part of the component state, so that the component updates the offset if/when the \",(0,n.jsx)(e.code,{children:\"imageWidth\"}),\" changes.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If the \",(0,n.jsx)(e.code,{children:\"transition\"}),\" styles are permanently on the image container, when the offset changes due to resizing, some transition will be seen and looks a little odd. Hence the \",(0,n.jsx)(e.code,{children:\"transition\"}),\" styles should only be added when offset changes due to navigation events and not resizing.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Downsides of an offset-based approach\"}),`\n`,(0,n.jsx)(e.p,{children:\"The offset-based approach was relatively easy to implement. You should also be aware of the downsides of this approach:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Larger DOM footprint\"}),\": All the images are present in the DOM from the get-go. If there are many images, it could result in poor performance. This can be mitigated with list virtualization and/or lazy loading of images.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Transition distance can be huge\"}),\": Transitioning from the first image to the last image or vice-versa (more generally speaking, across multiple images) can be a jarring experience because the browser will scroll through all the intermediate images.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Follow up\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"There are many ways to implement image carousels, each with its own advantages and limitations. \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel-iii\",children:\"Image Carousel III\"}),\" explores a different, more performant approach, where only the current image and next image is rendered into the DOM and addresses some of the downsides of the offset-based approach.\"]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var p=M;var a=c(h());function f(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,a.jsxs)(e.ul,{children:[`\n`,(0,a.jsx)(e.li,{children:\"Ensure test cases for basic navigation still pass.\"}),`\n`,(0,a.jsx)(e.li,{children:\"Click the navigation buttons in rapid succession (while the transition is ongoing) and check that no unexpected behavior occurs.\"}),`\n`]})]})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,a.jsx)(e,Object.assign({},t,{children:(0,a.jsx)(f,t)})):f(t)}var b=D;var i=c(h());function w(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",strong:\"strong\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"All images should have \",(0,i.jsx)(e.code,{children:\"alt\"}),\" text that describes the image to support accessibility. It will be read out loud by screen readers and is also used by search engines.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Add appropriate \",(0,i.jsx)(e.code,{children:\"aria-label\"}),\"s to the buttons since the buttons do not have visible labels.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"[Not implemented]\"}),\": Add a screen-reader-only element with the \",(0,i.jsx)(e.code,{children:'aria-live=\"polite\"'}),\" attribute and \",(0,i.jsx)(e.code,{children:\"alt\"}),\" text of the new image as contents. This instructs screen readers to announce that a new image is displayed.\"]}),`\n`]})]})}function X(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(w,t)})):w(t)}var y=X;function v(t){return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(p,{}),`\n`,(0,o.jsx)(b,{}),`\n`,(0,o.jsx)(y,{})]})}function F(t={}){let{wrapper:e}=t.components||{};return e?(0,o.jsx)(e,Object.assign({},t,{children:(0,o.jsx)(v,t)})):v(t)}var I=F;return O(W);})();\n;return Component;"
}