{
  "author": "yangshun",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/image-carousel-ii-react-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.0\",\n    \"@types/react-dom\": \"18.2.0\",\n    \"typescript\": \"5.0.2\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.tsx": {
      "code": "import ImageCarousel from './ImageCarousel';\n\nconst images = [\n  {\n    src: 'https://picsum.photos/id/600/600/400',\n    alt: 'Forest',\n  },\n  {\n    src: 'https://picsum.photos/id/100/600/400',\n    alt: 'Beach',\n  },\n  {\n    src: 'https://picsum.photos/id/200/600/400',\n    alt: 'Yak',\n  },\n  {\n    src: 'https://picsum.photos/id/300/600/400',\n    alt: 'Hay',\n  },\n  {\n    src: 'https://picsum.photos/id/400/600/400',\n    alt: 'Plants',\n  },\n  {\n    src: 'https://picsum.photos/id/500/600/400',\n    alt: 'Building',\n  },\n];\n\nexport default function App() {\n  return (\n    <div className=\"wrapper\">\n      <ImageCarousel images={images} />\n    </div>\n  );\n}\n"
    },
    "/src/ImageCarousel.tsx": {
      "code": "import { useEffect, useRef, useState } from 'react';\n\nfunction clsx(...classnames: Array<any>) {\n  return classnames.filter(Boolean).join(' ');\n}\n\nexport default function ImageCarousel({\n  images,\n}: Readonly<{\n  images: ReadonlyArray<{ src: string; alt: string }>;\n}>) {\n  const ref = useRef<HTMLDivElement | null>(null);\n  const [currIndex, setCurrIndex] = useState(0);\n  const [imageWidth, setImageWidth] = useState<\n    number | null\n  >(null);\n  const [isTransitioning, setIsTransitioning] =\n    useState(false);\n\n  function updateImageWidth() {\n    setImageWidth(\n      ref.current?.getBoundingClientRect()?.width ?? 0,\n    );\n  }\n\n  function changeCurrIndex(newIndex: number) {\n    const nextIndex =\n      (newIndex + images.length) % images.length;\n    setIsTransitioning(true);\n    setCurrIndex(nextIndex);\n  }\n\n  useEffect(() => {\n    updateImageWidth();\n\n    window.addEventListener('resize', updateImageWidth);\n\n    return () => {\n      window.removeEventListener(\n        'resize',\n        updateImageWidth,\n      );\n    };\n  }, [updateImageWidth]);\n\n  return (\n    <div className=\"image-carousel\" ref={ref}>\n      <div\n        className={clsx(\n          'image-carousel__row',\n          // Only add transition class when there is a need to\n          // animate the transition, otherwise the translation update\n          // is also transitioned when resizing the screen.\n          isTransitioning &&\n            'image-carousel__row--transitioning',\n        )}\n        style={{\n          transform: imageWidth\n            ? `translateX(-${currIndex * imageWidth}px)`\n            : undefined,\n        }}\n        onTransitionEnd={() => {\n          setIsTransitioning(false);\n        }}>\n        {images.map(({ alt, src }) => (\n          <img\n            alt={alt}\n            src={src}\n            key={src}\n            className={clsx('image-carousel__image')}\n          />\n        ))}\n      </div>\n      <button\n        aria-label=\"Previous image\"\n        disabled={isTransitioning}\n        className=\"image-carousel__button image-carousel__button--prev\"\n        onClick={() => {\n          changeCurrIndex(currIndex - 1);\n        }}>\n        &#10094;\n      </button>\n      <div className=\"image-carousel__pages\">\n        {images.map(({ alt, src }, index) => (\n          <button\n            aria-label={`Navigate to ${alt}`}\n            className={clsx(\n              'image-carousel__pages__button',\n              index === currIndex &&\n                'image-carousel__pages__button--active',\n            )}\n            disabled={isTransitioning}\n            key={src}\n            onClick={() => {\n              changeCurrIndex(index);\n            }}\n          />\n        ))}\n      </div>\n      <button\n        aria-label=\"Next image\"\n        className=\"image-carousel__button image-carousel__button--next\"\n        disabled={isTransitioning}\n        onClick={() => {\n          changeCurrIndex(currIndex + 1);\n        }}>\n        &#10095;\n      </button>\n    </div>\n  );\n}\n"
    },
    "/src/index.tsx": {
      "code": "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root')!);\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "* {\n  box-sizing: border-box;\n  margin: 0;\n}\n\nbody {\n  font-family: sans-serif;\n}\n\n.wrapper {\n  display: flex;\n  flex-direction: column;\n  width: 100vw;\n  height: 100vh;\n  justify-content: center;\n  align-items: center;\n}\n\n.image-carousel {\n  background-color: #000;\n  height: 400px;\n  overflow: hidden;\n  width: min(600px, 100vw);\n  position: relative;\n}\n\n.image-carousel__row {\n  display: flex;\n  position: absolute;\n  inset: 0;\n}\n\n.image-carousel__row--transitioning {\n  transition: transform 0.5s linear;\n}\n\n.image-carousel__image {\n  object-fit: contain;\n  height: 400px;\n  width: min(600px, 100vw);\n}\n\n.image-carousel__button {\n  --size: 40px;\n  height: var(--size);\n  width: var(--size);\n\n  background-color: #0008;\n  border-radius: 100%;\n  border: none;\n  color: #fff;\n  cursor: pointer;\n\n  position: absolute;\n  top: 50%;\n  transform: translateY(-50%);\n}\n\n.image-carousel__button:hover {\n  background-color: #000b;\n}\n\n.image-carousel__button--prev {\n  left: 16px;\n}\n\n.image-carousel__button--next {\n  right: 16px;\n}\n\n.image-carousel__pages {\n  background-color: #0008;\n  border-radius: 12px;\n  display: inline-flex;\n  gap: 8px;\n  padding: 8px;\n\n  position: absolute;\n  bottom: 24px;\n  left: 50%;\n  transform: translateX(-50%);\n}\n\n.image-carousel__pages__button {\n  --size: 8px;\n  height: var(--size);\n  width: var(--size);\n\n  border: none;\n  border-radius: 100%;\n  background-color: #666;\n  cursor: pointer;\n  display: inline-block;\n  flex-shrink: 0;\n  padding: 0;\n  transition: background-color 0.3s ease-in-out;\n}\n\n.image-carousel__pages__button:hover {\n  background-color: #ccc;\n}\n\n.image-carousel__pages__button--active {\n  background-color: #fff;\n}\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"include\": [\"**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.tsx",
      "/src/ImageCarousel.tsx",
      "/src/styles.css"
    ],
    "activeFile": "/src/ImageCarousel.tsx",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var x=Object.create;var l=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var _=Object.getOwnPropertyNames;var S=Object.getPrototypeOf,C=Object.prototype.hasOwnProperty;var z=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),T=(t,e)=>{for(var r in e)l(t,r,{get:e[r],enumerable:!0})},m=(t,e,r,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of _(e))!C.call(t,s)&&s!==r&&l(t,s,{get:()=>e[s],enumerable:!(d=j(e,s))||d.enumerable});return t};var c=(t,e,r)=>(r=t!=null?x(S(t)):{},m(e||!t||!t.__esModule?l(r,\"default\",{value:t,enumerable:!0}):r,t)),O=t=>m(l({},\"__esModule\",{value:!0}),t);var h=z((k,g)=>{g.exports=_jsx_runtime});var W={};T(W,{default:()=>I});var o=c(h());var n=c(h());function u(t){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",h4:\"h4\",code:\"code\",a:\"a\",pre:\"pre\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",ol:\"ol\",li:\"li\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Structure\"}),`\n`,(0,n.jsx)(e.p,{children:\"One of the easiest way to implement an image carousel is rendering all the images in a horizontal fashion within a container (the images will overflow horizontally) and changing the horizontal offset.\"}),`\n`,(0,n.jsx)(e.p,{children:\"With this structure, navigating between images can be done in two ways: (1) changing the container's scroll position and (2) CSS transforms on the container.\"}),`\n`,(0,n.jsx)(e.h4,{children:\"1. Scroll position\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"By placing the images in a row and restricting the container to be the same size as the image carousel dimensions, the images will take up a longer horizontal space than the container and to view the various images, the \",(0,n.jsx)(e.code,{children:\"scrollOffset\"}),\" of the container can be modified. Combined with the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_scroll_snap\",children:\"CSS scroll snap\"}),\" property, touchpad and touchscreen users can scroll/swipe through the images horizontally. This method doesn't involve JavaScript at all and is highly recommended if all you need is a basic horizontal image carousel.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To support pagination button interactions, you can programmatically set the scroll position by using the \",(0,n.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/scroll\",children:[(0,n.jsx)(e.code,{children:\"Element.scroll()\"}),\" method\"]}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`containerEl.scroll({\n  left: 100, // Calculate this offset value based on size of the image.\n  behavior: 'smooth', // Smooth transitions for free!\n});\n`})}),`\n`,(0,n.jsx)(e.h4,{children:\"2. CSS transforms\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The other way to change the displayed image is to add \",(0,n.jsx)(e.code,{children:\"transform: translateX(100px)\"}),\" on the container. The value to translate by depends on the size of the image. The solution implements this method since it is slightly more complex to implement and provides more learning value.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Determining how much to scroll/translate by\"}),`\n`,(0,n.jsx)(e.p,{children:\"Using this offset technique, for the various images:\"}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Image no.\"}),(0,n.jsx)(e.th,{children:\"Offset\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"1\"}),(0,n.jsx)(e.td,{children:\"0\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"2\"}),(0,n.jsx)(e.td,{children:\"One image width\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"3\"}),(0,n.jsx)(e.td,{children:\"Two image width\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"4\"}),(0,n.jsx)(e.td,{children:\"Three image width\"})]})]})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Observe that the offset can be determined with \",(0,n.jsx)(e.code,{children:\"(index - 1) * imageWidth\"}),\". However, because the images have a dynamic width (when the screen is narrower than 600px), the image width value is not available ahead of time and has to be calculated during runtime.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can obtain a reference to the image carousel's root element and use \",(0,n.jsx)(e.code,{children:\"el.getBoundingClientRect().width\"}),\" to get an image's width.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Transitions\"}),`\n`,(0,n.jsx)(e.p,{children:\"With the CSS transform method, transitions can be easily enabled by the following CSS:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-css\",children:`transition: transform 0.5s linear;\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Just by setting the \",(0,n.jsx)(e.code,{children:\"transform\"}),\" property to a new \",(0,n.jsx)(e.code,{children:\"translateX()\"}),\" value, the browser will transition the container smoothly to the new position, displaying the new image.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Resizing\"}),`\n`,(0,n.jsx)(e.p,{children:\"One issue with using an offset-based approach for transitions is that if the width of the image carousel changes, the current offset (which is based on the image dimensions) will no longer be accurate.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Therefore we need to listen for window \",(0,n.jsx)(e.code,{children:\"resize\"}),\" events and make the \",(0,n.jsx)(e.code,{children:\"imageWidth\"}),\" as part of the component state, so that the component updates the offset if/when the \",(0,n.jsx)(e.code,{children:\"imageWidth\"}),\" changes.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If the \",(0,n.jsx)(e.code,{children:\"transition\"}),\" styles are permanently on the image container, when the offset changes due to resizing, some transition will be seen and looks a little odd. Hence the \",(0,n.jsx)(e.code,{children:\"transition\"}),\" styles should only be added when offset changes due to navigation events and not resizing.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Downsides of an offset-based approach\"}),`\n`,(0,n.jsx)(e.p,{children:\"The offset-based approach was relatively easy to implement. You should also be aware of the downsides of this approach:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Larger DOM footprint\"}),\": All the images are present in the DOM from the get-go. If there are many images, it could result in poor performance. This can be mitigated with list virtualization and/or lazy loading of images.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Transition distance can be huge\"}),\": Transitioning from the first image to the last image or vice-versa (more generally speaking, across multiple images) can be a jarring experience because the browser will scroll through all the intermediate images.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Follow up\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"There are many ways to implement image carousels, each with its own advantages and limitations. \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel-iii\",children:\"Image Carousel III\"}),\" explores a different, more performant approach, where only the current image and next image is rendered into the DOM and addresses some of the downsides of the offset-based approach.\"]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var p=M;var a=c(h());function f(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,a.jsxs)(e.ul,{children:[`\n`,(0,a.jsx)(e.li,{children:\"Ensure test cases for basic navigation still pass.\"}),`\n`,(0,a.jsx)(e.li,{children:\"Click the navigation buttons in rapid succession (while the transition is ongoing) and check that no unexpected behavior occurs.\"}),`\n`]})]})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,a.jsx)(e,Object.assign({},t,{children:(0,a.jsx)(f,t)})):f(t)}var b=D;var i=c(h());function w(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",strong:\"strong\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"All images should have \",(0,i.jsx)(e.code,{children:\"alt\"}),\" text that describes the image to support accessibility. It will be read out loud by screen readers and is also used by search engines.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Add appropriate \",(0,i.jsx)(e.code,{children:\"aria-label\"}),\"s to the buttons since the buttons do not have visible labels.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"[Not implemented]\"}),\": Add a screen-reader-only element with the \",(0,i.jsx)(e.code,{children:'aria-live=\"polite\"'}),\" attribute and \",(0,i.jsx)(e.code,{children:\"alt\"}),\" text of the new image as contents. This instructs screen readers to announce that a new image is displayed.\"]}),`\n`]})]})}function X(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(w,t)})):w(t)}var y=X;function v(t){return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(p,{}),`\n`,(0,o.jsx)(b,{}),`\n`,(0,o.jsx)(y,{})]})}function F(t={}){let{wrapper:e}=t.components||{};return e?(0,o.jsx)(e,Object.assign({},t,{children:(0,o.jsx)(v,t)})):v(t)}var I=F;return O(W);})();\n;return Component;"
}