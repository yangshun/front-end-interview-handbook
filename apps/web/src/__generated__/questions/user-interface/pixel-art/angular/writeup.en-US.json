{
  "skeleton": "var Component=(()=>{var m=Object.create;var c=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var j=(l,e)=>()=>(e||l((e={exports:{}}).exports,e),e.exports),v=(l,e)=>{for(var i in e)c(l,i,{get:e[i],enumerable:!0})},a=(l,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of x(e))!b.call(l,r)&&r!==i&&c(l,r,{get:()=>e[r],enumerable:!(o=g(e,r))||o.enumerable});return l};var h=(l,e,i)=>(i=l!=null?m(w(l)):{},a(e||!l||!l.__esModule?c(i,\"default\",{value:l,enumerable:!0}):i,l)),C=l=>a(c({},\"__esModule\",{value:!0}),l);var d=j((B,s)=>{s.exports=_jsx_runtime});var y={};v(y,{default:()=>M});var t=h(d());var n=h(d());function p(l){let e=Object.assign({p:\"p\",img:\"img\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",a:\"a\"},l.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Build a pixel art drawing tool where users can paint pixels with selected colors and also erase colored pixels.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/img/questions/pixel-art/pixel-art-example.png\",alt:\"Pixel art example\"})}),`\n`,(0,n.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Canvas\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"A 15 x 15 grid of cells. Each cell is 20px x 20px.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Pixels alternate between white and gray.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Modes\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:'There are 2 modes available: \"Draw\" and \"Erase\"'}),`\n`,(0,n.jsx)(e.li,{children:\"Clicking on the individual tab item will activate the respective mode.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Colorpicker\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"A color can be selected from the list of colors. Selected colors will have a black border to indicate the selected state.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Drawing mode\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Clicking on a cell with paint it with the currently-selected color.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Dragging on the canvas will fill the underlying pixel with the selected color.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Erasing mode\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Clicking on a cell with remove any color from that cell.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Dragging on the canvas while this mode is selected will remove colors from that cell.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Colors:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"White: \",(0,n.jsx)(e.code,{children:\"#ffffff\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Gray: \",(0,n.jsx)(e.code,{children:\"#e9ecef\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Black: \",(0,n.jsx)(e.code,{children:\"#000\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Red: \",(0,n.jsx)(e.code,{children:\"#cc0001\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Orange: \",(0,n.jsx)(e.code,{children:\"#fb940b\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Yellow: \",(0,n.jsx)(e.code,{children:\"#ffff01\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Green: \",(0,n.jsx)(e.code,{children:\"#01cc00\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Teal: \",(0,n.jsx)(e.code,{children:\"#38d9a9\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Blue: \",(0,n.jsx)(e.code,{children:\"#228be6\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Purple: \",(0,n.jsx)(e.code,{children:\"#7950f2\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Beige: \",(0,n.jsx)(e.code,{children:\"#ff8787\"})]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Source\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This question is adapted from \",(0,n.jsx)(e.a,{href:\"https://sadanandpai.github.io/frontend-mini-challenges/javascript/src/challenges/pixel-art/\",children:\"Front End Mini Challenges\"}),\".\"]})]})}function D(l={}){let{wrapper:e}=l.components||{};return e?(0,n.jsx)(e,Object.assign({},l,{children:(0,n.jsx)(p,l)})):p(l)}var u=D;function f(l){return(0,t.jsx)(u,{})}function _(l={}){let{wrapper:e}=l.components||{};return e?(0,t.jsx)(e,Object.assign({},l,{children:(0,t.jsx)(f,l)})):f(l)}var M=_;return C(y);})();\n;return Component;",
  "solution": "var Component=(()=>{var y=Object.create;var s=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var T=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),D=(n,e)=>{for(var i in e)s(n,i,{get:e[i],enumerable:!0})},u=(n,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of C(e))!k.call(n,c)&&c!==i&&s(n,c,{get:()=>e[c],enumerable:!(d=j(e,c))||d.enumerable});return n};var h=(n,e,i)=>(i=n!=null?y(_(n)):{},u(e||!n||!n.__esModule?s(i,\"default\",{value:n,enumerable:!0}):i,n)),M=n=>u(s({},\"__esModule\",{value:!0}),n);var a=T((E,g)=>{g.exports=_jsx_runtime});var A={};D(A,{default:()=>W});var r=h(a());var t=h(a());function m(n){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"The solution consist of two parts: (1) Canvas and (2) Toolbar.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"State\"}),`\n`,(0,t.jsx)(e.p,{children:\"We'll need the following states within the application:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Mode: Whether the app is in drawing or erasing mode.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Selected color: Active color for drawing.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Canvas colors: A 2-d array of color values, representing the pixel art canvas.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Dragging: Whether the cursor is in the dragging state.\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"The current mode and selected color state can reside within the top-level component while the canvas colors and dragging state is only needed within the canvas.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Toolbar\"}),`\n`,(0,t.jsx)(e.p,{children:\"Rendering the toolbar component is pretty straightforward. The various buttons within the toolbar will update the mode and the selected color.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The only thing to note is to use a non-transparent border for white-color cells and a non-black border when black color is selected.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Canvas\"}),`\n`,(0,t.jsx)(e.p,{children:\"There are many ways to render the canvas, and we have opted to use rows of flexboxes instead of CSS grid (which uses a linear array of cells) here because it's easier to render the alternating background for the empty cells.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We'll add a \",(0,t.jsx)(e.code,{children:\"mousedown\"}),\" listener to the top-level DOM element within the canvas and change the state to be dragging when that happens. When the \",(0,t.jsx)(e.code,{children:\"mouseup\"}),\" even is fired, the dragging state is reset.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The canvas contains many cells and each cell is a pixel that is either empty or filled with a color. The cell listens for two events:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"mousedown\"}),\": Trigger the drawing/erasing of the cell. We want the selected action to be triggered immediately when the mouse is pressed, hence the \",(0,t.jsx)(e.code,{children:\"mousedown\"}),\" event is used as opposed to \",(0,t.jsx)(e.code,{children:\"click\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"mouseenter\"}),\": Trigger the drawing/erasing of the cell. This event is only needed when the canvas is in the dragging state.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Depending on the current mode, the cells grid will be updated with the new color, or the color is erased from the cell.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Inline styles are used for the background color of the cells to allow for easy changing of the hex values without having to create CSS classes for each possible color.\"})]})}function S(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var p=S;var o=h(a());function w(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Canvas should contain a 15 x 15 grid of cells.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Canvas should not have any colors applied on initial load.\"}),`\n`,(0,o.jsxs)(e.li,{children:[\"Toolbar should render the mode picker and colorpicker.\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Mode picker allows selection of modes.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Colorpicker allows selection of colors. Black and white are rendered fine.\"}),`\n`]}),`\n`]}),`\n`,(0,o.jsxs)(e.li,{children:[\"Drawing mode\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Clicking once on a Cell while drawing should color that cell.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Dragging over cells while drawing should color those cells with the selected color\"}),`\n`,(0,o.jsx)(e.li,{children:\"Drawing over an already-colored cell with a different color should update the cell with that color.\"}),`\n`]}),`\n`]}),`\n`,(0,o.jsxs)(e.li,{children:[\"Erasing mode\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Clicking once on a cell while erasing should erase that cell's color.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Clicking and dragging over multiple cells while erasing should remove those cell's colors.\"}),`\n`]}),`\n`]}),`\n`]})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,o.jsx)(e,Object.assign({},n,{children:(0,o.jsx)(w,n)})):w(n)}var f=F;var l=h(a());function b(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\"},n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,l.jsxs)(e.ul,{children:[`\n`,(0,l.jsxs)(e.li,{children:[\"Use \",(0,l.jsx)(e.code,{children:\"<button>\"}),'s for interactive elements such as the \"Draw\"/\"Erase\" buttons, and colorpicker options.']}),`\n`,(0,l.jsxs)(e.li,{children:[\"Add \",(0,l.jsx)(e.code,{children:\"aria-label\"}),\"s to the color options button since they have no visible labels.\"]}),`\n`,(0,l.jsxs)(e.li,{children:[\"Since each canvas cell is a \",(0,l.jsx)(e.code,{children:\"<button>\"}),\", you can \",(0,l.jsx)(\"kbd\",{children:\"Tab\"}),\" through them and use \",(0,l.jsx)(\"kbd\",{children:\"Space\"}),\" to trigger the currently selected action on them. For extra credit, you can add keyboard navigation (up, down, left, right) to easily navigate through the cells, draw with \",(0,l.jsx)(\"kbd\",{children:\"Enter\"}),\" and erase with \",(0,l.jsx)(\"kbd\",{children:\"Backspace\"}),\".\"]}),`\n`]})]})}function O(n={}){let{wrapper:e}=n.components||{};return e?(0,l.jsx)(e,Object.assign({},n,{children:(0,l.jsx)(b,n)})):b(n)}var v=O;function x(n){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(p,{}),`\n`,(0,r.jsx)(f,{}),`\n`,(0,r.jsx)(v,{})]})}function X(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(x,n)})):x(n)}var W=X;return M(A);})();\n;return Component;"
}