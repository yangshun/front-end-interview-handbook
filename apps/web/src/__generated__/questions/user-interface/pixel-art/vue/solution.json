{
  "author": "willnguyen1312",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/pixel-art-vue-solution\",\n  \"author\": \"willnguyen1312\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/main.js\",\n  \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\"\n  },\n  \"dependencies\": {\n    \"core-js\": \"3.32.2\",\n    \"vue\": \"3.3.4\"\n  },\n  \"devDependencies\": {\n    \"@vue/cli-plugin-babel\": \"5.0.8\",\n    \"@vue/cli-service\": \"5.0.8\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width,initial-scale=1.0\" />\n    <title>Vue</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- Built files will be auto injected -->\n  </body>\n</html>\n"
    },
    "/src/App.vue": {
      "code": "<script setup lang=\"ts\">\nimport { ref } from 'vue';\nimport Canvas from './Canvas.vue';\nimport Toolbar from './Toolbar.vue';\nimport { Color, Mode } from './colors';\n\nconst mode = ref<Mode>('draw');\nconst selectedColor = ref<Color>('black');\n</script>\n\n<template>\n  <div class=\"app\">\n    <Canvas\n      :selectedColor=\"selectedColor\"\n      :mode=\"mode\"\n      :initialRows=\"15\"\n      :initialColumns=\"15\" />\n    <Toolbar\n      v-model:selectedColor=\"selectedColor\"\n      v-model:mode=\"mode\" />\n  </div>\n</template>\n\n<style>\n.app {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n}\n</style>\n"
    },
    "/src/Canvas.vue": {
      "code": "<script setup lang=\"ts\">\nimport { ref } from 'vue';\nimport { COLORS, Color, Mode } from './colors';\nconst props = defineProps<{\n  mode: Mode;\n  selectedColor: Color;\n  initialRows: number;\n  initialColumns: number;\n}>();\n\nconst grid = ref<(Color | null)[][]>(\n  Array.from({ length: props.initialRows }, () =>\n    Array(props.initialColumns).fill(null),\n  ),\n);\n\nconst isDragging = ref(false);\n\nfunction mark(rowIndex: number, cellIndex: number) {\n  grid.value[rowIndex][cellIndex] =\n    props.mode === 'erase' ? null : props.selectedColor;\n}\n</script>\n\n<template>\n  <div\n    class=\"grid\"\n    @mousedown=\"isDragging = true\"\n    @mouseup=\"isDragging = false\">\n    <div\n      v-for=\"(row, rowIndex) in grid\"\n      :class=\"[\n        'grid__row',\n        rowIndex % 2 === 0\n          ? 'grid__row--even'\n          : 'grid__row--odd',\n      ]\"\n      :key=\"rowIndex\">\n      <button\n        v-for=\"(cellColor, cellIndex) in row\"\n        :key=\"cellIndex\"\n        @click=\"mark(rowIndex, cellIndex)\"\n        @mousedown=\"mark(rowIndex, cellIndex)\"\n        @mouseenter=\"\n          () => {\n            if (isDragging) {\n              mark(rowIndex, cellIndex);\n            }\n          }\n        \"\n        :style=\"{\n          'background-color':\n            cellColor != null\n              ? COLORS[cellColor]\n              : undefined,\n        }\"\n        class=\"grid__cell\" />\n    </div>\n  </div>\n</template>\n\n<style>\n.grid {\n  display: flex;\n  flex-direction: column;\n}\n\n.grid__row {\n  display: flex;\n  flex-shrink: 0;\n}\n\n.grid__cell {\n  --cell-size: 20px;\n\n  height: var(--cell-size);\n  width: var(--cell-size);\n  border: 0;\n  flex-shrink: 0;\n  background-color: transparent;\n}\n\n.grid__row--even .grid__cell:nth-child(odd),\n.grid__row--odd .grid__cell:nth-child(even) {\n  background-color: #e9ecef;\n}\n</style>\n"
    },
    "/src/colors.ts": {
      "code": "export const COLORS = {\n  white: '#fff',\n  gray: '#e9ecef',\n  black: '#000',\n  red: '#cc0001',\n  orange: '#fb940b',\n  yellow: '#ffff01',\n  green: '#01cc00',\n  teal: '#38d9a9',\n  blue: '#228be6',\n  purple: '#7950f2',\n  beige: '#ff8787',\n} as const;\nexport type Color = keyof typeof COLORS;\n\nexport type Mode = 'draw' | 'erase';\n"
    },
    "/src/main.js": {
      "code": "import { createApp } from 'vue';\nimport App from './App.vue';\n\nimport './styles.css';\n\ncreateApp(App).mount('#app');\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n"
    },
    "/src/Toolbar.vue": {
      "code": "<script setup lang=\"ts\">\nimport { COLORS, Color, Mode } from './colors';\n\nconst props = defineProps<{\n  mode: Mode;\n  selectedColor: Color;\n}>();\n\nconst emit = defineEmits<{\n  'update:mode': [value: Mode];\n  'update:selectedColor': [value: Color];\n}>();\n</script>\n\n<template>\n  <div class=\"toolbar\">\n    <div>\n      <button\n        @click=\"() => $emit('update:mode', 'draw')\"\n        :class=\"[\n          'toolbar__mode',\n          mode === 'draw' && 'toolbar__mode--selected',\n        ]\">\n        Draw\n      </button>\n      <button\n        @click=\"() => $emit('update:mode', 'erase')\"\n        :class=\"[\n          'toolbar__mode',\n          mode === 'erase' && 'toolbar__mode--selected',\n        ]\">\n        Erase\n      </button>\n    </div>\n    <div class=\"toolbar__color-picker\">\n      <button\n        v-for=\"[color, hex] in Object.entries(COLORS)\"\n        :key=\"color\"\n        :aria-label=\"color\"\n        :class=\"[\n          'toolbar__color',\n          color === selectedColor &&\n            'toolbar__color--selected',\n        ]\"\n        :style=\"{\n          'border-color': (() => {\n            if (\n              color !== selectedColor &&\n              color === 'white'\n            ) {\n              return '#ccc';\n            }\n\n            if (\n              color === selectedColor &&\n              color === 'black'\n            ) {\n              return '#fff';\n            }\n          })(),\n          'background-color': hex,\n        }\"\n        @click=\"\n          () => {\n            $emit('update:selectedColor', color);\n            $emit('update:mode', 'draw');\n          }\n        \" />\n    </div>\n  </div>\n</template>\n\n<style>\n.toolbar {\n  display: flex;\n  gap: 20px;\n}\n\n.toolbar .toolbar__mode {\n  height: 36px;\n  background-color: transparent;\n  border: 2px solid black;\n  font-size: 14px;\n}\n\n.toolbar .toolbar__mode--selected {\n  background-color: black;\n  color: white;\n}\n\n.toolbar .toolbar__color-picker {\n  display: flex;\n}\n\n.toolbar .toolbar__color {\n  --size: 20px;\n\n  width: var(--size);\n  height: var(--size);\n  border: 2px solid transparent;\n}\n\n.toolbar .toolbar__color--selected {\n  border: 2px solid black;\n}\n</style>\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.vue"
    ],
    "activeFile": "/src/App.vue",
    "environment": "vue-cli"
  },
  "writeup": "var Component=(()=>{var y=Object.create;var s=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var T=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),D=(n,e)=>{for(var i in e)s(n,i,{get:e[i],enumerable:!0})},u=(n,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of C(e))!k.call(n,c)&&c!==i&&s(n,c,{get:()=>e[c],enumerable:!(d=j(e,c))||d.enumerable});return n};var h=(n,e,i)=>(i=n!=null?y(_(n)):{},u(e||!n||!n.__esModule?s(i,\"default\",{value:n,enumerable:!0}):i,n)),M=n=>u(s({},\"__esModule\",{value:!0}),n);var a=T((E,g)=>{g.exports=_jsx_runtime});var A={};D(A,{default:()=>W});var r=h(a());var t=h(a());function m(n){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"The solution consist of two parts: (1) Canvas and (2) Toolbar.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"State\"}),`\n`,(0,t.jsx)(e.p,{children:\"We'll need the following states within the application:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Mode: Whether the app is in drawing or erasing mode.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Selected color: Active color for drawing.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Canvas colors: A 2-d array of color values, representing the pixel art canvas.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Dragging: Whether the cursor is in the dragging state.\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"The current mode and selected color state can reside within the top-level component while the canvas colors and dragging state is only needed within the canvas.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Toolbar\"}),`\n`,(0,t.jsx)(e.p,{children:\"Rendering the toolbar component is pretty straightforward. The various buttons within the toolbar will update the mode and the selected color.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The only thing to note is to use a non-transparent border for white-color cells and a non-black border when black color is selected.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Canvas\"}),`\n`,(0,t.jsx)(e.p,{children:\"There are many ways to render the canvas, and we have opted to use rows of flexboxes instead of CSS grid (which uses a linear array of cells) here because it's easier to render the alternating background for the empty cells.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We'll add a \",(0,t.jsx)(e.code,{children:\"mousedown\"}),\" listener to the top-level DOM element within the canvas and change the state to be dragging when that happens. When the \",(0,t.jsx)(e.code,{children:\"mouseup\"}),\" even is fired, the dragging state is reset.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The canvas contains many cells and each cell is a pixel that is either empty or filled with a color. The cell listens for two events:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"mousedown\"}),\": Trigger the drawing/erasing of the cell. We want the selected action to be triggered immediately when the mouse is pressed, hence the \",(0,t.jsx)(e.code,{children:\"mousedown\"}),\" event is used as opposed to \",(0,t.jsx)(e.code,{children:\"click\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"mouseenter\"}),\": Trigger the drawing/erasing of the cell. This event is only needed when the canvas is in the dragging state.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Depending on the current mode, the cells grid will be updated with the new color, or the color is erased from the cell.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Inline styles are used for the background color of the cells to allow for easy changing of the hex values without having to create CSS classes for each possible color.\"})]})}function S(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var p=S;var o=h(a());function w(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Canvas should contain a 15 x 15 grid of cells.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Canvas should not have any colors applied on initial load.\"}),`\n`,(0,o.jsxs)(e.li,{children:[\"Toolbar should render the mode picker and colorpicker.\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Mode picker allows selection of modes.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Colorpicker allows selection of colors. Black and white are rendered fine.\"}),`\n`]}),`\n`]}),`\n`,(0,o.jsxs)(e.li,{children:[\"Drawing mode\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Clicking once on a Cell while drawing should color that cell.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Dragging over cells while drawing should color those cells with the selected color\"}),`\n`,(0,o.jsx)(e.li,{children:\"Drawing over an already-colored cell with a different color should update the cell with that color.\"}),`\n`]}),`\n`]}),`\n`,(0,o.jsxs)(e.li,{children:[\"Erasing mode\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Clicking once on a cell while erasing should erase that cell's color.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Clicking and dragging over multiple cells while erasing should remove those cell's colors.\"}),`\n`]}),`\n`]}),`\n`]})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,o.jsx)(e,Object.assign({},n,{children:(0,o.jsx)(w,n)})):w(n)}var f=F;var l=h(a());function b(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\"},n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,l.jsxs)(e.ul,{children:[`\n`,(0,l.jsxs)(e.li,{children:[\"Use \",(0,l.jsx)(e.code,{children:\"<button>\"}),'s for interactive elements such as the \"Draw\"/\"Erase\" buttons, and colorpicker options.']}),`\n`,(0,l.jsxs)(e.li,{children:[\"Add \",(0,l.jsx)(e.code,{children:\"aria-label\"}),\"s to the color options button since they have no visible labels.\"]}),`\n`,(0,l.jsxs)(e.li,{children:[\"Since each canvas cell is a \",(0,l.jsx)(e.code,{children:\"<button>\"}),\", you can \",(0,l.jsx)(\"kbd\",{children:\"Tab\"}),\" through them and use \",(0,l.jsx)(\"kbd\",{children:\"Space\"}),\" to trigger the currently selected action on them. For extra credit, you can add keyboard navigation (up, down, left, right) to easily navigate through the cells, draw with \",(0,l.jsx)(\"kbd\",{children:\"Enter\"}),\" and erase with \",(0,l.jsx)(\"kbd\",{children:\"Backspace\"}),\".\"]}),`\n`]})]})}function O(n={}){let{wrapper:e}=n.components||{};return e?(0,l.jsx)(e,Object.assign({},n,{children:(0,l.jsx)(b,n)})):b(n)}var v=O;function x(n){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(p,{}),`\n`,(0,r.jsx)(f,{}),`\n`,(0,r.jsx)(v,{})]})}function X(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(x,n)})):x(n)}var W=X;return M(A);})();\n;return Component;"
}