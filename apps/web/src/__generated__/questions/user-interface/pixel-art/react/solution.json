{
  "author": "yangshun",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/pixel-art-react-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.0\",\n    \"@types/react-dom\": \"18.2.0\",\n    \"typescript\": \"5.0.2\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.tsx": {
      "code": "import { useState } from 'react';\nimport Canvas from './Canvas';\nimport Toolbar from './Toolbar';\nimport { Color, Mode } from './colors';\n\nexport default function App() {\n  const [mode, setMode] = useState<Mode>('draw');\n  const [selectedColor, setColor] =\n    useState<Color>('black');\n\n  return (\n    <div className=\"app\">\n      <Canvas selectedColor={selectedColor} mode={mode} />\n      <Toolbar\n        selectedColor={selectedColor}\n        onColorChange={setColor}\n        mode={mode}\n        onModeChange={setMode}\n      />\n    </div>\n  );\n}\n"
    },
    "/src/Canvas.tsx": {
      "code": "import { useState } from 'react';\n\nimport Cell from './Cell';\nimport { Color, Mode } from './colors';\n\ntype Props = Readonly<{\n  selectedColor: Color;\n  initialRows?: number;\n  initialColumns?: number;\n  mode: Mode;\n}>;\n\nexport default function Canvas({\n  selectedColor,\n  mode,\n  initialRows = 15,\n  initialColumns = 15,\n}: Props) {\n  const [grid, setGrid] = useState<(Color | null)[][]>(\n    Array.from({ length: initialRows }, () =>\n      Array(initialColumns).fill(null),\n    ),\n  );\n  const [isDragging, setIsDragging] = useState(false);\n\n  return (\n    <div\n      className=\"grid\"\n      onMouseDown={() => setIsDragging(true)}\n      onMouseUp={() => setIsDragging(false)}>\n      {grid.map((row, rowIndex) => (\n        <div\n          className={[\n            'grid__row',\n            rowIndex % 2 === 0\n              ? 'grid__row--even'\n              : 'grid__row--odd',\n          ].join(' ')}\n          key={rowIndex}>\n          {row.map((cellColor, cellIndex) => (\n            <Cell\n              key={cellIndex}\n              color={cellColor}\n              isDragging={isDragging}\n              onMark={() => {\n                const newGrid = grid.map((row) => [...row]);\n                newGrid[rowIndex][cellIndex] =\n                  mode === 'erase' ? null : selectedColor;\n                setGrid(newGrid);\n              }}\n            />\n          ))}\n        </div>\n      ))}\n    </div>\n  );\n}\n"
    },
    "/src/Cell.tsx": {
      "code": "import { COLORS, Color } from './colors';\n\ntype Props = Readonly<{\n  color: Color | null;\n  isDragging: boolean;\n  onMark: () => void;\n}>;\n\nexport default function Cell({\n  color,\n  isDragging,\n  onMark,\n}: Props) {\n  return (\n    <button\n      onClick={onMark}\n      onMouseDown={onMark}\n      onMouseEnter={isDragging ? onMark : undefined}\n      style={{\n        backgroundColor:\n          color != null ? COLORS[color] : undefined,\n      }}\n      className=\"grid__cell\"\n    />\n  );\n}\n"
    },
    "/src/colors.ts": {
      "code": "export const COLORS = {\n  white: '#fff',\n  gray: '#e9ecef',\n  black: '#000',\n  red: '#cc0001',\n  orange: '#fb940b',\n  yellow: '#ffff01',\n  green: '#01cc00',\n  teal: '#38d9a9',\n  blue: '#228be6',\n  purple: '#7950f2',\n  beige: '#ff8787',\n} as const;\nexport type Color = keyof typeof COLORS;\n\nexport type Mode = 'draw' | 'erase';\n"
    },
    "/src/index.tsx": {
      "code": "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root')!);\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n.app {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n}\n\n.grid {\n  display: flex;\n  flex-direction: column;\n}\n\n.grid__row {\n  display: flex;\n  flex-shrink: 0;\n}\n\n.grid__cell {\n  --cell-size: 20px;\n\n  height: var(--cell-size);\n  width: var(--cell-size);\n  border: 0;\n  flex-shrink: 0;\n  background-color: transparent;\n}\n\n.grid__row--even .grid__cell:nth-child(odd),\n.grid__row--odd .grid__cell:nth-child(even) {\n  background-color: #e9ecef;\n}\n\n.toolbar {\n  display: flex;\n  gap: 20px;\n}\n\n.toolbar .toolbar__mode {\n  height: 36px;\n  background-color: transparent;\n  border: 2px solid black;\n  font-size: 14px;\n}\n\n.toolbar .toolbar__mode--selected {\n  background-color: black;\n  color: white;\n}\n\n.toolbar .toolbar__color-picker {\n  display: flex;\n}\n\n.toolbar .toolbar__color {\n  --size: 20px;\n\n  width: var(--size);\n  height: var(--size);\n  border: 2px solid transparent;\n}\n\n.toolbar .toolbar__color--selected {\n  border: 2px solid black;\n}\n"
    },
    "/src/Toolbar.tsx": {
      "code": "import { COLORS, Color, Mode } from './colors';\n\ntype Props = Readonly<{\n  selectedColor: Color;\n  onColorChange: (color: Color) => void;\n  mode: Mode;\n  onModeChange: (mode: Mode) => void;\n}>;\n\nexport default function Toolbar({\n  selectedColor,\n  onColorChange,\n  mode,\n  onModeChange,\n}: Props) {\n  function onColorClick(color: Color) {\n    onModeChange('draw');\n    onColorChange(color);\n  }\n\n  return (\n    <div className=\"toolbar\">\n      <div>\n        <button\n          onClick={() => onModeChange('draw')}\n          className={[\n            'toolbar__mode',\n            mode === 'draw' && 'toolbar__mode--selected',\n          ]\n            .filter(Boolean)\n            .join(' ')}>\n          Draw\n        </button>\n        <button\n          onClick={() => onModeChange('erase')}\n          className={[\n            'toolbar__mode',\n            mode === 'erase' && 'toolbar__mode--selected',\n          ]\n            .filter(Boolean)\n            .join(' ')}>\n          Erase\n        </button>\n      </div>\n      <div className=\"toolbar__color-picker\">\n        {Object.entries(COLORS).map(([color, hex]) => (\n          <button\n            key={color}\n            aria-label={color}\n            className={[\n              'toolbar__color',\n              color === selectedColor &&\n                'toolbar__color--selected',\n            ]\n              .filter(Boolean)\n              .join(' ')}\n            style={{\n              borderColor: (() => {\n                if (\n                  color !== selectedColor &&\n                  color === 'white'\n                ) {\n                  return '#ccc';\n                }\n\n                if (\n                  color === selectedColor &&\n                  color === 'black'\n                ) {\n                  return '#fff';\n                }\n              })(),\n              backgroundColor: hex as string,\n            }}\n            onClick={() => onColorClick(color as Color)}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.tsx",
      "/src/Canvas.tsx",
      "/src/Cell.tsx",
      "/src/Toolbar.tsx",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.tsx",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var y=Object.create;var s=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var C=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var T=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),D=(n,e)=>{for(var i in e)s(n,i,{get:e[i],enumerable:!0})},u=(n,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of C(e))!k.call(n,c)&&c!==i&&s(n,c,{get:()=>e[c],enumerable:!(d=j(e,c))||d.enumerable});return n};var h=(n,e,i)=>(i=n!=null?y(_(n)):{},u(e||!n||!n.__esModule?s(i,\"default\",{value:n,enumerable:!0}):i,n)),M=n=>u(s({},\"__esModule\",{value:!0}),n);var a=T((E,g)=>{g.exports=_jsx_runtime});var A={};D(A,{default:()=>W});var r=h(a());var t=h(a());function m(n){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"The solution consist of two parts: (1) Canvas and (2) Toolbar.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"State\"}),`\n`,(0,t.jsx)(e.p,{children:\"We'll need the following states within the application:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Mode: Whether the app is in drawing or erasing mode.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Selected color: Active color for drawing.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Canvas colors: A 2-d array of color values, representing the pixel art canvas.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Dragging: Whether the cursor is in the dragging state.\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"The current mode and selected color state can reside within the top-level component while the canvas colors and dragging state is only needed within the canvas.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Toolbar\"}),`\n`,(0,t.jsx)(e.p,{children:\"Rendering the toolbar component is pretty straightforward. The various buttons within the toolbar will update the mode and the selected color.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The only thing to note is to use a non-transparent border for white-color cells and a non-black border when black color is selected.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Canvas\"}),`\n`,(0,t.jsx)(e.p,{children:\"There are many ways to render the canvas, and we have opted to use rows of flexboxes instead of CSS grid (which uses a linear array of cells) here because it's easier to render the alternating background for the empty cells.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We'll add a \",(0,t.jsx)(e.code,{children:\"mousedown\"}),\" listener to the top-level DOM element within the canvas and change the state to be dragging when that happens. When the \",(0,t.jsx)(e.code,{children:\"mouseup\"}),\" even is fired, the dragging state is reset.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The canvas contains many cells and each cell is a pixel that is either empty or filled with a color. The cell listens for two events:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"mousedown\"}),\": Trigger the drawing/erasing of the cell. We want the selected action to be triggered immediately when the mouse is pressed, hence the \",(0,t.jsx)(e.code,{children:\"mousedown\"}),\" event is used as opposed to \",(0,t.jsx)(e.code,{children:\"click\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"mouseenter\"}),\": Trigger the drawing/erasing of the cell. This event is only needed when the canvas is in the dragging state.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Depending on the current mode, the cells grid will be updated with the new color, or the color is erased from the cell.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Inline styles are used for the background color of the cells to allow for easy changing of the hex values without having to create CSS classes for each possible color.\"})]})}function S(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var p=S;var o=h(a());function w(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Canvas should contain a 15 x 15 grid of cells.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Canvas should not have any colors applied on initial load.\"}),`\n`,(0,o.jsxs)(e.li,{children:[\"Toolbar should render the mode picker and colorpicker.\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Mode picker allows selection of modes.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Colorpicker allows selection of colors. Black and white are rendered fine.\"}),`\n`]}),`\n`]}),`\n`,(0,o.jsxs)(e.li,{children:[\"Drawing mode\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Clicking once on a Cell while drawing should color that cell.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Dragging over cells while drawing should color those cells with the selected color\"}),`\n`,(0,o.jsx)(e.li,{children:\"Drawing over an already-colored cell with a different color should update the cell with that color.\"}),`\n`]}),`\n`]}),`\n`,(0,o.jsxs)(e.li,{children:[\"Erasing mode\",`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Clicking once on a cell while erasing should erase that cell's color.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Clicking and dragging over multiple cells while erasing should remove those cell's colors.\"}),`\n`]}),`\n`]}),`\n`]})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,o.jsx)(e,Object.assign({},n,{children:(0,o.jsx)(w,n)})):w(n)}var f=F;var l=h(a());function b(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\"},n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,l.jsxs)(e.ul,{children:[`\n`,(0,l.jsxs)(e.li,{children:[\"Use \",(0,l.jsx)(e.code,{children:\"<button>\"}),'s for interactive elements such as the \"Draw\"/\"Erase\" buttons, and colorpicker options.']}),`\n`,(0,l.jsxs)(e.li,{children:[\"Add \",(0,l.jsx)(e.code,{children:\"aria-label\"}),\"s to the color options button since they have no visible labels.\"]}),`\n`,(0,l.jsxs)(e.li,{children:[\"Since each canvas cell is a \",(0,l.jsx)(e.code,{children:\"<button>\"}),\", you can \",(0,l.jsx)(\"kbd\",{children:\"Tab\"}),\" through them and use \",(0,l.jsx)(\"kbd\",{children:\"Space\"}),\" to trigger the currently selected action on them. For extra credit, you can add keyboard navigation (up, down, left, right) to easily navigate through the cells, draw with \",(0,l.jsx)(\"kbd\",{children:\"Enter\"}),\" and erase with \",(0,l.jsx)(\"kbd\",{children:\"Backspace\"}),\".\"]}),`\n`]})]})}function O(n={}){let{wrapper:e}=n.components||{};return e?(0,l.jsx)(e,Object.assign({},n,{children:(0,l.jsx)(b,n)})):b(n)}var v=O;function x(n){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(p,{}),`\n`,(0,r.jsx)(f,{}),`\n`,(0,r.jsx)(v,{})]})}function X(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(x,n)})):x(n)}var W=X;return M(A);})();\n;return Component;"
}