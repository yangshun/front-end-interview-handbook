{
  "author": "yangshun",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/file-explorer-react-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.0\",\n    \"@types/react-dom\": \"18.2.0\",\n    \"typescript\": \"5.0.2\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.tsx": {
      "code": "import FileExplorer from './FileExplorer';\n\nexport default function App() {\n  const data = [\n    {\n      id: 1,\n      name: 'README.md',\n    },\n    {\n      id: 2,\n      name: 'Documents',\n      children: [\n        {\n          id: 3,\n          name: 'Word.doc',\n        },\n        {\n          id: 4,\n          name: 'Powerpoint.ppt',\n        },\n      ],\n    },\n    {\n      id: 5,\n      name: 'Downloads',\n      children: [\n        {\n          id: 6,\n          name: 'unnamed.txt',\n        },\n        {\n          id: 7,\n          name: 'Misc',\n          children: [\n            {\n              id: 8,\n              name: 'foo.txt',\n            },\n            {\n              id: 9,\n              name: 'bar.txt',\n            },\n          ],\n        },\n      ],\n    },\n  ];\n\n  return <FileExplorer data={data} />;\n}\n"
    },
    "/src/FileExplorer.tsx": {
      "code": "import { useState } from 'react';\nimport FileList from './FileList';\n\nexport type FileData = Readonly<{\n  id: number;\n  name: string;\n  children?: ReadonlyArray<FileData>;\n}>;\n\nexport default function FileExplorer({\n  data,\n}: Readonly<{ data: ReadonlyArray<FileData> }>) {\n  return (\n    <div>\n      <FileList fileList={data} level={1} />\n    </div>\n  );\n}\n\nexport function FileObject({\n  file,\n  level,\n}: Readonly<{ file: FileData; level: number }>) {\n  const [expanded, setExpanded] = useState(false);\n  const { children: fileChildren, name: fileName } = file;\n  // If the children field is present, the item is a directory.\n  const isDirectory = Boolean(fileChildren);\n\n  return (\n    <li className=\"file-item\">\n      <button\n        className={[\n          'file-item-button',\n          isDirectory && 'file-item-button--directory',\n        ]\n          .filter(Boolean)\n          .join(' ')}\n        onClick={() => {\n          if (!isDirectory) {\n            return;\n          }\n\n          setExpanded(!expanded);\n        }}>\n        <span>{fileName}</span>{' '}\n        {isDirectory && <>[{expanded ? '-' : '+'}]</>}\n      </button>\n      {fileChildren &&\n        fileChildren.length > 0 &&\n        expanded && (\n          <FileList\n            fileList={fileChildren}\n            level={level + 1}\n          />\n        )}\n    </li>\n  );\n}\n"
    },
    "/src/FileList.tsx": {
      "code": "import { FileObject, FileData } from './FileExplorer';\n\nexport default function FileList({\n  fileList,\n  level,\n}: Readonly<{\n  fileList: ReadonlyArray<FileData>;\n  level: number;\n}>) {\n  const directories = fileList.filter(\n    (fileItem) => fileItem.children,\n  );\n  directories.sort((a, b) => a.name.localeCompare(b.name));\n\n  const nonDirectories = fileList.filter(\n    (fileItem) => !fileItem.children,\n  );\n  nonDirectories.sort((a, b) =>\n    a.name.localeCompare(b.name),\n  );\n\n  const items = [...directories, ...nonDirectories];\n\n  return (\n    <ul className=\"file-list\">\n      {items.map((file) => (\n        <FileObject\n          key={file.id}\n          file={file}\n          level={level}\n        />\n      ))}\n    </ul>\n  );\n}\n"
    },
    "/src/index.tsx": {
      "code": "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root')!);\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n.file-list {\n  list-style: none;\n  margin: 0;\n  padding-left: 16px;\n}\n\n.file-item {\n  padding: 0;\n}\n\n.file-item-button {\n  background-color: transparent;\n  border: none;\n  line-height: 1.5;\n  cursor: pointer;\n  font-size: 16px;\n  padding: 0;\n}\n\n.file-item-button--directory {\n  display: flex;\n  gap: 4px;\n  font-weight: bold;\n}\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/FileExplorer.tsx",
      "/src/FileList.tsx",
      "/src/styles.css"
    ],
    "activeFile": "/src/FileExplorer.tsx",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var x=Object.create;var d=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var F=Object.getOwnPropertyNames;var T=Object.getPrototypeOf,_=Object.prototype.hasOwnProperty;var C=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),D=(t,e)=>{for(var l in e)d(t,l,{get:e[l],enumerable:!0})},p=(t,e,l,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of F(e))!_.call(t,s)&&s!==l&&d(t,s,{get:()=>e[s],enumerable:!(h=j(e,s))||h.enumerable});return t};var c=(t,e,l)=>(l=t!=null?x(T(t)):{},p(e||!t||!t.__esModule?d(l,\"default\",{value:t,enumerable:!0}):l,t)),M=t=>p(d({},\"__esModule\",{value:!0}),t);var a=C((R,m)=>{m.exports=_jsx_runtime});var E={};D(E,{default:()=>V});var o=c(a());var i=c(a());function u(t){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Rendering:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Verify that the component renders without errors\"}),`\n`,(0,i.jsx)(e.li,{children:\"Check that all file and directory names are displayed correctly\"}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure directories are displayed before files\"}),`\n`,(0,i.jsx)(e.li,{children:\"Confirm that items within each directory are sorted alphabetically\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Directory expansion/collapse:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Test expanding a directory by clicking on it\"}),`\n`,(0,i.jsx)(e.li,{children:\"Test collapsing an expanded directory by clicking on it again\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that the expand/collapse indicator changes appropriately\"}),`\n`,(0,i.jsx)(e.li,{children:\"Test expanding/collapsing nested directories\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Indentation:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Check that contents of directories are indented correctly\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that nested directories have appropriate levels of indentation\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"File interaction:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Confirm that files are not expandable or interactive\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Empty directories:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Test rendering of empty directories\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that empty directories can still be expanded/collapsed\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Sorting:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Confirm that directories appear before files in each level\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify alphabetical sorting within directories and files separately\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"State persistence:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Check if expanded/collapsed state of directories persists when re-rendering\"}),`\n`]}),`\n`]}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(u,t)})):u(t)}var f=k;var n=c(a());function g(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",h4:\"h4\",pre:\"pre\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"File explorers are usually implemented in a tree-like navigation fashion and are hierarchical and recursive in nature.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Components\"}),`\n`,(0,n.jsx)(e.p,{children:\"In terms of front end components, recursion means that the components can be rendering itself, or render a component that renders itself. Hence it's important to design the recursive components well to allow for reusability.\"}),`\n`,(0,n.jsx)(e.p,{children:\"There are two distinct types of components here:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"FileObject\"}),\": It accepts a \",(0,n.jsx)(e.code,{children:\"FileData\"}),\" prop and renders the item name. Depending on whether the item is a directory, based on the presence of the \",(0,n.jsx)(e.code,{children:\"children\"}),\" field, it can render the \",(0,n.jsx)(e.code,{children:\"FileList\"}),\" component. If the item is a directory, the item can be toggled. The state of whether the \",(0,n.jsx)(e.code,{children:\"children\"}),\" items are shown will also be contained within this file.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"FileList\"}),\": It accepts an array of \",(0,n.jsx)(e.code,{children:\"FileData\"}),\"s and maps each of them to render \",(0,n.jsx)(e.code,{children:\"FileObject\"}),\" components. This component also sorts the list of items alphabetically and for the directories to come first.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Strictly speaking, we could combine \",(0,n.jsx)(e.code,{children:\"FileList\"}),\" into \",(0,n.jsx)(e.code,{children:\"FileObject\"}),\" so there is no need for two different components, but that'd make \",(0,n.jsx)(e.code,{children:\"FileObject\"}),\" quite complicated as it will also contain the ordering logic.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsx)(e.p,{children:\"There are two common ways to render tree-like structures:\"}),`\n`,(0,n.jsx)(e.h4,{children:\"1. Nested structure\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The most intuitive approach is to use a nested elements approach where each parent node renders left paddings so that child items are indented. It is similar to having nested \",(0,n.jsx)(e.code,{children:\"<ul>\"}),\"s and \",(0,n.jsx)(e.code,{children:\"<li>\"}),\"s.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-html\",children:`<ul>\n  <li>\n    <div>docs</div>\n    <ul>\n      <li>foo.md</li>\n      <li>bar.md</li>\n    </ul>\n  </li>\n  <li>\n    <div>README.md</div>\n  </li>\n</ul>\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"The advantage of this approach is that indentation for children is simpler to implement. Each level's indentation is a result of the sum of the previous level's left padding. Additionally, if there's a need to remove a directory and all its descendants, the removal can be done by deleting a single node for that directory, as its descendants are contained within it.\"}),`\n`,(0,n.jsx)(e.p,{children:\"However, if there are DOM operations needed, then traversing the DOM will be more troublesome due to the need to traverse among inner components.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This nested approach is used by Figma's workspace layers panel and \",(0,n.jsx)(e.a,{href:\"https://github.com/yangshun/top-javascript-interview-questions/tree/main/questions\",children:\"GitHub's file explorer view\"}),\".\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"2. Flat structure\"}),`\n`,(0,n.jsx)(e.p,{children:\"The other possible structure is having a single flat list of items and add the right amount of padding for descendant items. While recursing, the current level will need to be passed as an argument so that the descendant items know what how much padding to render.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-html\",children:`<!-- The bullets will have to be hidden as \n they will still be flushed to the left. -->\n<ul>\n  <li>docs</li>\n  <li style=\"padding-left: 16px\">foo.md</li>\n  <li style=\"padding-left: 16px\">bar.md</li>\n  <li>README.md</li>\n</ul>\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"A single flat list of DOM elements is easier to traverse. Also, this flat approach provides the most control over the rendering and allows for virtualized items in large directories that contain many files. Virtualization is not easy to achieve using a nested structure because in order for items to be indented by the right amount, their parents have to be rendered as well \\u2013 a nested structure makes it hard or even impossible to render only the minimal items that need to be displayed.\"}),`\n`,(0,n.jsx)(e.p,{children:\"However, if there's a need to remove a directory and all its descendants, the right nodes have to be selected for removal.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This flat approach is used by \",(0,n.jsx)(e.a,{href:\"https://github.dev/yangshun/top-javascript-interview-questions/\",children:\"VS Code\"}),\" because of the need to handle large amount of files. In fact, VS Code uses \",(0,n.jsx)(e.code,{children:\"position: absolute; left: Xpx; top: Ypx;\"}),\" along with a flat list for positioning and it only renders the visible file items.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Choosing the approach\"}),`\n`,(0,n.jsx)(e.p,{children:\"The approach to use depends on the apps' technology stack and amount of items to be rendered. If the component is built for small directories and using vanilla JavaScript with lots of manual DOM manipulation, then the nested structure could be easier to implement. Otherwise, the flat structure is recommended for the reasons of flexibility and scalability.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The official solution implements the nested structure since it is the most commonly found. During interviews, it is expected that candidates implement the nested structure version. However, you should know about the benefits and limitations of each approach so that you can elaborate when asked.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Regardless of nested or flat structure, an important thing that should not be missed is accessibility of the component. To stand out in your interviews, you should discuss the accessibility aspects of the file explorer. They are covered in the \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/file-explorer-ii\",children:\"File Explorer II\"}),\" question.\"]})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(g,t)})):g(t)}var y=A;var r=c(a());function b(t){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Accessibility is important for a good File Explorer component. The \",(0,r.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/treeview\",children:\"ARIA Authoring Practices Guide for Tree View Pattern\"}),\" has a long list of guidelines for the ARIA roles, states, and properties to add to the various elements of a Tree View. We recommend working on \",(0,r.jsx)(e.a,{href:\"/questions/user-interface/file-explorer-ii\",children:\"File Explorer II\"}),\" and get to know about the accessibility criteria of a Tree View component.\"]})]})}function I(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(b,t)})):b(t)}var w=I;function v(t){return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(y,{}),`\n`,(0,o.jsx)(f,{}),`\n`,(0,o.jsx)(w,{})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,o.jsx)(e,Object.assign({},t,{children:(0,o.jsx)(v,t)})):v(t)}var V=O;return M(E);})();\n;return Component;"
}