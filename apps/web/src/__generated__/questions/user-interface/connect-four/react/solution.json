{
  "author": "utpal-d4l",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/connect-four-react-solution\",\n  \"author\": \"utpal-d4l\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.0\",\n    \"@types/react-dom\": \"18.2.0\",\n    \"typescript\": \"5.0.2\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.tsx": {
      "code": "import React, { useState } from 'react';\n\nconst ROWS = 6;\nconst COLS = 7;\nconst COUNT_TO_WIN = 4;\n\nconst PLAYERS = ['red', 'yellow'] as const;\ntype Player = (typeof PLAYERS)[number];\ntype CurrentPlayerIndex = number;\n\nconst EMPTY_CELL = '#fff';\n\nconst PLAYER_TOKENS: Record<Player, string> = {\n  red: '#d9313d',\n  yellow: '#fdc601',\n};\n\n// Direction deltas for horizontal, vertical and diagonal\n// directions.\n// The first value is the row delta, second value is the column delta.\n// These will be used to check if there are N consecutive tokens\n// in each direction for winning condition.\nconst DIRECTION_DELTAS = [\n  [0, 1], // Horizontal\n  [1, 0], // Vertical\n  [1, -1], // Diagonal (bottom left to top right)\n  [1, 1], // Diagonal (top left to bottom right)\n];\n\n// Game grid data structure.\ntype GameGridCellValue = Player | null;\ntype GameGridType = Array<Array<GameGridCellValue>>;\n\n// Generate initial game grid.\nfunction getInitialGrid(): GameGridType {\n  return Array(ROWS)\n    .fill(null)\n    .map(() => Array(COLS).fill(null));\n}\n\n// Check if a player has won.\nfunction checkIfPlayerWon(\n  grid: GameGridType,\n  row: number,\n  col: number,\n  player: Player,\n): boolean {\n  return DIRECTION_DELTAS.some(([deltaRow, deltaCol]) => {\n    // Count the maximum consecutive discs for the\n    // player in the 4 different directions.\n    let consecutiveDiscs = 0;\n    let maxConsecutiveDiscs = 0;\n\n    for (\n      let i = -COUNT_TO_WIN + 1;\n      i <= COUNT_TO_WIN - 1;\n      i++\n    ) {\n      const currRow = row + deltaRow * i;\n      const currCol = col + deltaCol * i;\n\n      if (grid?.[currRow]?.[currCol] === player) {\n        consecutiveDiscs += 1;\n        maxConsecutiveDiscs = Math.max(\n          consecutiveDiscs,\n          maxConsecutiveDiscs,\n        );\n      } else {\n        consecutiveDiscs = 0;\n      }\n    }\n\n    return maxConsecutiveDiscs >= COUNT_TO_WIN;\n  });\n}\n\n// Player section component where player can\n// select a column to drop their piece.\nfunction PlayerMoveSection({\n  availableColumns,\n  currentColumn,\n  currentPlayer,\n  gameHasEnded,\n  onColumnHover,\n  onPlayerMove,\n}: {\n  availableColumns: Set<number>;\n  currentColumn: number | null;\n  currentPlayer: Player;\n  gameHasEnded: boolean;\n  onColumnHover: (column: number) => void;\n  onPlayerMove: (column: number) => void;\n}): React.ReactElement {\n  return (\n    <div className=\"player-move-section\">\n      {Array.from({ length: COLS }).map((_, index) => (\n        <button\n          aria-label={`Column ${index + 1}`}\n          disabled={\n            !availableColumns.has(index) || gameHasEnded\n          }\n          key={index}\n          style={{\n            backgroundColor:\n              currentColumn === index && !gameHasEnded\n                ? PLAYER_TOKENS[currentPlayer]\n                : undefined,\n          }}\n          className=\"player-move-column\"\n          onMouseEnter={() => onColumnHover(index)}\n          onClick={() => onPlayerMove(index)}\n        />\n      ))}\n    </div>\n  );\n}\n\nfunction GameGrid({\n  grid,\n}: {\n  grid: GameGridType;\n}): React.ReactElement {\n  return (\n    <div\n      className=\"grid\"\n      style={{\n        gridTemplateRows: `repeat(${ROWS}, var(--grid-item-size))`,\n        gridTemplateColumns: `repeat(${COLS}, var(--grid-item-size)`,\n      }}>\n      {grid.map((rows, rowIndex) =>\n        rows.map((cellValue, colIndex) => (\n          <div\n            key={`${rowIndex}-${colIndex}`}\n            style={{\n              backgroundColor:\n                cellValue != null\n                  ? PLAYER_TOKENS[cellValue]\n                  : EMPTY_CELL,\n            }}\n            className=\"grid-item\"\n          />\n        )),\n      )}\n    </div>\n  );\n}\n\n// Winner details component.\nfunction WinnerSection({\n  winner,\n}: {\n  winner: Player;\n}): React.ReactElement {\n  return (\n    <div\n      className=\"winner-token\"\n      style={{ backgroundColor: PLAYER_TOKENS[winner] }}>\n      WON\n    </div>\n  );\n}\n\nexport default function App() {\n  // State to handle game grid state.\n  const [grid, setGrid] = useState<GameGridType>(() =>\n    getInitialGrid(),\n  );\n  // Current player index.\n  const [currentPlayerIndex, setCurrentPlayerIndex] =\n    useState<CurrentPlayerIndex>(0);\n  // Winner state. It will be player's index if there's a winner.\n  const [winner, setWinner] = useState<Player | null>(null);\n\n  // State to handle current column selected by the current player.\n  const [currentColumn, setCurrentColumn] = useState<\n    number | null\n  >(null);\n\n  function onPlayerMove(column: number) {\n    // Make a deep clone of the grid.\n    const newGrid = grid.map((row) => [...row]);\n\n    let rowToPlace = ROWS - 1;\n    // Find lowest row in current column that is empty.\n    while (newGrid[rowToPlace][column] != null) {\n      rowToPlace--;\n    }\n\n    const player = PLAYERS[currentPlayerIndex];\n    newGrid[rowToPlace][column] = player;\n    if (\n      checkIfPlayerWon(newGrid, rowToPlace, column, player)\n    ) {\n      setWinner(player);\n    }\n\n    // Go to the next player.\n    setCurrentPlayerIndex(\n      (currentPlayerIndex + 1) % PLAYERS.length,\n    );\n    setGrid(newGrid);\n  }\n\n  function onColumnHover(index: number) {\n    setCurrentColumn(index);\n  }\n\n  function onRestart() {\n    setGrid(getInitialGrid());\n    setCurrentColumn(null);\n    setCurrentPlayerIndex(0);\n    setWinner(null);\n  }\n\n  const movesSoFar = grid.reduce(\n    (count, row) => count + row.filter(Boolean).length,\n    0,\n  );\n  const isDraw =\n    movesSoFar === ROWS * COLS && winner == null;\n  const gameHasEnded = isDraw || winner != null;\n  const availableColumns = new Set(\n    grid[0]\n      .map((piece, index) => (piece == null ? index : -1))\n      .filter((item) => item !== -1),\n  );\n\n  return (\n    <div className=\"app\">\n      <PlayerMoveSection\n        availableColumns={availableColumns}\n        currentColumn={currentColumn}\n        currentPlayer={PLAYERS[currentPlayerIndex]}\n        gameHasEnded={gameHasEnded}\n        onColumnHover={onColumnHover}\n        onPlayerMove={onPlayerMove}\n      />\n      <GameGrid grid={grid} />\n      <button onClick={onRestart} className=\"reset-button\">\n        Reset\n      </button>\n      {isDraw && <h2>DRAW</h2>}\n      {winner != null && <WinnerSection winner={winner} />}\n    </div>\n  );\n}\n"
    },
    "/src/index.tsx": {
      "code": "import React, { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root')!);\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n\n.app {\n  --grid-item-size: 50px;\n  --grid-item-gap: 10px;\n\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n.player-move-section {\n  display: flex;\n  align-items: center;\n  padding: var(--grid-item-gap);\n  gap: var(--grid-item-gap);\n}\n\n.player-move-column {\n  background-color: transparent;\n  height: var(--grid-item-size);\n  width: var(--grid-item-size);\n  border-radius: 100%;\n  transition: background-color 0.1s linear;\n  outline: none;\n  border: none;\n  cursor: pointer;\n}\n\n.grid {\n  display: grid;\n  grid-template-rows: repeat(6, var(--grid-item-size));\n  grid-template-columns: repeat(7, var(--grid-item-size));\n  background-color: #1c61f2;\n  border-radius: 16px;\n  padding: var(--grid-item-gap);\n  gap: var(--grid-item-gap);\n}\n\n.grid-item {\n  border-radius: 100%;\n  transition: background-color 0.25s linear;\n}\n\n.winner-token {\n  height: var(--grid-item-size);\n  width: var(--grid-item-size);\n  border-radius: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: white;\n  font-size: 12px;\n  font-weight: 600;\n}\n\n.reset-button {\n  background-color: #ccc;\n  border: none;\n  padding-block: 8px;\n  padding-inline: 16px;\n  font-weight: 600;\n  border-radius: 16px;\n  cursor: pointer;\n  margin-block: var(--grid-item-gap);\n}\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.tsx",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.tsx",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var y=Object.create;var l=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var S=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var O=(c,e)=>()=>(e||c((e={exports:{}}).exports,e),e.exports),x=(c,e)=>{for(var t in e)l(c,t,{get:e[t],enumerable:!0})},s=(c,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of v(e))!k.call(c,o)&&o!==t&&l(c,o,{get:()=>e[o],enumerable:!(a=b(e,o))||a.enumerable});return c};var h=(c,e,t)=>(t=c!=null?y(S(c)):{},s(e||!c||!c.__esModule?l(t,\"default\",{value:c,enumerable:!0}):t,c)),C=c=>s(l({},\"__esModule\",{value:!0}),c);var d=O((R,p)=>{p.exports=_jsx_runtime});var U={};x(U,{default:()=>I});var r=h(d());var n=h(d());function u(c){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",img:\"img\",h3:\"h3\",h4:\"h4\",ul:\"ul\",li:\"li\",strong:\"strong\",blockquote:\"blockquote\",a:\"a\",ol:\"ol\",br:\"br\",em:\"em\"},c.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the spirit of good software engineering, let's devise a solution that is as customizable as possible. We will build a Connect Four game that works with any numbers of rows, columns, and players. Let these be constants \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\", \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\", and \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\" respectively.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/img/questions/connect-four/connect-four-example.png\",alt:\"Connect Four example\"})}),`\n`,(0,n.jsx)(e.h3,{children:\"Setting up the playground\"}),`\n`,(0,n.jsx)(e.p,{children:\"From the example image, we see that we need at least three main sections:\"}),`\n`,(0,n.jsx)(e.h4,{children:\"1. The disc-drop area\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is where a player will drop their disc. It is a single row of \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" cells, each representing a column in the game grid. The color of the disc shown will be the current player's.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"2. The game grid\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is where all the discs will be placed. It is a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" grid. More specifically, it is a \",(0,n.jsx)(e.code,{children:\"div\"}),\" of \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\" number of \",(0,n.jsx)(e.code,{children:\"div\"}),\"s. Each of these \",(0,n.jsx)(e.code,{children:\"div\"}),\"s contains \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" number of \",(0,n.jsx)(e.code,{children:\"div\"}),\"s.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Each cell has two states:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"empty\"}),\": which displays a transparent (or the app's background color) circle, and\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"occupied\"}),\": which displays a circle colored with the player's disc color.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Tip: Use \",(0,n.jsx)(e.code,{children:\"border-radius: 100%;\"}),\" to make a \",(0,n.jsx)(e.code,{children:\"div\"}),\" a circle. This will apply a border radius of half of the width/height of the \",(0,n.jsx)(e.code,{children:\"div\"}),\" in each corner.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"3. The controls area\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is where the reset button and game state (winning player, draw, errors, etc.) elements will be placed.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"States\"}),`\n`,(0,n.jsx)(e.p,{children:\"As with any games, we need to keep track of some states throughout one game session.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid\"}),\", which is a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" array that represents the current grid of discs.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\", which is the current player's identifier, so we know whose disc to drop into the grid.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"winner\"}),\", which is the winning player's identifier, so we know who to congratulate! It is \",(0,n.jsx)(e.code,{children:\"null\"}),\" at first. This state also doubles as a flag to indicate if the game has ended.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Names may vary, and you may need other states to support your implementation. These are the minimum.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Binding the interactions\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"At this point, you'd probably be thinking of the \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Connect_Four\",children:\"actual Connect Four game\"}),\". To keep things simple, let's not worry about the animations of the discs dropping into the grid.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Choosing a column to drop a disc\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the disc-drop area, think of each cell as a button. When a button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" is clicked, it triggers an event to drop a disc into column \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We will need to pass the current player's color to color these buttons.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Notably, we want to only show a disc where the player is hovering; they are planning their move! There are many ways to detect if a button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" is hovered.\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"We can use the \",(0,n.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/:hover\",children:[(0,n.jsx)(e.code,{children:\":hover\"}),\" CSS pseudo-class\"]}),\" to detect if the button is currently hovered.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"We can use the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event\",children:(0,n.jsx)(e.code,{children:\"mouseenter\"})}),\" or \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event\",children:(0,n.jsx)(e.code,{children:\"mousemove\"})}),\" event listeners on the buttons to set a state (maybe some \",(0,n.jsx)(e.code,{children:\"currentColumn\"}),\") to \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Once we know if a button \",(0,n.jsx)(e.code,{children:\"i\"}),\" is hovered, we can then modify \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/background-color\",children:(0,n.jsx)(e.code,{children:\"background-color\"})}),\", \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/opacity\",children:(0,n.jsx)(e.code,{children:\"opacity\"})}),\", or \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/visibility\",children:(0,n.jsx)(e.code,{children:\"visibility\"})}),\" to show or hide the button.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Dropping a disc\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We trigger this interaction by binding a \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event\",children:(0,n.jsx)(e.code,{children:\"click\"})}),\" event listener to each button in the disc-drop area. This function will receive the column index \",(0,n.jsx)(e.code,{children:\"i\"}),\" as an argument.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The general algorithm for dropping a player \",(0,n.jsx)(e.code,{children:\"player\"}),\"'s disc into column \",(0,n.jsx)(e.code,{children:\"i\"}),\" is as follows.\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Find the cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\" such that it is the first empty row in column \",(0,n.jsx)(e.code,{children:\"i\"}),\".\",(0,n.jsx)(e.br,{}),`\n`,\"We do this by iterating through the elements (rows) of \",(0,n.jsx)(e.code,{children:\"grid\"}),\" and finding the first element at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" (cell in each row) that is \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"cell\"}),\" to \",(0,n.jsx)(e.code,{children:\"player\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"After dropping a disc, we check if the game has ended.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If yes, we update \",(0,n.jsx)(e.code,{children:\"winner\"}),\" to the winning player's identifier.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If not, we update \",(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\" to the next player in \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Remember that if we cannot find an empty cell in column \",(0,n.jsx)(e.code,{children:\"i\"}),\", we should not allow any disc to drop there. We could either:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Show an error message with \",(0,n.jsx)(e.code,{children:\"alert\"}),\" or some other UI element, or\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Completely disable the button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" and not allow interactions with unavailable columns.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"Checking for the winning condition\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The naive way is to go through every cell in \",(0,n.jsx)(e.code,{children:\"grid\"}),\" and check that for every cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\", if it is a part of any one of the valid winning segments.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A more optimal approach is to only check the cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\" where the player dropped their disc. We can do this because the fact that we are able to drop a disc means there mustn't be a winner yet, so the game continues. This means if a player wins now, it is specifically caused by this one mutation: the placement at \",(0,n.jsx)(e.code,{children:\"cell\"}),\". So, it suffices to only check around \",(0,n.jsx)(e.code,{children:\"cell\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"At \",(0,n.jsx)(e.code,{children:\"cell\"}),\", we check if it is a part of any one of the valid winning segments. We check the four directions: \\u2500, \\u2502, \\u2572, and \\u2571 that crosses \",(0,n.jsx)(e.code,{children:\"cell\"}),\". Each direction is a 7 elements-long array of coordinates relative to \",(0,n.jsx)(e.code,{children:\"cell\"}),\".\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"It is length 7 because each winning segment is 4 elements-long. So, combining the north and south directions, for example, we get 7 elements.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the spirit of good software engineering, we will generalize this algorithm by extracting \",(0,n.jsx)(e.code,{children:\"4\"}),\" out as a constant \",(0,n.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\". This way, we can easily change the winning condition in the future!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"For each direction, count the maximum number of consecutive discs of the current player's color. If there are at least \",(0,n.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" of them, the player has won.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The naive algorithm will take \",(0,n.jsx)(e.code,{children:\"O(ROWS * COLUMNS)\"}),\" time, while the optimal algorithm will take \",(0,n.jsx)(e.code,{children:\"O(COUNT_TO_WIN)\"}),\" time, which is effectively \",(0,n.jsx)(e.code,{children:\"O(1)\"}),\" constant time.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Tip: You can use the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\",children:\"optional chaining operator\"}),\" to safely grab a cell at a coordinate, even if it may be out of bounds. For example, \",(0,n.jsx)(e.code,{children:\"grid?.[r]?.[c]\"}),\" will return \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" if \",(0,n.jsx)(e.code,{children:\"r\"}),\" or \",(0,n.jsx)(e.code,{children:\"c\"}),\" are out of bounds in \",(0,n.jsx)(e.code,{children:\"grid\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"Checking for a draw\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"There are many ways to achieve this. One way is to check if after a disc drop, there is no \",(0,n.jsx)(e.code,{children:\"winner\"}),\", and every cell in \",(0,n.jsx)(e.code,{children:\"grid\"}),\" is occupied.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A more optimal approach is to keep track of the number of discs dropped \",(0,n.jsx)(e.em,{children:\"as we drop them\"}),\". If it reaches \",(0,n.jsx)(e.code,{children:\"ROWS * COLUMNS\"}),\", then we know that the game has ended in a draw. Then we don't have to incur that extra \",(0,n.jsx)(e.code,{children:\"O(ROWS * COLUMNS)\"}),\" time to check if every cell is occupied. Neat!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, keeping track of the number of discs is considered duplicated state since it can be derived from the \",(0,n.jsx)(e.code,{children:\"grid\"}),\" state. Since the number of cells is considered small, it is optional to do such an optimization.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Resetting the game\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is as easy as setting the states back to their initial values, i.e.,\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid\"}),\" to a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" array of \",(0,n.jsx)(e.code,{children:\"null\"}),\"s,\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\" to the first player in \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\", and\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"winner\"}),\" to \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]})]})}function W(c={}){let{wrapper:e}=c.components||{};return e?(0,n.jsx)(e,Object.assign({},c,{children:(0,n.jsx)(u,c)})):u(c)}var m=W;var i=h(d());function g(c){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\"},c.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Let the game be configured with \",(0,i.jsx)(e.code,{children:\"PLAYERS\"}),\" players and the winning condition be \",(0,i.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" consecutive discs of the same color.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"For a given \",(0,i.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,i.jsx)(e.code,{children:\"COLUMNS\"}),\" grid \",(0,i.jsx)(e.code,{children:\"grid\"}),\" and a given \",(0,i.jsx)(e.code,{children:\"player\"}),\",\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"For any given column \",(0,i.jsx)(e.code,{children:\"i\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If there is at least one empty cell \",(0,i.jsx)(e.code,{children:\"cell\"}),\", dropping a disc will result in \",(0,i.jsx)(e.code,{children:\"cell\"}),\" being filled with \",(0,i.jsx)(e.code,{children:\"player\"}),\"'s disc color.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Dropping a disc in a column will fill spaces from the bottom.\"}),`\n`,(0,i.jsx)(e.li,{children:\"If there is no empty cell, a disc cannot be placed in the column. If you have other behaviors for this case, expect it to happen too.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"When a disc is dropped into some cell \",(0,i.jsx)(e.code,{children:\"cell\"}),\", for each of the four directions: \\u2500, \\u2502, \\u2572, and \\u2571 that crosses \",(0,i.jsx)(e.code,{children:\"cell\"}),\",\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If there are at least \",(0,i.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" consecutive cells filled with \",(0,i.jsx)(e.code,{children:\"player\"}),\"'s disc color, there's an indicator for the winning player.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Otherwise, the color of the disc to drop in the next turn is the next player in \",(0,i.jsx)(e.code,{children:\"PLAYERS\"}),\"'s.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Game progress:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Players can take turns to drop the discs until a player wins or a there's a draw.\"}),`\n`,(0,i.jsx)(e.li,{children:\"If all cells are filled and no player has won, a draw indicator appears.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Game conclusion\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"When the winning or a draw indicator appears, no more discs can be dropped.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Clicking on the \"Reset\" button will turn all cells ',(0,i.jsx)(e.code,{children:\"grid\"}),\" to its base color, and clear any winning or draw indicators.\"]}),`\n`]})]})}function T(c={}){let{wrapper:e}=c.components||{};return e?(0,i.jsx)(e,Object.assign({},c,{children:(0,i.jsx)(g,c)})):g(c)}var f=T;function w(c){let e=Object.assign({h3:\"h3\",h4:\"h4\",code:\"code\",p:\"p\",a:\"a\",em:\"em\"},c.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(m,{}),`\n`,(0,r.jsx)(e.h3,{children:\"React-specific notes\"}),`\n`,(0,r.jsxs)(e.h4,{children:[(0,r.jsx)(e.code,{children:\"useState\"}),\" and \",(0,r.jsx)(e.code,{children:\"grid\"}),\" mutations\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Since we are using \",(0,r.jsx)(e.code,{children:\"useState\"}),\" as the \",(0,r.jsx)(e.code,{children:\"grid\"}),\" state, we should not mutate \",(0,r.jsx)(e.code,{children:\"grid\"}),\" when we drop a disc. We need to make a deep copy the \",(0,r.jsx)(e.code,{children:\"grid\"}),\" state, mutate the copy, and then set the state to the copy with \",(0,r.jsx)(e.code,{children:\"setGrid\"}),\". We can also use \",(0,r.jsxs)(e.a,{href:\"https://immerjs.github.io/immer/produce/\",children:[\"Immer's \",(0,r.jsx)(e.code,{children:\"produce\"})]}),\" if third-party libraries are allowed.\"]}),`\n`,(0,r.jsxs)(e.h4,{children:[\"Using indices as \",(0,r.jsx)(e.code,{children:\"key\"}),\"s\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"When we \",(0,r.jsx)(e.code,{children:\"map\"}),\" the rows and cells in \",(0,r.jsx)(e.code,{children:\"grid\"}),\", we use their indices as \",(0,r.jsx)(e.code,{children:\"key\"}),\"s. If you are a student of React, you'd probably realize that \",(0,r.jsx)(e.a,{href:\"https://react.dev/learn/rendering-lists#why-does-react-need-keys\",children:\"React warns against it\"}),\". But in this case, it's perfectly fine to use indices as \",(0,r.jsx)(e.code,{children:\"key\"}),\"s because \",(0,r.jsxs)(e.em,{children:[\"they are the correct identifiers of the rows and cells in \",(0,r.jsx)(e.code,{children:\"grid\"})]}),', do not contain state and the grid dimensions do not change while the game is in-progress. Therefore, it will not cause any \"subtle and confusing bugs\" as React warns.']}),`\n`,(0,r.jsx)(f,{})]})}function _(c={}){let{wrapper:e}=c.components||{};return e?(0,r.jsx)(e,Object.assign({},c,{children:(0,r.jsx)(w,c)})):w(c)}var I=_;return C(U);})();\n;return Component;"
}