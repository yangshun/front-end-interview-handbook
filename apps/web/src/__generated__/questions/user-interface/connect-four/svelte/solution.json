{
  "author": "willnguyen1312",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/connect-four-svelte-solution\",\n  \"author\": \"willnguyen1312\",\n  \"version\": \"0.0.1\",\n  \"main\": \"src/index.js\",\n  \"dependencies\": {\n    \"svelte\": \"^3.58.0\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Svelte</title>\n    <link rel=\"stylesheet\" href=\"public/bundle.css\" />\n  </head>\n\n  <body>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n"
    },
    "/src/App.svelte": {
      "code": "<script>\n  import GameGrid from './GameGrid.svelte';\n  import PlayerMoveSection from './PlayerMoveSection.svelte';\n  import WinnerSection from './WinnerSection.svelte';\n  import { COLS, ROWS } from './const';\n  const COUNT_TO_WIN = 4;\n  const PLAYERS = ['red', 'yellow'];\n\n  // Direction deltas for horizontal, vertical and diagonal\n  // directions.\n  // The first value is the row delta, second value is the column delta.\n  // These will be used to check if there are N consecutive tokens\n  // in each direction for winning condition.\n  const DIRECTION_DELTAS = [\n    [0, 1], // Horizontal\n    [1, 0], // Vertical\n    [1, -1], // Diagonal (bottom left to top right)\n    [1, 1], // Diagonal (top left to bottom right)\n  ];\n\n  // Generate initial game grid.\n  function getInitialGrid() {\n    return Array(ROWS)\n      .fill(null)\n      .map(() => Array(COLS).fill(null));\n  }\n\n  // Check if a player has won.\n  function checkIfPlayerWon(grid, row, col, player) {\n    return DIRECTION_DELTAS.some(([deltaRow, deltaCol]) => {\n      // Count the maximum consecutive discs for the\n      // player in the 4 different directions.\n      let consecutiveDiscs = 0;\n      let maxConsecutiveDiscs = 0;\n\n      for (\n        let i = -COUNT_TO_WIN + 1;\n        i <= COUNT_TO_WIN - 1;\n        i++\n      ) {\n        const currRow = row + deltaRow * i;\n        const currCol = col + deltaCol * i;\n\n        if (grid?.[currRow]?.[currCol] === player) {\n          consecutiveDiscs += 1;\n          maxConsecutiveDiscs = Math.max(\n            consecutiveDiscs,\n            maxConsecutiveDiscs,\n          );\n        } else {\n          consecutiveDiscs = 0;\n        }\n      }\n\n      return maxConsecutiveDiscs >= COUNT_TO_WIN;\n    });\n  }\n\n  let grid = getInitialGrid();\n  let currentPlayerIndex = 0;\n  let winner = null;\n  let currentColumn = null;\n\n  function handlePlayerMove(column) {\n    let rowToPlace = ROWS - 1;\n    // Find lowest row in current column that is empty.\n    while (grid[rowToPlace][column] != null) {\n      rowToPlace--;\n    }\n\n    const player = PLAYERS[currentPlayerIndex];\n    grid[rowToPlace][column] = player;\n    if (\n      checkIfPlayerWon(grid, rowToPlace, column, player)\n    ) {\n      winner = player;\n    }\n\n    // Go to the next player.\n    currentPlayerIndex =\n      (currentPlayerIndex + 1) % PLAYERS.length;\n  }\n\n  function handleColumnHover(index) {\n    currentColumn = index;\n  }\n\n  function restart() {\n    grid = getInitialGrid();\n    currentColumn = null;\n    currentPlayerIndex = 0;\n    winner = null;\n  }\n\n  $: movesSoFar = grid.reduce(\n    (count, row) => count + row.filter(Boolean).length,\n    0,\n  );\n  $: isDraw = movesSoFar === ROWS * COLS && winner == null;\n  $: gameHasEnded = isDraw || winner != null;\n  $: availableColumns = new Set(\n    grid[0]\n      .map((piece, index) => (piece == null ? index : -1))\n      .filter((item) => item !== -1),\n  );\n</script>\n\n<div class=\"app\">\n  <PlayerMoveSection\n    {availableColumns}\n    {currentColumn}\n    {gameHasEnded}\n    currentPlayer={PLAYERS[currentPlayerIndex]}\n    on:column-hover={(event) =>\n      handleColumnHover(event.detail.index)}\n    on:player-move={(event) =>\n      handlePlayerMove(event.detail.index)} />\n\n  <GameGrid {grid} />\n\n  <button on:click={restart} class=\"reset-button\">\n    Reset\n  </button>\n\n  {#if isDraw}\n    <h2>DRAW</h2>\n  {/if}\n\n  {#if winner != null}\n    <WinnerSection {winner} />\n  {/if}\n</div>\n\n<style>\n  .app {\n    --grid-item-size: 50px;\n    --grid-item-gap: 10px;\n\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  .reset-button {\n    background-color: #ccc;\n    border: none;\n    padding-block: 8px;\n    padding-inline: 16px;\n    font-weight: 600;\n    border-radius: 16px;\n    cursor: pointer;\n    margin-block: var(--grid-item-gap);\n  }\n</style>\n"
    },
    "/src/const.js": {
      "code": "export const ROWS = 6;\nexport const COLS = 7;\n\nexport const PLAYER_TOKENS = {\n  red: '#d9313d',\n  yellow: '#fdc601',\n};\n"
    },
    "/src/GameGrid.svelte": {
      "code": "<script>\n  import { COLS, PLAYER_TOKENS, ROWS } from './const';\n\n  const EMPTY_CELL = '#fff';\n\n  export let grid;\n</script>\n\n<div\n  class=\"grid\"\n  style:grid-template-rows={`repeat(${ROWS}, var(--grid-item-size))`}\n  style:grid-template-columns={`repeat(${COLS}, var(--grid-item-size))`}>\n  {#each grid as rows, rowIndex (rowIndex)}\n    {#each rows as cellValue, colIndex (colIndex)}\n      <div\n        style:background-color={cellValue != null\n          ? PLAYER_TOKENS[cellValue]\n          : EMPTY_CELL}\n        class=\"grid-item\" />\n    {/each}\n  {/each}\n</div>\n\n<style>\n  .grid {\n    display: grid;\n    grid-template-rows: repeat(6, var(--grid-item-size));\n    grid-template-columns: repeat(7, var(--grid-item-size));\n    background-color: #1c61f2;\n    border-radius: 16px;\n    padding: var(--grid-item-gap);\n    gap: var(--grid-item-gap);\n  }\n\n  .grid-item {\n    border-radius: 100%;\n    transition: background-color 0.25s linear;\n  }\n</style>\n"
    },
    "/src/index.js": {
      "code": "import App from './App.svelte';\nimport './styles.css';\n\nconst app = new App({\n  target: document.body,\n});\n\nexport default app;\n"
    },
    "/src/PlayerMoveSection.svelte": {
      "code": "<script>\n  import { createEventDispatcher } from 'svelte';\n  import { COLS, PLAYER_TOKENS } from './const';\n  export let availableColumns;\n  export let currentColumn;\n  export let currentPlayer;\n  export let gameHasEnded;\n\n  const dispatch = createEventDispatcher();\n</script>\n\n<div class=\"player-move-section\">\n  {#each { length: COLS } as _, index (index)}\n    <button\n      aria-label={`Column ${index + 1}`}\n      disabled={!availableColumns.has(index) ||\n        gameHasEnded}\n      style:background-color={currentColumn === index &&\n      !gameHasEnded\n        ? PLAYER_TOKENS[currentPlayer]\n        : undefined}\n      class=\"player-move-column\"\n      on:mouseenter={() =>\n        dispatch('column-hover', { index })}\n      on:click={() => dispatch('player-move', { index })} />\n  {/each}\n</div>\n\n<style>\n  .player-move-section {\n    display: flex;\n    align-items: center;\n    padding: var(--grid-item-gap);\n    gap: var(--grid-item-gap);\n  }\n\n  .player-move-column {\n    background-color: transparent;\n    height: var(--grid-item-size);\n    width: var(--grid-item-size);\n    border-radius: 100%;\n    transition: background-color 0.1s linear;\n    outline: none;\n    border: none;\n    cursor: pointer;\n  }\n</style>\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}\n"
    },
    "/src/WinnerSection.svelte": {
      "code": "<script>\n  import { PLAYER_TOKENS } from './const';\n  export let winner;\n</script>\n\n<div\n  class=\"winner-token\"\n  style:background-color={PLAYER_TOKENS[winner]}>\n  WON\n</div>\n\n<style>\n  .winner-token {\n    height: var(--grid-item-size);\n    width: var(--grid-item-size);\n    border-radius: 100%;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    color: white;\n    font-size: 12px;\n    font-weight: 600;\n  }\n</style>\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.svelte"
    ],
    "activeFile": "/src/App.svelte",
    "environment": "svelte"
  },
  "writeup": "var Component=(()=>{var y=Object.create;var l=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var S=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var O=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),x=(r,e)=>{for(var o in e)l(r,o,{get:e[o],enumerable:!0})},s=(r,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of v(e))!k.call(r,t)&&t!==o&&l(r,t,{get:()=>e[t],enumerable:!(a=b(e,t))||a.enumerable});return r};var h=(r,e,o)=>(o=r!=null?y(S(r)):{},s(e||!r||!r.__esModule?l(o,\"default\",{value:r,enumerable:!0}):o,r)),C=r=>s(l({},\"__esModule\",{value:!0}),r);var d=O((L,p)=>{p.exports=_jsx_runtime});var U={};x(U,{default:()=>I});var c=h(d());var n=h(d());function u(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",img:\"img\",h3:\"h3\",h4:\"h4\",ul:\"ul\",li:\"li\",strong:\"strong\",blockquote:\"blockquote\",a:\"a\",ol:\"ol\",br:\"br\",em:\"em\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the spirit of good software engineering, let's devise a solution that is as customizable as possible. We will build a Connect Four game that works with any numbers of rows, columns, and players. Let these be constants \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\", \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\", and \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\" respectively.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/img/questions/connect-four/connect-four-example.png\",alt:\"Connect Four example\"})}),`\n`,(0,n.jsx)(e.h3,{children:\"Setting up the playground\"}),`\n`,(0,n.jsx)(e.p,{children:\"From the example image, we see that we need at least three main sections:\"}),`\n`,(0,n.jsx)(e.h4,{children:\"1. The disc-drop area\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is where a player will drop their disc. It is a single row of \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" cells, each representing a column in the game grid. The color of the disc shown will be the current player's.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"2. The game grid\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is where all the discs will be placed. It is a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" grid. More specifically, it is a \",(0,n.jsx)(e.code,{children:\"div\"}),\" of \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\" number of \",(0,n.jsx)(e.code,{children:\"div\"}),\"s. Each of these \",(0,n.jsx)(e.code,{children:\"div\"}),\"s contains \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" number of \",(0,n.jsx)(e.code,{children:\"div\"}),\"s.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Each cell has two states:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"empty\"}),\": which displays a transparent (or the app's background color) circle, and\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"occupied\"}),\": which displays a circle colored with the player's disc color.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Tip: Use \",(0,n.jsx)(e.code,{children:\"border-radius: 100%;\"}),\" to make a \",(0,n.jsx)(e.code,{children:\"div\"}),\" a circle. This will apply a border radius of half of the width/height of the \",(0,n.jsx)(e.code,{children:\"div\"}),\" in each corner.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"3. The controls area\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is where the reset button and game state (winning player, draw, errors, etc.) elements will be placed.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"States\"}),`\n`,(0,n.jsx)(e.p,{children:\"As with any games, we need to keep track of some states throughout one game session.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid\"}),\", which is a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" array that represents the current grid of discs.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\", which is the current player's identifier, so we know whose disc to drop into the grid.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"winner\"}),\", which is the winning player's identifier, so we know who to congratulate! It is \",(0,n.jsx)(e.code,{children:\"null\"}),\" at first. This state also doubles as a flag to indicate if the game has ended.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Names may vary, and you may need other states to support your implementation. These are the minimum.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Binding the interactions\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"At this point, you'd probably be thinking of the \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Connect_Four\",children:\"actual Connect Four game\"}),\". To keep things simple, let's not worry about the animations of the discs dropping into the grid.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Choosing a column to drop a disc\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the disc-drop area, think of each cell as a button. When a button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" is clicked, it triggers an event to drop a disc into column \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We will need to pass the current player's color to color these buttons.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Notably, we want to only show a disc where the player is hovering; they are planning their move! There are many ways to detect if a button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" is hovered.\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"We can use the \",(0,n.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/:hover\",children:[(0,n.jsx)(e.code,{children:\":hover\"}),\" CSS pseudo-class\"]}),\" to detect if the button is currently hovered.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"We can use the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event\",children:(0,n.jsx)(e.code,{children:\"mouseenter\"})}),\" or \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event\",children:(0,n.jsx)(e.code,{children:\"mousemove\"})}),\" event listeners on the buttons to set a state (maybe some \",(0,n.jsx)(e.code,{children:\"currentColumn\"}),\") to \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Once we know if a button \",(0,n.jsx)(e.code,{children:\"i\"}),\" is hovered, we can then modify \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/background-color\",children:(0,n.jsx)(e.code,{children:\"background-color\"})}),\", \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/opacity\",children:(0,n.jsx)(e.code,{children:\"opacity\"})}),\", or \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/visibility\",children:(0,n.jsx)(e.code,{children:\"visibility\"})}),\" to show or hide the button.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Dropping a disc\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We trigger this interaction by binding a \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event\",children:(0,n.jsx)(e.code,{children:\"click\"})}),\" event listener to each button in the disc-drop area. This function will receive the column index \",(0,n.jsx)(e.code,{children:\"i\"}),\" as an argument.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The general algorithm for dropping a player \",(0,n.jsx)(e.code,{children:\"player\"}),\"'s disc into column \",(0,n.jsx)(e.code,{children:\"i\"}),\" is as follows.\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Find the cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\" such that it is the first empty row in column \",(0,n.jsx)(e.code,{children:\"i\"}),\".\",(0,n.jsx)(e.br,{}),`\n`,\"We do this by iterating through the elements (rows) of \",(0,n.jsx)(e.code,{children:\"grid\"}),\" and finding the first element at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" (cell in each row) that is \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"cell\"}),\" to \",(0,n.jsx)(e.code,{children:\"player\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"After dropping a disc, we check if the game has ended.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If yes, we update \",(0,n.jsx)(e.code,{children:\"winner\"}),\" to the winning player's identifier.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If not, we update \",(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\" to the next player in \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Remember that if we cannot find an empty cell in column \",(0,n.jsx)(e.code,{children:\"i\"}),\", we should not allow any disc to drop there. We could either:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Show an error message with \",(0,n.jsx)(e.code,{children:\"alert\"}),\" or some other UI element, or\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Completely disable the button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" and not allow interactions with unavailable columns.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"Checking for the winning condition\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The naive way is to go through every cell in \",(0,n.jsx)(e.code,{children:\"grid\"}),\" and check that for every cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\", if it is a part of any one of the valid winning segments.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A more optimal approach is to only check the cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\" where the player dropped their disc. We can do this because the fact that we are able to drop a disc means there mustn't be a winner yet, so the game continues. This means if a player wins now, it is specifically caused by this one mutation: the placement at \",(0,n.jsx)(e.code,{children:\"cell\"}),\". So, it suffices to only check around \",(0,n.jsx)(e.code,{children:\"cell\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"At \",(0,n.jsx)(e.code,{children:\"cell\"}),\", we check if it is a part of any one of the valid winning segments. We check the four directions: \\u2500, \\u2502, \\u2572, and \\u2571 that crosses \",(0,n.jsx)(e.code,{children:\"cell\"}),\". Each direction is a 7 elements-long array of coordinates relative to \",(0,n.jsx)(e.code,{children:\"cell\"}),\".\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"It is length 7 because each winning segment is 4 elements-long. So, combining the north and south directions, for example, we get 7 elements.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the spirit of good software engineering, we will generalize this algorithm by extracting \",(0,n.jsx)(e.code,{children:\"4\"}),\" out as a constant \",(0,n.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\". This way, we can easily change the winning condition in the future!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"For each direction, count the maximum number of consecutive discs of the current player's color. If there are at least \",(0,n.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" of them, the player has won.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The naive algorithm will take \",(0,n.jsx)(e.code,{children:\"O(ROWS * COLUMNS)\"}),\" time, while the optimal algorithm will take \",(0,n.jsx)(e.code,{children:\"O(COUNT_TO_WIN)\"}),\" time, which is effectively \",(0,n.jsx)(e.code,{children:\"O(1)\"}),\" constant time.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Tip: You can use the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\",children:\"optional chaining operator\"}),\" to safely grab a cell at a coordinate, even if it may be out of bounds. For example, \",(0,n.jsx)(e.code,{children:\"grid?.[r]?.[c]\"}),\" will return \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" if \",(0,n.jsx)(e.code,{children:\"r\"}),\" or \",(0,n.jsx)(e.code,{children:\"c\"}),\" are out of bounds in \",(0,n.jsx)(e.code,{children:\"grid\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"Checking for a draw\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"There are many ways to achieve this. One way is to check if after a disc drop, there is no \",(0,n.jsx)(e.code,{children:\"winner\"}),\", and every cell in \",(0,n.jsx)(e.code,{children:\"grid\"}),\" is occupied.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A more optimal approach is to keep track of the number of discs dropped \",(0,n.jsx)(e.em,{children:\"as we drop them\"}),\". If it reaches \",(0,n.jsx)(e.code,{children:\"ROWS * COLUMNS\"}),\", then we know that the game has ended in a draw. Then we don't have to incur that extra \",(0,n.jsx)(e.code,{children:\"O(ROWS * COLUMNS)\"}),\" time to check if every cell is occupied. Neat!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, keeping track of the number of discs is considered duplicated state since it can be derived from the \",(0,n.jsx)(e.code,{children:\"grid\"}),\" state. Since the number of cells is considered small, it is optional to do such an optimization.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Resetting the game\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is as easy as setting the states back to their initial values, i.e.,\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid\"}),\" to a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" array of \",(0,n.jsx)(e.code,{children:\"null\"}),\"s,\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\" to the first player in \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\", and\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"winner\"}),\" to \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]})]})}function T(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(u,r)})):u(r)}var m=T;var i=h(d());function g(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\"},r.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Let the game be configured with \",(0,i.jsx)(e.code,{children:\"PLAYERS\"}),\" players and the winning condition be \",(0,i.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" consecutive discs of the same color.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"For a given \",(0,i.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,i.jsx)(e.code,{children:\"COLUMNS\"}),\" grid \",(0,i.jsx)(e.code,{children:\"grid\"}),\" and a given \",(0,i.jsx)(e.code,{children:\"player\"}),\",\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"For any given column \",(0,i.jsx)(e.code,{children:\"i\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If there is at least one empty cell \",(0,i.jsx)(e.code,{children:\"cell\"}),\", dropping a disc will result in \",(0,i.jsx)(e.code,{children:\"cell\"}),\" being filled with \",(0,i.jsx)(e.code,{children:\"player\"}),\"'s disc color.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Dropping a disc in a column will fill spaces from the bottom.\"}),`\n`,(0,i.jsx)(e.li,{children:\"If there is no empty cell, a disc cannot be placed in the column. If you have other behaviors for this case, expect it to happen too.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"When a disc is dropped into some cell \",(0,i.jsx)(e.code,{children:\"cell\"}),\", for each of the four directions: \\u2500, \\u2502, \\u2572, and \\u2571 that crosses \",(0,i.jsx)(e.code,{children:\"cell\"}),\",\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If there are at least \",(0,i.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" consecutive cells filled with \",(0,i.jsx)(e.code,{children:\"player\"}),\"'s disc color, there's an indicator for the winning player.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Otherwise, the color of the disc to drop in the next turn is the next player in \",(0,i.jsx)(e.code,{children:\"PLAYERS\"}),\"'s.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Game progress:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Players can take turns to drop the discs until a player wins or a there's a draw.\"}),`\n`,(0,i.jsx)(e.li,{children:\"If all cells are filled and no player has won, a draw indicator appears.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Game conclusion\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"When the winning or a draw indicator appears, no more discs can be dropped.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Clicking on the \"Reset\" button will turn all cells ',(0,i.jsx)(e.code,{children:\"grid\"}),\" to its base color, and clear any winning or draw indicators.\"]}),`\n`]})]})}function W(r={}){let{wrapper:e}=r.components||{};return e?(0,i.jsx)(e,Object.assign({},r,{children:(0,i.jsx)(g,r)})):g(r)}var f=W;function w(r){return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(m,{}),`\n`,(0,c.jsx)(f,{})]})}function _(r={}){let{wrapper:e}=r.components||{};return e?(0,c.jsx)(e,Object.assign({},r,{children:(0,c.jsx)(w,r)})):w(r)}var I=_;return C(U);})();\n;return Component;"
}