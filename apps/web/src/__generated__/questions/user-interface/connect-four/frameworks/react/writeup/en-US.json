{
  "skeleton": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),v=(o,e)=>{for(var r in e)l(o,r,{get:e[r],enumerable:!0})},s=(o,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of y(e))!x.call(o,t)&&t!==r&&l(o,t,{get:()=>e[t],enumerable:!(c=g(e,t))||c.enumerable});return o};var d=(o,e,r)=>(r=o!=null?f(w(o)):{},s(e||!o||!o.__esModule?l(r,\"default\",{value:o,enumerable:!0}):r,o)),j=o=>s(l({},\"__esModule\",{value:!0}),o);var a=b((D,h)=>{h.exports=_jsx_runtime});var M={};v(M,{default:()=>F});var i=d(a());var n=d(a());function u(o){let e=Object.assign({p:\"p\",img:\"img\",h2:\"h2\",ul:\"ul\",li:\"li\",h3:\"h3\",code:\"code\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:'Build a \"Connect Four\" game for two players in which the players take turns dropping colored discs from the top into a vertically suspended board/grid.'}),`\n`,(0,n.jsx)(e.p,{children:\"The objective of the game is to be the first player to form a horizontal, vertical, or diagonal line of four of their own colored discs.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/img/questions/connect-four/connect-four-example.png\",alt:\"Connect Four example\"})}),`\n`,(0,n.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The board should have 6 rows and 7 columns.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The game should support two players, Player 1 and Player 2, with distinct colors for their game pieces (e.g., red and yellow).\"}),`\n`,(0,n.jsx)(e.li,{children:\"Players take turns to drop their pieces onto the board. Player 1 goes first, and then the players alternate turns.\"}),`\n`,(0,n.jsx)(e.li,{children:\"When a player clicks on a column, their piece should fall to the lowest available position within that column.\"}),`\n`,(0,n.jsx)(e.li,{children:\"A player can only place a piece in a column that is not already full. If a column is full, the player must choose a different column.\"}),`\n`,(0,n.jsx)(e.li,{children:\"When a player successfully connects four of their pieces horizontally, vertically, or diagonally, declare them as the winner and display a victory message.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the game board is full (i.e., no more valid moves are possible) and no player has connected four pieces, declare the game as a draw.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Provide a button to restart the game, allowing players to play again without having to refresh the page.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Colors\"}),`\n`,(0,n.jsx)(e.p,{children:\"Feel free to use the following hex values when making your game:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Red pieces: \",(0,n.jsx)(e.code,{children:\"#d9313d\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Yellow pieces: \",(0,n.jsx)(e.code,{children:\"#fdc601\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Blue board: \",(0,n.jsx)(e.code,{children:\"#1c61f2\"})]}),`\n`]})]})}function _(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(u,o)})):u(o)}var p=_;function m(o){return(0,i.jsx)(p,{})}function C(o={}){let{wrapper:e}=o.components||{};return e?(0,i.jsx)(e,Object.assign({},o,{children:(0,i.jsx)(m,o)})):m(o)}var F=C;return j(M);})();\n;return Component;",
  "solution": "var Component=(()=>{var y=Object.create;var l=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var S=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var O=(c,e)=>()=>(e||c((e={exports:{}}).exports,e),e.exports),x=(c,e)=>{for(var t in e)l(c,t,{get:e[t],enumerable:!0})},s=(c,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of v(e))!k.call(c,o)&&o!==t&&l(c,o,{get:()=>e[o],enumerable:!(a=b(e,o))||a.enumerable});return c};var h=(c,e,t)=>(t=c!=null?y(S(c)):{},s(e||!c||!c.__esModule?l(t,\"default\",{value:c,enumerable:!0}):t,c)),C=c=>s(l({},\"__esModule\",{value:!0}),c);var d=O((R,p)=>{p.exports=_jsx_runtime});var U={};x(U,{default:()=>I});var r=h(d());var n=h(d());function u(c){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",img:\"img\",h3:\"h3\",h4:\"h4\",ul:\"ul\",li:\"li\",strong:\"strong\",blockquote:\"blockquote\",a:\"a\",ol:\"ol\",br:\"br\",em:\"em\"},c.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the spirit of good software engineering, let's devise a solution that is as customizable as possible. We will build a Connect Four game that works with any numbers of rows, columns, and players. Let these be constants \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\", \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\", and \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\" respectively.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/img/questions/connect-four/connect-four-example.png\",alt:\"Connect Four example\"})}),`\n`,(0,n.jsx)(e.h3,{children:\"Setting up the playground\"}),`\n`,(0,n.jsx)(e.p,{children:\"From the example image, we see that we need at least three main sections:\"}),`\n`,(0,n.jsx)(e.h4,{children:\"1. The disc-drop area\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is where a player will drop their disc. It is a single row of \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" cells, each representing a column in the game grid. The color of the disc shown will be the current player's.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"2. The game grid\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This is where all the discs will be placed. It is a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" grid. More specifically, it is a \",(0,n.jsx)(e.code,{children:\"div\"}),\" of \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\" number of \",(0,n.jsx)(e.code,{children:\"div\"}),\"s. Each of these \",(0,n.jsx)(e.code,{children:\"div\"}),\"s contains \",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" number of \",(0,n.jsx)(e.code,{children:\"div\"}),\"s.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Each cell has two states:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"empty\"}),\": which displays a transparent (or the app's background color) circle, and\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"occupied\"}),\": which displays a circle colored with the player's disc color.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Tip: Use \",(0,n.jsx)(e.code,{children:\"border-radius: 100%;\"}),\" to make a \",(0,n.jsx)(e.code,{children:\"div\"}),\" a circle. This will apply a border radius of half of the width/height of the \",(0,n.jsx)(e.code,{children:\"div\"}),\" in each corner.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"3. The controls area\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is where the reset button and game state (winning player, draw, errors, etc.) elements will be placed.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"States\"}),`\n`,(0,n.jsx)(e.p,{children:\"As with any games, we need to keep track of some states throughout one game session.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid\"}),\", which is a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" array that represents the current grid of discs.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\", which is the current player's identifier, so we know whose disc to drop into the grid.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"winner\"}),\", which is the winning player's identifier, so we know who to congratulate! It is \",(0,n.jsx)(e.code,{children:\"null\"}),\" at first. This state also doubles as a flag to indicate if the game has ended.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Names may vary, and you may need other states to support your implementation. These are the minimum.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Binding the interactions\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"At this point, you'd probably be thinking of the \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Connect_Four\",children:\"actual Connect Four game\"}),\". To keep things simple, let's not worry about the animations of the discs dropping into the grid.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Choosing a column to drop a disc\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the disc-drop area, think of each cell as a button. When a button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" is clicked, it triggers an event to drop a disc into column \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"We will need to pass the current player's color to color these buttons.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Notably, we want to only show a disc where the player is hovering; they are planning their move! There are many ways to detect if a button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" is hovered.\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"We can use the \",(0,n.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/:hover\",children:[(0,n.jsx)(e.code,{children:\":hover\"}),\" CSS pseudo-class\"]}),\" to detect if the button is currently hovered.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"We can use the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/mouseenter_event\",children:(0,n.jsx)(e.code,{children:\"mouseenter\"})}),\" or \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/mousemove_event\",children:(0,n.jsx)(e.code,{children:\"mousemove\"})}),\" event listeners on the buttons to set a state (maybe some \",(0,n.jsx)(e.code,{children:\"currentColumn\"}),\") to \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Once we know if a button \",(0,n.jsx)(e.code,{children:\"i\"}),\" is hovered, we can then modify \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/background-color\",children:(0,n.jsx)(e.code,{children:\"background-color\"})}),\", \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/opacity\",children:(0,n.jsx)(e.code,{children:\"opacity\"})}),\", or \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/visibility\",children:(0,n.jsx)(e.code,{children:\"visibility\"})}),\" to show or hide the button.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Dropping a disc\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We trigger this interaction by binding a \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event\",children:(0,n.jsx)(e.code,{children:\"click\"})}),\" event listener to each button in the disc-drop area. This function will receive the column index \",(0,n.jsx)(e.code,{children:\"i\"}),\" as an argument.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The general algorithm for dropping a player \",(0,n.jsx)(e.code,{children:\"player\"}),\"'s disc into column \",(0,n.jsx)(e.code,{children:\"i\"}),\" is as follows.\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Find the cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\" such that it is the first empty row in column \",(0,n.jsx)(e.code,{children:\"i\"}),\".\",(0,n.jsx)(e.br,{}),`\n`,\"We do this by iterating through the elements (rows) of \",(0,n.jsx)(e.code,{children:\"grid\"}),\" and finding the first element at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" (cell in each row) that is \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"cell\"}),\" to \",(0,n.jsx)(e.code,{children:\"player\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"After dropping a disc, we check if the game has ended.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If yes, we update \",(0,n.jsx)(e.code,{children:\"winner\"}),\" to the winning player's identifier.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If not, we update \",(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\" to the next player in \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Remember that if we cannot find an empty cell in column \",(0,n.jsx)(e.code,{children:\"i\"}),\", we should not allow any disc to drop there. We could either:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Show an error message with \",(0,n.jsx)(e.code,{children:\"alert\"}),\" or some other UI element, or\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Completely disable the button at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" and not allow interactions with unavailable columns.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"Checking for the winning condition\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The naive way is to go through every cell in \",(0,n.jsx)(e.code,{children:\"grid\"}),\" and check that for every cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\", if it is a part of any one of the valid winning segments.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A more optimal approach is to only check the cell \",(0,n.jsx)(e.code,{children:\"cell\"}),\" where the player dropped their disc. We can do this because the fact that we are able to drop a disc means there mustn't be a winner yet, so the game continues. This means if a player wins now, it is specifically caused by this one mutation: the placement at \",(0,n.jsx)(e.code,{children:\"cell\"}),\". So, it suffices to only check around \",(0,n.jsx)(e.code,{children:\"cell\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"At \",(0,n.jsx)(e.code,{children:\"cell\"}),\", we check if it is a part of any one of the valid winning segments. We check the four directions: \\u2500, \\u2502, \\u2572, and \\u2571 that crosses \",(0,n.jsx)(e.code,{children:\"cell\"}),\". Each direction is a 7 elements-long array of coordinates relative to \",(0,n.jsx)(e.code,{children:\"cell\"}),\".\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"It is length 7 because each winning segment is 4 elements-long. So, combining the north and south directions, for example, we get 7 elements.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the spirit of good software engineering, we will generalize this algorithm by extracting \",(0,n.jsx)(e.code,{children:\"4\"}),\" out as a constant \",(0,n.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\". This way, we can easily change the winning condition in the future!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"For each direction, count the maximum number of consecutive discs of the current player's color. If there are at least \",(0,n.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" of them, the player has won.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The naive algorithm will take \",(0,n.jsx)(e.code,{children:\"O(ROWS * COLUMNS)\"}),\" time, while the optimal algorithm will take \",(0,n.jsx)(e.code,{children:\"O(COUNT_TO_WIN)\"}),\" time, which is effectively \",(0,n.jsx)(e.code,{children:\"O(1)\"}),\" constant time.\"]}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Tip: You can use the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining\",children:\"optional chaining operator\"}),\" to safely grab a cell at a coordinate, even if it may be out of bounds. For example, \",(0,n.jsx)(e.code,{children:\"grid?.[r]?.[c]\"}),\" will return \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" if \",(0,n.jsx)(e.code,{children:\"r\"}),\" or \",(0,n.jsx)(e.code,{children:\"c\"}),\" are out of bounds in \",(0,n.jsx)(e.code,{children:\"grid\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"Checking for a draw\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"There are many ways to achieve this. One way is to check if after a disc drop, there is no \",(0,n.jsx)(e.code,{children:\"winner\"}),\", and every cell in \",(0,n.jsx)(e.code,{children:\"grid\"}),\" is occupied.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A more optimal approach is to keep track of the number of discs dropped \",(0,n.jsx)(e.em,{children:\"as we drop them\"}),\". If it reaches \",(0,n.jsx)(e.code,{children:\"ROWS * COLUMNS\"}),\", then we know that the game has ended in a draw. Then we don't have to incur that extra \",(0,n.jsx)(e.code,{children:\"O(ROWS * COLUMNS)\"}),\" time to check if every cell is occupied. Neat!\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, keeping track of the number of discs is considered duplicated state since it can be derived from the \",(0,n.jsx)(e.code,{children:\"grid\"}),\" state. Since the number of cells is considered small, it is optional to do such an optimization.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Resetting the game\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is as easy as setting the states back to their initial values, i.e.,\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid\"}),\" to a \",(0,n.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,n.jsx)(e.code,{children:\"COLUMNS\"}),\" array of \",(0,n.jsx)(e.code,{children:\"null\"}),\"s,\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"currentPlayer\"}),\" to the first player in \",(0,n.jsx)(e.code,{children:\"PLAYERS\"}),\", and\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"winner\"}),\" to \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]})]})}function W(c={}){let{wrapper:e}=c.components||{};return e?(0,n.jsx)(e,Object.assign({},c,{children:(0,n.jsx)(u,c)})):u(c)}var m=W;var i=h(d());function g(c){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\"},c.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Let the game be configured with \",(0,i.jsx)(e.code,{children:\"PLAYERS\"}),\" players and the winning condition be \",(0,i.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" consecutive discs of the same color.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"For a given \",(0,i.jsx)(e.code,{children:\"ROWS\"}),\"-by-\",(0,i.jsx)(e.code,{children:\"COLUMNS\"}),\" grid \",(0,i.jsx)(e.code,{children:\"grid\"}),\" and a given \",(0,i.jsx)(e.code,{children:\"player\"}),\",\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"For any given column \",(0,i.jsx)(e.code,{children:\"i\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If there is at least one empty cell \",(0,i.jsx)(e.code,{children:\"cell\"}),\", dropping a disc will result in \",(0,i.jsx)(e.code,{children:\"cell\"}),\" being filled with \",(0,i.jsx)(e.code,{children:\"player\"}),\"'s disc color.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Dropping a disc in a column will fill spaces from the bottom.\"}),`\n`,(0,i.jsx)(e.li,{children:\"If there is no empty cell, a disc cannot be placed in the column. If you have other behaviors for this case, expect it to happen too.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"When a disc is dropped into some cell \",(0,i.jsx)(e.code,{children:\"cell\"}),\", for each of the four directions: \\u2500, \\u2502, \\u2572, and \\u2571 that crosses \",(0,i.jsx)(e.code,{children:\"cell\"}),\",\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If there are at least \",(0,i.jsx)(e.code,{children:\"COUNT_TO_WIN\"}),\" consecutive cells filled with \",(0,i.jsx)(e.code,{children:\"player\"}),\"'s disc color, there's an indicator for the winning player.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Otherwise, the color of the disc to drop in the next turn is the next player in \",(0,i.jsx)(e.code,{children:\"PLAYERS\"}),\"'s.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Game progress:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Players can take turns to drop the discs until a player wins or a there's a draw.\"}),`\n`,(0,i.jsx)(e.li,{children:\"If all cells are filled and no player has won, a draw indicator appears.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Game conclusion\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"When the winning or a draw indicator appears, no more discs can be dropped.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Clicking on the \"Reset\" button will turn all cells ',(0,i.jsx)(e.code,{children:\"grid\"}),\" to its base color, and clear any winning or draw indicators.\"]}),`\n`]})]})}function T(c={}){let{wrapper:e}=c.components||{};return e?(0,i.jsx)(e,Object.assign({},c,{children:(0,i.jsx)(g,c)})):g(c)}var f=T;function w(c){let e=Object.assign({h3:\"h3\",h4:\"h4\",code:\"code\",p:\"p\",a:\"a\",em:\"em\"},c.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(m,{}),`\n`,(0,r.jsx)(e.h3,{children:\"React-specific notes\"}),`\n`,(0,r.jsxs)(e.h4,{children:[(0,r.jsx)(e.code,{children:\"useState\"}),\" and \",(0,r.jsx)(e.code,{children:\"grid\"}),\" mutations\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Since we are using \",(0,r.jsx)(e.code,{children:\"useState\"}),\" as the \",(0,r.jsx)(e.code,{children:\"grid\"}),\" state, we should not mutate \",(0,r.jsx)(e.code,{children:\"grid\"}),\" when we drop a disc. We need to make a deep copy the \",(0,r.jsx)(e.code,{children:\"grid\"}),\" state, mutate the copy, and then set the state to the copy with \",(0,r.jsx)(e.code,{children:\"setGrid\"}),\". We can also use \",(0,r.jsxs)(e.a,{href:\"https://immerjs.github.io/immer/produce/\",children:[\"Immer's \",(0,r.jsx)(e.code,{children:\"produce\"})]}),\" if third-party libraries are allowed.\"]}),`\n`,(0,r.jsxs)(e.h4,{children:[\"Using indices as \",(0,r.jsx)(e.code,{children:\"key\"}),\"s\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"When we \",(0,r.jsx)(e.code,{children:\"map\"}),\" the rows and cells in \",(0,r.jsx)(e.code,{children:\"grid\"}),\", we use their indices as \",(0,r.jsx)(e.code,{children:\"key\"}),\"s. If you are a student of React, you'd probably realize that \",(0,r.jsx)(e.a,{href:\"https://react.dev/learn/rendering-lists#why-does-react-need-keys\",children:\"React warns against it\"}),\". But in this case, it's perfectly fine to use indices as \",(0,r.jsx)(e.code,{children:\"key\"}),\"s because \",(0,r.jsxs)(e.em,{children:[\"they are the correct identifiers of the rows and cells in \",(0,r.jsx)(e.code,{children:\"grid\"})]}),', do not contain state and the grid dimensions do not change while the game is in-progress. Therefore, it will not cause any \"subtle and confusing bugs\" as React warns.']}),`\n`,(0,r.jsx)(f,{})]})}function _(c={}){let{wrapper:e}=c.components||{};return e?(0,r.jsx)(e,Object.assign({},c,{children:(0,r.jsx)(w,c)})):w(c)}var I=_;return C(U);})();\n;return Component;"
}