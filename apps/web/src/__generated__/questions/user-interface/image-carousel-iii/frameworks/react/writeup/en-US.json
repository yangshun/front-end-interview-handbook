{
  "skeleton": "var Component=(()=>{var f=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),q=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},h=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of b(e))!y.call(t,o)&&o!==i&&s(t,o,{get:()=>e[o],enumerable:!(l=p(e,o))||l.enumerable});return t};var u=(t,e,i)=>(i=t!=null?f(x(t)):{},h(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),j=t=>h(s({},\"__esModule\",{value:!0}),t);var a=w((v,c)=>{c.exports=_jsx_runtime});var D={};q(D,{default:()=>M});var r=u(a());var n=u(a());function m(t){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is a follow up to the \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel\",children:\"Image Carousel\"}),\" question, you should complete that question first before attempting this question.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Build an image carousel that displays a sequence of images, smoothly transitioning when navigating between images.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The main difference between this question and \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel-ii\",children:\"Image Carousel II\"}),\" is that there should only be a \",(0,n.jsx)(e.strong,{children:\"maximum of two image elements\"}),\" in the DOM at any one time. This improves performance because the number of image elements present in the DOM is no longer proportional to the number of images, and the image carousel does not unnecessarily load images that aren't shown. However, this approach comes at the cost of higher implementation complexity.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"All requirements of \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel\",children:\"Image Carousel\"}),\" question should be supported.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Upon clicking the Prev/Next buttons, the current image should smoothly translate out while the next image enters. Translation direction is left/right respectively.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Transitions when clicking on the page buttons is optional but highly encouraged. Aim to reuse the transitioning code for the Prev/Next buttons.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"There should only be a \",(0,n.jsx)(e.strong,{children:\"maximum of two image elements\"}),\" in the DOM at any one time.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:'Click on the \"See what you are building\" button to see a preview of the result.'}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The skeleton code uses the solution of \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/image-carousel\",children:\"Image Carousel\"}),\", but you are free to use your own solution as a starting point.\"]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var g=C;function d(t){return(0,r.jsx)(g,{})}function I(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(d,t)})):d(t)}var M=I;return j(D);})();\n;return Component;",
  "solution": "var Component=(()=>{var x=Object.create;var d=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var S=Object.getPrototypeOf,M=Object.prototype.hasOwnProperty;var j=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),I=(t,e)=>{for(var o in e)d(t,o,{get:e[o],enumerable:!0})},m=(t,e,o,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of k(e))!M.call(t,s)&&s!==o&&d(t,s,{get:()=>e[s],enumerable:!(h=T(e,s))||h.enumerable});return t};var c=(t,e,o)=>(o=t!=null?x(S(t)):{},m(e||!t||!t.__esModule?d(o,\"default\",{value:t,enumerable:!0}):o,t)),_=t=>m(d({},\"__esModule\",{value:!0}),t);var l=j((H,u)=>{u.exports=_jsx_runtime});var F={};I(F,{default:()=>X});var a=c(l());var n=c(l());function g(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\",code:\"code\",strong:\"strong\",pre:\"pre\",ol:\"ol\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"We are able to reuse most of the existing markup for this question. The complexity is in rendering both current + new images, and animating the transitions.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Complexities of CSS transitions\"}),`\n`,(0,n.jsx)(e.p,{children:\"CSS transitions which involve removal of the animated elements at the end can be quite tricky to implement well. The element needs to stay in the DOM for the duration of the transition, then be removed. Removing the element typically requires JavaScript intervention. You need to coordinate the CSS transition duration with the JavaScript timing for element removal, which can lead to synchronization issues.\"}),`\n`,(0,n.jsx)(e.p,{children:\"If a transition is cancelled or interrupted (e.g., by quickly toggling a state), you need to handle these cases gracefully, potentially removing the element immediately or reverting to a different state.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Determining how to handle events on elements that are transitioning out can be tricky. Should they still be interactive? How do you prevent unintended interactions?\"}),`\n`,(0,n.jsx)(e.p,{children:\"It is hard to build transitions that involve entering and leaving the DOM when using declarative UI frameworks because these frameworks render based the UI on the current state. Transitions usually involve displaying both current and new states at the same time, which means your UI code has to include both current + new state values and include the logic for transitioning between them correctly and with the right timing. These can be quite complex to implement correctly after accounting for the scenarios listed above.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Thus, it is common for frameworks to provide abstractions to make implementing animations easier:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"React does not provide any first class abstractions but endorses React-specific animation libraries like \",(0,n.jsx)(e.a,{href:\"https://reactcommunity.org/react-transition-group/\",children:\"React Transition Group\"}),\" and \",(0,n.jsx)(e.a,{href:\"https://framer.com/motion\",children:\"Framer Motion\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Angular provides the \",(0,n.jsx)(e.a,{href:\"https://angular.dev/guide/animations\",children:(0,n.jsx)(e.code,{children:\"@angular/animations\"})}),\" module.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Vue provides the \",(0,n.jsx)(e.a,{href:\"https://vuejs.org/guide/built-ins/transition.html\",children:(0,n.jsx)(e.code,{children:\"<Transition>\"})}),\" and \",(0,n.jsx)(e.a,{href:\"https://vuejs.org/guide/built-ins/transition-group.html\",children:(0,n.jsx)(e.code,{children:\"<TransitionGroup>\"})}),\" components.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Svelte provides the \",(0,n.jsx)(e.a,{href:\"https://svelte.dev/docs/svelte-animate\",children:(0,n.jsx)(e.code,{children:\"svelte/animate\"})}),\" module.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In production cases, most apps are better off using the battle-tested libraries mentioned over rolling custom animations and transitions.\"}),`\n`,(0,n.jsx)(e.p,{children:\"However, for practice purposes, let's complete this question by implementing the transitions from scratch.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"How to transition\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since the current and new images do not affect DOM layout, the CSS \",(0,n.jsx)(e.code,{children:\"transform\"}),\" property is a perfect choice for transitioning because of:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"GPU acceleration\"}),\": Many browsers can offload transform operations to the GPU, resulting in smoother animations and better overall performance.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Reduced repaints\"}),\": CSS \",(0,n.jsx)(e.code,{children:\"transform\"}),\"s don't trigger repaints of the entire page layout, unlike changes to properties like like \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"margin\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Assuming we're transitioning from the first image to the second image, the transition can be executed as such:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The current image is the default state and starts without any CSS transforms. It ends with \",(0,n.jsx)(e.code,{children:\"transform: transformX(-100%)\"}),\" (displaced to the left, hidden out of view).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The next image starts with a CSS transform of \",(0,n.jsx)(e.code,{children:\"transform: transformX(100%)\"}),\" (displaced to the right, hidden out of view). It ends without any CSS transforms since it is meant to end with the default state and replace the current image.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"We can create the following CSS classes to support these CSS transitions:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-css\",children:`.image-carousel__image {\n  /* Other irrelevant CSS omitted. */\n  transition: transform 0.5s linear;\n}\n\n.image-carousel__image--displaced-left {\n  transform: translateX(-100%);\n}\n\n.image-carousel__image--displaced-right {\n  transform: translateX(100%);\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"These classes can be used to support a transition from the right-to-left direction as well by switching the order.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Transition stages\"}),`\n`,(0,n.jsx)(e.p,{children:\"For an image carousel transitioning between two images, the transition can be done in the following stages:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Idle\"}),\": Render only the current image in the DOM.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Before transition\"}),\": Upon receiving the instruction to navigate to a new image (e.g. via a button click), render two images (both current and next image) into the DOM. The next image is not visible yet, but is present in the DOM so that it can be transitioned in.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Transitioning\"}),\": The current image translates out (exit transition). The next image translates in (entrance transition).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Transition end\"}),\": The images are at their new positions. The current image should not be visible anymore and can be removed from the DOM. Only the next image is visible.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Back to idle\"}),\": The next image is now the current image and is the only visible image rendered in the DOM.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"As mentioned, the component will need to support both current and new states, on top of the \",(0,n.jsx)(e.code,{children:\"currIndex\"}),\" value, there will be two new state values needed to support the transition stages above \\u2013 \",(0,n.jsx)(e.code,{children:\"nextIndex\"}),\" and \",(0,n.jsx)(e.code,{children:\"isTransitioning\"}),\".\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Idle\"}),\": In the idle stage, the image carousel displays the image based on the \",(0,n.jsx)(e.code,{children:\"currIndex\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Before transition\"}),\": When a button press happens, the \",(0,n.jsx)(e.code,{children:\"changeImageIndex\"}),\" function is called, which sets the \",(0,n.jsx)(e.code,{children:\"nextIndex\"}),' value, the carousel is now in the \"Before transition\" stage. With the new ',(0,n.jsx)(e.code,{children:\"nextIndex\"}),\" value, render the next image to the DOM (not visible yet). At this stage, both images are in the DOM, with the next image in a displaced position that is not visible. As mentioned above, the displacement can be achieved with \",(0,n.jsx)(e.code,{children:\"transform: translateX(...)\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Transitioning\"}),\": The transition is kicked off in the next frame with the help of \",(0,n.jsx)(e.code,{children:\"requestAnimationFrame()\"}),\". Without starting the transition in the next frame, the next image does not have an initial state to transition from and the transition will not happen. The current image translates out via \",(0,n.jsx)(e.code,{children:\"transform: translateX(...)\"}),\", while the next image translates in. The end state of the next image is without any \",(0,n.jsx)(e.code,{children:\"transform\"}),\" properties.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Transition end\"}),\": At this point, the original image has been displaced and is no longer visible, the next image is the only visible image remaining. A \",(0,n.jsx)(e.code,{children:\"transitionend\"}),\" listener is added to the next image element to notify the component when the transition has ended.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Back to idle\"}),': The various state values can be reset to the \"Idle\" stage. By setting the ',(0,n.jsx)(e.code,{children:\"currIndex\"}),\" to be the new value, the previous image will be removed from the DOM. For frameworks that make use of virtual DOMs, the new \",(0,n.jsx)(e.code,{children:\"<img>\"}),\" element should be used as the current image. In React, specifying the \",(0,n.jsx)(e.code,{children:\"key\"}),\" value helps to signal to the framework to reuse particular elements across renders. Without the \",(0,n.jsx)(e.code,{children:\"key\"}),\" value, React will attempt to destroy the \",(0,n.jsx)(e.code,{children:\"<img>\"}),\" element and recreate it, messing with the transitions.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Here's a table demonstrating the various stages and the respective state values when going from the first image to the second image:\"}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Stage\"}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"currIndex\"})}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"nextIndex\"})}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"isTransitioning\"})}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"currImage\"})}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"nextImage\"})})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Idle\"}),(0,n.jsx)(e.td,{children:\"0\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"null\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"false\"})}),(0,n.jsx)(e.td,{children:\"Visible\"}),(0,n.jsx)(e.td,{children:\"Not in DOM\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Preparing for transition\"}),(0,n.jsx)(e.td,{children:\"0\"}),(0,n.jsx)(e.td,{children:\"1\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"false\"})}),(0,n.jsx)(e.td,{children:\"Visible\"}),(0,n.jsx)(e.td,{children:\"Displaced (Not visible)\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Transitioning\"}),(0,n.jsx)(e.td,{children:\"0\"}),(0,n.jsx)(e.td,{children:\"1\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"true\"})}),(0,n.jsx)(e.td,{children:\"Transitioning\"}),(0,n.jsx)(e.td,{children:\"Transitioning\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Transition end\"}),(0,n.jsx)(e.td,{children:\"0\"}),(0,n.jsx)(e.td,{children:\"1\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"true\"})}),(0,n.jsx)(e.td,{children:\"Displaced (Not visible)\"}),(0,n.jsx)(e.td,{children:\"Visible\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Back to idle\"}),(0,n.jsx)(e.td,{children:\"1\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"null\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"false\"})}),(0,n.jsx)(e.td,{children:\"Not in DOM\"}),(0,n.jsx)(e.td,{children:\"Visible\"})]})]})]}),`\n`,(0,n.jsx)(e.p,{children:\"As you can see, animating just two images horizontally already requires multiple state transitions, the code can get complex very easily when adding more animations.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Events while transitioning\"}),`\n`,(0,n.jsx)(e.p,{children:\"As mentioned above, determining how to handle events on elements that are transitioning out can be tricky. Should they still be interactive? How do you prevent unintended interactions?\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The easiest and most reasonable approach to do is to disable the buttons while the transition is ongoing. The \",(0,n.jsx)(e.code,{children:\"isTransitioning\"}),\" value can be used to determine ongoing transitions and disable event handling on the buttons if so.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Follow up\"}),`\n`,(0,n.jsx)(e.p,{children:\"What we have implemented is a simple image carousel. But image carousels can be packed with more features and multiple further improvements. Here are some common follow up questions you can expect:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Notice that the new images can take some time to load and a flash of black is seen (due to the background color). How can you load images eagerly so that no loading flashes occur?\"}),`\n`,(0,n.jsx)(e.li,{children:\"How can you support autoplay functionality, aka the carousel transitions to the next image after a specified duration?\"}),`\n`,(0,n.jsx)(e.li,{children:\"How can you support an infinite list of images?\"}),`\n`]})]})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(g,t)})):g(t)}var p=D;var r=c(l());function f(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Ensure test cases for basic navigation still pass.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Click the navigation buttons in rapid succession (while the transition is ongoing) and check that no unexpected behavior occurs.\"}),`\n`]})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(f,t)})):f(t)}var b=O;var i=c(l());function v(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",strong:\"strong\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"All images should have \",(0,i.jsx)(e.code,{children:\"alt\"}),\" text that describes the image to support accessibility. It will be read out loud by screen readers and is also used by search engines.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Add appropriate \",(0,i.jsx)(e.code,{children:\"aria-label\"}),\"s to the buttons since the buttons do not have visible labels.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"[Not implemented]\"}),\": Add a screen-reader-only element with the \",(0,i.jsx)(e.code,{children:'aria-live=\"polite\"'}),\" attribute and \",(0,i.jsx)(e.code,{children:\"alt\"}),\" text of the new image as contents. This instructs screen readers to announce that a new image is displayed.\"]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(v,t)})):v(t)}var w=C;function y(t){return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(p,{}),`\n`,(0,a.jsx)(b,{}),`\n`,(0,a.jsx)(w,{})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,a.jsx)(e,Object.assign({},t,{children:(0,a.jsx)(y,t)})):y(t)}var X=A;return _(F);})();\n;return Component;"
}