{
  "author": "yangshun",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/progress-bars-iv-react-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.js": {
      "code": "import { useState } from 'react';\n\nfunction ProgressBar({ progress }) {\n  return (\n    <div className=\"bar\">\n      <div\n        className=\"bar-contents\"\n        style={{ transform: `scaleX(${progress / 100})` }}\n      />\n    </div>\n  );\n}\n\nconst INITIAL_PROGRESSION = [0];\nconst CONCURRENCY_LIMIT = 3;\n\nexport default function App() {\n  const [progression, setProgression] = useState(\n    INITIAL_PROGRESSION,\n  );\n  const [timerId, setTimerId] = useState(null);\n\n  function start() {\n    const timer = window.setInterval(() => {\n      setProgression((currProgression) => {\n        // Find the bars which aren't full.\n        const nonFullBars = currProgression\n          .map((value, index) => ({ value, index }))\n          .filter(({ value }) => value < 100);\n        // All bars are full, none to increment.\n        if (nonFullBars.length === 0) {\n          return currProgression;\n        }\n\n        // Get the first LIMIT non-full bars and increment them.\n        const barsToIncrement = nonFullBars.slice(\n          0,\n          CONCURRENCY_LIMIT,\n        );\n        const newProgression = currProgression.slice();\n        for (const { index } of barsToIncrement) {\n          newProgression[index] += 0.5;\n        }\n        return newProgression;\n      });\n    }, 10);\n\n    setTimerId(timer);\n  }\n\n  function stop() {\n    window.clearInterval(timerId);\n    setTimerId(null);\n  }\n\n  function appendBar() {\n    setProgression(progression.concat(0));\n  }\n\n  function reset() {\n    stop();\n    setProgression(INITIAL_PROGRESSION);\n  }\n\n  // Derived state to determine if the bars are progressing.\n  const isProgressing = timerId != null;\n\n  return (\n    <div className=\"wrapper\">\n      <div className=\"buttons\">\n        <button\n          onClick={() => {\n            appendBar();\n          }}>\n          Add\n        </button>\n        <button\n          onClick={() => {\n            isProgressing ? stop() : start();\n          }}>\n          {isProgressing ? 'Pause' : 'Start'}\n        </button>\n        <button\n          onClick={() => {\n            reset();\n          }}>\n          Reset\n        </button>\n      </div>\n      <div className=\"bars\">\n        {progression.map((progress, index) => (\n          <ProgressBar key={index} progress={progress} />\n        ))}\n      </div>\n      <pre>\n        {JSON.stringify(\n          { isProgressing, progression },\n          null,\n          2,\n        )}\n      </pre>\n    </div>\n  );\n}\n"
    },
    "/src/index.js": {
      "code": "import React, { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n.wrapper {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  justify-content: center;\n}\n\n.buttons {\n  display: flex;\n  column-gap: 8px;\n}\n\n.bars {\n  display: flex;\n  flex-direction: column;\n  row-gap: 8px;\n}\n\n.bar {\n  background-color: #ccc;\n  height: 8px;\n}\n\n.bar-contents {\n  background-color: green;\n  height: 100%;\n  transform-origin: left;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.js",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.js",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var y=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),x=(i,e)=>{for(var r in e)o(i,r,{get:e[r],enumerable:!0})},h=(i,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of b(e))!v.call(i,a)&&a!==r&&o(i,a,{get:()=>e[a],enumerable:!(l=g(e,a))||l.enumerable});return i};var d=(i,e,r)=>(r=i!=null?f(w(i)):{},h(e||!i||!i.__esModule?o(r,\"default\",{value:i,enumerable:!0}):r,i)),T=i=>h(o({},\"__esModule\",{value:!0}),i);var s=y((P,c)=>{c.exports=_jsx_runtime});var j={};x(j,{default:()=>S});var n=d(s());var t=d(s());function u(i){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",h3:\"h3\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Add\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:['Hitting \"Add\" adds a new empty bar is appended to the bottom of the list.',`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The bar should eventually fill up if the animation is ongoing.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Adding new bars should not change the animation state.\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"If all the bars are full and the animation is ongoing and a new bar is added, the newly added bar should start filling up.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Start\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Hitting \"Start\" starts filling up to 3 bars in parallel.'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Pause\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Hitting \"Pause\" when the bars are filling up should stop the animation and the button should show \"Start\".'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Reset\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Hitting \"Reset\" clears all bars and the \"Start\"/\"Pause\" button should show \"Start\" if it was showing \"Pause\".'}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Testing Concurrency\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Hit \"Add\" 3 times to have 4 bars in total, then hit \"Start\". The first 3 should start filling up and complete together and the fourth only starts filling up after the first 3 completes.'}),`\n`,(0,t.jsx)(e.li,{children:`Hit \"Add\" once to have 2 bars in total, then hit \"Start\". After 1 second, hit \"Add\" again. The third bar should start filling up as soon as it's added.`}),`\n`,(0,t.jsx)(e.li,{children:`Hit \"Add\" once to have 2 bars in total, then hit \"Start\". After 1 second, hit \"Add\" twice. The third bar should start filling up as soon as it's added but the fourth bar only starts filling up after the first bar is completed.`}),`\n`]})]})}function A(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(u,i)})):u(i)}var p=A;function m(i){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",h3:\"h3\",code:\"code\",h4:\"h4\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/progress-bars-iii\",children:\"Progress Bars III\"}),\", you should complete that question first before attempting this question.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The question can be split into three parts: (1) State, (2) Animation, and (3) Interactions.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsx)(e.p,{children:\"Since we need to allow for pausing and resuming of the animations, the simple states we used in the previous Progress Bars questions will no longer be sufficient. We need to be able to track each bar's completion percentage.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"A list of progress bars can be modelled with using an array of numeric values, where each value ranges from 0-100, indicating the completion percentage of the bar. The initial state of an empty progress bar will be \",(0,n.jsx)(e.code,{children:\"[0]\"}),\" and two full progress bars is represented by \",(0,n.jsx)(e.code,{children:\"[100, 100]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Appending new bars is simply adding a 0 to the end of the array, via \",(0,n.jsx)(e.code,{children:\"Array.prototype.concat(0)\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Animation\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To have fine-grain control over the animation, we cannot rely on CSS transitions anymore and have to use the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\"/\",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" browser APIs in JavaScript.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"It'll be easier to think about the animation as a loop run at fixed intervals. In every loop, we can increment the relevant progress bars' completion percentages by a small amount to give the impression of a smooth gradual animation.\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"setInterval\"}),\" returns a \",(0,n.jsx)(e.code,{children:\"timerId\"}),\" value which we will save in a state variable so that we can retrieve it when stopping the animation, via \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\". The value of \",(0,n.jsx)(e.code,{children:\"timerId\"}),\" will be \",(0,n.jsx)(e.code,{children:\"null\"}),\" if there's no timer running. To make the animation look smooth, we should pick a time interval that is below 16ms (for a 60fps experience). To fill up a bar from 0 to 100 in 2000ms, one possible combination is to update the completion percentage by 0.5% every 10ms.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Interactions\"}),`\n`,(0,n.jsx)(e.h4,{children:\"Start\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"start\"}),\" function starts the timer via \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" which fires a callback at (nearly) fixed intervals. Each time the callback is fired, we find the first 3 bars that are not full and increase their values by 0.5.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that we need to use the callback form of \",(0,n.jsx)(e.code,{children:\"setProgression\"}),\", which receives the updated \",(0,n.jsx)(e.code,{children:\"progression\"}),\" value as the parameter. This is necessary because the \",(0,n.jsx)(e.code,{children:\"setProgression\"}),\" callback's closure will be referencing a stale version of \",(0,n.jsx)(e.code,{children:\"progression\"}),\" and the callback form of \",(0,n.jsx)(e.code,{children:\"setProgression\"}),\" will provide us with the most updated \",(0,n.jsx)(e.code,{children:\"progression\"}),\" value.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In idiomatic React, we avoid mutation as much as possible, so we make a copy of the \",(0,n.jsx)(e.code,{children:\"progression\"}),\" array first (via \",(0,n.jsx)(e.code,{children:\"slice()\"}),\") before mutation the index of the non-full progress bar.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"If we can't find a non-full progress bar, it means all the bars are full and nothing needs to be done.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Pausing\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Pausing is straightforward. We cancel any existing timers and set the \",(0,n.jsx)(e.code,{children:\"timerId\"}),\" to be \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Appending a New Bar\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To append a new empty bar, we can use \",(0,n.jsx)(e.code,{children:\"progression.concat(0)\"}),\", which clones the array and adds 0 to the end.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Reset\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Simply set \",(0,n.jsx)(e.code,{children:\"progression\"}),\" back to the initial value and call the \",(0,n.jsx)(e.code,{children:\"stop()\"}),\" function.\"]}),`\n`,(0,n.jsx)(p,{})]})}function I(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(m,i)})):m(i)}var S=I;return T(j);})();\n;return Component;"
}