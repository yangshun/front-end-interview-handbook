{
  "skeleton": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var w=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),I=(n,e)=>{for(var r in e)s(n,r,{get:e[r],enumerable:!0})},u=(n,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of b(e))!y.call(n,i)&&i!==r&&s(n,i,{get:()=>e[i],enumerable:!(a=f(e,i))||a.enumerable});return n};var p=(n,e,r)=>(r=n!=null?d(x(n)):{},u(e||!n||!n.__esModule?s(r,\"default\",{value:n,enumerable:!0}):r,n)),j=n=>u(s({},\"__esModule\",{value:!0}),n);var o=w((D,h)=>{h.exports=_jsx_runtime});var P={};I(P,{default:()=>M});var l=p(o());var t=p(o());function c(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\",img:\"img\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/progress-bars-iii\",children:\"Progress Bars III\"}),\", you should complete that question first before attempting this question.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/progress-bars-iii\",children:\"Progress Bars III\"}),\", we built progress bars which fill up in parallel, where multiple of them are filling up concurrently, up to a limit of 3. In this question, we'll allow pausing and resuming of the animation.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Initially there will be one empty progress bar.\"}),`\n`,(0,t.jsx)(e.li,{children:\"The progress bars fill up gradually in parallel, up to a limit of 3 concurrent bars filling up. i.e. the fourth progress bar will only start filling up after the third progress bar is completely filled up.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Each bar takes approximately 2000ms to completely fill up.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Implement the following buttons with the functionality:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Start/Pause: Starts/pauses the filling up of the progress bars. The button label turns into \"Pause\" when the animation is playing.'}),`\n`,(0,t.jsx)(e.li,{children:\"Add: Appends a new progress bar to the bottom of the list.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Reset: Resets to the initial state where there is only one empty bar and stops any running animations.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Example\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/progress-bars-iv/progress-bars-example.png\",alt:\"Progress Bars Example\"})})]})}function _(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(c,n)})):c(n)}var g=_;function m(n){return(0,l.jsx)(g,{})}function q(n={}){let{wrapper:e}=n.components||{};return e?(0,l.jsx)(e,Object.assign({},n,{children:(0,l.jsx)(m,n)})):m(n)}var M=q;return j(P);})();\n;return Component;",
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var y=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),x=(i,e)=>{for(var r in e)o(i,r,{get:e[r],enumerable:!0})},h=(i,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of b(e))!v.call(i,a)&&a!==r&&o(i,a,{get:()=>e[a],enumerable:!(l=g(e,a))||l.enumerable});return i};var d=(i,e,r)=>(r=i!=null?f(w(i)):{},h(e||!i||!i.__esModule?o(r,\"default\",{value:i,enumerable:!0}):r,i)),T=i=>h(o({},\"__esModule\",{value:!0}),i);var s=y((P,c)=>{c.exports=_jsx_runtime});var j={};x(j,{default:()=>S});var n=d(s());var t=d(s());function u(i){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",h3:\"h3\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Add\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:['Hitting \"Add\" adds a new empty bar is appended to the bottom of the list.',`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The bar should eventually fill up if the animation is ongoing.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Adding new bars should not change the animation state.\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"If all the bars are full and the animation is ongoing and a new bar is added, the newly added bar should start filling up.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Start\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Hitting \"Start\" starts filling up to 3 bars in parallel.'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Pause\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Hitting \"Pause\" when the bars are filling up should stop the animation and the button should show \"Start\".'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Reset\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Hitting \"Reset\" clears all bars and the \"Start\"/\"Pause\" button should show \"Start\" if it was showing \"Pause\".'}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Testing Concurrency\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Hit \"Add\" 3 times to have 4 bars in total, then hit \"Start\". The first 3 should start filling up and complete together and the fourth only starts filling up after the first 3 completes.'}),`\n`,(0,t.jsx)(e.li,{children:`Hit \"Add\" once to have 2 bars in total, then hit \"Start\". After 1 second, hit \"Add\" again. The third bar should start filling up as soon as it's added.`}),`\n`,(0,t.jsx)(e.li,{children:`Hit \"Add\" once to have 2 bars in total, then hit \"Start\". After 1 second, hit \"Add\" twice. The third bar should start filling up as soon as it's added but the fourth bar only starts filling up after the first bar is completed.`}),`\n`]})]})}function A(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(u,i)})):u(i)}var p=A;function m(i){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",h3:\"h3\",code:\"code\",h4:\"h4\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/progress-bars-iii\",children:\"Progress Bars III\"}),\", you should complete that question first before attempting this question.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The question can be split into three parts: (1) State, (2) Animation, and (3) Interactions.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsx)(e.p,{children:\"Since we need to allow for pausing and resuming of the animations, the simple states we used in the previous Progress Bars questions will no longer be sufficient. We need to be able to track each bar's completion percentage.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"A list of progress bars can be modelled with using an array of numeric values, where each value ranges from 0-100, indicating the completion percentage of the bar. The initial state of an empty progress bar will be \",(0,n.jsx)(e.code,{children:\"[0]\"}),\" and two full progress bars is represented by \",(0,n.jsx)(e.code,{children:\"[100, 100]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Appending new bars is simply adding a 0 to the end of the array, via \",(0,n.jsx)(e.code,{children:\"Array.prototype.concat(0)\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Animation\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To have fine-grain control over the animation, we cannot rely on CSS transitions anymore and have to use the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\"/\",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" browser APIs in JavaScript.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"It'll be easier to think about the animation as a loop run at fixed intervals. In every loop, we can increment the relevant progress bars' completion percentages by a small amount to give the impression of a smooth gradual animation.\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"setInterval\"}),\" returns a \",(0,n.jsx)(e.code,{children:\"timerId\"}),\" value which we will save in a state variable so that we can retrieve it when stopping the animation, via \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\". The value of \",(0,n.jsx)(e.code,{children:\"timerId\"}),\" will be \",(0,n.jsx)(e.code,{children:\"null\"}),\" if there's no timer running. To make the animation look smooth, we should pick a time interval that is below 16ms (for a 60fps experience). To fill up a bar from 0 to 100 in 2000ms, one possible combination is to update the completion percentage by 0.5% every 10ms.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Interactions\"}),`\n`,(0,n.jsx)(e.h4,{children:\"Start\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"start\"}),\" function starts the timer via \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" which fires a callback at (nearly) fixed intervals. Each time the callback is fired, we find the first 3 bars that are not full and increase their values by 0.5.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that we need to use the callback form of \",(0,n.jsx)(e.code,{children:\"setProgression\"}),\", which receives the updated \",(0,n.jsx)(e.code,{children:\"progression\"}),\" value as the parameter. This is necessary because the \",(0,n.jsx)(e.code,{children:\"setProgression\"}),\" callback's closure will be referencing a stale version of \",(0,n.jsx)(e.code,{children:\"progression\"}),\" and the callback form of \",(0,n.jsx)(e.code,{children:\"setProgression\"}),\" will provide us with the most updated \",(0,n.jsx)(e.code,{children:\"progression\"}),\" value.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In idiomatic React, we avoid mutation as much as possible, so we make a copy of the \",(0,n.jsx)(e.code,{children:\"progression\"}),\" array first (via \",(0,n.jsx)(e.code,{children:\"slice()\"}),\") before mutation the index of the non-full progress bar.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"If we can't find a non-full progress bar, it means all the bars are full and nothing needs to be done.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Pausing\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Pausing is straightforward. We cancel any existing timers and set the \",(0,n.jsx)(e.code,{children:\"timerId\"}),\" to be \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Appending a New Bar\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"To append a new empty bar, we can use \",(0,n.jsx)(e.code,{children:\"progression.concat(0)\"}),\", which clones the array and adds 0 to the end.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Reset\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Simply set \",(0,n.jsx)(e.code,{children:\"progression\"}),\" back to the initial value and call the \",(0,n.jsx)(e.code,{children:\"stop()\"}),\" function.\"]}),`\n`,(0,n.jsx)(p,{})]})}function I(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(m,i)})):m(i)}var S=I;return T(j);})();\n;return Component;"
}