{
  "author": "yangshun",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/tabs-iii-react-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.js": {
      "code": "import Tabs from './Tabs';\n\nexport default function App() {\n  return (\n    <div className=\"wrapper\">\n      <button>A focusable element</button>\n      <Tabs\n        items={[\n          {\n            value: 'html',\n            label: 'HTML',\n            panel:\n              'The HyperText Markup Language or HTML is the standard markup language for documents designed to be displayed in a web browser.',\n          },\n          {\n            value: 'css',\n            label: 'CSS',\n            panel:\n              'Cascading Style Sheets is a style sheet language used for describing the presentation of a document written in a markup language such as HTML or XML.',\n          },\n          {\n            value: 'javascript',\n            label: 'JavaScript',\n            panel:\n              'JavaScript, often abbreviated as JS, is a programming language that is one of the core technologies of the World Wide Web, alongside HTML and CSS.',\n          },\n        ]}\n      />\n      <button>Some other focusable element</button>\n    </div>\n  );\n}\n"
    },
    "/src/index.js": {
      "code": "import React, { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n.wrapper {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n}\n\n.tabs {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.tabs-list {\n  display: flex;\n  gap: 6px;\n}\n\n.tabs-list-item {\n  --active-color: blueviolet;\n\n  background: none;\n  border: 1px solid #000;\n  border-radius: 4px;\n  cursor: pointer;\n  padding: 6px 10px;\n}\n\n.tabs-list-item:hover {\n  border-color: var(--active-color);\n  color: var(--active-color);\n}\n\n.tabs-list-item--active,\n.tabs-list-item--active:hover {\n  border-color: var(--active-color);\n  background-color: var(--active-color);\n  color: #fff;\n}\n"
    },
    "/src/Tabs.js": {
      "code": "import { useId, useState } from 'react';\n\nfunction getTabListItemId(tabsId, value) {\n  return tabsId + '-tab-' + value;\n}\n\nfunction getTabPanelId(tabsId, value) {\n  return tabsId + '-tabpanel-' + value;\n}\n\nexport default function Tabs({ defaultValue, items }) {\n  const tabsId = useId();\n  const [value, setValue] = useState(\n    defaultValue ?? items[0].value,\n  );\n\n  function setValueViaIndex(index) {\n    const newValue = items[index].value;\n    setValue(newValue);\n    document\n      .getElementById(getTabListItemId(tabsId, newValue))\n      .focus();\n  }\n\n  return (\n    <div className=\"tabs\">\n      <div\n        className=\"tabs-list\"\n        role=\"tablist\"\n        onKeyDown={(event) => {\n          switch (event.code) {\n            case 'ArrowLeft': {\n              const index = items.findIndex(\n                ({ value: itemValue }) =>\n                  itemValue === value,\n              );\n              setValueViaIndex(\n                // Use modulo to wrap around to the end if necessary.\n                (index - 1 + items.length) % items.length,\n              );\n              break;\n            }\n            case 'ArrowRight': {\n              const index = items.findIndex(\n                ({ value: itemValue }) =>\n                  itemValue === value,\n              );\n              // Use modulo to wrap around to the start if necessary.\n              setValueViaIndex((index + 1) % items.length);\n              break;\n            }\n            case 'Home': {\n              // Set the first item ias the active item.\n              setValueViaIndex(0);\n              break;\n            }\n            case 'End': {\n              // Set the last item ias the active item.\n              setValueViaIndex(items.length - 1);\n              break;\n            }\n            default:\n              break;\n          }\n        }}>\n        {items.map(({ label, value: itemValue }) => {\n          const isActiveValue = itemValue === value;\n\n          return (\n            <button\n              id={getTabListItemId(tabsId, itemValue)}\n              key={itemValue}\n              type=\"button\"\n              className={[\n                'tabs-list-item',\n                isActiveValue && 'tabs-list-item--active',\n              ]\n                .filter(Boolean)\n                .join(' ')}\n              onClick={() => {\n                setValue(itemValue);\n              }}\n              role=\"tab\"\n              tabIndex={isActiveValue ? 0 : -1}\n              aria-controls={getTabPanelId(\n                tabsId,\n                itemValue,\n              )}\n              aria-selected={isActiveValue}>\n              {label}\n            </button>\n          );\n        })}\n      </div>\n      <div>\n        {items.map(({ panel, value: itemValue }) => (\n          <div\n            key={itemValue}\n            tabIndex={0}\n            id={getTabPanelId(tabsId, itemValue)}\n            aria-labelledby={getTabListItemId(\n              tabsId,\n              itemValue,\n            )}\n            role=\"tabpanel\"\n            hidden={itemValue !== value}>\n            {panel}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.js",
      "/src/Tabs.js",
      "/src/styles.css"
    ],
    "activeFile": "/src/Tabs.js",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var m=Object.create;var d=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var a in e)d(n,a,{get:e[a],enumerable:!0})},r=(n,e,a,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of v(e))!k.call(n,c)&&c!==a&&d(n,c,{get:()=>e[c],enumerable:!(h=p(e,c))||h.enumerable});return n};var s=(n,e,a)=>(a=n!=null?m(w(n)):{},r(e||!n||!n.__esModule?d(a,\"default\",{value:n,enumerable:!0}):a,n)),x=n=>r(d({},\"__esModule\",{value:!0}),n);var o=y((_,l)=>{l.exports=_jsx_runtime});var I={};g(I,{default:()=>j});var t=s(o());var i=s(o());function b(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"We've intentionally added some focusable elements above and below the \",(0,i.jsx)(e.code,{children:\"Tabs\"}),\" component to make it easier to check the focus order.\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Switching tabs\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Left\"}),` key should activate the previous tab element\nand activate the last tab element if the first tab was active.`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Right\"}),` key should activate the next tab element\nand activate the first tab element if the last tab was active.`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Home\"}),\" key should activate the first tab element.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"End\"}),\" key should activate the last tab element.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Focus behavior\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Click on the topmost button. After that, hitting \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" should focus on the active tab element, which is not necessarily the first tab.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Click on the bottommost button. After that, hitting \",(0,i.jsx)(\"kbd\",{children:\"Shift\"}),\" + \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" should focus on the tabpanel, not any of the tabs.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"When switching between the tabs using the keyboard, the new tab should be focused. Hitting \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" again should shift focus to the tabpanel instead of any other tabs.\"]}),`\n`]}),`\n`]}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(b,n)})):b(n)}var u=T;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",h3:\"h3\",code:\"code\",ul:\"ul\",li:\"li\",h4:\"h4\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The following explanation assumes you have a good understanding of \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii/react/solution\",children:\"Tabs II's React solution\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Listening for Keyboard Events\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Firstly, it's crucial to know the difference between the \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" vs the \",(0,t.jsx)(e.code,{children:\"keydown\"}),\" event. The \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" event is only fired when a key that produces a character value is pressed down. This would exclude the \",(0,t.jsx)(\"kbd\",{children:\"Left\"}),\", \",(0,t.jsx)(\"kbd\",{children:\"Right\"}),\", \",(0,t.jsx)(\"kbd\",{children:\"Home\"}),\", and \",(0,t.jsx)(\"kbd\",{children:\"End\"}),\" keys which are requirements of this question. The \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" event is also deprecated and shouldn't be used. For these reasons, we should be using the \",(0,t.jsx)(e.code,{children:\"keydown\"}),\" event. We'll add the \",(0,t.jsx)(e.code,{children:\"onKeyDown\"}),\" prop to \",(0,t.jsx)(e.code,{children:'<div role=\"tablist\">'}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To know which key is being pressed, we can use \",(0,t.jsx)(e.code,{children:\"event.key\"}),\" or \",(0,t.jsx)(e.code,{children:\"event.code\"}),\" on the event passed to \",(0,t.jsx)(e.code,{children:\"onKeyDown\"}),\"'s callback. There are some \",(0,t.jsxs)(e.a,{href:\"https://javascript.info/keyboard-events\",children:[\"differences between \",(0,t.jsx)(e.code,{children:\"event.key\"}),\" vs \",(0,t.jsx)(e.code,{children:\"event.code\"})]}),\" but for the purposes of this question it doesn't make a difference and can be ignored. We'll just use \",(0,t.jsx)(e.code,{children:\"event.code\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Responding to Keyboard Events\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Next we read the \",(0,t.jsx)(e.code,{children:\"event.code\"}),\" property and respond with custom code depending on its value. A \",(0,t.jsx)(e.code,{children:\"switch\"}),\" case is suitable for such a situation:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"ArrowLeft\"}),': Activate the previous tab or \"wrap around\" to the last one if the focus was on the first. We first find the index of the active tab item, decrease it by one, and use modulo arithmetic to elegantly handle the \"wrap around\".']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"ArrowRight\"}),': Activate the next tab or \"wrap around\" to the first one if the focus was on the last. We first find the index of the active tab item, increase it by one, and use modulo arithmetic to elegantly handle the \"wrap around\".']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Home\"}),\": Activate the first tab.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"End\"}),\": Activate the last tab.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"When a new tab is activated, it should come into focus. Since we know the \",(0,t.jsx)(e.code,{children:\"id\"}),\" of each tab element, we can imperatively call \",(0,t.jsx)(e.code,{children:\".focus()\"}),\" on it by using \",(0,t.jsx)(e.code,{children:\"document.getElementById()\"}),\" with the desired tab element id. This approach is non-idiomatic by usual React standards but is acceptable during interviews.\"]}),`\n`,(0,t.jsxs)(e.h4,{children:[(0,t.jsx)(\"kbd\",{children:\"Tab\"}),\"-ing Behavior\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii/react/solution\",children:\"Tabs II\"}),\", all our tabs were focusable and you could jump to each tab via the \",(0,t.jsx)(\"kbd\",{children:\"Tab\"}),\" key. However, that behavior is non-standard according to the WAI-ARIA Tabs specification, which states that only the active tab should be focusable. We can achieve this by making the non-active tabs non-focusable by adding the \",(0,t.jsx)(e.code,{children:\"tabIndex={-1}\"}),\" attribute to them. On a related note, we should also make the \",(0,t.jsx)(e.code,{children:'<div role=\"tabpanel\">'}),\" focusable by adding \",(0,t.jsx)(e.code,{children:\"tabIndex={0}\"}),\".\"]}),`\n`,(0,t.jsx)(u,{}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/tabs/\",children:\"Tabs Patterns | ARIA Authoring Practices Guide\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.radix-ui.com/primitives/docs/components/tabs\",children:\"Tabs \\u2013 Radix Primitives\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://react-spectrum.adobe.com/react-aria/Tabs.html\",children:\"Tabs \\u2013 React Aria\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://headlessui.com/react/tabs\",children:\"Tabs - Headless UI\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://ariakit.org/components/tab\",children:\"Tab \\u2013 Ariakit\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://reach.tech/tabs\",children:\"Tabs | Reach UI\"})}),`\n`]})]})}function A(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var j=A;return x(I);})();\n;return Component;"
}