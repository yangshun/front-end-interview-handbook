{
  "skeleton": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var I=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var o in e)i(n,o,{get:e[o],enumerable:!0})},l=(n,e,o,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of w(e))!y.call(n,s)&&s!==o&&i(n,s,{get:()=>e[s],enumerable:!(c=m(e,s))||c.enumerable});return n};var h=(n,e,o)=>(o=n!=null?p(g(n)):{},l(e||!n||!n.__esModule?i(o,\"default\",{value:n,enumerable:!0}):o,n)),x=n=>l(i({},\"__esModule\",{value:!0}),n);var r=I((W,d)=>{d.exports=_jsx_runtime});var j={};v(j,{default:()=>T});var a=h(r());var t=h(r());function u(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" This is an advanced version of \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii\",children:\"Tabs II\"}),\", you should complete that question first before attempting this question. This question is not available in Vanilla JavaScript as it will require a fair bit of code to add keyboard interactions without a JavaScript framework.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii\",children:\"Tabs II\"}),\", we built a functional Tabs component that has the necessary \",(0,t.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/tabs/#wai-ariaroles,states,andproperties\",children:\"WAI-ARIA roles, states, and properties\"}),\". For a completely accessible Tabs component, we should also add the \",(0,t.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/tabs/#keyboardinteraction\",children:\"necessary keyboard interactions\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We'll be following a modified subset of the \",(0,t.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/tabs/#keyboardinteraction\",children:\"necessary keyboard interactions for Tabs\"}),\". Note that the tabs component we're building is activated automatically on focus, so the respective tabpanel contents are shown as soon as the focus changes to a different tab.\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"When \",(0,t.jsx)(\"kbd\",{children:\"Tab\"}),\" key is pressed:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"When focus moves into the tab list, places focus on the active tab element.\"}),`\n`,(0,t.jsx)(e.li,{children:\"When the tab list contains the focus, moves focus to the next element in the page tab sequence outside the tablist, which is the tabpanel.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"When focus is on a tab element in the tab list:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(\"kbd\",{children:\"Left Arrow\"}),`: moves focus to the previous tab.\nIf focus is on the first tab, moves focus to the last\ntab.`]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(\"kbd\",{children:\"Right Arrow\"}),`: Moves focus to the next tab. If\nfocus is on the last tab element, moves focus to the\nfirst tab.`]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(\"kbd\",{children:\"Home\"}),`: Moves focus to the first tab. Shows\ntabpanel content of the newly focused tab.`]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(\"kbd\",{children:\"End\"}),`: Moves focus to the last tab. Shows\ntabpanel content of the newly focused tab.`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The focus of this question is on adding keyboard functionality, not the styling. We have provided the solution to \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii\",children:\"Tabs II\"}),\" here for you to build on top of. You can reuse the existing styling.\"]})]})}function A(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var f=A;function b(n){return(0,a.jsx)(f,{})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(b,n)})):b(n)}var T=k;return x(j);})();\n;return Component;",
  "solution": "var Component=(()=>{var m=Object.create;var d=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),k=(n,e)=>{for(var a in e)d(n,a,{get:e[a],enumerable:!0})},r=(n,e,a,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of v(e))!g.call(n,o)&&o!==a&&d(n,o,{get:()=>e[o],enumerable:!(h=p(e,o))||h.enumerable});return n};var s=(n,e,a)=>(a=n!=null?m(w(n)):{},r(e||!n||!n.__esModule?d(a,\"default\",{value:n,enumerable:!0}):a,n)),x=n=>r(d({},\"__esModule\",{value:!0}),n);var c=y((W,l)=>{l.exports=_jsx_runtime});var I={};k(I,{default:()=>j});var t=s(c());var i=s(c());function u(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"We've intentionally added some focusable elements above and below the \",(0,i.jsx)(e.code,{children:\"Tabs\"}),\" component to make it easier to check the focus order.\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Switching tabs\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Left\"}),` key should activate the previous tab element\nand activate the last tab element if the first tab was active.`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Right\"}),` key should activate the next tab element\nand activate the first tab element if the last tab was active.`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Home\"}),\" key should activate the first tab element.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"End\"}),\" key should activate the last tab element.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Focus behavior\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Click on the topmost button. After that, hitting \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" should focus on the active tab element, which is not necessarily the first tab.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Click on the bottommost button. After that, hitting \",(0,i.jsx)(\"kbd\",{children:\"Shift\"}),\" + \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" should focus on the tabpanel, not any of the tabs.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"When switching between the tabs using the keyboard, the new tab should be focused. Hitting \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" again should shift focus to the tabpanel instead of any other tabs.\"]}),`\n`]}),`\n`]}),`\n`]})]})}function A(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(u,n)})):u(n)}var b=A;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",h3:\"h3\",code:\"code\",ul:\"ul\",li:\"li\",h4:\"h4\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The following explanation assumes you have a good understanding of \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii/angular/solution\",children:\"Tabs II's Angular solution\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Listening for Keyboard Events\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Firstly it's crucial to know the difference between the \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" vs the \",(0,t.jsx)(e.code,{children:\"keydown\"}),\" event. The \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" event is only fired when a key that produces a character value is pressed down. This would exclude the \",(0,t.jsx)(\"kbd\",{children:\"Left\"}),\", \",(0,t.jsx)(\"kbd\",{children:\"Right\"}),\", \",(0,t.jsx)(\"kbd\",{children:\"Home\"}),\", and \",(0,t.jsx)(\"kbd\",{children:\"End\"}),\" keys which are requirements of this question. The \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" event is also deprecated and shouldn't be used. For these reasons, we should be using the \",(0,t.jsx)(e.code,{children:\"keydown\"}),\" event. We'll add the \",(0,t.jsx)(e.code,{children:\"onKeyDown\"}),\" prop to \",(0,t.jsx)(e.code,{children:'<div role=\"tablist\">'}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To know which key is being pressed, we can use \",(0,t.jsx)(e.code,{children:\"event.key\"}),\" or \",(0,t.jsx)(e.code,{children:\"event.code\"}),\" on the event passed to \",(0,t.jsx)(e.code,{children:\"onKeyDown\"}),\"'s callback. There are some \",(0,t.jsxs)(e.a,{href:\"https://javascript.info/keyboard-events\",children:[\"differences between \",(0,t.jsx)(e.code,{children:\"event.key\"}),\" vs \",(0,t.jsx)(e.code,{children:\"event.code\"})]}),\" but for the purposes of this question it doesn't make a difference and can be ignored. We'll just use \",(0,t.jsx)(e.code,{children:\"event.code\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Responding to Keyboard Events\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Next we read the \",(0,t.jsx)(e.code,{children:\"event.code\"}),\" property and respond with custom code depending on its value. A \",(0,t.jsx)(e.code,{children:\"switch\"}),\" case is suitable for such a situation:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"ArrowLeft\"}),': Activate the previous tab or \"wrap around\" to the last one if the focus was on the first. We first find the index of the active tab item, decrease it by one, and use modulo arithmetic to elegantly handle the \"wrap around\".']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"ArrowRight\"}),': Activate the next tab or \"wrap around\" to the first one if the focus was on the last. We first find the index of the active tab item, increase it by one, and use modulo arithmetic to elegantly handle the \"wrap around\".']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Home\"}),\": Activate the first tab.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"End\"}),\": Activate the last tab.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"When a new tab is activated, it should come into focus. Since we know the \",(0,t.jsx)(e.code,{children:\"id\"}),\" of each tab element, we can imperatively call \",(0,t.jsx)(e.code,{children:\".focus()\"}),\" on it by using \",(0,t.jsx)(e.code,{children:\"document.getElementById()\"}),\" with the desired tab element id. This approach is non-idiomatic by usual Angular standards but is acceptable during interviews.\"]}),`\n`,(0,t.jsxs)(e.h4,{children:[(0,t.jsx)(\"kbd\",{children:\"Tab\"}),\"-ing Behavior\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii/angular/solution\",children:\"Tabs II\"}),\", all our tabs were focusable and you could jump to each tab via the \",(0,t.jsx)(\"kbd\",{children:\"Tab\"}),\" key. However, that behavior is non-standard according to the WAI-ARIA Tabs specification, which states that only the active tab should be focusable. We can achieve this by making the non-active tabs non-focusable by adding the \",(0,t.jsx)(e.code,{children:\"tabIndex={-1}\"}),\" attribute to them. On a related note, we should also make the \",(0,t.jsx)(e.code,{children:'<div role=\"tabpanel\">'}),\" focusable by adding \",(0,t.jsx)(e.code,{children:\"tabIndex={0}\"}),\".\"]}),`\n`,(0,t.jsx)(b,{}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/tabs/\",children:\"Tabs | ARIA Authoring Practices Guide\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://reach.tech/tabs\",children:\"Tabs | Reach UI\"})}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var j=T;return x(I);})();\n;return Component;"
}