{
  "author": "michalgrzegorczyk-dev",
  "files": {
    "/angular.json": {
      "code": "{\n  \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"defaultProject\": \"greatfrontend\",\n  \"projects\": {\n    \"greatfrontend\": {\n      \"projectType\": \"application\",\n      \"schematics\": {},\n      \"root\": \"\",\n      \"sourceRoot\": \"src\",\n      \"prefix\": \"app\",\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/my-app\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": [\"zone.js\"],\n            \"tsConfig\": \"tsconfig.app.json\",\n            \"assets\": [\"src/favicon.ico\", \"src/assets\"],\n            \"styles\": [\"src/styles.css\"],\n            \"scripts\": []\n          },\n          \"configurations\": {\n            \"production\": {\n              \"budgets\": [\n                {\n                  \"type\": \"initial\",\n                  \"maximumWarning\": \"500kb\",\n                  \"maximumError\": \"1mb\"\n                },\n                {\n                  \"type\": \"anyComponentStyle\",\n                  \"maximumWarning\": \"2kb\",\n                  \"maximumError\": \"4kb\"\n                }\n              ],\n              \"outputHashing\": \"all\"\n            },\n            \"development\": {\n              \"buildOptimizer\": false,\n              \"optimization\": false,\n              \"vendorChunk\": true,\n              \"extractLicenses\": false,\n              \"sourceMap\": true,\n              \"namedChunks\": true\n            }\n          },\n          \"defaultConfiguration\": \"production\"\n        },\n        \"serve\": {\n          \"builder\": \"@angular-devkit/build-angular:dev-server\",\n          \"configurations\": {\n            \"production\": {\n              \"browserTarget\": \"greatfrontend:build:production\"\n            },\n            \"development\": {\n              \"browserTarget\": \"greatfrontend:build:development\"\n            }\n          },\n          \"defaultConfiguration\": \"development\"\n        },\n        \"extract-i18n\": {\n          \"builder\": \"@angular-devkit/build-angular:extract-i18n\",\n          \"options\": {\n            \"browserTarget\": \"greatfrontend:build\"\n          }\n        },\n        \"test\": {\n          \"builder\": \"@angular-devkit/build-angular:karma\",\n          \"options\": {\n            \"polyfills\": [\"zone.js\", \"zone.js/testing\"],\n            \"tsConfig\": \"tsconfig.spec.json\",\n            \"assets\": [\"src/favicon.ico\", \"src/assets\"],\n            \"styles\": [\"src/styles.css\"],\n            \"scripts\": []\n          }\n        }\n      }\n    }\n  },\n  \"cli\": {\n    \"analytics\": \"7ca5c4d0-e5db-4d23-9ffd-8c8c042e34e7\"\n  }\n}\n"
    },
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/tabs-iii-angular-solution\",\n  \"author\": \"michalgrzegorczyk-dev\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"@angular/common\": \"16.2.4\",\n    \"@angular/compiler\": \"16.2.4\",\n    \"@angular/core\": \"16.2.4\",\n    \"@angular/forms\": \"16.2.4\",\n    \"@angular/platform-browser\": \"16.2.4\",\n    \"@angular/platform-browser-dynamic\": \"16.2.4\",\n    \"rxjs\": \"7.8.0\",\n    \"zone.js\": \"0.13.1\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"16.2.1\",\n    \"@angular/cli\": \"16.2.1\",\n    \"@angular/compiler-cli\": \"16.2.4\",\n    \"@types/jasmine\": \"4.3.5\",\n    \"jasmine-core\": \"4.6.0\",\n    \"karma\": \"6.4.2\",\n    \"karma-chrome-launcher\": \"3.2.0\",\n    \"karma-coverage\": \"2.2.1\",\n    \"karma-jasmine\": \"5.1.0\",\n    \"karma-jasmine-html-reporter\": \"2.1.0\",\n    \"typescript\": \"5.0.2\"\n  },\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"watch\": \"ng build --watch --configuration development\",\n    \"test\": \"ng test\"\n  }\n}\n"
    },
    "/src/app/app.component.html": {
      "code": "<div class=\"wrapper\">\n  <button>A focusable element</button>\n  <app-tabs [items]=\"tabs\"></app-tabs>\n  <button>Some other focusable element</button>\n</div>\n"
    },
    "/src/app/app.component.ts": {
      "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n})\nexport class AppComponent {\n  tabs = [\n    {\n      value: 'html',\n      label: 'HTML',\n      panel:\n        'The HyperText Markup Language or HTML is the standard markup language for documents designed to be displayed in a web browser.',\n    },\n    {\n      value: 'css',\n      label: 'CSS',\n      panel:\n        'Cascading Style Sheets is a style sheet language used for describing the presentation of a document written in a markup language such as HTML or XML.',\n    },\n    {\n      value: 'javascript',\n      label: 'JavaScript',\n      panel:\n        'JavaScript, often abbreviated as JS, is a programming language that is one of the core technologies of the World Wide Web, alongside HTML and CSS.',\n    },\n  ];\n}\n"
    },
    "/src/app/app.module.ts": {
      "code": "import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { TabsComponent } from './tabs.component';\n\n@NgModule({\n  declarations: [AppComponent, TabsComponent],\n  imports: [BrowserModule, FormsModule],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n"
    },
    "/src/app/tabs.component.html": {
      "code": "<div class=\"tabs\">\n  <div class=\"tabs-list\" role=\"tablist\">\n    <button\n      *ngFor=\"let item of items\"\n      [id]=\"getTabListItemId(item.value)\"\n      type=\"button\"\n      [class]=\"[\n        'tabs-list-item',\n        item.value === value ? 'tabs-list-item--active' : ''\n      ]\"\n      (click)=\"setValue(item.value)\"\n      role=\"tab\"\n      [attr.tabIndex]=\"item.value === value ? 0 : -1\"\n      [attr.aria-controls]=\"getTabPanelId(item.value)\"\n      [attr.aria-selected]=\"item.value === value\">\n      {{ item.label }}\n    </button>\n  </div>\n  <div>\n    <div\n      *ngFor=\"let item of items\"\n      [id]=\"getTabPanelId(item.value)\"\n      tabIndex=\"0\"\n      [attr.aria-labelledby]=\"getTabListItemId(item.value)\"\n      role=\"tabpanel\"\n      [hidden]=\"item.value !== value\">\n      {{ item.panel }}\n    </div>\n  </div>\n</div>\n"
    },
    "/src/app/tabs.component.ts": {
      "code": "import {\n  Component,\n  HostListener,\n  Input,\n} from '@angular/core';\n\n@Component({\n  selector: 'app-tabs',\n  templateUrl: './tabs.component.html',\n})\nexport class TabsComponent {\n  @Input()\n  items!: any[];\n\n  @Input()\n  defaultValue!: string;\n\n  value = '';\n  tabsId =\n    'tabs-' + Math.random().toString(36).substring(2, 9);\n\n  @HostListener('document:keydown', ['$event'])\n  handleKeyboardEvent(event: KeyboardEvent): void {\n    const currentIndex = this.items.findIndex(\n      (item) => item.value === this.value,\n    );\n    switch (event.code) {\n      case 'ArrowLeft':\n        this.setValueViaIndex(\n          (currentIndex - 1 + this.items.length) %\n            this.items.length,\n        );\n        break;\n      case 'ArrowRight':\n        this.setValueViaIndex(\n          (currentIndex + 1) % this.items.length,\n        );\n        break;\n      case 'Home':\n        this.setValueViaIndex(0);\n        break;\n      case 'End':\n        this.setValueViaIndex(this.items.length - 1);\n        break;\n    }\n  }\n\n  ngOnInit(): void {\n    this.value = this.defaultValue ?? this.items[0].value;\n  }\n\n  getTabListItemId(value: string): string {\n    return `${this.tabsId}-tab-${value}`;\n  }\n\n  getTabPanelId(value: string): string {\n    return `${this.tabsId}-tabpanel-${value}`;\n  }\n\n  setValue(newValue: string): void {\n    this.value = newValue;\n    const element = document.getElementById(\n      this.getTabListItemId(newValue),\n    );\n    if (element) {\n      element.focus();\n    }\n  }\n\n  setValueViaIndex(index: number): void {\n    const newValue = this.items[index].value;\n    this.setValue(newValue);\n  }\n}\n"
    },
    "/src/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Angular</title>\n    <base href=\"/\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <app-root></app-root>\n  </body>\n</html>\n"
    },
    "/src/main.ts": {
      "code": "import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\nenableProdMode();\nplatformBrowserDynamic()\n  .bootstrapModule(AppModule)\n  .catch((err) => console.error(err));\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n.wrapper {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n}\n\n.tabs {\n  display: flex;\n  flex-direction: column;\n  gap: 8px;\n}\n\n.tabs-list {\n  display: flex;\n  gap: 6px;\n}\n\n.tabs-list-item {\n  --active-color: blueviolet;\n\n  background: none;\n  border: 1px solid #000;\n  border-radius: 4px;\n  cursor: pointer;\n  padding: 6px 10px;\n}\n\n.tabs-list-item:hover {\n  border-color: var(--active-color);\n  color: var(--active-color);\n}\n\n.tabs-list-item--active,\n.tabs-list-item--active:hover {\n  border-color: var(--active-color);\n  background-color: var(--active-color);\n  color: #fff;\n}\n"
    },
    "/tsconfig.app.json": {
      "code": "/* To learn more about this file see: https://angular.io/config/tsconfig. */\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./out-tsc/app\",\n    \"types\": []\n  },\n  \"files\": [\"src/main.ts\"],\n  \"include\": [\"src/**/*.d.ts\"]\n}\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"compileOnSave\": false,\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n    \"outDir\": \"./dist/out-tsc\",\n    \"forceConsistentCasingInFileNames\": true,\n    \"strict\": true,\n    \"noImplicitOverride\": true,\n    \"noPropertyAccessFromIndexSignature\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"sourceMap\": true,\n    \"declaration\": false,\n    \"downlevelIteration\": true,\n    \"experimentalDecorators\": true,\n    \"moduleResolution\": \"node\",\n    \"target\": \"es2020\",\n    \"module\": \"esnext\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"]\n  },\n  \"angularCompilerOptions\": {\n    \"enableI18nLegacyMessageIdFormat\": false,\n    \"strictInjectionParameters\": true,\n    \"strictInputAccessModifiers\": true,\n    \"strictTemplates\": true\n  }\n}\n"
    },
    "/tsconfig.spec.json": {
      "code": "/* To learn more about this file see: https://angular.io/config/tsconfig. */\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./out-tsc/spec\",\n    \"types\": [\"jasmine\"]\n  },\n  \"include\": [\"src/**/*.spec.ts\", \"src/**/*.d.ts\"]\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/app/app.component.ts",
      "/src/app/app.component.html",
      "/src/styles.css"
    ],
    "activeFile": "/src/app/app.component.ts",
    "environment": "angular-cli"
  },
  "writeup": "var Component=(()=>{var m=Object.create;var d=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),k=(n,e)=>{for(var a in e)d(n,a,{get:e[a],enumerable:!0})},r=(n,e,a,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of v(e))!g.call(n,o)&&o!==a&&d(n,o,{get:()=>e[o],enumerable:!(h=p(e,o))||h.enumerable});return n};var s=(n,e,a)=>(a=n!=null?m(w(n)):{},r(e||!n||!n.__esModule?d(a,\"default\",{value:n,enumerable:!0}):a,n)),x=n=>r(d({},\"__esModule\",{value:!0}),n);var c=y((W,l)=>{l.exports=_jsx_runtime});var I={};k(I,{default:()=>j});var t=s(c());var i=s(c());function u(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"We've intentionally added some focusable elements above and below the \",(0,i.jsx)(e.code,{children:\"Tabs\"}),\" component to make it easier to check the focus order.\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Switching tabs\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Left\"}),` key should activate the previous tab element\nand activate the last tab element if the first tab was active.`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Right\"}),` key should activate the next tab element\nand activate the first tab element if the last tab was active.`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"Home\"}),\" key should activate the first tab element.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(\"kbd\",{children:\"End\"}),\" key should activate the last tab element.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Focus behavior\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Click on the topmost button. After that, hitting \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" should focus on the active tab element, which is not necessarily the first tab.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Click on the bottommost button. After that, hitting \",(0,i.jsx)(\"kbd\",{children:\"Shift\"}),\" + \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" should focus on the tabpanel, not any of the tabs.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"When switching between the tabs using the keyboard, the new tab should be focused. Hitting \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" again should shift focus to the tabpanel instead of any other tabs.\"]}),`\n`]}),`\n`]}),`\n`]})]})}function A(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(u,n)})):u(n)}var b=A;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",h3:\"h3\",code:\"code\",ul:\"ul\",li:\"li\",h4:\"h4\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The following explanation assumes you have a good understanding of \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii/angular/solution\",children:\"Tabs II's Angular solution\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Listening for Keyboard Events\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Firstly it's crucial to know the difference between the \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" vs the \",(0,t.jsx)(e.code,{children:\"keydown\"}),\" event. The \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" event is only fired when a key that produces a character value is pressed down. This would exclude the \",(0,t.jsx)(\"kbd\",{children:\"Left\"}),\", \",(0,t.jsx)(\"kbd\",{children:\"Right\"}),\", \",(0,t.jsx)(\"kbd\",{children:\"Home\"}),\", and \",(0,t.jsx)(\"kbd\",{children:\"End\"}),\" keys which are requirements of this question. The \",(0,t.jsx)(e.code,{children:\"keypress\"}),\" event is also deprecated and shouldn't be used. For these reasons, we should be using the \",(0,t.jsx)(e.code,{children:\"keydown\"}),\" event. We'll add the \",(0,t.jsx)(e.code,{children:\"onKeyDown\"}),\" prop to \",(0,t.jsx)(e.code,{children:'<div role=\"tablist\">'}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To know which key is being pressed, we can use \",(0,t.jsx)(e.code,{children:\"event.key\"}),\" or \",(0,t.jsx)(e.code,{children:\"event.code\"}),\" on the event passed to \",(0,t.jsx)(e.code,{children:\"onKeyDown\"}),\"'s callback. There are some \",(0,t.jsxs)(e.a,{href:\"https://javascript.info/keyboard-events\",children:[\"differences between \",(0,t.jsx)(e.code,{children:\"event.key\"}),\" vs \",(0,t.jsx)(e.code,{children:\"event.code\"})]}),\" but for the purposes of this question it doesn't make a difference and can be ignored. We'll just use \",(0,t.jsx)(e.code,{children:\"event.code\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Responding to Keyboard Events\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Next we read the \",(0,t.jsx)(e.code,{children:\"event.code\"}),\" property and respond with custom code depending on its value. A \",(0,t.jsx)(e.code,{children:\"switch\"}),\" case is suitable for such a situation:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"ArrowLeft\"}),': Activate the previous tab or \"wrap around\" to the last one if the focus was on the first. We first find the index of the active tab item, decrease it by one, and use modulo arithmetic to elegantly handle the \"wrap around\".']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"ArrowRight\"}),': Activate the next tab or \"wrap around\" to the first one if the focus was on the last. We first find the index of the active tab item, increase it by one, and use modulo arithmetic to elegantly handle the \"wrap around\".']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"Home\"}),\": Activate the first tab.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"End\"}),\": Activate the last tab.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"When a new tab is activated, it should come into focus. Since we know the \",(0,t.jsx)(e.code,{children:\"id\"}),\" of each tab element, we can imperatively call \",(0,t.jsx)(e.code,{children:\".focus()\"}),\" on it by using \",(0,t.jsx)(e.code,{children:\"document.getElementById()\"}),\" with the desired tab element id. This approach is non-idiomatic by usual Angular standards but is acceptable during interviews.\"]}),`\n`,(0,t.jsxs)(e.h4,{children:[(0,t.jsx)(\"kbd\",{children:\"Tab\"}),\"-ing Behavior\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/tabs-ii/angular/solution\",children:\"Tabs II\"}),\", all our tabs were focusable and you could jump to each tab via the \",(0,t.jsx)(\"kbd\",{children:\"Tab\"}),\" key. However, that behavior is non-standard according to the WAI-ARIA Tabs specification, which states that only the active tab should be focusable. We can achieve this by making the non-active tabs non-focusable by adding the \",(0,t.jsx)(e.code,{children:\"tabIndex={-1}\"}),\" attribute to them. On a related note, we should also make the \",(0,t.jsx)(e.code,{children:'<div role=\"tabpanel\">'}),\" focusable by adding \",(0,t.jsx)(e.code,{children:\"tabIndex={0}\"}),\".\"]}),`\n`,(0,t.jsx)(b,{}),`\n`,(0,t.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.w3.org/WAI/ARIA/apg/patterns/tabs/\",children:\"Tabs | ARIA Authoring Practices Guide\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://reach.tech/tabs\",children:\"Tabs | Reach UI\"})}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var j=T;return x(I);})();\n;return Component;"
}