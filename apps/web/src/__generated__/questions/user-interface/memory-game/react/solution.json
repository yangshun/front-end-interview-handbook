{
  "author": "utpal-d4l",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/memory-game-react-solution\",\n  \"author\": \"utpal-d4l\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.js": {
      "code": "import {\n  useCallback,\n  useEffect,\n  useRef,\n  useState,\n} from 'react';\n\nconst emojis = [\n  'ğŸµ',\n  'ğŸ¶',\n  'ğŸ¦Š',\n  'ğŸ±',\n  'ğŸ¦',\n  'ğŸ¯',\n  'ğŸ´',\n  'ğŸ¦„',\n  'ğŸ¦“',\n  'ğŸ¦Œ',\n  'ğŸ®',\n  'ğŸ·',\n  'ğŸ­',\n  'ğŸ¹',\n  'ğŸ»',\n  'ğŸ¨',\n  'ğŸ¼',\n  'ğŸ½',\n  'ğŸ¸',\n  'ğŸ°',\n  'ğŸ™',\n];\n\nfunction shuffle(array) {\n  for (let i = 0; i < array.length; i++) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n\n// Generate cards configuration with the required groups of emojis.\nfunction generateCards(totalCount, matchCount) {\n  const numGroups = totalCount / matchCount;\n  if (numGroups > emojis.length) {\n    throw new Error('Not enough emojis');\n  }\n\n  const emojisList = emojis.slice(0, numGroups);\n  const cards = Array.from(\n    { length: numGroups },\n    () => null,\n  )\n    .map((_, idx) => idx)\n    .map((idx) =>\n      Array.from(\n        { length: matchCount },\n        () => emojisList[idx],\n      ),\n    )\n    .flat();\n\n  shuffle(cards);\n  return cards;\n}\n\nfunction MemoryGame({\n  cols = 4,\n  rows = 4,\n  delay = 2000,\n  matchCount = 2,\n}) {\n  // Total number of cells.\n  const totalCount = rows * cols;\n  // An array of emojis to represent the cards.\n  const [cards, setCards] = useState(\n    generateCards(totalCount, matchCount),\n  );\n  // Currently flipped cards.\n  const [flipped, setFlipped] = useState([]);\n  // Identifier of matched cards.\n  const [matched, setMatched] = useState(new Set());\n  // Delay before cards are flipped back.\n  const waitTimer = useRef(null);\n  // Whether the game has completed.\n  const [gameCompleted, setGameCompleted] = useState(false);\n\n  const resetGame = useCallback(() => {\n    waitTimer.current = null;\n    setCards(generateCards(totalCount, matchCount));\n    setFlipped([]);\n    setMatched(new Set());\n    setGameCompleted(false);\n  }, [matchCount, totalCount]);\n\n  useEffect(() => {\n    resetGame();\n  }, [cols, rows, matchCount, resetGame]);\n\n  if (matchCount < 2) {\n    throw new Error(`${matchCount} should be 2 or more`);\n  }\n\n  if (totalCount % matchCount !== 0) {\n    throw new Error(\n      `Cannot divide total cells of ${totalCount} by ${matchCount}`,\n    );\n  }\n\n  function onFlip(index) {\n    let currFlipped = flipped;\n\n    // Player flips more cards while there are\n    // unmatched cards flipped open.\n    if (waitTimer.current != null) {\n      clearTimeout(waitTimer.current);\n      waitTimer.current = null;\n      currFlipped = [];\n    }\n\n    const newflipped = [...currFlipped, index];\n    setFlipped(newflipped);\n\n    // Not enough cards are flipped.\n    if (newflipped.length < matchCount) {\n      return;\n    }\n\n    const allFlippedAreSame = newflipped.every(\n      (index) => cards[newflipped[0]] === cards[index],\n    );\n\n    if (allFlippedAreSame) {\n      const newMatchedSet = new Set(matched);\n      newMatchedSet.add(cards[newflipped[0]]);\n      setMatched(newMatchedSet);\n      setFlipped([]);\n\n      if (newMatchedSet.size * matchCount === totalCount) {\n        setGameCompleted(true);\n      }\n\n      return;\n    }\n\n    const timer = setTimeout(() => {\n      // After a delay if no new cards were flipped,\n      // flip all cards back.\n      setFlipped([]);\n      waitTimer.current = null;\n    }, delay);\n\n    waitTimer.current = timer;\n  }\n\n  return (\n    <div className=\"app\">\n      <div\n        className=\"grid\"\n        style={{\n          gridTemplateRows: `repeat(${rows}, var(--size))`,\n          gridTemplateColumns: `repeat(${cols}, var(--size))`,\n        }}>\n        {cards.map((card, index) => {\n          const isMatched = matched.has(cards[index]);\n          const isFlipped = flipped.includes(index);\n\n          return (\n            <button\n              key={index}\n              className={[\n                'card',\n                matched.has(cards[index]) &&\n                  'card--revealed',\n              ]\n                .filter(Boolean)\n                .join(' ')}\n              disabled={isMatched || isFlipped}\n              onClick={() => {\n                onFlip(index);\n              }}>\n              {(isMatched || isFlipped) && card}\n            </button>\n          );\n        })}\n      </div>\n      {gameCompleted && (\n        <button onClick={resetGame}>Play Again</button>\n      )}\n    </div>\n  );\n}\n\nexport default function App() {\n  return (\n    <MemoryGame\n      rows={4}\n      cols={4}\n      delay={2000}\n      matchCount={2}\n    />\n  );\n}\n"
    },
    "/src/index.js": {
      "code": "import React, { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n* {\n  box-sizing: border-box;\n}\n\n.app {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  row-gap: 10px;\n}\n\n.grid {\n  --size: 60px;\n\n  display: grid;\n  gap: 8px;\n  justify-content: center;\n  border: 2px solid black;\n  border-radius: 8px;\n  padding: 8px;\n}\n\n.card {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border: 2px solid black;\n  border-radius: 6px;\n  font-size: 30px;\n  cursor: pointer;\n  background-color: #eee;\n  overflow: hidden;\n  position: relative;\n}\n\n.card:disabled {\n  color: #000;\n}\n\n.card--revealed {\n  background: transparent;\n  border-color: transparent;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.js",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.js",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var g=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),k=(a,e)=>{for(var r in e)c(a,r,{get:e[r],enumerable:!0})},h=(a,e,r,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of y(e))!b.call(a,i)&&i!==r&&c(a,i,{get:()=>e[i],enumerable:!(d=p(e,i))||d.enumerable});return a};var o=(a,e,r)=>(r=a!=null?g(w(a)):{},h(e||!a||!a.__esModule?c(r,\"default\",{value:a,enumerable:!0}):r,a)),x=a=>h(c({},\"__esModule\",{value:!0}),a);var l=v((_,s)=>{s.exports=_jsx_runtime});var S={};k(S,{default:()=>T});var n=o(l());var t=o(l());function m(a){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},a.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initial Display\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Open the game and verify that the grid of faced-down cards is displayed correctly.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Check that the number of cards in the grid is as expected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that all cards are facedown and not revealing their images.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Card Flipping\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Click on a card and verify that it reveals its image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Click on another card and verify that it also reveals the image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that the selected cards remain face-up if they match.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the selected cards flip back if they don't match after a short delay.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have the same image and verify that they remain face-up.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Non-Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and verify that they flip back after a short delay if no new cards are selected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and select a new card, the first two selected cards should be flipped back.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Game Completion\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Play the game until all pairs are successfully matched.\"}),`\n`,(0,t.jsx)(e.li,{children:'Verify that the \"Play Again\" button is displayed and clicking on it resets the game.'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"New Game/Reset\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Start a new game or reset the current game.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the grid is reset, with all cards facedown.\"}),`\n`]}),`\n`]}),`\n`]})]})}function j(a={}){let{wrapper:e}=a.components||{};return e?(0,t.jsx)(e,Object.assign({},a,{children:(0,t.jsx)(m,a)})):m(a)}var u=j;function f(a){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\",a:\"a\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Props\"}),`\n`,(0,n.jsx)(e.p,{children:\"The default memory game shown in the diagram is 4 x 4 and the goal is to match pairs. In order to make the game customizable, we can introduce the following props:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"rows\"}),\": Number of rows.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cols\"}),\": Number of columns.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matchCount\"}),\": How many of the same images there are. The default is 2 but making it a parameter is a positive signal.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"delay\"}),\": Delay before selected non-matching cards are flipped back over.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Since these parameters can be combined in ways that make the game unplayable, we can do a basic check of whether the total number of cells is divisible by the match count.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cards\"}),\": The game board can be represented as a one-dimensional array called \",(0,n.jsx)(e.code,{children:\"cards\"}),\", containing the correct number of groups of unique emojis. On a 4 x 4 board, the array has a length of 16 and \",(0,n.jsx)(e.code,{children:\"cards[4]\"}),\" will correspond to row 2 column 1. This array is generated during initialization and not modified throughout the duration of the game. It's only regenerated when the user chooses to play again.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"flipped\"}),\": An array of indices to track which cards are flipped. This array excludes matched cards.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matched\"}),\": A set of images (emojis) that have been matched.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"waitTimer\"}),\": A ref to track the timer ID for whether to automatically flip back the cards after \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"gameCompleted\"}),\": Boolean value to represent whether the game is completed.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsx)(e.p,{children:\"CSS grid is used to render the cards in a 2-dimensional format. It's a great choice because you can render the cards as a single list of DOM elements but with the right CSS grid settings, they can be displayed in a rows x cols layout.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Card Generation\"}),`\n`,(0,n.jsx)(e.p,{children:\"The following process can be used for generating the cards:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Make N groups of \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" emojis where N = total cells / \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" in a single array.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Shuffle the array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"onFlip\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For the most part, \",(0,n.jsx)(e.code,{children:\"onFlip\"}),\" adds cards to the \",(0,n.jsx)(e.code,{children:\"selected\"}),\" array. If there aren't enough cards to make a decision whether there's a match yet, the function terminates. When enough cards are selected, check whether all the selected cards are similar. If so, we can add the selected emoji to the \",(0,n.jsx)(e.code,{children:\"matched\"}),\" set and reset \",(0,n.jsx)(e.code,{children:\"selected\"}),\" to be empty so that the player can continue with the game. If there isn't a match, we wait for \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration to pass before flipping the selected cards back over. We use a \",(0,n.jsx)(e.code,{children:\"useRef\"}),\" for \",(0,n.jsx)(e.code,{children:\"waitTimer\"}),\" so that we can access the same timerID value in the \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" callback. If we used \",(0,n.jsx)(e.code,{children:\"useState\"}),\", we could be accessing stale timer ID value due to closures. This is an extremely common source of bugs when using \",(0,n.jsx)(e.code,{children:\"setTimeout\"}),\" or \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" within React components, read \",(0,n.jsx)(e.a,{href:\"https://overreacted.io/making-setinterval-declarative-with-react-hooks/\",children:\"this post by Dan Abramov\"}),\" to learn more.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another scenario we have to handle is when the user selects more cards before the \",(0,n.jsx)(e.code,{children:\"delay\"}),\" has passed. \",(0,n.jsx)(e.code,{children:\"waitTimer\"}),\" has to be cleared and the currently unmatched open cards have to be flipped back.\"]}),`\n`,(0,n.jsx)(u,{})]})}function C(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(f,a)})):f(a)}var T=C;return x(S);})();\n;return Component;"
}