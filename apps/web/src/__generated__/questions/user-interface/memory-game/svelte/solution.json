{
  "author": "tanhauhau",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/memory-game-svelte-solution\",\n  \"author\": \"tanhauhau\",\n  \"version\": \"0.0.1\",\n  \"main\": \"src/index.js\",\n  \"dependencies\": {\n    \"svelte\": \"^3.58.0\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Svelte</title>\n    <link rel=\"stylesheet\" href=\"public/bundle.css\" />\n  </head>\n\n  <body>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n"
    },
    "/src/App.svelte": {
      "code": "<script>\n  import './styles.css';\n  const emojis = [\n    '🐵',\n    '🐶',\n    '🦊',\n    '🐱',\n    '🦁',\n    '🐯',\n    '🐴',\n    '🦄',\n    '🦓',\n    '🦌',\n    '🐮',\n    '🐷',\n    '🐭',\n    '🐹',\n    '🐻',\n    '🐨',\n    '🐼',\n    '🐽',\n    '🐸',\n    '🐰',\n    '🐙',\n  ];\n\n  function shuffle(array) {\n    for (let i = 0; i < array.length; i++) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n  }\n\n  // Generate cards configuration with the required groups of emojis.\n  function generateCards(totalCount, matchCount) {\n    const numGroups = totalCount / matchCount;\n    if (numGroups > emojis.length) {\n      throw new Error('Not enough emojis');\n    }\n\n    const emojisList = emojis.slice(0, numGroups);\n    const cards = Array.from(\n      { length: numGroups },\n      () => null,\n    )\n      .map((_, idx) => idx)\n      .map((idx) =>\n        Array.from(\n          { length: matchCount },\n          () => emojisList[idx],\n        ),\n      )\n      .flat();\n\n    shuffle(cards);\n    return cards;\n  }\n\n  export let cols = 4;\n  export let rows = 4;\n  export let delay = 2000;\n  export let matchCount = 2;\n\n  // Total number of cells.\n  $: totalCount = rows * cols;\n  // An array of emojis to represent the cards.\n  let cards = generateCards(totalCount, matchCount);\n  // Currently flipped cards.\n  let flipped = [];\n  // Identifier of matched cards.\n  let matched = new Set();\n  // Delay before cards are flipped back.\n  let waitTimer = null;\n  // Whether the game has completed.\n  let gameCompleted = false;\n\n  function resetGame() {\n    waitTimer = null;\n    cards = generateCards(totalCount, matchCount);\n    flipped = [];\n    matched = new Set();\n    gameCompleted = false;\n  }\n\n  $: if (matchCount < 2) {\n    throw new Error(`${matchCount} should be 2 or more`);\n  }\n  $: if (totalCount % matchCount !== 0) {\n    throw new Error(\n      `Cannot divide total cells of ${totalCount} by ${matchCount}`,\n    );\n  }\n  $: cols, rows, matchCount, resetGame();\n\n  function onFlip(index) {\n    let currFlipped = flipped;\n\n    // Player flips more cards while there are\n    // unmatched cards flipped open.\n    if (waitTimer != null) {\n      clearTimeout(waitTimer);\n      waitTimer = null;\n      currFlipped = [];\n    }\n\n    const newflipped = [...currFlipped, index];\n    flipped = newflipped;\n\n    // Not enough cards are flipped.\n    if (newflipped.length < matchCount) {\n      return;\n    }\n\n    const allFlippedAreSame = newflipped.every(\n      (index) => cards[newflipped[0]] === cards[index],\n    );\n\n    if (allFlippedAreSame) {\n      const newMatchedSet = new Set(matched);\n      newMatchedSet.add(cards[newflipped[0]]);\n      matched = newMatchedSet;\n      flipped = [];\n\n      if (newMatchedSet.size * matchCount === totalCount) {\n        gameCompleted = true;\n      }\n\n      return;\n    }\n\n    const timer = setTimeout(() => {\n      // After a delay if no new cards were flipped,\n      // flip all cards back.\n      flipped = [];\n      waitTimer = null;\n    }, delay);\n\n    waitTimer = timer;\n  }\n</script>\n\n<div class=\"app\">\n  <div\n    class=\"grid\"\n    style=\"\n      grid-template-rows: repeat({rows}, var(--size));\n      grid-template-columns: repeat({cols}, var(--size));\n    \">\n    {#each cards as card, index}\n      {@const isMatched = matched.has(cards[index])}\n      {@const isFlipped = flipped.includes(index)}\n\n      <button\n        class=\"card\"\n        class:card--revealed={matched.has(cards[index])}\n        disabled={isMatched || isFlipped}\n        on:click={() => {\n          onFlip(index);\n        }}>\n        {isMatched || isFlipped ? card : ''}\n      </button>\n    {/each}\n  </div>\n  {#if gameCompleted}\n    <button on:click={resetGame}>Play Again</button>\n  {/if}\n</div>\n\n<style>\n  * {\n    box-sizing: border-box;\n  }\n\n  .app {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    row-gap: 10px;\n  }\n\n  .grid {\n    --size: 60px;\n\n    display: grid;\n    gap: 8px;\n    justify-content: center;\n    border: 2px solid black;\n    border-radius: 8px;\n    padding: 8px;\n  }\n\n  .card {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border: 2px solid black;\n    border-radius: 6px;\n    font-size: 30px;\n    cursor: pointer;\n    background-color: #eee;\n    overflow: hidden;\n    position: relative;\n  }\n\n  .card:disabled {\n    color: #000;\n  }\n\n  .card--revealed {\n    background: transparent;\n    border-color: transparent;\n  }\n</style>\n"
    },
    "/src/index.js": {
      "code": "import App from './App.svelte';\nimport './styles.css';\n\nconst app = new App({\n  target: document.body,\n});\n\nexport default app;\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.svelte",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.svelte",
    "environment": "svelte"
  },
  "writeup": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var v=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),C=(i,e)=>{for(var a in e)c(i,a,{get:e[a],enumerable:!0})},h=(i,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!w.call(i,r)&&r!==a&&c(i,r,{get:()=>e[r],enumerable:!(l=g(e,r))||l.enumerable});return i};var s=(i,e,a)=>(a=i!=null?p(b(i)):{},h(e||!i||!i.__esModule?c(a,\"default\",{value:i,enumerable:!0}):a,i)),j=i=>h(c({},\"__esModule\",{value:!0}),i);var d=v((F,o)=>{o.exports=_jsx_runtime});var _={};C(_,{default:()=>S});var n=s(d());var t=s(d());function m(i){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initial Display\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Open the game and verify that the grid of faced-down cards is displayed correctly.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Check that the number of cards in the grid is as expected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that all cards are facedown and not revealing their images.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Card Flipping\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Click on a card and verify that it reveals its image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Click on another card and verify that it also reveals the image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that the selected cards remain face-up if they match.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the selected cards flip back if they don't match after a short delay.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have the same image and verify that they remain face-up.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Non-Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and verify that they flip back after a short delay if no new cards are selected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and select a new card, the first two selected cards should be flipped back.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Game Completion\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Play the game until all pairs are successfully matched.\"}),`\n`,(0,t.jsx)(e.li,{children:'Verify that the \"Play Again\" button is displayed and clicking on it resets the game.'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"New Game/Reset\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Start a new game or reset the current game.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the grid is reset, with all cards facedown.\"}),`\n`]}),`\n`]}),`\n`]})]})}function k(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(m,i)})):m(i)}var u=k;function f(i){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Props\"}),`\n`,(0,n.jsx)(e.p,{children:\"For flexibility, the memory game can be modified using:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"rows\"}),\": Determines the number of rows.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cols\"}),\": Determines the number of columns.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matchCount\"}),\": Specifies how many identical images there should be. The default value is 2, but having it adjustable is a useful feature.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"delay\"}),\": Dictates the time lapse before non-matching cards turn back face-down.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"We need to validate these configurations to ensure they produce a playable game. One such validation is ensuring the total cell count can be divided by the match count without remainder.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"State Management\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cards\"}),\": A one-dimensional array depicting the game board. It contains groups of emojis (based on \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\"). For instance, in a 4 x 4 board, the array has a size of 16, and \",(0,n.jsx)(e.code,{children:\"cards[4]\"}),\" corresponds to the card in the 2nd row, 1st column. It is only re-generated when starting a new game.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"flipped\"}),\": Stores indices of flipped cards that haven't been matched yet.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matched\"}),\": A set to store emojis that have found their matching pairs.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"waitTimer\"}),\": Used to keep track of the timer for auto-flipping cards after the \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"gameCompleted\"}),\": A boolean to track if all pairs have been matched.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsx)(e.p,{children:\"CSS grid is used to render the cards in a 2-dimensional format. It's a great choice because you can render the cards as a single list of DOM elements but with the right CSS grid settings, they can be displayed in a rows x cols layout.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Generating the Cards\"}),`\n`,(0,n.jsx)(e.p,{children:\"The card creation is as follows:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Make N groups of \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" emojis where N = total cells / \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" in a single array.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Shuffle the array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"onFlip\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For the most part, \",(0,n.jsx)(e.code,{children:\"onFlip\"}),\" adds cards to the \",(0,n.jsx)(e.code,{children:\"selected\"}),\" array. If there aren't enough cards to make a decision whether there's a match yet, the function terminates. When enough cards are selected, check whether all the selected cards are similar. If so, we can add the selected emoji to the \",(0,n.jsx)(e.code,{children:\"matched\"}),\" set and reset \",(0,n.jsx)(e.code,{children:\"selected\"}),\" to be empty so that the player can continue with the game. If there isn't a match, we wait for \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration to pass before flipping the selected cards back over.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If a player tries flipping more cards before the \",(0,n.jsx)(e.code,{children:\"delay\"}),\" elapses, the already flipped cards (that aren't matched) need to be reset immediately. Using \",(0,n.jsx)(e.code,{children:\"clearTimeout\"}),\" with the timer stored in \",(0,n.jsx)(e.code,{children:\"waitTimer\"}),\" achieves this.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In Svelte, the reactivity system via \",(0,n.jsx)(e.code,{children:\"$:\"}),\" ensures the checks and updates to the game state are done efficiently. When props like \",(0,n.jsx)(e.code,{children:\"cols\"}),\", \",(0,n.jsx)(e.code,{children:\"rows\"}),\", or \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" change, necessary functions and validations are automatically re-invoked.\"]}),`\n`,(0,n.jsx)(u,{})]})}function x(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(f,i)})):f(i)}var S=x;return j(_);})();\n;return Component;"
}