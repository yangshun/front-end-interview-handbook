{
  "skeleton": "var Component=(()=>{var f=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var j=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var a in e)i(n,a,{get:e[a],enumerable:!0})},c=(n,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!w.call(n,r)&&r!==a&&i(n,r,{get:()=>e[r],enumerable:!(o=g(e,r))||o.enumerable});return n};var d=(n,e,a)=>(a=n!=null?f(x(n)):{},c(e||!n||!n.__esModule?i(a,\"default\",{value:n,enumerable:!0}):a,n)),_=n=>c(i({},\"__esModule\",{value:!0}),n);var l=j((X,h)=>{h.exports=_jsx_runtime});var k={};b(k,{default:()=>v});var s=d(l());var t=d(l());function m(n){let e=Object.assign({p:\"p\",img:\"img\",h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"Build a memory game where the player needs to match pairs of cards.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/memory-game/memory-game-example.png\",alt:\"Memory game example\"})}),`\n`,(0,t.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Display a grid of faced-down cards on the screen, with each card representing a different item or image. You can use emojis as the image, a list of emojis has been provided.\"}),`\n`,(0,t.jsx)(e.li,{children:\"The grid should consist of an equal number of cards to make pairs.\"}),`\n`,(0,t.jsx)(e.li,{children:\"When a player clicks on a card, it should flip over and reveal its image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Allow the player to select two cards at a time.\"}),`\n`,(0,t.jsx)(e.li,{children:\"If the two selected cards have the same image, it's a match and they should remain face-up.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the two selected cards have different images and the player\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Selects other cards, the two selected cards should flip back.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Do nothing, the two selected cards should flip back facedown after a short delay.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:'When all pairs have been successfully matched, end the game and display a \"Play again\" button.'}),`\n`]})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var u=M;function p(n){return(0,s.jsx)(u,{})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(p,n)})):p(n)}var v=D;return _(k);})();\n;return Component;",
  "solution": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var v=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),C=(i,e)=>{for(var a in e)c(i,a,{get:e[a],enumerable:!0})},h=(i,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!w.call(i,r)&&r!==a&&c(i,r,{get:()=>e[r],enumerable:!(l=g(e,r))||l.enumerable});return i};var s=(i,e,a)=>(a=i!=null?p(b(i)):{},h(e||!i||!i.__esModule?c(a,\"default\",{value:i,enumerable:!0}):a,i)),j=i=>h(c({},\"__esModule\",{value:!0}),i);var d=v((F,o)=>{o.exports=_jsx_runtime});var _={};C(_,{default:()=>S});var n=s(d());var t=s(d());function m(i){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initial Display\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Open the game and verify that the grid of faced-down cards is displayed correctly.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Check that the number of cards in the grid is as expected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that all cards are facedown and not revealing their images.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Card Flipping\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Click on a card and verify that it reveals its image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Click on another card and verify that it also reveals the image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that the selected cards remain face-up if they match.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the selected cards flip back if they don't match after a short delay.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have the same image and verify that they remain face-up.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Non-Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and verify that they flip back after a short delay if no new cards are selected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and select a new card, the first two selected cards should be flipped back.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Game Completion\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Play the game until all pairs are successfully matched.\"}),`\n`,(0,t.jsx)(e.li,{children:'Verify that the \"Play Again\" button is displayed and clicking on it resets the game.'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"New Game/Reset\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Start a new game or reset the current game.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the grid is reset, with all cards facedown.\"}),`\n`]}),`\n`]}),`\n`]})]})}function k(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(m,i)})):m(i)}var u=k;function f(i){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Props\"}),`\n`,(0,n.jsx)(e.p,{children:\"For flexibility, the memory game can be modified using:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"rows\"}),\": Determines the number of rows.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cols\"}),\": Determines the number of columns.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matchCount\"}),\": Specifies how many identical images there should be. The default value is 2, but having it adjustable is a useful feature.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"delay\"}),\": Dictates the time lapse before non-matching cards turn back face-down.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"We need to validate these configurations to ensure they produce a playable game. One such validation is ensuring the total cell count can be divided by the match count without remainder.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"State Management\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cards\"}),\": A one-dimensional array depicting the game board. It contains groups of emojis (based on \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\"). For instance, in a 4 x 4 board, the array has a size of 16, and \",(0,n.jsx)(e.code,{children:\"cards[4]\"}),\" corresponds to the card in the 2nd row, 1st column. It is only re-generated when starting a new game.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"flipped\"}),\": Stores indices of flipped cards that haven't been matched yet.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matched\"}),\": A set to store emojis that have found their matching pairs.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"waitTimer\"}),\": Used to keep track of the timer for auto-flipping cards after the \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"gameCompleted\"}),\": A boolean to track if all pairs have been matched.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsx)(e.p,{children:\"CSS grid is used to render the cards in a 2-dimensional format. It's a great choice because you can render the cards as a single list of DOM elements but with the right CSS grid settings, they can be displayed in a rows x cols layout.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Generating the Cards\"}),`\n`,(0,n.jsx)(e.p,{children:\"The card creation is as follows:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Make N groups of \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" emojis where N = total cells / \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" in a single array.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Shuffle the array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"onFlip\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For the most part, \",(0,n.jsx)(e.code,{children:\"onFlip\"}),\" adds cards to the \",(0,n.jsx)(e.code,{children:\"selected\"}),\" array. If there aren't enough cards to make a decision whether there's a match yet, the function terminates. When enough cards are selected, check whether all the selected cards are similar. If so, we can add the selected emoji to the \",(0,n.jsx)(e.code,{children:\"matched\"}),\" set and reset \",(0,n.jsx)(e.code,{children:\"selected\"}),\" to be empty so that the player can continue with the game. If there isn't a match, we wait for \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration to pass before flipping the selected cards back over.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If a player tries flipping more cards before the \",(0,n.jsx)(e.code,{children:\"delay\"}),\" elapses, the already flipped cards (that aren't matched) need to be reset immediately. Using \",(0,n.jsx)(e.code,{children:\"clearTimeout\"}),\" with the timer stored in \",(0,n.jsx)(e.code,{children:\"waitTimer\"}),\" achieves this.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In Svelte, the reactivity system via \",(0,n.jsx)(e.code,{children:\"$:\"}),\" ensures the checks and updates to the game state are done efficiently. When props like \",(0,n.jsx)(e.code,{children:\"cols\"}),\", \",(0,n.jsx)(e.code,{children:\"rows\"}),\", or \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" change, necessary functions and validations are automatically re-invoked.\"]}),`\n`,(0,n.jsx)(u,{})]})}function x(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(f,i)})):f(i)}var S=x;return j(_);})();\n;return Component;"
}