{
  "author": "willnguyen1312",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/memory-game-vue-solution\",\n  \"author\": \"willnguyen1312\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/main.js\",\n  \"scripts\": {\n    \"serve\": \"vue-cli-service serve\",\n    \"build\": \"vue-cli-service build\"\n  },\n  \"dependencies\": {\n    \"core-js\": \"3.32.2\",\n    \"vue\": \"3.3.4\"\n  },\n  \"devDependencies\": {\n    \"@vue/cli-plugin-babel\": \"5.0.8\",\n    \"@vue/cli-service\": \"5.0.8\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width,initial-scale=1.0\" />\n    <title>Vue</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    <!-- Built files will be auto injected -->\n  </body>\n</html>\n"
    },
    "/src/App.vue": {
      "code": "<script setup>\nimport MemoryGame from './MemoryGame.vue';\n</script>\n\n<template>\n  <MemoryGame\n    :rows=\"4\"\n    :cols=\"4\"\n    :delay=\"2000\"\n    :matchCount=\"2\" />\n</template>\n"
    },
    "/src/main.js": {
      "code": "import { createApp } from 'vue';\nimport App from './App.vue';\n\nimport './styles.css';\n\ncreateApp(App).mount('#app');\n"
    },
    "/src/MemoryGame.vue": {
      "code": "<script setup>\nimport { computed, ref, watch } from 'vue';\n\nconst props = defineProps({\n  rows: Number,\n  cols: Number,\n  delay: Number,\n  matchCount: Number,\n});\n\nconst emojis = [\n  '🐵',\n  '🐶',\n  '🦊',\n  '🐱',\n  '🦁',\n  '🐯',\n  '🐴',\n  '🦄',\n  '🦓',\n  '🦌',\n  '🐮',\n  '🐷',\n  '🐭',\n  '🐹',\n  '🐻',\n  '🐨',\n  '🐼',\n  '🐽',\n  '🐸',\n  '🐰',\n  '🐙',\n];\n\nfunction shuffle(array) {\n  for (let i = 0; i < array.length; i++) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n\n// Generate cards configuration with the required groups of emojis.\nfunction generateCards(totalCount, matchCount) {\n  const numGroups = totalCount / matchCount;\n  if (numGroups > emojis.length) {\n    throw new Error('Not enough emojis');\n  }\n\n  const emojisList = emojis.slice(0, numGroups);\n  const cards = Array.from(\n    { length: numGroups },\n    () => null,\n  )\n    .map((_, idx) => idx)\n    .map((idx) =>\n      Array.from(\n        { length: matchCount },\n        () => emojisList[idx],\n      ),\n    )\n    .flat();\n\n  shuffle(cards);\n  return cards;\n}\n\n// Total number of cells.\nconst totalCount = computed(() => props.rows * props.cols);\n// An array of emojis to represent the cards.\nconst cards = ref([]);\n// Currently flipped cards.\nconst flipped = ref([]);\n// Identifier of matched cards.\nconst matched = ref(new Set());\n// Delay before cards are flipped back.\nlet waitTimer = null;\n// Whether the game has completed.\nconst gameCompleted = ref(false);\n\nfunction resetGame() {\n  waitTimer = null;\n  cards.value = generateCards(\n    totalCount.value,\n    props.matchCount,\n  );\n  flipped.value.length = 0;\n  matched.value.clear();\n  gameCompleted.value = false;\n}\n\nfunction onFlip(index) {\n  // Player flips more cards while there are\n  // unmatched cards flipped open.\n  if (waitTimer != null) {\n    clearTimeout(waitTimer);\n    waitTimer = null;\n    flipped.value.length = 0;\n  }\n\n  flipped.value.push(index);\n\n  // Not enough cards are flipped.\n  if (flipped.value.length < props.matchCount) {\n    return;\n  }\n\n  const allFlippedAreSame = flipped.value.every(\n    (index) =>\n      cards.value[flipped.value[0]] === cards.value[index],\n  );\n\n  if (allFlippedAreSame) {\n    matched.value.add(cards.value[flipped.value[0]]);\n    flipped.value.length = 0;\n\n    if (\n      matched.value.size * props.matchCount ===\n      totalCount.value\n    ) {\n      gameCompleted.value = true;\n    }\n\n    return;\n  }\n\n  const timer = setTimeout(() => {\n    // After a delay if no new cards were flipped,\n    // flip all cards back.\n    flipped.value.length = 0;\n    waitTimer = null;\n  }, props.delay);\n\n  waitTimer = timer;\n}\n\nfunction checkDisabledCard(index) {\n  return (\n    matched.value.has(cards.value[index]) ||\n    flipped.value.includes(index)\n  );\n}\n\nwatch(\n  [\n    () => props.cols,\n    () => props.rows,\n    () => props.matchCount,\n  ],\n  resetGame,\n  {\n    immediate: true,\n  },\n);\n</script>\n\n<template>\n  <div class=\"app\">\n    <div\n      class=\"grid\"\n      :style=\"{\n        gridTemplateRows: `repeat(${rows}, var(--size))`,\n        gridTemplateColumns: `repeat(${cols}, var(--size))`,\n      }\">\n      <button\n        v-for=\"(card, index) in cards\"\n        :key=\"index\"\n        :class=\"[\n          'card',\n          matched.has(cards[index]) && 'card--revealed',\n        ]\"\n        :disabled=\"checkDisabledCard(index)\"\n        @click=\"onFlip(index)\">\n        {{ checkDisabledCard(index) ? card : '' }}\n      </button>\n    </div>\n\n    <button v-if=\"gameCompleted\" @click=\"resetGame\">\n      Play Again\n    </button>\n  </div>\n</template>\n\n<style>\n.app {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  row-gap: 10px;\n}\n\n.grid {\n  --size: 60px;\n\n  display: grid;\n  gap: 8px;\n  justify-content: center;\n  border: 2px solid black;\n  border-radius: 8px;\n  padding: 8px;\n}\n\n.card {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border: 2px solid black;\n  border-radius: 6px;\n  font-size: 30px;\n  cursor: pointer;\n  background-color: #eee;\n  overflow: hidden;\n  position: relative;\n}\n\n.card:disabled {\n  color: #000;\n}\n\n.card--revealed {\n  background: transparent;\n  border-color: transparent;\n}\n</style>\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.vue",
      "/src/MemoryGame.vue"
    ],
    "activeFile": "/src/MemoryGame.vue",
    "environment": "vue-cli"
  },
  "writeup": "var Component=(()=>{var g=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var k=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),v=(a,e)=>{for(var i in e)c(a,i,{get:e[i],enumerable:!0})},h=(a,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!b.call(a,r)&&r!==i&&c(a,r,{get:()=>e[r],enumerable:!(d=p(e,r))||d.enumerable});return a};var o=(a,e,i)=>(i=a!=null?g(w(a)):{},h(e||!a||!a.__esModule?c(i,\"default\",{value:a,enumerable:!0}):i,a)),x=a=>h(c({},\"__esModule\",{value:!0}),a);var l=k((M,s)=>{s.exports=_jsx_runtime});var _={};v(_,{default:()=>S});var n=o(l());var t=o(l());function m(a){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},a.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initial Display\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Open the game and verify that the grid of faced-down cards is displayed correctly.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Check that the number of cards in the grid is as expected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that all cards are facedown and not revealing their images.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Card Flipping\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Click on a card and verify that it reveals its image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Click on another card and verify that it also reveals the image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that the selected cards remain face-up if they match.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the selected cards flip back if they don't match after a short delay.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have the same image and verify that they remain face-up.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Non-Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and verify that they flip back after a short delay if no new cards are selected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and select a new card, the first two selected cards should be flipped back.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Game Completion\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Play the game until all pairs are successfully matched.\"}),`\n`,(0,t.jsx)(e.li,{children:'Verify that the \"Play Again\" button is displayed and clicking on it resets the game.'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"New Game/Reset\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Start a new game or reset the current game.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the grid is reset, with all cards facedown.\"}),`\n`]}),`\n`]}),`\n`]})]})}function j(a={}){let{wrapper:e}=a.components||{};return e?(0,t.jsx)(e,Object.assign({},a,{children:(0,t.jsx)(m,a)})):m(a)}var u=j;function f(a){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",ol:\"ol\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Props\"}),`\n`,(0,n.jsx)(e.p,{children:\"The default memory game shown in the diagram is 4 x 4 and the goal is to match pairs. In order to make the game customizable, we can introduce the following props:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"rows\"}),\": Number of rows.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cols\"}),\": Number of columns.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matchCount\"}),\": How many of the same images there are. The default is 2 but making it a parameter is a positive signal.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"delay\"}),\": Delay before selected non-matching cards are flipped back over.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Since these parameters can be combined in ways that make the game unplayable, we can do a basic check of whether the total number of cells is divisible by the match count.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cards\"}),\": The game board can be represented as a one-dimensional array called \",(0,n.jsx)(e.code,{children:\"cards\"}),\", containing the correct number of groups of unique emojis. On a 4 x 4 board, the array has a length of 16 and \",(0,n.jsx)(e.code,{children:\"cards[4]\"}),\" will correspond to row 2 column 1. This array is generated during initialization and not modified throughout the duration of the game. It's only regenerated when the user chooses to play again.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"flipped\"}),\": An array of indices to track which cards are flipped. This array excludes matched cards.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matched\"}),\": A set of images (emojis) that have been matched.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"waitTimer\"}),\": A variable to track the timer ID for whether to automatically flip back the cards after \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"gameCompleted\"}),\": Boolean value to represent whether the game is completed.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsx)(e.p,{children:\"CSS grid is used to render the cards in a 2-dimensional format. It's a great choice because you can render the cards as a single list of DOM elements but with the right CSS grid settings, they can be displayed in a rows x cols layout.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Card Generation\"}),`\n`,(0,n.jsx)(e.p,{children:\"The following process can be used for generating the cards:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Make N groups of \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" emojis where N = total cells / \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" in a single array.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Shuffle the array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"onFlip\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For the most part, \",(0,n.jsx)(e.code,{children:\"onFlip\"}),\" adds cards to the \",(0,n.jsx)(e.code,{children:\"selected\"}),\" array. If there aren't enough cards to make a decision whether there's a match yet, the function terminates. When enough cards are selected, check whether all the selected cards are similar. If so, we can add the selected emoji to the \",(0,n.jsx)(e.code,{children:\"matched\"}),\" set and reset \",(0,n.jsx)(e.code,{children:\"selected\"}),\" to be empty so that the player can continue with the game. If there isn't a match, we wait for \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration to pass before flipping the selected cards back over.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If a player tries flipping more cards before the \",(0,n.jsx)(e.code,{children:\"delay\"}),\" elapses, the already flipped cards (that aren't matched) need to be reset immediately. Using \",(0,n.jsx)(e.code,{children:\"clearTimeout\"}),\" with the timer stored in \",(0,n.jsx)(e.code,{children:\"waitTimer\"}),\" achieves this.\"]}),`\n`,(0,n.jsx)(u,{})]})}function C(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(f,a)})):f(a)}var S=C;return x(_);})();\n;return Component;"
}