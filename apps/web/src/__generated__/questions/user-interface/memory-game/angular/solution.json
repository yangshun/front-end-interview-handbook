{
  "author": "michalgrzegorczyk-dev",
  "files": {
    "/angular.json": {
      "code": "{\n  \"$schema\": \"./node_modules/@angular/cli/lib/config/schema.json\",\n  \"version\": 1,\n  \"newProjectRoot\": \"projects\",\n  \"defaultProject\": \"greatfrontend\",\n  \"projects\": {\n    \"greatfrontend\": {\n      \"projectType\": \"application\",\n      \"schematics\": {},\n      \"root\": \"\",\n      \"sourceRoot\": \"src\",\n      \"prefix\": \"app\",\n      \"architect\": {\n        \"build\": {\n          \"builder\": \"@angular-devkit/build-angular:browser\",\n          \"options\": {\n            \"outputPath\": \"dist/my-app\",\n            \"index\": \"src/index.html\",\n            \"main\": \"src/main.ts\",\n            \"polyfills\": [\"zone.js\"],\n            \"tsConfig\": \"tsconfig.app.json\",\n            \"assets\": [\"src/favicon.ico\", \"src/assets\"],\n            \"styles\": [\"src/styles.css\"],\n            \"scripts\": []\n          },\n          \"configurations\": {\n            \"production\": {\n              \"budgets\": [\n                {\n                  \"type\": \"initial\",\n                  \"maximumWarning\": \"500kb\",\n                  \"maximumError\": \"1mb\"\n                },\n                {\n                  \"type\": \"anyComponentStyle\",\n                  \"maximumWarning\": \"2kb\",\n                  \"maximumError\": \"4kb\"\n                }\n              ],\n              \"outputHashing\": \"all\"\n            },\n            \"development\": {\n              \"buildOptimizer\": false,\n              \"optimization\": false,\n              \"vendorChunk\": true,\n              \"extractLicenses\": false,\n              \"sourceMap\": true,\n              \"namedChunks\": true\n            }\n          },\n          \"defaultConfiguration\": \"production\"\n        },\n        \"serve\": {\n          \"builder\": \"@angular-devkit/build-angular:dev-server\",\n          \"configurations\": {\n            \"production\": {\n              \"browserTarget\": \"greatfrontend:build:production\"\n            },\n            \"development\": {\n              \"browserTarget\": \"greatfrontend:build:development\"\n            }\n          },\n          \"defaultConfiguration\": \"development\"\n        },\n        \"extract-i18n\": {\n          \"builder\": \"@angular-devkit/build-angular:extract-i18n\",\n          \"options\": {\n            \"browserTarget\": \"greatfrontend:build\"\n          }\n        },\n        \"test\": {\n          \"builder\": \"@angular-devkit/build-angular:karma\",\n          \"options\": {\n            \"polyfills\": [\"zone.js\", \"zone.js/testing\"],\n            \"tsConfig\": \"tsconfig.spec.json\",\n            \"assets\": [\"src/favicon.ico\", \"src/assets\"],\n            \"styles\": [\"src/styles.css\"],\n            \"scripts\": []\n          }\n        }\n      }\n    }\n  },\n  \"cli\": {\n    \"analytics\": \"7ca5c4d0-e5db-4d23-9ffd-8c8c042e34e7\"\n  }\n}\n"
    },
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/memory-game-angular-solution\",\n  \"author\": \"michalgrzegorczyk-dev\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"@angular/common\": \"16.2.4\",\n    \"@angular/compiler\": \"16.2.4\",\n    \"@angular/core\": \"16.2.4\",\n    \"@angular/forms\": \"16.2.4\",\n    \"@angular/platform-browser\": \"16.2.4\",\n    \"@angular/platform-browser-dynamic\": \"16.2.4\",\n    \"rxjs\": \"7.8.0\",\n    \"zone.js\": \"0.13.1\"\n  },\n  \"devDependencies\": {\n    \"@angular-devkit/build-angular\": \"16.2.1\",\n    \"@angular/cli\": \"16.2.1\",\n    \"@angular/compiler-cli\": \"16.2.4\",\n    \"@types/jasmine\": \"4.3.5\",\n    \"jasmine-core\": \"4.6.0\",\n    \"karma\": \"6.4.2\",\n    \"karma-chrome-launcher\": \"3.2.0\",\n    \"karma-coverage\": \"2.2.1\",\n    \"karma-jasmine\": \"5.1.0\",\n    \"karma-jasmine-html-reporter\": \"2.1.0\",\n    \"typescript\": \"5.0.2\"\n  },\n  \"scripts\": {\n    \"ng\": \"ng\",\n    \"start\": \"ng serve\",\n    \"build\": \"ng build\",\n    \"watch\": \"ng build --watch --configuration development\",\n    \"test\": \"ng test\"\n  }\n}\n"
    },
    "/src/app/app.component.css": {
      "code": ""
    },
    "/src/app/app.component.html": {
      "code": "<app-memory-game\n  [rows]=\"4\"\n  [cols]=\"4\"\n  [delay]=\"1000\"\n  [matchCount]=\"2\" />\n"
    },
    "/src/app/app.component.ts": {
      "code": "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n})\nexport class AppComponent {}\n"
    },
    "/src/app/app.module.ts": {
      "code": "import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { FormsModule } from '@angular/forms';\n\nimport { MemoryGameComponent } from './memory-game.component';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [AppComponent, MemoryGameComponent],\n  imports: [BrowserModule, FormsModule],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n"
    },
    "/src/app/memory-game.component.html": {
      "code": "<div class=\"app\">\n  <div\n    class=\"grid\"\n    [ngStyle]=\"{\n      'grid-template-rows':\n        'repeat(' + rows + ', var(--size))',\n      'grid-template-columns':\n        'repeat(' + cols + ', var(--size))'\n    }\">\n    <button\n      *ngFor=\"let card of cards; let index = index\"\n      class=\"card\"\n      [ngClass]=\"{\n        'card--revealed': matched.has(cards[index])\n      }\"\n      [disabled]=\"\n        matched.has(cards[index]) || flipped.includes(index)\n      \"\n      (click)=\"onFlip(index)\">\n      {{\n        matched.has(cards[index]) || flipped.includes(index)\n          ? card\n          : ''\n      }}\n    </button>\n  </div>\n  <button *ngIf=\"gameCompleted\" (click)=\"resetGame()\">\n    Play Again\n  </button>\n</div>\n"
    },
    "/src/app/memory-game.component.ts": {
      "code": "import { Component, Input, OnInit } from '@angular/core';\n\nconst emojis = [\n  'üêµ',\n  'üê∂',\n  'ü¶ä',\n  'üê±',\n  'ü¶Å',\n  'üêØ',\n  'üê¥',\n  'ü¶Ñ',\n  'ü¶ì',\n  'ü¶å',\n  'üêÆ',\n  'üê∑',\n  'üê≠',\n  'üêπ',\n  'üêª',\n  'üê®',\n  'üêº',\n  'üêΩ',\n  'üê∏',\n  'üê∞',\n  'üêô',\n];\n\nfunction shuffle(array: any) {\n  for (let i = 0; i < array.length; i++) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n\nfunction generateCards(\n  totalCount: number,\n  matchCount: number,\n) {\n  const numGroups = totalCount / matchCount;\n  if (numGroups > emojis.length) {\n    throw new Error('Not enough emojis');\n  }\n\n  const emojisList = emojis.slice(0, numGroups);\n  const cards = Array.from(\n    { length: numGroups },\n    () => null,\n  )\n    .map((_, idx) => idx)\n    .map((idx) =>\n      Array.from(\n        { length: matchCount },\n        () => emojisList[idx],\n      ),\n    )\n    .flat();\n\n  shuffle(cards);\n  return cards;\n}\n\n@Component({\n  selector: 'app-memory-game',\n  templateUrl: './memory-game.component.html',\n})\nexport class MemoryGameComponent implements OnInit {\n  @Input()\n  cols!: number;\n\n  @Input()\n  rows!: number;\n\n  @Input()\n  delay!: number;\n\n  @Input()\n  matchCount!: number;\n\n  totalCount!: number;\n  cards: string[] = [];\n  flipped: number[] = [];\n  matched = new Set<string>();\n  gameCompleted: boolean = false;\n  waitTimer: number = 0;\n\n  ngOnInit() {\n    this.totalCount = this.rows * this.cols;\n    this.cards = generateCards(\n      this.totalCount,\n      this.matchCount,\n    );\n  }\n\n  onFlip(index: number) {\n    let currFlipped = this.flipped;\n\n    if (this.waitTimer) {\n      clearTimeout(this.waitTimer);\n      this.waitTimer = 0;\n      currFlipped = [];\n    }\n\n    const newFlipped = [...currFlipped, index];\n    this.flipped = newFlipped;\n\n    if (newFlipped.length < this.matchCount) {\n      return;\n    }\n\n    const allFlippedAreSame = newFlipped.every(\n      (i) => this.cards[newFlipped[0]] === this.cards[i],\n    );\n\n    if (allFlippedAreSame) {\n      this.matched.add(this.cards[newFlipped[0]]);\n      this.flipped = [];\n\n      if (\n        this.matched.size * this.matchCount ===\n        this.totalCount\n      ) {\n        this.gameCompleted = true;\n      }\n\n      return;\n    }\n\n    this.waitTimer = setTimeout(() => {\n      this.flipped = [];\n    }, this.delay);\n  }\n\n  resetGame() {\n    this.waitTimer = 0;\n    this.cards = generateCards(\n      this.totalCount,\n      this.matchCount,\n    );\n    this.flipped = [];\n    this.matched = new Set();\n    this.gameCompleted = false;\n  }\n}\n"
    },
    "/src/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf-8\" />\n    <title>Angular</title>\n    <base href=\"/\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <app-root></app-root>\n  </body>\n</html>\n"
    },
    "/src/main.ts": {
      "code": "import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\nenableProdMode();\nplatformBrowserDynamic()\n  .bootstrapModule(AppModule)\n  .catch((err) => console.error(err));\n"
    },
    "/src/styles.css": {
      "code": "/* You can add global styles to this file, and also import other style files */\nbody {\n  font-family: sans-serif;\n}\n\n* {\n  box-sizing: border-box;\n}\n\n.app {\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  row-gap: 10px;\n}\n\n.grid {\n  --size: 60px;\n\n  display: grid;\n  gap: 8px;\n  justify-content: center;\n  border: 2px solid black;\n  border-radius: 8px;\n  padding: 8px;\n}\n\n.card {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border: 2px solid black;\n  border-radius: 6px;\n  font-size: 30px;\n  cursor: pointer;\n  background-color: #eee;\n  overflow: hidden;\n  position: relative;\n}\n\n.card:disabled {\n  color: #000;\n}\n\n.card--revealed {\n  background: transparent;\n  border-color: transparent;\n}\n"
    },
    "/tsconfig.app.json": {
      "code": "/* To learn more about this file see: https://angular.io/config/tsconfig. */\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./out-tsc/app\",\n    \"types\": []\n  },\n  \"files\": [\"src/main.ts\"],\n  \"include\": [\"src/**/*.d.ts\"]\n}\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"compileOnSave\": false,\n  \"compilerOptions\": {\n    \"baseUrl\": \"./\",\n    \"outDir\": \"./dist/out-tsc\",\n    \"forceConsistentCasingInFileNames\": true,\n    \"strict\": true,\n    \"noImplicitOverride\": true,\n    \"noPropertyAccessFromIndexSignature\": true,\n    \"noImplicitReturns\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"sourceMap\": true,\n    \"declaration\": false,\n    \"downlevelIteration\": true,\n    \"experimentalDecorators\": true,\n    \"moduleResolution\": \"node\",\n    \"target\": \"es2020\",\n    \"module\": \"esnext\",\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"]\n  },\n  \"angularCompilerOptions\": {\n    \"enableI18nLegacyMessageIdFormat\": false,\n    \"strictInjectionParameters\": true,\n    \"strictInputAccessModifiers\": true,\n    \"strictTemplates\": true\n  }\n}\n"
    },
    "/tsconfig.spec.json": {
      "code": "/* To learn more about this file see: https://angular.io/config/tsconfig. */\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./out-tsc/spec\",\n    \"types\": [\"jasmine\"]\n  },\n  \"include\": [\"src/**/*.spec.ts\", \"src/**/*.d.ts\"]\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/app/app.component.ts",
      "/src/app/app.component.html",
      "/src/styles.css"
    ],
    "activeFile": "/src/app/app.component.ts",
    "environment": "angular-cli"
  },
  "writeup": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),k=(i,e)=>{for(var a in e)c(i,a,{get:e[a],enumerable:!0})},h=(i,e,a,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!b.call(i,r)&&r!==a&&c(i,r,{get:()=>e[r],enumerable:!(d=g(e,r))||d.enumerable});return i};var o=(i,e,a)=>(a=i!=null?p(w(i)):{},h(e||!i||!i.__esModule?c(a,\"default\",{value:i,enumerable:!0}):a,i)),x=i=>h(c({},\"__esModule\",{value:!0}),i);var l=v((M,s)=>{s.exports=_jsx_runtime});var S={};k(S,{default:()=>I});var n=o(l());var t=o(l());function m(i){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initial Display\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Open the game and verify that the grid of faced-down cards is displayed correctly.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Check that the number of cards in the grid is as expected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that all cards are facedown and not revealing their images.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Card Flipping\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Click on a card and verify that it reveals its image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Click on another card and verify that it also reveals the image.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Ensure that the selected cards remain face-up if they match.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the selected cards flip back if they don't match after a short delay.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have the same image and verify that they remain face-up.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Non-Matching Pairs\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and verify that they flip back after a short delay if no new cards are selected.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Select two cards that have different images and select a new card, the first two selected cards should be flipped back.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Game Completion\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Play the game until all pairs are successfully matched.\"}),`\n`,(0,t.jsx)(e.li,{children:'Verify that the \"Play Again\" button is displayed and clicking on it resets the game.'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"New Game/Reset\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Start a new game or reset the current game.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the grid is reset, with all cards facedown.\"}),`\n`]}),`\n`]}),`\n`]})]})}function j(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(m,i)})):m(i)}var u=j;function f(i){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",ol:\"ol\",h3:\"h3\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The default memory game shown in the diagram is 4 x 4 and the goal is to match pairs. In order to make the game customizable, we can introduce the following \",(0,n.jsx)(e.code,{children:\"@Input\"}),\"s:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"rows\"}),\": Number of rows.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cols\"}),\": Number of columns.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matchCount\"}),\": How many of the same images there are. The default is 2 but making it a parameter is a positive signal.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"delay\"}),\": Delay before selected non-matching cards are flipped back over.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The following process can be used for generating the cards:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Make N groups of \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" emojis where N = total cells / \",(0,n.jsx)(e.code,{children:\"matchCount\"}),\" in a single array.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Shuffle the array.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"onFlip\"}),\" - For the most part, \",(0,n.jsx)(e.code,{children:\"onFlip\"}),\" method adds cards to the \",(0,n.jsx)(e.code,{children:\"selected\"}),\" array. If there aren't enough cards to make a decision whether there's a match yet, the function terminates. When enough cards are selected, check whether all the selected cards are similar. If so, we can add the selected emoji to the \",(0,n.jsx)(e.code,{children:\"matched\"}),\" set and reset \",(0,n.jsx)(e.code,{children:\"selected\"}),\" to be empty so that the player can continue with the game. If there isn't a match, we wait for \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration to pass before flipping the selected cards back over.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another scenario we have to handle is when the user selects more cards before the \",(0,n.jsx)(e.code,{children:\"delay\"}),\" has passed. \",(0,n.jsx)(e.code,{children:\"waitTimer\"}),\" has to be cleared and the currently unmatched open cards have to be flipped back.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cards\"}),\": The game board can be represented as a one-dimensional array called \",(0,n.jsx)(e.code,{children:\"cards\"}),\", containing the correct number of groups of unique emojis. On a 4 x 4 board, the array has a length of 16 and \",(0,n.jsx)(e.code,{children:\"cards[4]\"}),\" will correspond to row 2 column 1. This array is generated during initialization and not modified throughout the duration of the game. It's only regenerated when the user chooses to play again.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"flipped\"}),\": An array of indices to track which cards are flipped. This array excludes matched cards.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matched\"}),\": A set of images (emojis) that have been matched.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"waitTimer\"}),\": A ref to track the timer ID for whether to automatically flip back the cards after \",(0,n.jsx)(e.code,{children:\"delay\"}),\" duration.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"gameCompleted\"}),\": Boolean value to represent whether the game is completed.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsx)(e.p,{children:\"CSS grid is used to render the cards in a 2-dimensional format. It's a great choice because you can render the cards as a single list of DOM elements but with the right CSS grid settings, they can be displayed in a rows x cols layout.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Angular Insights\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"You can adopt a more advanced, reactive-like approach using RxJS (without using subscriptions as possible). However, if you opt for subscriptions, remember about destroying them to prevent memory leaks.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"You might create service for maintaining the state. Inject the service in smart component and crete dumb components that only display and interact with the UI and all events from dumb components are passed to the smart one.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"If you're confident with the latest Angular versions, consider using signals standalone API.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"You can try to focus more on keywords such as \",(0,n.jsx)(e.code,{children:\"readonly\"}),\", \",(0,n.jsx)(e.code,{children:\"private\"}),\", \",(0,n.jsx)(e.code,{children:\"public\"}),\" and \",(0,n.jsx)(e.code,{children:\"void\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsx)(e.p,{children:\"If you're creating a bigger application it would be good practice to use styles per component instead of putting all styles in one file.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(u,{})]})}function C(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(f,i)})):f(i)}var I=C;return x(S);})();\n;return Component;"
}