{
  "author": "yangshun",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/progress-bars-ii-react-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.js": {
      "code": "import { useEffect, useState } from 'react';\n\nfunction ProgressBar({ isEmpty, onCompleted }) {\n  const [startTransition, setStartTransition] =\n    useState(false);\n\n  // Start transition when the bar is no longer empty.\n  useEffect(() => {\n    if (isEmpty || startTransition) {\n      return;\n    }\n\n    setStartTransition(true);\n  }, [isEmpty]);\n\n  return (\n    <div className=\"bar\">\n      <div\n        className={[\n          'bar-contents',\n          startTransition && 'bar-contents--filled',\n        ]\n          .filter(Boolean)\n          .join(' ')}\n        onTransitionEnd={() => {\n          onCompleted();\n        }}\n      />\n    </div>\n  );\n}\n\nexport default function App() {\n  const [bars, setBars] = useState(0);\n  const [numFilledUpBars, setNumFilledUpBars] = useState(0);\n\n  return (\n    <div className=\"wrapper\">\n      <div>\n        <button\n          onClick={() => {\n            setBars(bars + 1);\n          }}>\n          Add\n        </button>\n      </div>\n      <div className=\"bars\">\n        {Array(bars)\n          .fill(null)\n          .map((_, index) => (\n            <ProgressBar\n              isEmpty={index > numFilledUpBars}\n              key={index}\n              onCompleted={() => {\n                setNumFilledUpBars(numFilledUpBars + 1);\n              }}\n            />\n          ))}\n      </div>\n    </div>\n  );\n}\n"
    },
    "/src/index.js": {
      "code": "import React, { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n.wrapper {\n  display: flex;\n  flex-direction: column;\n  gap: 16px;\n  justify-content: center;\n}\n\n.bars {\n  display: flex;\n  flex-direction: column;\n  row-gap: 8px;\n}\n\n.bar {\n  background-color: #ccc;\n  height: 8px;\n}\n\n.bar-contents {\n  background-color: green;\n  height: 100%;\n  transform: scaleX(0);\n  transform-origin: left;\n  transition-duration: 2000ms;\n  transition-property: transform;\n  transition-timing-function: linear;\n}\n\n.bar-contents--filled {\n  transform: scaleX(1);\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.js",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.js",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var f=Object.create;var s=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var j=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of b(e))!x.call(t,o)&&o!==i&&s(t,o,{get:()=>e[o],enumerable:!(l=g(e,o))||l.enumerable});return t};var d=(t,e,i)=>(i=t!=null?f(w(t)):{},c(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),_=t=>c(s({},\"__esModule\",{value:!0}),t);var a=j((M,h)=>{h.exports=_jsx_runtime});var T={};y(T,{default:()=>F});var n=d(a());var r=d(a());function p(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:['Hitting \"Add\" appends a new empty progress bar to the bottom of the list',`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"The first bar starts filling up as soon as it appears.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Can add multiple progress bars, which fill up gradually one after another.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"If all existing bars are filled up, a newly added bar starts filling up immediately.\"}),`\n`]}),`\n`]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(p,t)})):p(t)}var u=C;function m(t){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",h2:\"h2\",h3:\"h3\",code:\"code\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This solution builds on top of the solution for \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/progress-bars\",children:\"Progress Bars\"}),\", so make sure to check that question's solution first.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The question can be split into two parts: (1) State, (2) Orchestration of Transitions.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"On top of the number of bars that we need, we'll need to know how many of the current bars have been filled up and which bars can start to fill up. We introduce a new numeric variable state called \",(0,n.jsx)(e.code,{children:\"numFilledUpBars\"}),\" to track the number of bars that have been filled up. Any bar that has an index that's greater than \",(0,n.jsx)(e.code,{children:\"numFilledUpBars\"}),\" should not start filling up yet. To know when to increment \",(0,n.jsx)(e.code,{children:\"numFilledUpBars\"}),\", we'll add an \",(0,n.jsx)(e.code,{children:\"onCompleted\"}),\" prop to \",(0,n.jsx)(e.code,{children:\"ProgressBar\"}),\" that fires when a progress bar is full.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Orchestration of Transitions\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Using the \",(0,n.jsx)(e.code,{children:\"numFilledUpBars\"}),\" state, we'll determine an \",(0,n.jsx)(e.code,{children:\"isEmpty\"}),\" value to be passed to the \",(0,n.jsx)(e.code,{children:\"ProgressBar\"}),\" as a prop. \",(0,n.jsx)(e.code,{children:\"ProgressBar\"}),\"s that have \",(0,n.jsx)(e.code,{children:\"isEmpty={true}\"}),\" should not be animating yet.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can use the \",(0,n.jsx)(e.code,{children:\"onTransitionEnd\"}),\" prop on React DOM elements to detect when a CSS transition is complete, and firing \",(0,n.jsx)(e.code,{children:\"onCompleted\"}),\" prop. Within the main \",(0,n.jsx)(e.code,{children:\"App\"}),\", the \",(0,n.jsx)(e.code,{children:\"numFilledUpBars\"}),\" will be incremented whenever an \",(0,n.jsx)(e.code,{children:\"onCompleted\"}),\" callback is triggered.\"]}),`\n`,(0,n.jsx)(u,{})]})}function B(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var F=B;return _(T);})();\n;return Component;"
}