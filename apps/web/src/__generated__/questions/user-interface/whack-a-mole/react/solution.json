{
  "author": "utpal-d4l",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/whack-a-mole-react-solution\",\n  \"author\": \"utpal-d4l\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.js": {
      "code": "import { useEffect, useRef, useState } from 'react';\n\n// Fisher-Yates shuffle.\nfunction shuffle(array) {\n  for (let i = 0; i < array.length; i++) {\n    let j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n\nfunction generateMolePositions(molesAtOnce, totalCount) {\n  // Generate an array containing values [0, totalCount].\n  const indices = Array.from({ length: totalCount }).map(\n    (_, index) => index,\n  );\n  shuffle(indices);\n  // Take the first `totalCount` items\n  // from the shuffled array.\n  const shuffledIndices = indices.slice(0, molesAtOnce);\n\n  return new Set(shuffledIndices);\n}\n\nfunction WhackAMole({\n  rows = 3,\n  cols = 3,\n  roundDuration = 30,\n  molesAtOnce = 1,\n  molesAppearingInterval = 1500,\n}) {\n  const totalCount = rows * cols;\n\n  // Set of indices for currently visible moles.\n  const [visible, setVisible] = useState(new Set());\n  // Current player score.\n  const [score, setScore] = useState(null);\n  // Whether the game is in progress.\n  const [running, setRunning] = useState(false);\n  // Time left for the current round.\n  const [timeLeft, setTimeLeft] = useState(roundDuration);\n  const countdownTimerId = useRef(null);\n\n  useEffect(() => {\n    let timerId;\n\n    if (running) {\n      // Generate moles at fixed intervals.\n      timerId = setInterval(() => {\n        setVisible(\n          generateMolePositions(molesAtOnce, totalCount),\n        );\n      }, molesAppearingInterval);\n    }\n\n    return () => {\n      clearInterval(timerId);\n      setVisible(new Set());\n    };\n  }, [\n    running,\n    molesAtOnce,\n    molesAppearingInterval,\n    totalCount,\n  ]);\n\n  function startGame() {\n    // Reset variables to default values.\n    setRunning(true);\n    setTimeLeft(roundDuration);\n    setScore(0);\n\n    // Interval to decrement the timer to 0.\n    countdownTimerId.current = setInterval(() => {\n      setTimeLeft((currTimeLeft) => {\n        if (currTimeLeft <= 0) {\n          clearInterval(countdownTimerId.current);\n          setRunning(false);\n          return 0;\n        }\n\n        return currTimeLeft - 1;\n      });\n    }, 1000);\n  }\n\n  useEffect(() => {\n    return () => {\n      // Clear countdown timer on unmount if it's running.\n      clearInterval(countdownTimerId.current);\n    };\n  }, []);\n\n  function whackMole(index) {\n    // Whacking on an empty cell, no-op.\n    if (!visible.has(index)) {\n      return;\n    }\n\n    const newVisible = new Set(visible);\n    newVisible.delete(index);\n    setVisible(newVisible);\n    setScore((score ?? 0) + 1);\n  }\n\n  return (\n    <div className=\"app\">\n      <div className=\"header\">\n        {score == null ? (\n          <button\n            className=\"start-button\"\n            type=\"button\"\n            onClick={startGame}>\n            Start Game\n          </button>\n        ) : (\n          <div className=\"round-information\">\n            <p>Score: {score}</p>\n            {!running && (\n              <button\n                className=\"start-button\"\n                type=\"button\"\n                onClick={startGame}>\n                Play again\n              </button>\n            )}\n            <p>Time Left: {timeLeft}</p>\n          </div>\n        )}\n      </div>\n      <div\n        className=\"grid\"\n        style={{\n          gridTemplateColumns: `repeat(${rows}, 1fr)`,\n          gridTemplateRows: `repeat(${cols}, 1fr)`,\n        }}>\n        {Array(totalCount)\n          .fill(null)\n          .map((_, index) => {\n            return (\n              <button\n                className=\"grid__cell\"\n                key={index}\n                onClick={() => whackMole(index)}>\n                <img\n                  src=\"https://www.greatfrontend.com/img/questions/whack-a-mole/mole-head.png\"\n                  alt=\"Mole head\"\n                  className={[\n                    'grid__cell-contents',\n                    'mole-head',\n                    visible.has(index) &&\n                      'mole-head--visible',\n                  ]\n                    .filter(Boolean)\n                    .join(' ')}\n                />\n                <img\n                  src=\"https://www.greatfrontend.com/img/questions/whack-a-mole/mole-hill.png\"\n                  alt=\"Mole hill\"\n                  className=\"grid__cell-contents mole-hill\"\n                />\n              </button>\n            );\n          })}\n      </div>\n    </div>\n  );\n}\n\nexport default function App() {\n  return (\n    <WhackAMole\n      rows={3}\n      cols={3}\n      roundDuration={15}\n      molesAtOnce={2}\n      molesAppearingInterval={1500}\n    />\n  );\n}\n"
    },
    "/src/index.js": {
      "code": "import React, { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "* {\n  margin: 0;\n  padding: 0;\n}\n\nbody {\n  --background-color: salmon;\n\n  background-color: var(--background-color);\n  font-family: sans-serif;\n  padding: 2rem;\n}\n\n.app {\n  box-sizing: border-box;\n  padding-block: 16px;\n  margin: 0 auto;\n  max-width: 480px;\n}\n\n.header {\n  display: flex;\n  height: 30px;\n  align-items: center;\n  padding: 1rem 0;\n  justify-content: center;\n}\n\n.round-information {\n  align-items: center;\n  display: flex;\n  flex-grow: 1;\n  justify-content: space-between;\n  font-weight: bold;\n}\n\n.start-button {\n  background-color: #fff;\n  border: none;\n  border-radius: 4px;\n  color: #000;\n  cursor: pointer;\n  font-weight: bold;\n  padding: 0.5rem 1rem;\n}\n\n.grid {\n  aspect-ratio: 1 / 1;\n  display: grid;\n  justify-content: center;\n}\n\n.grid__cell {\n  border: none;\n  background-color: var(--background-color);\n  position: relative;\n  overflow: hidden;\n}\n\n.grid__cell-contents {\n  --width: 0;\n  --height: 0;\n  object-fit: contain;\n  position: absolute;\n  bottom: 0;\n  left: 50%;\n  transform: translateX(-50%);\n  width: var(--width);\n  height: var(--height);\n  user-select: none;\n}\n\n.mole-hill {\n  --width: 100%;\n  --height: 30%;\n  transform: translate(-50%, 10px);\n}\n\n.mole-head {\n  --width: 100%;\n  --height: 70%;\n\n  transform: translate(-50%, 100%);\n  transition: transform 0.1s ease-in;\n  cursor: pointer;\n}\n\n.mole-head--visible {\n  transform: translate(-50%, 0%);\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.js",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.js",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var w=Object.create;var a=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var k=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),T=(t,e)=>{for(var o in e)a(t,o,{get:e[o],enumerable:!0})},h=(t,e,o,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of v(e))!j.call(t,c)&&c!==o&&a(t,c,{get:()=>e[c],enumerable:!(d=b(e,c))||d.enumerable});return t};var s=(t,e,o)=>(o=t!=null?w(x(t)):{},h(e||!t||!t.__esModule?a(o,\"default\",{value:t,enumerable:!0}):o,t)),_=t=>h(a({},\"__esModule\",{value:!0}),t);var l=k((S,m)=>{m.exports=_jsx_runtime});var M={};T(M,{default:()=>I});var n=s(l());var i=s(l());function u(t){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\",code:\"code\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Game Start\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:'Verify that the round starts when the \"Start\" button is clicked.'}),`\n`,(0,i.jsx)(e.li,{children:\"Check that the timer starts counting down from the specified time limit.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure that moles start appearing randomly in the holes.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Whacking Moles\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Test that \",(0,i.jsx)(e.code,{children:\"molesAtOnce\"}),\" moles appear every \",(0,i.jsx)(e.code,{children:\"molesAppearingInterval\"}),\".\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Click on a visible mole and verify that the mole disappears.\"}),`\n`,(0,i.jsx)(e.li,{children:'Confirm that the score increases by one when a mole is successfully \"whacked\".'}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure that clicking a hole that is not visible does not affect the score.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Game End\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Verify that the round ends when the timer reaches zero.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Check that the moles stop appearing once the game ends.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure that the final score is displayed correctly.\"}),`\n`,(0,i.jsx)(e.li,{children:'Test that the \"Play Again\" button shows up after the game ends and clicking on it starts a new round.'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Game Logic\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Verify that moles appear and disappear randomly from different holes.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Test the time limit functionality by setting different time limits and verifying that the game ends accordingly.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Verify that hitting a mole adds one to the score and missing a mole does not affect the score.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Edge Cases\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Test the game behavior when unexpected input or invalid actions occur, such as clicking rapidly on multiple holes.\"}),`\n`]}),`\n`]}),`\n`]})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(u,t)})):u(t)}var p=O;var r=s(l());function f(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Timers created by \",(0,r.jsx)(e.code,{children:\"setInterval\"}),\" and \",(0,r.jsx)(e.code,{children:\"setTimeout\"}),\" are not precise. If the main thread is busy, the callback's execution can be delayed. However, these approaches are likely sufficient for the purpose of the interview. You can score brownie points for mentioning this.\"]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(f,t)})):f(t)}var g=C;function y(t){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Props\"}),`\n`,(0,n.jsx)(e.p,{children:\"The default whack-a-mole game shown in the diagram is 3 x 3 with predefined durations for the round and how long the mole appears for. In order to make the game customizable, we can introduce the following props:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"rows\"}),\": Number of rows.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"cols\"}),\": Number of columns.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"roundDuration\"}),\": How long the round lasts.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"molesAtOnce\"}),\": How many moles appear at once. In arcades, there could be multiple moles appearing at the same time for increased difficulty levels.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"molesAppearingInterval\"}),\": How long the moles show up for.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsx)(e.p,{children:\"The game board can be represented as a one-dimensional array of indices. On a 3 x 3 board, the array has a length of 9 and index 3 will correspond to row 2 column 1.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"visible\"}),\": A set of indices determining the positions of the visible moles. This is generated every \",(0,n.jsx)(e.code,{children:\"molesAppearingInterval\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"score\"}),\": Current score.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"running\"}),\": Whether the game is in progress.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"timeLeft\"}),\": Time left for the current round, in seconds.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"CSS grid is used to render the cells in a 2-dimensional format. It's a great choice because you can render the cells as a single list of DOM elements but with the right CSS grid settings, they can be displayed in a \",(0,n.jsx)(e.code,{children:\"rows\"}),\" x \",(0,n.jsx)(e.code,{children:\"cols\"}),\" layout.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Generating Moles\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Every \",(0,n.jsx)(e.code,{children:\"molesAppearingInterval\"}),\", regardless of how many moles are visible on the page, we should generate positions for the next set of \",(0,n.jsx)(e.code,{children:\"molesAtOnce\"}),\" moles. We can can randomly generate indices \",(0,n.jsx)(e.code,{children:\"molesAtOnce\"}),\" times, but when \",(0,n.jsx)(e.code,{children:\"molesAtOnce\"}),\" > 1, there's a slim chance that that the generated indices are repeated and you need to randomly generate again.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"An elegant way to generate unique indices is to create an array of indices, shuffling the array, and taking the first \",(0,n.jsx)(e.code,{children:\"molesAtOnce\"}),\" values. It requires O(N) space but this approach is arguably simpler to understand and implement correctly.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"When using \",(0,n.jsx)(e.code,{children:\"setInterval\"}),\" within React components, an extremely common source of bugs is accessing stale prop/state values. Hence the dependent variables are used in the \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" dependency array to re-run the intervals when dependent variables are updated. Read \",(0,n.jsx)(e.a,{href:\"https://overreacted.io/making-setinterval-declarative-with-react-hooks/\",children:\"this post by Dan Abramov\"}),\" to learn more.\"]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"startGame\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This function is called at the start of a new round and a countdown timer is started. It starts an interval timer that runs every second, decrementing the \",(0,n.jsx)(e.code,{children:\"currTimeLeft\"}),\" by 1 every second until \",(0,n.jsx)(e.code,{children:\"currTimeLeft\"}),\" reaches 0.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that the timer should also be cleared upon unmounting, hence we can assign the timerId to a \",(0,n.jsx)(e.code,{children:\"countdownTimerId\"}),\" ref and clear it when the component unmounts. Otherwise the timer could be still running and attempting to update component state even when the component is no longer on-screen.\"]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"whackMole\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"This function removes indices from the \",(0,n.jsx)(e.code,{children:\"visible\"}),\" set when the correct cells are clicked, if they are present in the set, and increments the score by 1.\"]}),`\n`,(0,n.jsx)(p,{}),`\n`,(0,n.jsx)(g,{})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(y,t)})):y(t)}var I=A;return _(M);})();\n;return Component;"
}