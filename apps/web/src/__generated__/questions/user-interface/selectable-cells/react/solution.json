{
  "author": "TODO",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/selectable-cells-react-solution\",\n  \"author\": \"TODO\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.js": {
      "code": "import { useEffect, useRef, useState } from 'react';\n\nconst ROWS = 10;\nconst COLS = 10;\n\nfunction isOverlapping(rectA, rectB) {\n  return (\n    rectA.left < rectB.right &&\n    rectA.right > rectB.left &&\n    rectA.bottom > rectB.top &&\n    rectA.top < rectB.bottom\n  );\n}\n\nfunction drawSelectionBox(\n  cursor,\n  dragOrigin,\n  selectionBoxEl,\n) {\n  // Update selection box position.\n  selectionBoxEl.style.left =\n    Math.min(cursor.x, dragOrigin.x) + 'px';\n  selectionBoxEl.style.top =\n    Math.min(cursor.y, dragOrigin.y) + 'px';\n\n  const width = Math.abs(cursor.x - dragOrigin.x);\n  const height = Math.abs(cursor.y - dragOrigin.y);\n\n  // Update selection box size.\n  selectionBoxEl.style.width = `${width}px`;\n  selectionBoxEl.style.height = `${height}px`;\n}\n\nfunction findSelectedCells(gridEl, selectionBoxEl) {\n  const selectedCells = new Set();\n\n  const cells = gridEl.querySelectorAll('.grid__cell');\n\n  // Check if each cell overlaps with selection box.\n  for (let i = 0; i < cells.length; i++) {\n    if (\n      isOverlapping(\n        selectionBoxEl.getBoundingClientRect(),\n        cells[i].getBoundingClientRect(),\n      )\n    ) {\n      selectedCells.add(i);\n    }\n  }\n\n  return selectedCells;\n}\n\nexport default function App() {\n  const dragAreaRef = useRef();\n  const selectionBoxRef = useRef();\n\n  const [dragOrigin, setDragOrigin] = useState(null);\n  const [selectedCells, setSelectedCells] = useState(\n    new Set(),\n  );\n\n  useEffect(() => {\n    function onMouseDown(event) {\n      // Reset selected cells.\n      setSelectedCells(new Set());\n\n      // Use mouse coordinates relative to the entire page\n      // as the contents can be larger than the viewport.\n      const { pageX: x, pageY: y } = event;\n\n      // Store the drag origin so that they can be referenced\n      // during in the `mousemove` event.\n      setDragOrigin({ x, y });\n      // Start showing the selection box.\n      selectionBoxRef.current.style.display = 'inherit';\n    }\n\n    window.addEventListener('mousedown', onMouseDown);\n\n    return () => {\n      window.removeEventListener('mousedown', onMouseDown);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (dragOrigin == null) {\n      return;\n    }\n\n    function onMouseMove(event) {\n      const selectionBoxEl = selectionBoxRef.current;\n      drawSelectionBox(\n        {\n          x: event.pageX,\n          y: event.pageY,\n        },\n        dragOrigin,\n        selectionBoxEl,\n      );\n\n      const newSelectedCells = findSelectedCells(\n        dragAreaRef.current,\n        selectionBoxEl,\n      );\n      setSelectedCells(newSelectedCells);\n    }\n\n    window.addEventListener('mousemove', onMouseMove);\n\n    return () => {\n      window.removeEventListener('mousemove', onMouseMove);\n    };\n  }, [dragOrigin]);\n\n  useEffect(() => {\n    if (dragOrigin == null) {\n      return;\n    }\n\n    function onMouseUp() {\n      setDragOrigin(null);\n      // Reset selection box style.\n      selectionBoxRef.current.style = '';\n    }\n\n    window.addEventListener('mouseup', onMouseUp);\n\n    return () => {\n      window.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [dragOrigin]);\n\n  return (\n    <>\n      <div ref={dragAreaRef} className=\"draggable-area\">\n        <div ref={selectionBoxRef} className=\"select-box\" />\n        <div\n          className=\"grid\"\n          style={{\n            gridTemplateColumns: `repeat(${COLS}, 1fr)`,\n            gridTemplateRows: `repeat(${ROWS}, 1fr)`,\n          }}>\n          {Array.from(\n            { length: ROWS * COLS },\n            (_, index) => (\n              <div\n                className={[\n                  'grid__cell',\n                  selectedCells.has(index) &&\n                    'grid__cell--selected',\n                ]\n                  .filter(Boolean)\n                  .join(' ')}\n                key={index}\n              />\n            ),\n          )}\n        </div>\n      </div>\n    </>\n  );\n}\n"
    },
    "/src/index.js": {
      "code": "import React, { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n  margin: 0;\n}\n\n.draggable-area {\n  width: 100vw;\n  height: 100vh;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n}\n\n.select-box {\n  border: 1px dashed #000;\n  display: none;\n  position: absolute;\n}\n\n.grid {\n  --size: 400px;\n\n  width: var(--size);\n  height: var(--size);\n  flex-shrink: 0;\n  display: grid;\n  border: 1px solid #000;\n}\n\n.grid__cell {\n  border: 1px solid #000;\n}\n\n.grid__cell--selected {\n  background: #d6d5fe;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.js",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.js",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var y=Object.create;var d=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,M=Object.prototype.hasOwnProperty;var D=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),C=(t,e)=>{for(var r in e)d(t,r,{get:e[r],enumerable:!0})},g=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of T(e))!M.call(t,s)&&s!==r&&d(t,s,{get:()=>e[s],enumerable:!(a=j(e,s))||a.enumerable});return t};var c=(t,e,r)=>(r=t!=null?y(_(t)):{},g(e||!t||!t.__esModule?d(r,\"default\",{value:t,enumerable:!0}):r,t)),S=t=>g(d({},\"__esModule\",{value:!0}),t);var h=D((I,u)=>{u.exports=_jsx_runtime});var L={};C(L,{default:()=>X});var l=c(h());var n=c(h());function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",ol:\"ol\",li:\"li\",h3:\"h3\",ul:\"ul\",code:\"code\",a:\"a\",h4:\"h4\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The solution can be broken down into a few parts:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Rendering the grid.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Drawing a selection box.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Detect overlapping grid cells.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"State\"}),`\n`,(0,n.jsx)(e.p,{children:\"There are two state values we need for this question:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"selectedCells\"}),\": The collection of selected cells' indexes. We can use a \",(0,n.jsx)(e.code,{children:\"Set\"}),\" to store the indices.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"dragOrigin\"}),\": The x/y coordinates of the start of the drag event as an object. This value is initially \",(0,n.jsx)(e.code,{children:\"null\"}),\". When the selection box is drawn, this value is the x/y coordinates.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering the grid\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"CSS grid can be used to render a linear list of DOM elements in a 2-dimensional format with \",(0,n.jsx)(e.code,{children:\"grid-template-columns\"}),\" and \",(0,n.jsx)(e.code,{children:\"grid-template-rows\"}),\". The dimensions of the grid and cells aren't specified, so feel free to use a reasonable number that can accommodate 10 x 10 cells within the preview area.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Each cell is uniquely identified by a number, which is its index in an array. The first cell in the top row is 0, first cell in second row is 10, and so on. Each cell is rendered with a 1px border, so strictly speaking, visually there's a 2px-thick line between each cell. It's non-trivial to make it such that each cell only has a line 1px-thick between them, and that is less an an exercise for the reader. Hint: check out \",(0,n.jsxs)(e.a,{href:\"https://tailwindcss.com/docs/divide-width\",children:[\"Tailwind CSS's \",(0,n.jsx)(e.code,{children:\"divide\"}),\" class\"]}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"With the set of selected cells indices, we can render the cells with a purple background if the cell's index is within that set.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Drawing the selection box\"}),`\n`,(0,n.jsx)(e.p,{children:\"Drawing the selection box can be split into three stages:\"}),`\n`,(0,n.jsx)(e.h4,{children:\"1. Mousedown\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The cursor position that this point first happens is called the drag origin. The \",(0,n.jsx)(e.code,{children:\"'mousedown'\"}),\" event can be used to detect when this happens and the coordinates can be obtained and stored as the \",(0,n.jsx)(e.code,{children:\"dragOrigin\"}),\". When the drag starts, we can also add event listeners for the \",(0,n.jsx)(e.code,{children:\"mousemove\"}),\" and \",(0,n.jsx)(e.code,{children:\"mouseup\"}),\" event.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"2. Mousemove\"}),`\n`,(0,n.jsx)(e.p,{children:\"This even is repeatedly fired when the mouse moves and is only relevant when the mouse button is already pressed down. When this event is fired, we need to draw the selection box and update the selected cells set so that the UI displays selected cells differently.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The top left corner of a browser window is (0, 0) and \",(0,n.jsx)(e.code,{children:\"absolute\"}),\"-positioned elements use the top left corner as a reference point. To draw a selection box anywhere we want on the page, the box has to be using \",(0,n.jsx)(e.code,{children:\"position: absolute\"}),\" and is positioned relative to its closest positioned ancestor. Since the whole page to be draggable, so we can create a wrapper element (\",(0,n.jsx)(e.code,{children:\".draggable-area\"}),\") that is \",(0,n.jsx)(e.code,{children:\"position: relative\"}),\" and fills up the whole page with \",(0,n.jsx)(e.code,{children:\"width: 100vw; height: 100vh\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The upper corner (CSS \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"top\"}),\" values) of the selection box is determined by the smaller values of the drag origin and the current mouse position. The CSS \",(0,n.jsx)(e.code,{children:\"width\"}),\" and \",(0,n.jsx)(e.code,{children:\"height\"}),\" values can be determined by taking the absolute difference between their x-values and y-values. This is done in the \",(0,n.jsx)(e.code,{children:\"drawSelectionBox\"}),\" function.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"3. Mouseup\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"On the \",(0,n.jsx)(e.code,{children:\"mouseup\"}),\" event, reset the drag origin value and any styling on the selection box.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Do remember to cleanup any event listeners added when the component/page unmounts.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Detect overlapping grid cells\"}),`\n`,(0,n.jsx)(e.p,{children:\"While drawing the selection box, there's another thing to do, which is to detect which grid cells are overlapping/intersecting with the selection box, so that their indices can be added to the selected cells set.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can use the \",(0,n.jsx)(e.code,{children:\"getBoundingClientRect()\"}),\" method on DOM elements to get the positions of the selection box and the grid cells and then determine if the selection box overlaps with a grid cell by checking the following conditions:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The left edge of the selection box is smaller than the right edge of the grid cell.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The right edge of the selection box is larger the right edge of the grid cell.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The top edge of the selection box is smaller than the bottom edge of the grid cell.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The bottom edge of the selection box is larger than the top edge of the grid cell.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If all of these conditions are true, then the selection box overlaps with the grid cell. This is a \",(0,n.jsx)(e.a,{href:\"https://silentmatt.com/rectangle-intersection/\",children:\"great visualization\"}),\" to demonstrate rectangle intersection.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"When a cell and a selection box overlap, add that cell's index to the set of selected cells.\"})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var m=O;var o=c(h());function w(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\"},t.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsxs)(e.li,{children:[\"Besides the \",(0,o.jsx)(e.code,{children:\"mouseup\"}),\" event, users will also expect other events like \",(0,o.jsx)(e.code,{children:\"contextmenu\"}),\", \",(0,o.jsx)(e.code,{children:\"mouseleave\"}),\", \",(0,o.jsx)(e.code,{children:\"touchend\"}),\" to end the dragging. However in an interview setting, these events are probably acceptable to omit.\"]}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,o.jsx)(e,Object.assign({},t,{children:(0,o.jsx)(w,t)})):w(t)}var b=k;var i=c(h());function f(t){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"A 10 x 10 grid is rendered.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Draw a selection box\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"A box is being drawn on mouse down and the box's position and dimensions follow the drag origin and the mouse's current position.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Move the cursor around the drag origin, the box should render correctly.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Upon releasing the mouse, the selection box disappears.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Start drawing from various positions on the page: outside the grid, within the grid, etc.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Select cells in the grid\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"While drawing the box over the grid, any overlapping cells should be highlighted.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Clicking anywhere on the screen causes the highlighted cells to no longer be highlighted.\"}),`\n`]}),`\n`]}),`\n`]})]})}function W(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(f,t)})):f(t)}var x=W;function v(t){return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(m,{}),`\n`,(0,l.jsx)(x,{}),`\n`,(0,l.jsx)(b,{})]})}function F(t={}){let{wrapper:e}=t.components||{};return e?(0,l.jsx)(e,Object.assign({},t,{children:(0,l.jsx)(v,t)})):v(t)}var X=F;return S(L);})();\n;return Component;"
}