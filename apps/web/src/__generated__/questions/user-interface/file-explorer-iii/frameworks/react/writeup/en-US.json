{
  "skeleton": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},d=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of x(e))!y.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(l=g(e,r))||l.enumerable});return t};var h=(t,e,i)=>(i=t!=null?m(b(t)):{},d(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),j=t=>d(o({},\"__esModule\",{value:!0}),t);var a=v((E,c)=>{c.exports=_jsx_runtime});var q={};w(q,{default:()=>_});var s=h(a());var n=h(a());function u(t){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",pre:\"pre\",code:\"code\",h2:\"h2\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note:\"}),\" This is a follow up to the \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/file-explorer\",children:\"File Explorer\"}),\" question, you should complete that question first before attempting this question.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/file-explorer\",children:\"File Explorer\"}),\", we built a functional file explorer component that displays an array of file objects in a hierarchical tree format using a nested DOM structure.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The other possible structure is having a single flat list of items and add the right amount of padding for descendant items. While recursing, the current level will need to be passed as an argument so that the descendant items know what how much padding to render.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-html\",children:`<!-- The bullets will have to be hidden as \n they will still be flushed to the left. -->\n<ul>\n  <li>docs</li>\n  <li style=\"padding-left: 16px\">foo.md</li>\n  <li style=\"padding-left: 16px\">bar.md</li>\n  <li>README.md</li>\n</ul>\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"A single flat list of DOM elements is easier to traverse. Also, this flat approach provides the most control over the rendering and allows for virtualized items in large directories that contain many files. Virtualization is not easy to achieve using a nested structure because in order for items to be indented by the right amount, their parents have to be rendered as well \\u2013 a nested structure makes it hard or even impossible to render only the minimal items that need to be displayed.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This flat approach is used by \",(0,n.jsx)(e.a,{href:\"https://github.dev/yangshun/top-javascript-interview-questions/\",children:\"VS Code\"}),\" because of the need to handle large amount of files. In fact, VS Code uses \",(0,n.jsx)(e.code,{children:\"position: absolute; left: Xpx; top: Ypx;\"}),\" for positioning and it only renders the visible file items.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,n.jsx)(e.p,{children:\"Modify the nested structure of the file explorer to a flat structure while retaining the same visual appearance.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The skeleton code uses the solution of \",(0,n.jsx)(e.a,{href:\"/questions/user-interface/file-explorer\",children:\"File Explorer\"}),\", but you are free to use your own solution as a starting point.\"]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var p=M;function f(t){return(0,s.jsx)(p,{})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,s.jsx)(e,Object.assign({},t,{children:(0,s.jsx)(f,t)})):f(t)}var _=D;return j(q);})();\n;return Component;",
  "solution": "var Component=(()=>{var g=Object.create;var s=Object.defineProperty;var j=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var _=Object.getPrototypeOf,M=Object.prototype.hasOwnProperty;var F=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),D=(e,n)=>{for(var l in n)s(e,l,{get:n[l],enumerable:!0})},p=(e,n,l,c)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of y(n))!M.call(e,r)&&r!==l&&s(e,r,{get:()=>n[r],enumerable:!(c=j(n,r))||c.enumerable});return e};var d=(e,n,l)=>(l=e!=null?g(_(e)):{},p(n||!e||!e.__esModule?s(l,\"default\",{value:e,enumerable:!0}):l,e)),w=e=>p(s({},\"__esModule\",{value:!0}),e);var a=F((v,u)=>{u.exports=_jsx_runtime});var E={};D(E,{default:()=>X});var i=d(a());var o=d(a());function h(e){let n=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\"},e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h2,{children:\"Test cases\"}),`\n`,(0,o.jsxs)(n.p,{children:[\"The resulting DOM should be similar to the following. Notice that there's a single \",(0,o.jsx)(n.code,{children:\"<ul>\"}),\" with a flat layer of \",(0,o.jsx)(n.code,{children:\"<li>\"}),\".\"]}),`\n`,(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:\"language-html\",children:`<ul>\n  <li style=\"padding-left: 0px;\">\n    <button><span>Documents</span> [-]</button>\n  </li>\n  <li style=\"padding-left: 16px;\">\n    <button>\n      <span>Powerpoint.ppt</span>\n    </button>\n  </li>\n  <li style=\"padding-left: 16px;\">\n    <button>\n      <span>Word.doc</span>\n    </button>\n  </li>\n  <li style=\"padding-left: 0px;\">\n    <button><span>Downloads</span> [-]</button>\n  </li>\n  <li style=\"padding-left: 16px;\">\n    <button><span>Misc</span> [-]</button>\n  </li>\n  <li style=\"padding-left: 32px;\">\n    <button>\n      <span>bar.txt</span>\n    </button>\n  </li>\n  <li style=\"padding-left: 32px;\">\n    <button>\n      <span>foo.txt</span>\n    </button>\n  </li>\n  <li style=\"padding-left: 16px;\">\n    <button>\n      <span>unnamed.txt</span>\n    </button>\n  </li>\n  <li style=\"padding-left: 0px;\">\n    <button>\n      <span>README.md</span>\n    </button>\n  </li>\n</ul>\n`})})]})}function C(e={}){let{wrapper:n}=e.components||{};return n?(0,o.jsx)(n,Object.assign({},e,{children:(0,o.jsx)(h,e)})):h(e)}var f=C;var t=d(a());function m(e){let n=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",h3:\"h3\",code:\"code\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(n.p,{children:[\"We'll build on top of \",(0,t.jsx)(n.a,{href:\"/questions/user-interface/file-explorer/react/solution\",children:\"File Explorer's solution\"}),\".\"]}),`\n`,(0,t.jsx)(n.h3,{children:\"Returning fragments\"}),`\n`,(0,t.jsxs)(n.p,{children:[\"The main change is to return fragments instead of \",(0,t.jsx)(n.code,{children:\"<ul>\"}),\". The root \",(0,t.jsx)(n.code,{children:\"<ul>\"}),\" is rendered by the \",(0,t.jsx)(n.code,{children:\"FileExplorer\"}),\" component and \",(0,t.jsx)(n.code,{children:\"FileObject\"}),\" and \",(0,t.jsx)(n.code,{children:\"FileList\"}),\" should return fragments and rendered as direct children of the \",(0,t.jsx)(n.code,{children:\"<ul>\"}),\" in \",(0,t.jsx)(n.code,{children:\"FileExplorer\"}),\".\"]}),`\n`,(0,t.jsx)(n.h3,{children:\"Rendering indentation\"}),`\n`,(0,t.jsxs)(n.p,{children:[\"The amount of left padding to use for each indentation level can be determined by the \",(0,t.jsx)(n.code,{children:\"level\"}),\" prop \\u2013 multiply the level (subtract one first) by the indentation width.\"]})]})}function O(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(m,e)})):m(e)}var x=O;function b(e){return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(x,{}),`\n`,(0,i.jsx)(f,{})]})}function T(e={}){let{wrapper:n}=e.components||{};return n?(0,i.jsx)(n,Object.assign({},e,{children:(0,i.jsx)(b,e)})):b(e)}var X=T;return w(E);})();\n;return Component;"
}