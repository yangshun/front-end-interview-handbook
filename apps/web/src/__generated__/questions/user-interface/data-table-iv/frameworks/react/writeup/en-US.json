{
  "skeleton": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),T=(n,e)=>{for(var i in e)o(n,i,{get:e[i],enumerable:!0})},c=(n,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of b(e))!w.call(n,a)&&a!==i&&o(n,a,{get:()=>e[a],enumerable:!(l=g(e,a))||l.enumerable});return n};var d=(n,e,i)=>(i=n!=null?m(x(n)):{},c(e||!n||!n.__esModule?o(i,\"default\",{value:n,enumerable:!0}):i,n)),I=n=>c(o({},\"__esModule\",{value:!0}),n);var s=y((M,h)=>{h.exports=_jsx_runtime});var _={};T(_,{default:()=>v});var r=d(s());var t=d(s());function u(n){let e=Object.assign({p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Note:\"}),\" This is a follow up to the \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/data-table-iii\",children:\"Data Table III\"}),\" question, you should complete that question first before attempting this question.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/data-table-iii\",children:\"Data Table III\"}),\", we built a generalized data table that displays rows in a paginated format and allows for sorting rows by specific columns in both ascending and descending order. The \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\" component is not coupled to the data and can be used to render any type of data.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Extend the \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\" component to allow per-column filtering functionality.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Requirements\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Each column can be configured to have a filter input within the header cell\"}),`\n`,(0,t.jsx)(e.li,{children:\"The filter input filters rows that match the value of the input\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Supported types of filters:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Text search\"}),\": For string fields. Match data based on case-insensitive string comparisons\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Range search\"}),\": For numerical fields. To keep things simple, use two text fields, indicating the min/max values. Match if the value lies between the provided min/max value\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"If any filter inputs are empty or invalid, they should be ignored\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Only rows that pass \",(0,t.jsx)(e.strong,{children:\"all\"}),\" the filter criteria present should remain\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"To assist in your testing, another table has been rendered using houses data (\",(0,t.jsx)(e.code,{children:\"src/data/houses.json\"}),\"). Feel free to comment out any code while working on the question. You should test your final solution with both datasets to ensure that the component remains generalized and flexible.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Hint\"}),\": Have a look at this \",(0,t.jsx)(e.a,{href:\"https://tanstack.com/table/latest/docs/framework/react/examples/filters\",children:\"TanStack Table Column Filters example\"}),\" if you need inspiration on designing an API for adding filters.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The skeleton code uses the solution of \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/data-table-iii\",children:\"Data Table III\"}),\", but you are free to use your own solution as a starting point.\"]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var f=j;function p(n){return(0,r.jsx)(f,{})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(p,n)})):p(n)}var v=D;return I(_);})();\n;return Component;",
  "solution": "var Component=(()=>{var w=Object.create;var o=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var k=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),j=(n,e)=>{for(var l in e)o(n,l,{get:e[l],enumerable:!0})},d=(n,e,l,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of v(e))!T.call(n,a)&&a!==l&&o(n,a,{get:()=>e[a],enumerable:!(s=x(e,a))||s.enumerable});return n};var c=(n,e,l)=>(l=n!=null?w(y(n)):{},d(e||!n||!n.__esModule?o(l,\"default\",{value:n,enumerable:!0}):l,n)),D=n=>d(o({},\"__esModule\",{value:!0}),n);var h=k((z,u)=>{u.exports=_jsx_runtime});var A={};j(A,{default:()=>M});var r=c(h());var t=c(h());function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",code:\"code\",ol:\"ol\",li:\"li\",h3:\"h3\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We'll build on top of \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/data-table-iii/solution\",children:\"Data Table III's solution\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In \",(0,t.jsx)(e.a,{href:\"/questions/user-interface/data-table-iii/solution\",children:\"Data Table III\"}),\", the \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\" implementation was generalized and no longer contains any code that is specific to users data. We need to preserve this generalization when extending the component with filtering functionality.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"There are a few things that need to be done:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Add column-specific filter input UI in the header cell\"}),`\n`,(0,t.jsx)(e.li,{children:\"Store the filter input state\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Allow the \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\" component to read the filter inputs state and use it when filtering data. Filtering has to be done before sorting and pagination occurs.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"There are a few ways to design the new fields to be added to the column definitions to enable filtering:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Simple configuration, but not as flexible\"}),`\n`,(0,t.jsx)(e.li,{children:\"More configuration needed, but more flexible\"}),`\n`,(0,t.jsx)(e.li,{children:\"Provide default configuration but also allow flexibility\"}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"1. Simple configuration, but not as flexible\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This method involves adding a \",(0,t.jsx)(e.code,{children:\"filterType\"}),\" string property to the column definitions that is either \",(0,t.jsx)(e.code,{children:\"string\"}),\" or \",(0,t.jsx)(e.code,{children:\"range\"}),\". That is all that is needed from an external API perspective. The complexity will be within the \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\" component \\u2013 it has to render the various filters inputs and use them when processing the data for presentation.\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The header cells are rendered by iterating over the column definitions. The addition here is to render the appropriate filter input depending on the \",(0,t.jsx)(e.code,{children:\"filterType\"}),\" value.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"When the filter input value changes, store the filter values as state within the \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\" component in an object called \",(0,t.jsx)(e.code,{children:\"filters\"}),\". The key of the \",(0,t.jsx)(e.code,{children:\"filters\"}),\" object is a unique identifier of the column (we can use the \",(0,t.jsx)(e.code,{children:\"key\"}),\" field of the column) and the value is filter data associated with that column's filter input. Each filter type has its own format:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"string\"}),\": Stores a single value representing the string to filter: \",(0,t.jsx)(e.code,{children:\"{ type: 'string'; value: string | null; }\"})]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"range\"}),\": Store two numeric values, the max and min value of the range: \",(0,t.jsx)(e.code,{children:\"{ type: 'range'; max?: number | null; min?: number | null; }\"})]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Create a \",(0,t.jsx)(e.code,{children:\"filterData\"}),\" function that takes in the data and filters state. For each row of data, iterate through the \",(0,t.jsx)(e.code,{children:\"filters\"}),\" object and only keep the rows that \",(0,t.jsx)(e.strong,{children:\"pass all the filter checks\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This approach is very easy to use as the API surface is small, but notice that there's more code baked into \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\":\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"We're rendering the same filter input UI depending on \",(0,t.jsx)(e.code,{children:\"filterType\"}),\"; the filter inputs cannot be customized. Customization is sometimes useful, e.g. if the placeholder has to be customized, or using your own input UI components.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The filtering logic is also contained within \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\", which is a case-insensitive substring match for strings, and a range match for numbers. The filtering logic cannot be customized.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"The solution uses this approach, and it is probably robust enough for interviews. Next, we can look at an alternative approach that is more flexible, but requires more configuration.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"2. More configuration needed, but more flexible\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This method involves adding a few function fields to the column definition that contains filtering logic. The \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\" component will call these function when rendering the filter inputs and filtering the matching rows. The filter value state can be the same as per approach 1 \\u2013 \",(0,t.jsx)(e.code,{children:\"filters\"}),\" object with keys as column \",(0,t.jsx)(e.code,{children:\"key\"}),\"s and value as the column-specific filter data.\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"renderFilter(filterValue, setFilterValue)\"}),\": A function that renders the filter input. It takes in the current \",(0,t.jsx)(e.code,{children:\"filterValue\"}),\" and a \",(0,t.jsx)(e.code,{children:\"setFilterValue\"}),\" function. The function should return UI that displays the \",(0,t.jsx)(e.code,{children:\"filterValue\"}),\" and responds to user inputs by calling \",(0,t.jsx)(e.code,{children:\"setFilterValue\"}),\", which will persist the filter state for that column within \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"matchesFilter(value, filterValue)\"}),\": A function that determines if the value matches the filter. It takes in the column's value for the row and the \",(0,t.jsx)(e.code,{children:\"filterValue\"}),\" and the developer is left to implement their own matching logic.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"With this approach, maximum flexibility is given \\u2013 the developer is given full control over the rendering and the matching logic. However, there can be quite a bit of repetition if a similar matching logic is used for all string-based fields. This approach is similar to the \",(0,t.jsx)(e.code,{children:\"comparator\"}),\" function used for sorting.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"3. Default configuration, with flexibility\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"A hybrid solution is to allow for both simple and advanced configuration options. For each column, if the \",(0,t.jsx)(e.code,{children:\"renderFilter\"}),\" and/or \",(0,t.jsx)(e.code,{children:\"matchesFilter\"}),\" field is defined, invoke them for rendering/filtering, otherwise use the default as per the simple approach.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"If you're interested, modify the solution to use this hybrid approach.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Follow up\"}),`\n`,(0,t.jsx)(e.p,{children:\"Now that we have a generalized data table that supports paginating, sorting, and filtering. The next logical extension is to fetch the data from a remote API.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"When fetching data from a remote API, the server will be in-charge of doing the paginating, sorting, filtering, so the \",(0,t.jsx)(e.code,{children:\"DataTable\"}),\" component does not need to include these processing logic anymore. The only thing the component needs to do is to collect user input (current page, page size, sorting field, sorting direction, filters state), call the API with these options, then present the results.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Have a look at \",(0,t.jsx)(e.a,{href:\"https://tanstack.com/table/\",children:\"TanStack Table\"}),\" to get a sense of what features goes into production-ready data table libraries and how complex data tables can be.\"]})]})}function I(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var p=I;var i=c(h());function g(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Filtering\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Text inputs\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Enter some strings in lower case, check that results match the search string\"}),`\n`,(0,i.jsx)(e.li,{children:\"Delete the entered values, check that the full results are displayed again\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Range inputs\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Enter only a min value, check that the results are all larger\"}),`\n`,(0,i.jsx)(e.li,{children:\"Enter only a max value, check that the results are all smaller\"}),`\n`,(0,i.jsx)(e.li,{children:\"Enter both min and max values, check that the results are within the min/max boundaries\"}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.li,{children:\"Ensure that all the existing features (pagination and sorting) still work as usual, with and without filters\"}),`\n`,(0,i.jsx)(e.li,{children:\"Test with housing data and check that the table can be rendered, pagination, sorting, and filtering functionality works correctly\"}),`\n`]})]})}function F(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(g,n)})):g(n)}var m=F;function b(n){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(p,{}),`\n`,(0,r.jsx)(m,{})]})}function _(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(b,n)})):b(n)}var M=_;return D(A);})();\n;return Component;"
}