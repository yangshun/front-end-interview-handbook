{
  "skeleton": "var Component=(()=>{var f=Object.create;var s=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var j=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},a=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of x(e))!b.call(t,o)&&o!==i&&s(t,o,{get:()=>e[o],enumerable:!(c=g(e,o))||c.enumerable});return t};var d=(t,e,i)=>(i=t!=null?f(y(t)):{},a(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),_=t=>a(s({},\"__esModule\",{value:!0}),t);var l=j((v,u)=>{u.exports=_jsx_runtime});var D={};w(D,{default:()=>M});var r=d(l());var n=d(l());function h(t){let e=Object.assign({p:\"p\",ol:\"ol\",li:\"li\",ul:\"ul\",code:\"code\",h2:\"h2\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"You're given some existing HTML for a Todo List app. Add the following functionality to the app:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:['Add new tasks on clicking the \"Submit\" button.',`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"<input>\"}),\" field should be cleared upon successful addition.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:'Remove tasks from the Todo List upon clicking the \"Delete\" button.'}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The focus of this question is on functionality, not the styling. There's no need to write any custom CSS.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"You may modify the markup (e.g. adding \",(0,n.jsx)(e.code,{children:\"id\"}),\"s, data attributes, replacing some tags, etc), but the result should remain the same visually.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"You may want to think about ways to improve the user experience of the application and implement them (you get bonus credit for doing that during interviews).\"}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var m=k;function p(t){return(0,r.jsx)(m,{})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(p,t)})):p(t)}var M=T;return _(D);})();\n;return Component;",
  "solution": "var Component=(()=>{var p=Object.create;var d=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),_=(n,e)=>{for(var s in e)d(n,s,{get:e[s],enumerable:!0})},h=(n,e,s,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of y(e))!j.call(n,o)&&o!==s&&d(n,o,{get:()=>e[o],enumerable:!(l=w(e,o))||l.enumerable});return n};var c=(n,e,s)=>(s=n!=null?p(x(n)):{},h(e||!n||!n.__esModule?d(s,\"default\",{value:n,enumerable:!0}):s,n)),A=n=>h(d({},\"__esModule\",{value:!0}),n);var r=v((F,u)=>{u.exports=_jsx_runtime});var C={};_(C,{default:()=>T});var t=c(r());var i=c(r());function m(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Add tasks\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Add a new task.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Add multiple tasks.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Add tasks with potentially malicious content like HTML (e.g. \",(0,i.jsx)(e.code,{children:\"<script>\"}),\", \",(0,i.jsx)(e.code,{children:\"<style>\"}),\" or \",(0,i.jsx)(e.code,{children:\"<link\"}),\">) and ensure there's no XSS.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Check that \",(0,i.jsx)(e.code,{children:\"<input>\"}),\" is cleared after a task is added.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Delete tasks\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Delete an existing task.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Delete multiple tasks.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Delete newly-added tasks.\"}),`\n`]}),`\n`]}),`\n`]})]})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(m,n)})):m(n)}var g=D;var a=c(r());function k(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",a:\"a\"},n.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,a.jsxs)(e.ul,{children:[`\n`,(0,a.jsxs)(e.li,{children:[\"All form \",(0,a.jsx)(e.code,{children:\"<input>\"}),\"s should be labelled either via \",(0,a.jsx)(e.code,{children:\"<label>\"}),\"s or \",(0,a.jsx)(e.code,{children:\"aria-label\"}),\" attributes. Since the original markup doesn't contain a \",(0,a.jsx)(e.code,{children:\"<label>\"}),\", we can add \",(0,a.jsx)(e.code,{children:\"aria-label\"}),\" to the \",(0,a.jsx)(e.code,{children:\"<input>\"}),\".\"]}),`\n`,(0,a.jsxs)(e.li,{children:[\"For screen reader users, they won't be aware that a new task has been added. An \",(0,a.jsx)(e.code,{children:\"aria-live\"}),\" region can be added to inform about the newly-added task. There is unlikely enough time to do this during an interview but you will get bonus points for mentioning it. Read more about \",(0,a.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions\",children:\"ARIA live regions on MDN\"}),\".\"]}),`\n`]})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,a.jsx)(e,Object.assign({},n,{children:(0,a.jsx)(k,n)})):k(n)}var b=M;function f(n){let e=Object.assign({h2:\"h2\",h3:\"h3\",p:\"p\",code:\"code\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.h3,{children:\"State\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"We will need two state variables: \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" and \",(0,t.jsx)(e.code,{children:\"newTask\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"tasks\"}),\": Since there's a list of tasks that can be modified, we will need it to be part of the component's state. If you are going to re-order the list of tasks, we need to specify a key for each item. This allow Svelte to track the reordering of the items, and reorder the DOM elements accordingly instead of update the DOM elements blindly. We cannot use the text of the task as the key because they are not guaranteed to be unique. Usually, the most foolproof method is to generate a unique ID for each task. Libraries like \",(0,t.jsx)(e.a,{href:\"https://github.com/uuidjs/uuid\",children:(0,t.jsx)(e.code,{children:\"uuid\"})}),\" come to mind, but in this case, a simple incrementing counter will do. Since we want \",(0,t.jsx)(e.code,{children:\"id\"}),\"s to be globally unique, it is initialized in the module script, outside of the component script.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"newTask\"}),\": this is the state to represent the text in our input field for creating a new task. When the user click on the submit button, we will be using the value of this state variables to add a new task in the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" array.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Adding tasks\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"New tasks should be added to the end of the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" array. We can construct a new task object based on the value of the \",(0,t.jsx)(e.code,{children:\"newTask\"}),\" value. To update the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" array, we can either modify the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" array directly or create a new array and assigned it to the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" variable. Since Svelte tracks changes through assignment statements, if we call \",(0,t.jsx)(e.code,{children:\"tasks.push()\"}),\" to modify the array directly, we need to add another assignment to hint Svelte that the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" variable has changed. This could be as simple as assigning \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" to itself, \",(0,t.jsx)(e.code,{children:\"tasks = tasks\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"After adding a new task using \",(0,t.jsx)(e.code,{children:\"newTask\"}),\" value, we should clear the input for the next task by setting \",(0,t.jsx)(e.code,{children:\"newTask\"}),\" to empty string \",(0,t.jsx)(e.code,{children:\"''\"}),\".\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Deleting tasks\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Having a unique \",(0,t.jsx)(e.code,{children:\"id\"}),\" for each task object simplifies things here because we can find through the existing list and remove the task corresponding to the \",(0,t.jsx)(e.code,{children:\"id\"}),\" to be removed. Upon finding the index of the task object to be removed, you can use \",(0,t.jsx)(e.code,{children:\"Array.prototype.splice\"}),\" to remove elements at that index.\"]}),`\n`,(0,t.jsx)(b,{}),`\n`,(0,t.jsx)(g,{})]})}function S(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var T=S;return A(C);})();\n;return Component;"
}