{
  "author": "yangshun",
  "files": {
    "/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div class=\"wrapper\">\n      <div id=\"stopwatch\"></div>\n    </div>\n    <script src=\"src/index.js\"></script>\n  </body>\n</html>\n"
    },
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/stopwatch-vanilla-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"devDependencies\": {\n    \"parcel\": \"2.9.3\"\n  },\n  \"source\": \"index.html\",\n  \"scripts\": {\n    \"start\": \"parcel\",\n    \"build\": \"parcel build\"\n  }\n}\n"
    },
    "/src/index.js": {
      "code": "import './styles.css';\n\n(() => {\n  const MS_IN_SECOND = 1000;\n  const SECONDS_IN_MINUTE = 60;\n  const MINUTES_IN_HOUR = 60;\n  const MS_IN_HOUR =\n    MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MS_IN_SECOND;\n  const MS_IN_MINUTE = SECONDS_IN_MINUTE * MS_IN_SECOND;\n\n  function formatTime(timeParam) {\n    let time = timeParam;\n    const parts = {\n      hours: 0,\n      minutes: 0,\n      seconds: 0,\n      ms: 0,\n    };\n    if (time > MS_IN_HOUR) {\n      parts.hours = Math.floor(time / MS_IN_HOUR);\n      time %= MS_IN_HOUR;\n    }\n\n    if (time > MS_IN_MINUTE) {\n      parts.minutes = Math.floor(time / MS_IN_MINUTE);\n      time %= MS_IN_MINUTE;\n    }\n\n    if (time > MS_IN_SECOND) {\n      parts.seconds = Math.floor(time / MS_IN_SECOND);\n      time %= MS_IN_SECOND;\n    }\n\n    parts.ms = time;\n    return parts;\n  }\n\n  function padTwoDigit(number) {\n    return number >= 10 ? String(number) : `0${number}`;\n  }\n\n  function timeSegment(value, unit, isSmall = false) {\n    const $containerEl = document.createElement('span');\n\n    const $digitEl = document.createElement('span');\n    $digitEl.classList.add('time-number');\n    $digitEl.textContent = value;\n    if (isSmall) {\n      $digitEl.classList.add('time-number--small');\n    }\n    $containerEl.append($digitEl);\n\n    if (unit != null) {\n      const $unitEl = document.createElement('span');\n      $unitEl.classList.add('time-unit');\n      $unitEl.textContent = unit;\n      $containerEl.append($unitEl);\n    }\n\n    return $containerEl;\n  }\n\n  function stopwatch($rootEl) {\n    // Timer ID of the active interval, if one is running.\n    let timerId = null;\n    let lastTickTiming = null;\n    let totalDuration = 0;\n    const $DOM = {\n      container: document.createElement('div'),\n      timeDisplay: document.createElement('button'),\n      timeInner: document.createElement('div'),\n      startStopButton: document.createElement('button'),\n      resetButton: document.createElement('button'),\n    };\n\n    function updateTime() {\n      $DOM.timeInner.innerHTML = '';\n      const formattedTime = formatTime(totalDuration);\n      if (formattedTime.hours > 0) {\n        $DOM.timeInner.append(\n          timeSegment(formattedTime.hours, 'h'),\n        );\n      }\n\n      if (formattedTime.minutes > 0) {\n        $DOM.timeInner.append(\n          timeSegment(formattedTime.minutes, 'm'),\n        );\n      }\n\n      $DOM.timeInner.append(\n        timeSegment(formattedTime.seconds, 's'),\n      );\n\n      $DOM.timeInner.append(\n        timeSegment(\n          padTwoDigit(Math.floor(formattedTime.ms / 10)),\n          null,\n          true,\n        ),\n      );\n    }\n\n    function tick() {\n      const now = Date.now();\n      const timePassed = now - lastTickTiming;\n      totalDuration += timePassed;\n      lastTickTiming = now;\n      updateTime();\n    }\n\n    function startTimer() {\n      lastTickTiming = Date.now();\n      timerId = window.setInterval(() => {\n        tick();\n      }, 1);\n      $DOM.startStopButton.textContent = 'Stop';\n    }\n\n    function stopInterval() {\n      window.clearInterval(timerId);\n      timerId = null;\n      $DOM.startStopButton.textContent = 'Start';\n    }\n\n    function resetTimer() {\n      stopInterval();\n      totalDuration = 0;\n      updateTime();\n    }\n\n    function toggleTimer() {\n      if (timerId != null) {\n        stopInterval();\n      } else {\n        startTimer();\n      }\n    }\n\n    function init() {\n      $DOM.timeDisplay.classList.add('time');\n      $DOM.timeDisplay.addEventListener('click', () => {\n        toggleTimer();\n      });\n      const $cover = document.createElement('span');\n      $cover.classList.add('time-cover');\n      $DOM.timeDisplay.append($cover);\n\n      $DOM.timeInner.classList.add('time-inner');\n      $DOM.timeDisplay.append($DOM.timeInner);\n\n      $DOM.container.append($DOM.timeDisplay);\n\n      const $buttonContainerEl =\n        document.createElement('div');\n\n      $DOM.startStopButton.addEventListener('click', () => {\n        toggleTimer();\n      });\n      $DOM.startStopButton.textContent = 'Start';\n\n      $DOM.resetButton.addEventListener('click', () => {\n        resetTimer();\n      });\n      $DOM.resetButton.textContent = 'Reset';\n\n      $buttonContainerEl.append(\n        $DOM.startStopButton,\n        $DOM.resetButton,\n      );\n      $DOM.container.append($buttonContainerEl);\n\n      updateTime();\n    }\n\n    // The beforeunload event is fired before the tab/window is closed.\n    // Clear the timer when the tab/window is about to be closed.\n    window.addEventListener('beforeunload', () => {\n      window.clearInterval(timerId);\n    });\n\n    init();\n    $rootEl.append($DOM.container);\n  }\n\n  stopwatch(document.getElementById('stopwatch'));\n})();\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\n.wrapper {\n  align-items: center;\n  display: flex;\n}\n\n.time {\n  background-color: transparent;\n  border: none;\n  cursor: pointer;\n  position: relative;\n  user-select: none;\n}\n\n.time-cover {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n}\n\n.time-inner {\n  align-items: baseline;\n  display: flex;\n  gap: 16px;\n}\n\n.time-unit {\n  font-size: 24px;\n}\n\n.time-number {\n  font-size: 62px;\n}\n\n.time-number--small {\n  font-size: 36px;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/index.html",
      "/src/index.js",
      "/src/styles.css"
    ],
    "activeFile": "/src/index.html",
    "environment": "parcel"
  },
  "writeup": "var Component=(()=>{var w=Object.create;var a=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var T=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),S=(n,e)=>{for(var o in e)a(n,o,{get:e[o],enumerable:!0})},d=(n,e,o,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of y(e))!k.call(n,l)&&l!==o&&a(n,l,{get:()=>e[l],enumerable:!(h=v(e,l))||h.enumerable});return n};var s=(n,e,o)=>(o=n!=null?w(T(n)):{},d(e||!n||!n.__esModule?a(o,\"default\",{value:n,enumerable:!0}):o,n)),_=n=>d(a({},\"__esModule\",{value:!0}),n);var c=x((F,u)=>{u.exports=_jsx_runtime});var M={};S(M,{default:()=>C});var t=s(c());var i=s(c());function m(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Start\" button to start the timer. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time increases constantly and shows the correct value.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Start\" button now shows \"Stop\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click \"Stop\" while the timer is running. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time stops increasing.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Stop\" button now shows \"start\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Start\" button after having stopped the timer. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time increases from the stopped timing and shows the correct value.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Start\" button now shows \"Stop\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Reset\" button while:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The timer is running. The timer should stop and be reset to 0.\"}),`\n`,(0,i.jsx)(e.li,{children:\"The timer is stopped/paused. The timer should be reset to 0.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.li,{children:'Repeat the above but click on the time instead of the \"Start\"/\"Stop\" button.'}),`\n`,(0,i.jsxs)(e.li,{children:[\"a11y\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Use \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" to cycle through the buttons.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Be able to use both \",(0,i.jsx)(\"kbd\",{children:\"Spacebar\"}),\" and \",(0,i.jsx)(\"kbd\",{children:\"Enter\"}),\" to interact with the 3 interactive elements.\"]}),`\n`]}),`\n`]}),`\n`]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(m,n)})):m(n)}var p=j;var r=s(c());function b(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"People who are unfamiliar with a11y will add an \",(0,r.jsx)(e.code,{children:\"onClick\"}),\"/\",(0,r.jsx)(e.code,{children:\"'click'\"}),\" event to the DOM element rendering the time (usually a \",(0,r.jsx)(e.code,{children:\"<div>\"}),\") and consider it complete. However, this the timer is not a11y-friendly just by doing so. Some might add \",(0,r.jsx)(e.code,{children:'tabIndex=\"0\"'}),\" (to allow focus) and \",(0,r.jsx)(e.code,{children:'role=\"button\"'}),\" to the element, which certainly improves the a11y, but is not the best.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"For the best a11y, we can and should use a \",(0,r.jsx)(e.code,{children:\"<button>\"}),\" to render the timing, which comes with additional a11y benefits like focus and keyboard support. By using a \",(0,r.jsx)(e.code,{children:\"<button>\"}),\", you get automatic focus support (be able to use \",(0,r.jsx)(\"kbd\",{children:\"Tab\"}),\" to focus onto the timer) and keyboard support (hit the \",(0,r.jsx)(\"kbd\",{children:\"Spacebar\"}),\" to start/stop the timer). The latter will not be possible without custom code to add key event listeners to non-interactive elements.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"User Experience\"}),`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:\"user-select: none\"}),\" is added to the timer so that the digits aren't selected if a user double clicks on them. Selecting the digits is usually not desired.\"]})]})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(b,n)})):b(n)}var g=D;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",a:\"a\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This question looks simple on first glance but is actually more complex than it seems. Note that \",(0,t.jsx)(e.code,{children:\"setInterval\"}),\"'s \",(0,t.jsx)(e.code,{children:\"delay\"}),\" parameter is unreliable. The actual amount of time that elapses between calls to the callback may be \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#reasons_for_delays_longer_than_specified\",children:\"longer than the given delay due to various reasons\"}),\". Because of this behavior, we cannot assume that each time the interval callback is fired, the same duration as passed. We will need to read the current time within the callback code to ensure that we are using the most updated timings.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"State\"}),`\n`,(0,t.jsx)(e.p,{children:\"The tricky part of this question is deciding what goes into the component state and how to manage them. We need a few states:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"totalDuration\"}),\": Total time that has passed so far.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"timerId\"}),\": Timer ID of the currently running interval timer, or \",(0,t.jsx)(e.code,{children:\"null\"}),\" if there's no currently running timer.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"lastTickTiming\"}),\": This is the time that the last interval callback has run. We will keep incrementing the \",(0,t.jsx)(e.code,{children:\"totalDuration\"}),\" by the delta between the current time (\",(0,t.jsx)(e.code,{children:\"Date.now()\"}),\") and the \",(0,t.jsx)(e.code,{children:\"lastTickTiming\"}),\". Using this approach, the \",(0,t.jsx)(e.code,{children:\"totalDuration\"}),\" will still be accurate even if the callbacks run at irregular intervals.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Since there are a few buttons in the requirements that has duplicate functionality, we should define these functionality as a few functions that will be triggered by the buttons:\"}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"startTimer\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"This function kicks off the timer and updates the \",(0,t.jsx)(e.code,{children:\"totalDuration\"}),\" value each time the \",(0,t.jsx)(e.code,{children:\"setInterval\"}),\" callback is run with the delta between the last update time (\",(0,t.jsx)(e.code,{children:\"lastTickTiming\"}),\") and the current time. We use a interval timing of 1ms since stopwatches are very time sensitive and millisecond-level precision is desired.\"]}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"stopInterval\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"A simple function to stop the interval timer from running (via \",(0,t.jsx)(e.code,{children:\"clearInterval\"}),\") and clear the current \",(0,t.jsx)(e.code,{children:\"timerId\"}),'. This is being used by the \"Stop\" button and \"Reset\" button.']}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"resetTimer\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"We want to reset the component to its initial state in this function. It stops the interval timer by calling \",(0,t.jsx)(e.code,{children:\"stopInterval()\"}),\" and also resets the total duration to 0. It's not important to reset the value of \",(0,t.jsx)(e.code,{children:\"lastTickTiming\"}),\" because it will be set at the start of \",(0,t.jsx)(e.code,{children:\"startTimer()\"}),', before the first interval callback is executed. Used by the \"Reset\" button.']}),`\n`,(0,t.jsx)(e.h3,{children:(0,t.jsx)(e.code,{children:\"toggleTimer\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"A function to toggle between calling \",(0,t.jsx)(e.code,{children:\"stopInterval()\"}),\" and \",(0,t.jsx)(e.code,{children:\"startTimer()\"}),` depending on whether there's a current timer. Used by the time display and the \"Start\"/\"Stop\" button.`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Special Note\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Because the time digits are constantly being re-rendered via the \",(0,t.jsx)(e.code,{children:\"updateTime()\"}),\" loop, the digits don't respond to clicks well. As a workaround, we add a persistent DOM element to cover the digits and ensure that all the clicks go through.\"]}),`\n`,(0,t.jsx)(p,{}),`\n`,(0,t.jsx)(g,{})]})}function I(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var C=I;return _(M);})();\n;return Component;"
}