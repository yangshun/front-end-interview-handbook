{
  "skeleton": "var Component=(()=>{var w=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var _=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),b=(e,t)=>{for(var o in t)s(e,o,{get:t[o],enumerable:!0})},c=(e,t,o,h)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let r of x(t))!j.call(e,r)&&r!==o&&s(e,r,{get:()=>t[r],enumerable:!(h=f(t,r))||h.enumerable});return e};var l=(e,t,o)=>(o=e!=null?w(g(e)):{},c(t||!e||!e.__esModule?s(o,\"default\",{value:e,enumerable:!0}):o,e)),y=e=>c(s({},\"__esModule\",{value:!0}),e);var a=_((X,d)=>{d.exports=_jsx_runtime});var D={};b(D,{default:()=>C});var i=l(a());var n=l(a());function m(e){let t=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",a:\"a\"},e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:'Build a stopwatch widget which can measure how much time has passed. It shows the current timer and has two buttons underneath: \"Start/Stop\" and \"Reset\".'}),`\n`,(0,n.jsx)(t.h2,{children:\"Requirements\"}),`\n`,(0,n.jsxs)(t.ul,{children:[`\n`,(0,n.jsx)(t.li,{children:\"Start/Stop Button: Starts/stops the timer depending on whether the timer is running.\"}),`\n`,(0,n.jsx)(t.li,{children:\"Reset: Resets the timer to 0 and stops the timer.\"}),`\n`,(0,n.jsxs)(t.li,{children:[\"The timer shows the number of seconds elapsed, down to the millisecond.\",`\n`,(0,n.jsxs)(t.ul,{children:[`\n`,(0,n.jsx)(t.li,{children:\"Clicking on the timer should start/stop the timer. The Start/Stop button's label should update accordingly as well.\"}),`\n`,(0,n.jsx)(t.li,{children:\"It'd be a nice optional addition to format the time to display in hh:mm:ss:ms format.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(t.p,{children:[\"You are free to exercise your creativity to style the appearance of the stopwatch. You can try out \",(0,n.jsx)(t.a,{href:\"https://www.google.com/search?q=stopwatch\",children:\"Google's stopwatch widget\"}),\" for inspiration and an example.\"]})]})}function S(e={}){let{wrapper:t}=e.components||{};return t?(0,n.jsx)(t,Object.assign({},e,{children:(0,n.jsx)(m,e)})):m(e)}var u=S;function p(e){return(0,i.jsx)(u,{})}function M(e={}){let{wrapper:t}=e.components||{};return t?(0,i.jsx)(t,Object.assign({},e,{children:(0,i.jsx)(p,e)})):p(e)}var C=M;return y(D);})();\n;return Component;",
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var S=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var s in e)l(n,s,{get:e[s],enumerable:!0})},d=(n,e,s,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of T(e))!k.call(n,o)&&o!==s&&l(n,o,{get:()=>e[o],enumerable:!(c=w(e,o))||c.enumerable});return n};var h=(n,e,s)=>(s=n!=null?f(v(n)):{},d(e||!n||!n.__esModule?l(s,\"default\",{value:n,enumerable:!0}):s,n)),_=n=>d(l({},\"__esModule\",{value:!0}),n);var a=S((F,u)=>{u.exports=_jsx_runtime});var O={};x(O,{default:()=>M});var t=h(a());var i=h(a());function m(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Start\" button to start the timer. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time increases constantly and shows the correct value.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Start\" button now shows \"Stop\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click \"Stop\" while the timer is running. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time stops increasing.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Stop\" button now shows \"start\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Start\" button after having stopped the timer. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time increases from the stopped timing and shows the correct value.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Start\" button now shows \"Stop\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Reset\" button while:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The timer is running. The timer should stop and be reset to 0.\"}),`\n`,(0,i.jsx)(e.li,{children:\"The timer is stopped/paused. The timer should be reset to 0.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.li,{children:'Repeat the above but click on the time instead of the \"Start\"/\"Stop\" button.'}),`\n`,(0,i.jsxs)(e.li,{children:[\"a11y\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Use \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" to cycle through the buttons.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Be able to use both \",(0,i.jsx)(\"kbd\",{children:\"Spacebar\"}),\" and \",(0,i.jsx)(\"kbd\",{children:\"Enter\"}),\" to interact with the 3 interactive elements.\"]}),`\n`]}),`\n`]}),`\n`]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(m,n)})):m(n)}var p=j;var r=h(a());function g(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"People who are unfamiliar with a11y will add an \",(0,r.jsx)(e.code,{children:\"onClick\"}),\"/\",(0,r.jsx)(e.code,{children:\"'click'\"}),\" event to the DOM element rendering the time (usually a \",(0,r.jsx)(e.code,{children:\"<div>\"}),\") and consider it complete. However, this the timer is not a11y-friendly just by doing so. Some might add \",(0,r.jsx)(e.code,{children:'tabIndex=\"0\"'}),\" (to allow focus) and \",(0,r.jsx)(e.code,{children:'role=\"button\"'}),\" to the element, which certainly improves the a11y, but is not the best.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"For the best a11y, we can and should use a \",(0,r.jsx)(e.code,{children:\"<button>\"}),\" to render the timing, which comes with additional a11y benefits like focus and keyboard support. By using a \",(0,r.jsx)(e.code,{children:\"<button>\"}),\", you get automatic focus support (be able to use \",(0,r.jsx)(\"kbd\",{children:\"Tab\"}),\" to focus onto the timer) and keyboard support (hit the \",(0,r.jsx)(\"kbd\",{children:\"Spacebar\"}),\" to start/stop the timer). The latter will not be possible without custom code to add key event listeners to non-interactive elements.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"User Experience\"}),`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:\"user-select: none\"}),\" is added to the timer so that the digits aren't selected if a user double clicks on them. Selecting the digits is usually not desired.\"]})]})}function C(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(g,n)})):g(n)}var b=C;function y(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",a:\"a\",h3:\"h3\",ul:\"ul\",li:\"li\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This question looks simple on first glance but is actually more complex than it seems. Note that \",(0,t.jsx)(e.code,{children:\"setInterval\"}),\"'s \",(0,t.jsx)(e.code,{children:\"delay\"}),\" parameter is unreliable. The actual amount of time that elapses between calls to the callback may be \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#reasons_for_delays_longer_than_specified\",children:\"longer than the given delay due to various reasons\"}),\". Because of this behavior, we cannot assume that each time the interval callback is fired, the same duration as passed. We will need to read the current time within the callback code to ensure that we are using the most updated timings.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"State\"}),`\n`,(0,t.jsx)(e.p,{children:\"The tricky part of this question is deciding what goes into the component state and how to manage them. We need a few states:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"lastTickTiming\"}),\": A variable to hold the timestamp of the last timer tick. This is crucial to determine how much time has passed since the last tick.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"totalDuration\"}),\": Maintains the total time elapsed in milliseconds since the timer started.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"timerId\"}),\": A reference to the interval function, helping in starting, pausing, or stopping the timer.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"isRunning\"}),\": A derived state that checks if the timer is currently running. This is determined by whether \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" is null or not.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Three main functions are central to the timer's operation:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"startTimer\"}),\": Initializes the timer by setting the last tick timing and creating an interval function that updates the \",(0,t.jsx)(e.code,{children:\"totalDuration\"}),\" every millisecond.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"stopInterval\"}),\": Clears the interval, effectively pausing the timer.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"resetTimer\"}),\": Resets the timer's state to its initial values.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Lastly, the \",(0,t.jsx)(e.code,{children:\"toggleTimer\"}),\" function is a convenient way to switch between starting and stopping the timer based on its current state.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,t.jsx)(e.p,{children:\"Some significant aspects of the rendering include:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Dynamic Timer Display\"}),': The time display is constructed dynamically, only showing hours or minutes if they are not zero. This avoids displaying \"0h 0m\" when the timer is just a few seconds or milliseconds in.']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Styling\"}),\": The timer is styled to make it look like a modern digital timer. The numbers are significantly larger than the units (like 'h', 'm', 's'), and milliseconds are slightly smaller than seconds for a clear hierarchy in the display. The \",(0,t.jsx)(e.code,{children:\"gap\"}),\" CSS property is used to maintain a consistent spacing between the units.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Timer Control Buttons\"}),\": Two primary buttons allow the user to control the timer:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"A button that toggles the timer's running state, displaying 'Stop' when the timer is running and 'Start' when it's paused.\"}),`\n`,(0,t.jsx)(e.li,{children:\"A 'Reset' button that sets the timer back to its initial state.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"By incorporating the described functionalities, this Svelte code provides a user-friendly, interactive stopwatch that accurately tracks and displays elapsed time.\"}),`\n`,(0,t.jsx)(p,{}),`\n`,(0,t.jsx)(b,{})]})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(y,n)})):y(n)}var M=D;return _(O);})();\n;return Component;"
}