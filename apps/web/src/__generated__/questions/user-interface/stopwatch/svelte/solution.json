{
  "author": "tanhauhau",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/stopwatch-svelte-solution\",\n  \"author\": \"tanhauhau\",\n  \"version\": \"0.0.1\",\n  \"main\": \"src/index.js\",\n  \"dependencies\": {\n    \"svelte\": \"^3.58.0\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html>\n  <head>\n    <meta charset=\"utf8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>Svelte</title>\n    <link rel=\"stylesheet\" href=\"public/bundle.css\" />\n  </head>\n\n  <body>\n    <script src=\"bundle.js\"></script>\n  </body>\n</html>\n"
    },
    "/src/App.svelte": {
      "code": "<script>\n  const MS_IN_SECOND = 1000;\n  const SECONDS_IN_MINUTE = 60;\n  const MINUTES_IN_HOUR = 60;\n  const MS_IN_HOUR =\n    MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MS_IN_SECOND;\n  const MS_IN_MINUTE = SECONDS_IN_MINUTE * MS_IN_SECOND;\n\n  function formatTime(timeParam) {\n    let time = timeParam;\n    let toPadTime = false;\n    const padTime = (number) =>\n      toPadTime\n        ? padTwoDigit(number)\n        : number === 0\n        ? ''\n        : number;\n    const parts = {\n      hours: '',\n      minutes: '',\n      seconds: '0',\n      ms: '00',\n    };\n    if (time > MS_IN_HOUR) {\n      parts.hours = Math.floor(time / MS_IN_HOUR);\n      time %= MS_IN_HOUR;\n      toPadTime = true;\n    }\n\n    if (time > MS_IN_MINUTE) {\n      parts.minutes = padTime(\n        Math.floor(time / MS_IN_MINUTE),\n      );\n      time %= MS_IN_MINUTE;\n      toPadTime = true;\n    } else {\n      parts.minutes = padTime(0);\n    }\n\n    if (time > MS_IN_SECOND) {\n      parts.seconds = padTime(\n        Math.floor(time / MS_IN_SECOND),\n      );\n      time %= MS_IN_SECOND;\n      toPadTime = true;\n    } else if (toPadTime) {\n      parts.seconds = padTime(0);\n    }\n\n    parts.ms = padTwoDigit(Math.floor(time / 10));\n\n    return parts;\n  }\n\n  function padTwoDigit(number) {\n    return number >= 10 ? String(number) : `0${number}`;\n  }\n\n  let lastTickTiming = null;\n  let totalDuration = 0;\n  // Timer ID of the active interval, if one is running.\n  let timerId = null;\n  // Derived state to determine if there's a timer running.\n  $: isRunning = timerId != null;\n  $: formattedTime = formatTime(totalDuration);\n\n  function startTimer() {\n    lastTickTiming = Date.now();\n    timerId = window.setInterval(() => {\n      const now = Date.now();\n      const timePassed = now - lastTickTiming;\n      totalDuration += timePassed;\n      lastTickTiming = now;\n    }, 1);\n  }\n\n  function stopInterval() {\n    window.clearInterval(timerId);\n    timerId = null;\n  }\n\n  function resetTimer() {\n    stopInterval();\n    totalDuration = 0;\n  }\n\n  function toggleTimer() {\n    if (isRunning) {\n      stopInterval();\n    } else {\n      startTimer();\n    }\n  }\n</script>\n\n<div>\n  <button\n    class=\"time\"\n    on:click={() => {\n      toggleTimer();\n    }}>\n    {#if formattedTime.hours}\n      <span>\n        <span class=\"time-number\">\n          {formattedTime.hours}\n        </span>\n        <span class=\"time-unit\">h</span>\n      </span>\n    {/if}\n    {#if formattedTime.minutes}\n      <span>\n        <span class=\"time-number\">\n          {formattedTime.minutes}\n        </span>\n        <span class=\"time-unit\">m</span>\n      </span>\n    {/if}\n    <span>\n      <span class=\"time-number\">\n        {formattedTime.seconds}\n      </span>\n      <span class=\"time-unit\">s</span>\n    </span>\n    <span class=\"time-number time-number--small\">\n      {formattedTime.ms}\n    </span>\n  </button>\n  <div>\n    <button\n      on:click={() => {\n        toggleTimer();\n      }}>\n      {isRunning ? 'Stop' : 'Start'}\n    </button>\n    <button\n      on:click={() => {\n        resetTimer();\n      }}>\n      Reset\n    </button>\n  </div>\n</div>\n\n<style>\n  .time {\n    align-items: baseline;\n    background-color: transparent;\n    border: none;\n    cursor: pointer;\n    display: flex;\n    gap: 16px;\n    user-select: none;\n  }\n\n  .time-unit {\n    font-size: 24px;\n  }\n\n  .time-number {\n    font-size: 62px;\n  }\n\n  .time-number--small {\n    font-size: 36px;\n  }\n</style>\n"
    },
    "/src/index.js": {
      "code": "import App from './App.svelte';\nimport './styles.css';\n\nconst app = new App({\n  target: document.body,\n});\n\nexport default app;\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/App.svelte",
      "/src/styles.css"
    ],
    "activeFile": "/src/App.svelte",
    "environment": "svelte"
  },
  "writeup": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var S=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var s in e)l(n,s,{get:e[s],enumerable:!0})},d=(n,e,s,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of T(e))!k.call(n,o)&&o!==s&&l(n,o,{get:()=>e[o],enumerable:!(c=w(e,o))||c.enumerable});return n};var h=(n,e,s)=>(s=n!=null?f(v(n)):{},d(e||!n||!n.__esModule?l(s,\"default\",{value:n,enumerable:!0}):s,n)),_=n=>d(l({},\"__esModule\",{value:!0}),n);var a=S((F,u)=>{u.exports=_jsx_runtime});var O={};x(O,{default:()=>M});var t=h(a());var i=h(a());function m(n){let e=Object.assign({h2:\"h2\",ul:\"ul\",li:\"li\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"Test cases\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Start\" button to start the timer. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time increases constantly and shows the correct value.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Start\" button now shows \"Stop\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click \"Stop\" while the timer is running. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time stops increasing.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Stop\" button now shows \"start\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Start\" button after having stopped the timer. Observe that:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The time increases from the stopped timing and shows the correct value.\"}),`\n`,(0,i.jsx)(e.li,{children:'The \"Start\" button now shows \"Stop\".'}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:['Click the \"Reset\" button while:',`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"The timer is running. The timer should stop and be reset to 0.\"}),`\n`,(0,i.jsx)(e.li,{children:\"The timer is stopped/paused. The timer should be reset to 0.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.li,{children:'Repeat the above but click on the time instead of the \"Start\"/\"Stop\" button.'}),`\n`,(0,i.jsxs)(e.li,{children:[\"a11y\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Use \",(0,i.jsx)(\"kbd\",{children:\"Tab\"}),\" to cycle through the buttons.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Be able to use both \",(0,i.jsx)(\"kbd\",{children:\"Spacebar\"}),\" and \",(0,i.jsx)(\"kbd\",{children:\"Enter\"}),\" to interact with the 3 interactive elements.\"]}),`\n`]}),`\n`]}),`\n`]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(m,n)})):m(n)}var p=j;var r=h(a());function g(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Accessibility\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"People who are unfamiliar with a11y will add an \",(0,r.jsx)(e.code,{children:\"onClick\"}),\"/\",(0,r.jsx)(e.code,{children:\"'click'\"}),\" event to the DOM element rendering the time (usually a \",(0,r.jsx)(e.code,{children:\"<div>\"}),\") and consider it complete. However, this the timer is not a11y-friendly just by doing so. Some might add \",(0,r.jsx)(e.code,{children:'tabIndex=\"0\"'}),\" (to allow focus) and \",(0,r.jsx)(e.code,{children:'role=\"button\"'}),\" to the element, which certainly improves the a11y, but is not the best.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"For the best a11y, we can and should use a \",(0,r.jsx)(e.code,{children:\"<button>\"}),\" to render the timing, which comes with additional a11y benefits like focus and keyboard support. By using a \",(0,r.jsx)(e.code,{children:\"<button>\"}),\", you get automatic focus support (be able to use \",(0,r.jsx)(\"kbd\",{children:\"Tab\"}),\" to focus onto the timer) and keyboard support (hit the \",(0,r.jsx)(\"kbd\",{children:\"Spacebar\"}),\" to start/stop the timer). The latter will not be possible without custom code to add key event listeners to non-interactive elements.\"]}),`\n`,(0,r.jsx)(e.h2,{children:\"User Experience\"}),`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.code,{children:\"user-select: none\"}),\" is added to the timer so that the digits aren't selected if a user double clicks on them. Selecting the digits is usually not desired.\"]})]})}function C(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(g,n)})):g(n)}var b=C;function y(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",a:\"a\",h3:\"h3\",ul:\"ul\",li:\"li\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This question looks simple on first glance but is actually more complex than it seems. Note that \",(0,t.jsx)(e.code,{children:\"setInterval\"}),\"'s \",(0,t.jsx)(e.code,{children:\"delay\"}),\" parameter is unreliable. The actual amount of time that elapses between calls to the callback may be \",(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#reasons_for_delays_longer_than_specified\",children:\"longer than the given delay due to various reasons\"}),\". Because of this behavior, we cannot assume that each time the interval callback is fired, the same duration as passed. We will need to read the current time within the callback code to ensure that we are using the most updated timings.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"State\"}),`\n`,(0,t.jsx)(e.p,{children:\"The tricky part of this question is deciding what goes into the component state and how to manage them. We need a few states:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"lastTickTiming\"}),\": A variable to hold the timestamp of the last timer tick. This is crucial to determine how much time has passed since the last tick.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"totalDuration\"}),\": Maintains the total time elapsed in milliseconds since the timer started.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"timerId\"}),\": A reference to the interval function, helping in starting, pausing, or stopping the timer.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"isRunning\"}),\": A derived state that checks if the timer is currently running. This is determined by whether \",(0,t.jsx)(e.code,{children:\"timerId\"}),\" is null or not.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"Three main functions are central to the timer's operation:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"startTimer\"}),\": Initializes the timer by setting the last tick timing and creating an interval function that updates the \",(0,t.jsx)(e.code,{children:\"totalDuration\"}),\" every millisecond.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"stopInterval\"}),\": Clears the interval, effectively pausing the timer.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"resetTimer\"}),\": Resets the timer's state to its initial values.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Lastly, the \",(0,t.jsx)(e.code,{children:\"toggleTimer\"}),\" function is a convenient way to switch between starting and stopping the timer based on its current state.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,t.jsx)(e.p,{children:\"Some significant aspects of the rendering include:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Dynamic Timer Display\"}),': The time display is constructed dynamically, only showing hours or minutes if they are not zero. This avoids displaying \"0h 0m\" when the timer is just a few seconds or milliseconds in.']}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Styling\"}),\": The timer is styled to make it look like a modern digital timer. The numbers are significantly larger than the units (like 'h', 'm', 's'), and milliseconds are slightly smaller than seconds for a clear hierarchy in the display. The \",(0,t.jsx)(e.code,{children:\"gap\"}),\" CSS property is used to maintain a consistent spacing between the units.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Timer Control Buttons\"}),\": Two primary buttons allow the user to control the timer:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"A button that toggles the timer's running state, displaying 'Stop' when the timer is running and 'Start' when it's paused.\"}),`\n`,(0,t.jsx)(e.li,{children:\"A 'Reset' button that sets the timer back to its initial state.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"By incorporating the described functionalities, this Svelte code provides a user-friendly, interactive stopwatch that accurately tracks and displays elapsed time.\"}),`\n`,(0,t.jsx)(p,{}),`\n`,(0,t.jsx)(b,{})]})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(y,n)})):y(n)}var M=D;return _(O);})();\n;return Component;"
}