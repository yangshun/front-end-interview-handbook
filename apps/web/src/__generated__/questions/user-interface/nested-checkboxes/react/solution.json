{
  "author": "yangshun",
  "files": {
    "/package.json": {
      "code": "{\n  \"name\": \"@gfe-questions/nested-checkboxes-react-solution\",\n  \"author\": \"yangshun\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"dependencies\": {\n    \"react\": \"18.2.0\",\n    \"react-dom\": \"18.2.0\",\n    \"react-scripts\": \"5.0.1\"\n  },\n  \"devDependencies\": {\n    \"@types/react\": \"18.2.0\",\n    \"@types/react-dom\": \"18.2.0\",\n    \"typescript\": \"5.0.2\"\n  },\n  \"scripts\": {\n    \"start\": \"react-scripts start\",\n    \"build\": \"react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  }\n}\n"
    },
    "/public/index.html": {
      "code": "<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1.0\" />\n  </head>\n  <body>\n    <div id=\"root\"></div>\n  </body>\n</html>\n"
    },
    "/src/App.tsx": {
      "code": "import Checkboxes from './Checkboxes';\n\nexport default function App() {\n  const checkboxesData = [\n    {\n      id: 1,\n      name: 'Electronics',\n      checked: false,\n      children: [\n        {\n          id: 2,\n          name: 'Mobile phones',\n          checked: false,\n          children: [\n            {\n              id: 3,\n              name: 'iPhone',\n              checked: false,\n            },\n            {\n              id: 4,\n              name: 'Android',\n              checked: false,\n            },\n          ],\n        },\n        {\n          id: 5,\n          name: 'Laptops',\n          checked: false,\n          children: [\n            {\n              id: 6,\n              name: 'MacBook',\n              checked: false,\n            },\n            {\n              id: 7,\n              name: 'Surface Pro',\n              checked: false,\n            },\n          ],\n        },\n      ],\n    },\n    {\n      id: 8,\n      name: 'Books',\n      checked: false,\n      children: [\n        {\n          id: 9,\n          name: 'Fiction',\n          checked: false,\n        },\n        {\n          id: 10,\n          name: 'Non-fiction',\n          checked: false,\n        },\n      ],\n    },\n    {\n      id: 11,\n      name: 'Toys',\n      checked: false,\n    },\n  ];\n\n  return (\n    <div>\n      <Checkboxes defaultCheckboxData={checkboxesData} />\n    </div>\n  );\n}\n"
    },
    "/src/Checkboxes.tsx": {
      "code": "import { useState } from 'react';\nimport CheckboxList, { CheckboxItem } from './CheckboxList';\nimport { CheckboxValue } from './CheckboxInput';\n\n/**\n * Recursively set descendants of the modified checkbox\n * to the new value.\n */\nfunction updateCheckboxAndDescendants(\n  checkboxItem: CheckboxItem,\n  checked: boolean,\n) {\n  checkboxItem.checked = checked;\n  if (!checkboxItem.children) {\n    return;\n  }\n\n  checkboxItem.children.forEach((childItem) =>\n    updateCheckboxAndDescendants(childItem, checked),\n  );\n}\n\n/**\n * Update checkbox states based on the modified checkbox's new state.\n * Only direct ancestors of the modified checkbox are affected.\n */\nfunction resolveCheckboxStates(\n  checkboxItem: CheckboxItem,\n  indices: ReadonlyArray<number>,\n) {\n  if (indices.length > 0 && checkboxItem.children) {\n    resolveCheckboxStates(\n      checkboxItem.children[indices[0]],\n      indices.slice(1),\n    );\n  }\n\n  if (!checkboxItem.children) {\n    return;\n  }\n\n  // Determine new checkbox state based on children.\n  const checkedChildren = checkboxItem.children.reduce(\n    (total, item) => total + Number(item.checked === true),\n    0,\n  );\n  const uncheckedChildren = checkboxItem.children.reduce(\n    (total, item) => total + Number(item.checked === false),\n    0,\n  );\n\n  if (checkedChildren === checkboxItem.children.length) {\n    checkboxItem.checked = true;\n  } else if (\n    uncheckedChildren === checkboxItem.children.length\n  ) {\n    checkboxItem.checked = false;\n  } else {\n    checkboxItem.checked = 'indeterminate';\n  }\n}\n\nexport default function Checkboxes({\n  defaultCheckboxData,\n}: Readonly<{\n  defaultCheckboxData: ReadonlyArray<CheckboxItem>;\n}>) {\n  const [checkboxData, setCheckboxData] = useState(\n    defaultCheckboxData,\n  );\n\n  return (\n    <CheckboxList\n      items={checkboxData}\n      onCheck={(checked, indices) => {\n        // Simple way to make a clone.\n        const newCheckboxData = JSON.parse(\n          JSON.stringify(checkboxData),\n        );\n\n        const nonFirstLevelIndices = indices.slice(1);\n        const modifiedCheckboxItem =\n          nonFirstLevelIndices.reduce(\n            (modifiedItem, index) =>\n              modifiedItem.children[index],\n            newCheckboxData[indices[0]],\n          );\n\n        updateCheckboxAndDescendants(\n          modifiedCheckboxItem,\n          checked,\n        );\n        resolveCheckboxStates(\n          newCheckboxData[indices[0]],\n          nonFirstLevelIndices,\n        );\n\n        setCheckboxData(newCheckboxData);\n      }}\n    />\n  );\n}\n"
    },
    "/src/CheckboxInput.tsx": {
      "code": "import {\n  InputHTMLAttributes,\n  useEffect,\n  useId,\n  useRef,\n} from 'react';\n\nexport type CheckboxValue = boolean | 'indeterminate';\n\nexport default function CheckboxInput({\n  checked,\n  label,\n  ...props\n}: Readonly<{\n  checked: CheckboxValue;\n  label: string;\n}> &\n  Omit<InputHTMLAttributes<HTMLInputElement>, 'checked'>) {\n  const id = useId();\n  const ref = useRef<HTMLInputElement | null>(null);\n\n  useEffect(() => {\n    if (!ref.current) {\n      return;\n    }\n\n    ref.current.indeterminate = checked === 'indeterminate';\n  }, [checked]);\n\n  return (\n    <div className=\"checkbox\">\n      <input\n        id={id}\n        ref={ref}\n        type=\"checkbox\"\n        checked={\n          checked === true || checked === false\n            ? checked\n            : false\n        }\n        {...props}\n      />\n      <label htmlFor={id}>{label}</label>\n    </div>\n  );\n}\n"
    },
    "/src/CheckboxList.tsx": {
      "code": "import CheckboxInput, {\n  CheckboxValue,\n} from './CheckboxInput';\n\nexport interface CheckboxItem {\n  id: number;\n  name: string;\n  checked: CheckboxValue;\n  children?: CheckboxItem[];\n}\n\nexport default function CheckboxList({\n  items,\n  onCheck,\n}: Readonly<{\n  items: ReadonlyArray<CheckboxItem>;\n  onCheck: (\n    value: boolean,\n    indices: ReadonlyArray<number>,\n  ) => void;\n}>) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={item.id}>\n          <div>\n            <CheckboxInput\n              checked={item.checked}\n              label={item.name}\n              onChange={(event) => {\n                onCheck(event.target.checked, [index]);\n              }}\n            />\n          </div>\n          {item.children && item.children.length > 0 && (\n            <CheckboxList\n              items={item.children}\n              onCheck={(newValue, indices) => {\n                onCheck(newValue, [index, ...indices]);\n              }}\n            />\n          )}\n        </li>\n      ))}\n    </ul>\n  );\n}\n"
    },
    "/src/index.tsx": {
      "code": "import { StrictMode } from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport App from './App';\n\nimport './styles.css';\n\nconst root = createRoot(document.getElementById('root')!);\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n"
    },
    "/src/styles.css": {
      "code": "body {\n  font-family: sans-serif;\n}\n\nul {\n  list-style: none;\n  margin: 0;\n  padding-left: 20px;\n}\n\nli {\n  padding: 0;\n}\n\n.checkbox {\n  display: inline-flex;\n  line-height: 1.5;\n  gap: 4px;\n  font-size: 16px;\n}\n"
    },
    "/tsconfig.json": {
      "code": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n"
    }
  },
  "workspace": {
    "visibleFiles": [
      "/src/Checkboxes.tsx",
      "/src/CheckboxInput.tsx",
      "/src/CheckboxList.tsx",
      "/src/styles.css"
    ],
    "activeFile": "/src/Checkboxes.tsx",
    "environment": "create-react-app"
  },
  "writeup": "var Component=(()=>{var g=Object.create;var r=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var C=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),T=(i,e)=>{for(var a in e)r(i,a,{get:e[a],enumerable:!0})},s=(i,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let d of y(e))!v.call(i,d)&&d!==a&&r(i,d,{get:()=>e[d],enumerable:!(l=x(e,d))||l.enumerable});return i};var o=(i,e,a)=>(a=i!=null?g(w(i)):{},s(e||!i||!i.__esModule?r(a,\"default\",{value:i,enumerable:!0}):a,i)),j=i=>s(r({},\"__esModule\",{value:!0}),i);var h=C((D,u)=>{u.exports=_jsx_runtime});var A={};T(A,{default:()=>S});var c=o(h());var t=o(h());function p(i){let e=Object.assign({h2:\"h2\",ol:\"ol\",li:\"li\",ul:\"ul\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Test Cases\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initial rendering:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Test that all checkboxes are rendered correctly according to the provided data structure.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that the initial state of all checkboxes is unchecked.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Leaf node behavior:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Check a leaf node (e.g., \"iPhone\") and verify it becomes checked.'}),`\n`,(0,t.jsx)(e.li,{children:\"Uncheck a leaf node and verify it becomes unchecked.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Ancestor/descendant state changes:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Descendant change propagation:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Check a parent (e.g., \"Laptops\") and verify all its descendants become checked.'}),`\n`,(0,t.jsx)(e.li,{children:\"Uncheck a parent and verify all its descendants become unchecked.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Ancestor change propagation:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Check all children of a parent (e.g., all under \"Mobile phones\") and verify the parent becomes checked.'}),`\n`,(0,t.jsx)(e.li,{children:\"Uncheck one child and verify the parent becomes indeterminate.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Uncheck all children and verify the parent becomes unchecked.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Multi-level hierarchy:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:'Check a leaf node (e.g., \"iPhone\") and verify its parent (\"Mobile phones\") becomes indeterminate and grandparent (\"Electronics\") becomes indeterminate.'}),`\n`,(0,t.jsx)(e.li,{children:'Check all leaf nodes under a mid-level parent (e.g., all under \"Mobile phones\") and verify the mid-level parent becomes checked and its parent (\"Electronics\") becomes indeterminate.'}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Indeterminate state:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Verify that when some but not all children are checked, the parent displays an indeterminate state.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Check if the indeterminate state is visually distinct from checked and unchecked states.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Check that indeterminate state can be propagated to the ancestors as well.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Root-level behavior:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Check all root-level items and verify they can be independently checked/unchecked.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Verify that checking/unchecking a root-level item with children affects all its descendants.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Edge cases:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Test with an empty data set to ensure the component handles it gracefully.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"User interactions:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Verify that checkboxes can be toggled using both mouse clicks and keyboard interactions (space bar when focused).\"}),`\n`,(0,t.jsx)(e.li,{children:\"Test tabbing through the checkboxes to ensure proper focus management.\"}),`\n`]}),`\n`]}),`\n`]})]})}function I(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(p,i)})):p(i)}var m=I;var n=o(h());function b(i){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",code:\"code\",pre:\"pre\",ol:\"ol\",li:\"li\",h4:\"h4\",ul:\"ul\",strong:\"strong\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,n.jsx)(e.p,{children:\"The solution can be broken down into two parts: (1) Rendering and (2) State updates\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Rendering\"}),`\n`,(0,n.jsx)(e.p,{children:\"As you can tell, the data provided is recursive in nature and can be of any depth. Hence our component must also support rendering nested checkboxes of arbitrary depth via recursion.\"}),`\n`,(0,n.jsx)(e.p,{children:\"In terms of front end components, recursion means that the components can be rendering itself, or render a component that renders itself. It's important to design the recursive components well to allow for reusability.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The most intuitive way to render recursive hierarchical structures is using \",(0,n.jsx)(e.code,{children:\"<ul>\"}),\" and \",(0,n.jsx)(e.code,{children:\"<li>\"}),\". \",(0,n.jsx)(e.code,{children:\"<ul>\"}),\"s can be nested within \",(0,n.jsx)(e.code,{children:\"<li>\"}),\"s:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-html\",children:`<ul>\n  <li>\n    <div><input type=\"checkbox\"><label>Electronics</div>\n    <ul>\n      <li><div><input type=\"checkbox\"><label>Mobile phones</div></li>\n      <li><div><input type=\"checkbox\"><label>Laptop</div></li>\n    </ul>\n  </li>\n  <li>\n    <div><div><input type=\"checkbox\"><label>Book</div></div>\n  </li>\n</ul>\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As long as the \",(0,n.jsx)(e.code,{children:\"<ul>\"}),\"s are rendered with an indentation (e.g. \",(0,n.jsx)(e.code,{children:\"padding-left\"}),\"), nested \",(0,n.jsx)(e.code,{children:\"<ul>\"}),\"s will automatically be indented by the right amount \\u2013 a summation of its own padding and ancestors' paddings.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can create a \",(0,n.jsx)(e.code,{children:\"CheckboxList\"}),\" component, that accepts an array of \",(0,n.jsx)(e.code,{children:\"CheckboxItem\"}),\"s and renders the list of \",(0,n.jsx)(e.code,{children:'<input type=\"checkbox\">'}),\"s. Depending on whether the \",(0,n.jsx)(e.code,{children:\"CheckboxItem\"}),\" has children, it will recursively render the children using \",(0,n.jsx)(e.code,{children:\"CheckboxList\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Indeterminate checkboxes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Did you know that besides the checked and unchecked states, \",(0,n.jsx)(e.code,{children:'<input type=\"checkbox>'}),' have an indeterminate state? Indeterminate state is often used to represent a \"partially checked\" state.']}),`\n`,(0,n.jsx)(e.p,{children:\"By default, browsers render checkboxes in the indeterminate state using a dash/hyphen within the box. One quirk about indeterminate checkboxes is that there's no HTML attribute for it, and it can only be set using JavaScript:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const $checkboxElement = document.querySelector(\n  'input[type=\"checkbox\"]',\n);\n$checkboxElement.indeterminate = true;\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"We can create a component \",(0,n.jsx)(e.code,{children:\"CheckboxInput\"}),\" that abstracts this logic away. The component will accept a \",(0,n.jsx)(e.code,{children:\"checked\"}),\" prop that is either a boolean value or the string \",(0,n.jsx)(e.code,{children:\"indeterminate\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"When an checkbox input element's \",(0,n.jsx)(e.code,{children:\"indeterminate\"}),\" property is \",(0,n.jsx)(e.code,{children:\"true\"}),\", it does not matter what the value of \",(0,n.jsx)(e.code,{children:\"checked\"}),\" is, the indeterminate dashed state will be displayed. This begs the question, what should the value of \",(0,n.jsx)(e.code,{children:\"checked\"}),\" be when a checkbox is set to indeterminate? When a user clicks on an indeterminate checkbox, it typically becomes checked. So it's better to make the checkbox's \",(0,n.jsx)(e.code,{children:\"checked\"}),\" property to be \",(0,n.jsx)(e.code,{children:\"false\"}),\" when it is indeterminate, such that clicking on indeterminate checkboxes will turn it into \",(0,n.jsx)(e.code,{children:\"checked\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"State updates\"}),`\n`,(0,n.jsx)(e.p,{children:\"After covering the layout and structure, the next step will be to manage the state updates of the checkboxes.\"}),`\n`,(0,n.jsx)(e.p,{children:\"When a checkbox is clicked/triggered, the following operations occur:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Update checkbox state.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Update the checkbox descendants' state.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Update the checkbox's ancestors' state.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Let's go through each operation in detail:\"}),`\n`,(0,n.jsx)(e.h4,{children:\"1. Update checkbox state\"}),`\n`,(0,n.jsx)(e.p,{children:\"The checkbox's state is updated, depending on its current state:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Unchecked\"}),\": It will become checked.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Checked\"}),\": It will become unchecked.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Indeterminate\"}),\": It will become checked.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h4,{children:\"2. Update descendants' state\"}),`\n`,(0,n.jsx)(e.p,{children:\"The checkbox's descendants are updated recursively to be of the same state, either checked or unchecked.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Because parents need to update the descendants' state, potentially across the entire tree if the top-most checkbox is triggered, the overall state should be lifted up and housed within the root component as the source of truth, instead of having each checkbox manage its own state.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Step 1 and 2 is implemented within the \",(0,n.jsx)(e.code,{children:\"updateCheckboxAndDescendants\"}),\" function, which takes in a checkbox item, the new value, and recursively sets itself + all descendants to be that new value.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"3. Update ancestors' state\"}),`\n`,(0,n.jsx)(e.p,{children:\"The checkbox's ancestors are updated based on the modified checkbox's new state. They could be updated to any of the possible states.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Ancestors need to inspect its \",(0,n.jsx)(e.strong,{children:\"direct children's\"}),\" checked state to determine its new state. It does not need to look at grandchildren and beyond, because a parent's state reflects the child's state. As long as the new state is updated in a bottom-up fashion (starting from the leaf nodes), parents only need to look at its direct children's state.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Step 3 is implemented as the \",(0,n.jsx)(e.code,{children:\"resolveCheckboxStates\"}),\" function. It firstly resolves the descendants' states, whether they should be updated to true/false/indeterminate and work its way upwards, terminating at a top-level checkbox. Note that only checkboxes in the direct ancestry chain of the modified checkbox will be affected.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Putting it together\"}),`\n`,(0,n.jsx)(e.p,{children:\"The root component will house the hierarchy and state of all the checkboxes. The default data is already in this format.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Each checkbox receives the minimal state needed for itself and its descendants.\"}),`\n`,(0,n.jsx)(e.li,{children:\"State mutations are done at the root / top-level since it contains the source of truth.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The change/click handlers have to include the index of the current checkbox (position among its siblings). When the root component receives an update due to a checkbox somewhere in its tree being modified, it receives two arguments:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"New checkbox state\"}),\": A boolean value. This will never be \",(0,n.jsx)(e.code,{children:\"indeterminate\"}),\", because \",(0,n.jsx)(e.code,{children:\"indeterminate\"}),\" state of a checkbox is a result of a user updating descendant checkboxes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Indices array\"}),\": An array of integers representing the positions of the checkboxes. E.g. \",(0,n.jsx)(e.code,{children:\"[0, 1]\"}),' means the second child of the first child starting from the root, aka the \"Laptops\". This is needed by the top-level component to trace which checkbox has been triggered.']}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In the root component, the state update function will receive the new checkbox state and indices array, using them to compute the new state of the checkboxes.\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"It makes a deep clone of the existing checkbox data. This may or may not be needed depending on the framework of choice. A simple way to perform a deep clone is \",(0,n.jsx)(e.code,{children:\"JSON.parse(JSON.stringify(data))\"}),\". This works well since the data at hand is serializable. With a clone of the data, we can mutate it however we want.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform steps 1 and 2, aka call \",(0,n.jsx)(e.code,{children:\"updateCheckboxAndDescendants()\"}),\" to update the descendants to be the new state.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform step 3, aka call \",(0,n.jsx)(e.code,{children:\"resolveCheckboxStates()\"}),\" to update the ancestors of the modified checkbox.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Commit the state update.\"}),`\n`]})]})}function _(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(b,i)})):b(i)}var k=_;function f(i){return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(k,{}),`\n`,(0,c.jsx)(m,{})]})}function M(i={}){let{wrapper:e}=i.components||{};return e?(0,c.jsx)(e,Object.assign({},i,{children:(0,c.jsx)(f,i)})):f(i)}var S=M;return j(A);})();\n;return Component;"
}