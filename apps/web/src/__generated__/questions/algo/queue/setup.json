{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/queue\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/queue.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/queue.run.test.ts": "import Queue from './queue';\n\ndescribe('Queue', () => {\n  test('constructor', () => {\n    const q = new Queue();\n    expect(q instanceof Queue);\n  });\n\n  test('enqueue()', () => {\n    const q = new Queue();\n    expect(q.enqueue(100)).toBe(1);\n    expect(q.enqueue(200)).toBe(2);\n  });\n\n  test('dequeue()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    q.enqueue(200);\n    expect(q.dequeue()).toBe(100);\n    expect(q.dequeue()).toBe(200);\n  });\n});\n",
    "/src/queue.submit.test.ts": "import Queue from './queue';\n\ndescribe('Queue', () => {\n  test('constructor', () => {\n    const q = new Queue();\n    expect(q instanceof Queue);\n  });\n\n  test('enqueue()', () => {\n    const q = new Queue();\n    expect(q.enqueue(100)).toBe(1);\n    expect(q.enqueue(200)).toBe(2);\n  });\n\n  test('dequeue()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    q.enqueue(200);\n    expect(q.dequeue()).toBe(100);\n    expect(q.length()).toBe(1);\n    expect(q.dequeue()).toBe(200);\n    expect(q.length()).toBe(0);\n    expect(q.dequeue()).toBe(undefined);\n  });\n\n  test('isEmpty()', () => {\n    const q = new Queue();\n    expect(q.isEmpty()).toBeTruthy();\n    q.enqueue(100);\n    expect(q.isEmpty()).toBeFalsy();\n    q.dequeue();\n    expect(q.isEmpty()).toBeTruthy();\n  });\n\n  test('length()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    expect(q.length()).toBe(1);\n    q.enqueue(200);\n    expect(q.length()).toBe(2);\n    q.dequeue();\n    expect(q.length()).toBe(1);\n    q.enqueue(300);\n    expect(q.length()).toBe(2);\n  });\n\n  test('front()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    expect(q.front()).toBe(100);\n    q.enqueue(200);\n    expect(q.front()).toBe(100);\n    q.dequeue();\n    expect(q.front()).toBe(200);\n    q.enqueue(300);\n    expect(q.front()).toBe(200);\n    q.dequeue();\n    q.dequeue();\n    expect(q.front()).toBe(undefined);\n  });\n\n  test('back()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    expect(q.back()).toBe(100);\n    q.enqueue(200);\n    expect(q.back()).toBe(200);\n    q.dequeue();\n    expect(q.back()).toBe(200);\n    q.enqueue(300);\n    expect(q.back()).toBe(300);\n    q.dequeue();\n    q.dequeue();\n    expect(q.back()).toBe(undefined);\n  });\n\n  test('integration', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    expect(q.length()).toBe(1);\n    expect(q.dequeue()).toBe(100);\n    expect(q.length()).toBe(0);\n    q.enqueue(200);\n    expect(q.length()).toBe(1);\n    expect(q.dequeue()).toBe(200);\n  });\n});\n",
    "/src/queue.ts": "class Node<T> {\n  value: T | undefined;\n  next: Node<T> | null;\n  prev: Node<T> | null;\n\n  constructor(value?: T) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nexport default class Queue<T> {\n  _dummyHead: Node<T>;\n  _dummyTail: Node<T>;\n  _length: number;\n\n  constructor() {\n    this._dummyHead = new Node<T>();\n    this._dummyTail = new Node<T>();\n    this._dummyHead.prev = this._dummyTail;\n    this._dummyTail.next = this._dummyHead;\n    this._length = 0;\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   */\n  enqueue(item: T) {\n    const node = new Node(item);\n    const prevLast = this._dummyTail.next;\n    prevLast!.prev = node;\n\n    node.next = prevLast;\n    node.prev = this._dummyTail;\n    this._dummyTail.next = node;\n    this._length++;\n    return this._length;\n  }\n\n  /**\n   * Remove an item from the front of the queue.\n   */\n  dequeue(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const node = this._dummyHead.prev;\n    const newFirst = node!.prev;\n    this._dummyHead.prev = newFirst;\n    newFirst!.next = this._dummyHead;\n    // Unlink the node to be dequeued.\n    node!.prev = null;\n    node!.next = null;\n    this._length--;\n    return node!.value;\n  }\n\n  /**\n   * Determines if the queue is empty.\n   */\n  isEmpty(): boolean {\n    return this._length === 0;\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   */\n  front(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyHead.prev!.value;\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue it.\n   */\n  back(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyTail.next!.value;\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length(): number {\n    return this._length;\n  }\n}\n"
  },
  "skeleton": {
    "js": "export default class Queue {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   * @param {*} item The item to be pushed onto the queue.\n   * @return {number} The new length of the queue.\n   */\n  enqueue(item) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Removes an item from the front of the queue.\n   * @return {*} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  dequeue() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Determines if the queue is empty.\n   * @return {boolean} `true` if the queue has no items, `false` otherwise.\n   */\n  isEmpty() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   * @return {*} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  front() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue.\n   * @return {*} The item at the back of the queue if it is not empty, `undefined` otherwise.\n   */\n  back() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length() {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export default class Queue<T> {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   * @param {T} item The item to be pushed onto the queue.\n   * @return {number} The new length of the queue.\n   */\n  enqueue(item: T): number {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Removes an item from the front of the queue.\n   * @return {T | undefined} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  dequeue(): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Determines if the queue is empty.\n   * @return {boolean} `true` if the queue has no items, `false` otherwise.\n   */\n  isEmpty(): boolean {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   * @return {T | undefined} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  front(): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue.\n   * @return {T | undefined} The item at the back of the queue if it is not empty, `undefined` otherwise.\n   */\n  back(): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length(): number {\n    throw 'Not implemented!';\n  }\n}"
  },
  "workspace": {
    "main": "/src/queue.ts",
    "run": "/src/queue.run.test.ts",
    "submit": "/src/queue.submit.test.ts"
  }
}