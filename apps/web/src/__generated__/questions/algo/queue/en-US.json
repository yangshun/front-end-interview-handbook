{
  "description": "var Component=(()=>{var a=Object.create;var r=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var s=Object.getOwnPropertyNames;var q=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var u in e)r(n,u,{get:e[u],enumerable:!0})},o=(n,e,u,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of s(e))!p.call(n,i)&&i!==u&&r(n,i,{get:()=>e[i],enumerable:!(c=m(e,i))||c.enumerable});return n};var g=(n,e,u)=>(u=n!=null?a(q(n)):{},o(e||!n||!n.__esModule?r(u,\"default\",{value:n,enumerable:!0}):u,n)),y=n=>o(r({},\"__esModule\",{value:!0}),n);var d=f((w,l)=>{l.exports=_jsx_runtime});var b={};x(b,{default:()=>O,frontmatter:()=>R});var t=g(d()),R={title:\"Queue\",excerpt:\"Implement a queue data structure containing the common queue methods\"};function h(n){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"Implement a queue data structure in JavaScript that contains the following operations:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"new Queue()\"}),\": Creates an instance of a \",(0,t.jsx)(e.code,{children:\"Queue\"}),\" class that doesn't contain any items. The constructor does not accept any arguments.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"enqueue()\"}),\": Adds an item to the back of the queue. Required time complexity: O(1).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"dequeue()\"}),\": Removes an item from the front of the queue. Required time complexity: O(1).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"isEmpty()\"}),\": Determines if the queue is empty. Required time complexity: O(1).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"front()\"}),\": Returns the item at the front of the queue without removing it from the queue. Required time complexity: O(1).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"back()\"}),\": Returns the item at the back of the queue without removing it from the queue. Required time complexity: O(1).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"length()\"}),\": Returns the number of items in the queue. Required time complexity: O(1).\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const queue = new Queue();\nqueue.isEmpty(); // true\nqueue.enqueue(1);\nqueue.enqueue(2);\nqueue.length(); // 2\nqueue.enqueue(3);\nqueue.front(); // 1\nqueue.back(); // 3\nqueue.dequeue(); // 1\nqueue.isEmpty(); // false\n`})})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var O=j;return y(b);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/queue\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/queue.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/queue.run.test.ts": "import Queue from './queue';\n\ndescribe('Queue', () => {\n  test('constructor', () => {\n    const q = new Queue();\n    expect(q instanceof Queue);\n  });\n\n  test('enqueue()', () => {\n    const q = new Queue();\n    expect(q.enqueue(100)).toBe(1);\n    expect(q.enqueue(200)).toBe(2);\n  });\n\n  test('dequeue()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    q.enqueue(200);\n    expect(q.dequeue()).toBe(100);\n    expect(q.dequeue()).toBe(200);\n  });\n});\n",
    "/src/queue.submit.test.ts": "import Queue from './queue';\n\ndescribe('Queue', () => {\n  test('constructor', () => {\n    const q = new Queue();\n    expect(q instanceof Queue);\n  });\n\n  test('enqueue()', () => {\n    const q = new Queue();\n    expect(q.enqueue(100)).toBe(1);\n    expect(q.enqueue(200)).toBe(2);\n  });\n\n  test('dequeue()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    q.enqueue(200);\n    expect(q.dequeue()).toBe(100);\n    expect(q.length()).toBe(1);\n    expect(q.dequeue()).toBe(200);\n    expect(q.length()).toBe(0);\n    expect(q.dequeue()).toBe(undefined);\n  });\n\n  test('isEmpty()', () => {\n    const q = new Queue();\n    expect(q.isEmpty()).toBeTruthy();\n    q.enqueue(100);\n    expect(q.isEmpty()).toBeFalsy();\n    q.dequeue();\n    expect(q.isEmpty()).toBeTruthy();\n  });\n\n  test('length()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    expect(q.length()).toBe(1);\n    q.enqueue(200);\n    expect(q.length()).toBe(2);\n    q.dequeue();\n    expect(q.length()).toBe(1);\n    q.enqueue(300);\n    expect(q.length()).toBe(2);\n  });\n\n  test('front()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    expect(q.front()).toBe(100);\n    q.enqueue(200);\n    expect(q.front()).toBe(100);\n    q.dequeue();\n    expect(q.front()).toBe(200);\n    q.enqueue(300);\n    expect(q.front()).toBe(200);\n    q.dequeue();\n    q.dequeue();\n    expect(q.front()).toBe(undefined);\n  });\n\n  test('back()', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    expect(q.back()).toBe(100);\n    q.enqueue(200);\n    expect(q.back()).toBe(200);\n    q.dequeue();\n    expect(q.back()).toBe(200);\n    q.enqueue(300);\n    expect(q.back()).toBe(300);\n    q.dequeue();\n    q.dequeue();\n    expect(q.back()).toBe(undefined);\n  });\n\n  test('integration', () => {\n    const q = new Queue();\n    q.enqueue(100);\n    expect(q.length()).toBe(1);\n    expect(q.dequeue()).toBe(100);\n    expect(q.length()).toBe(0);\n    q.enqueue(200);\n    expect(q.length()).toBe(1);\n    expect(q.dequeue()).toBe(200);\n  });\n});\n",
    "/src/queue.ts": "class Node<T> {\n  value: T | undefined;\n  next: Node<T> | null;\n  prev: Node<T> | null;\n\n  constructor(value?: T) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nexport default class Queue<T> {\n  _dummyHead: Node<T>;\n  _dummyTail: Node<T>;\n  _length: number;\n\n  constructor() {\n    this._dummyHead = new Node<T>();\n    this._dummyTail = new Node<T>();\n    this._dummyHead.prev = this._dummyTail;\n    this._dummyTail.next = this._dummyHead;\n    this._length = 0;\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   */\n  enqueue(item: T) {\n    const node = new Node(item);\n    const prevLast = this._dummyTail.next;\n    prevLast!.prev = node;\n\n    node.next = prevLast;\n    node.prev = this._dummyTail;\n    this._dummyTail.next = node;\n    this._length++;\n    return this._length;\n  }\n\n  /**\n   * Remove an item from the front of the queue.\n   */\n  dequeue(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const node = this._dummyHead.prev;\n    const newFirst = node!.prev;\n    this._dummyHead.prev = newFirst;\n    newFirst!.next = this._dummyHead;\n    // Unlink the node to be dequeued.\n    node!.prev = null;\n    node!.next = null;\n    this._length--;\n    return node!.value;\n  }\n\n  /**\n   * Determines if the queue is empty.\n   */\n  isEmpty(): boolean {\n    return this._length === 0;\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   */\n  front(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyHead.prev!.value;\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue it.\n   */\n  back(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyTail.next!.value;\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length(): number {\n    return this._length;\n  }\n}\n"
  },
  "info": {
    "excerpt": "Implement a queue data structure containing the common queue methods",
    "title": "Queue"
  },
  "metadata": {
    "access": "free",
    "author": "yangshun",
    "companies": [],
    "created": 1670457600,
    "difficulty": "medium",
    "duration": 15,
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/queue",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "stack"
    ],
    "slug": "queue",
    "subtitle": null,
    "topics": [
      "queue"
    ]
  },
  "skeleton": {
    "js": "export default class Queue {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   * @param {*} item The item to be pushed onto the queue.\n   * @return {number} The new length of the queue.\n   */\n  enqueue(item) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Removes an item from the front of the queue.\n   * @return {*} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  dequeue() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Determines if the queue is empty.\n   * @return {boolean} `true` if the queue has no items, `false` otherwise.\n   */\n  isEmpty() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   * @return {*} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  front() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue.\n   * @return {*} The item at the back of the queue if it is not empty, `undefined` otherwise.\n   */\n  back() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length() {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export default class Queue<T> {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   * @param {T} item The item to be pushed onto the queue.\n   * @return {number} The new length of the queue.\n   */\n  enqueue(item: T): number {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Removes an item from the front of the queue.\n   * @return {T | undefined} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  dequeue(): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Determines if the queue is empty.\n   * @return {boolean} `true` if the queue has no items, `false` otherwise.\n   */\n  isEmpty(): boolean {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   * @return {T | undefined} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  front(): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue.\n   * @return {T | undefined} The item at the back of the queue if it is not empty, `undefined` otherwise.\n   */\n  back(): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length(): number {\n    throw 'Not implemented!';\n  }\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var d=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var q=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),_=(n,e)=>{for(var i in e)d(n,i,{get:e[i],enumerable:!0})},r=(n,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let u of y(e))!g.call(n,u)&&u!==i&&d(n,u,{get:()=>e[u],enumerable:!(o=f(e,u))||o.enumerable});return n};var T=(n,e,i)=>(i=n!=null?p(q(n)):{},r(e||!n||!n.__esModule?d(i,\"default\",{value:n,enumerable:!0}):i,n)),w=n=>r(d({},\"__esModule\",{value:!0}),n);var s=v((j,h)=>{h.exports=_jsx_runtime});var N={};_(N,{default:()=>H});var t=T(s());var m=MDXCodeBlock;var l=`class Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nexport default class Queue {\n  constructor() {\n    this._dummyHead = new Node();\n    this._dummyTail = new Node();\n    this._dummyHead.prev = this._dummyTail;\n    this._dummyTail.next = this._dummyHead;\n    this._length = 0;\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   * @param {*} item The item to be pushed onto the queue.\n   * @return {number} The new length of the queue.\n   */\n  enqueue(item) {\n    const node = new Node(item);\n    const prevLast = this._dummyTail.next;\n    prevLast.prev = node;\n\n    node.next = prevLast;\n    node.prev = this._dummyTail;\n    this._dummyTail.next = node;\n    this._length++;\n    return this._length;\n  }\n\n  /**\n   * Remove an item from the front of the queue.\n   * @return {*} The item at the front of the queue if it is not empty, \\`undefined\\` otherwise.\n   */\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const node = this._dummyHead.prev;\n    const newFirst = node.prev;\n    this._dummyHead.prev = newFirst;\n    newFirst.next = this._dummyHead;\n    // Unlink the node to be dequeued.\n    node.prev = null;\n    node.next = null;\n    this._length--;\n    return node.value;\n  }\n\n  /**\n   * Determines if the queue is empty.\n   * @return {boolean} \\`true\\` if the queue has no items, \\`false\\` otherwise.\n   */\n  isEmpty() {\n    return this._length === 0;\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   * @return {*} The item at the front of the queue if it is not empty, \\`undefined\\` otherwise.\n   */\n  front() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyHead.prev.value;\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue it.\n   * @return {*} The item at the back of the queue if it is not empty, \\`undefined\\` otherwise.\n   */\n  back() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyTail.next.value;\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length() {\n    return this._length;\n  }\n}\n`;var a=`class Node<T> {\n  value: T | undefined;\n  next: Node<T> | null;\n  prev: Node<T> | null;\n\n  constructor(value?: T) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nexport default class Queue<T> {\n  _dummyHead: Node<T>;\n  _dummyTail: Node<T>;\n  _length: number;\n\n  constructor() {\n    this._dummyHead = new Node<T>();\n    this._dummyTail = new Node<T>();\n    this._dummyHead.prev = this._dummyTail;\n    this._dummyTail.next = this._dummyHead;\n    this._length = 0;\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   */\n  enqueue(item: T) {\n    const node = new Node(item);\n    const prevLast = this._dummyTail.next;\n    prevLast!.prev = node;\n\n    node.next = prevLast;\n    node.prev = this._dummyTail;\n    this._dummyTail.next = node;\n    this._length++;\n    return this._length;\n  }\n\n  /**\n   * Remove an item from the front of the queue.\n   */\n  dequeue(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const node = this._dummyHead.prev;\n    const newFirst = node!.prev;\n    this._dummyHead.prev = newFirst;\n    newFirst!.next = this._dummyHead;\n    // Unlink the node to be dequeued.\n    node!.prev = null;\n    node!.next = null;\n    this._length--;\n    return node!.value;\n  }\n\n  /**\n   * Determines if the queue is empty.\n   */\n  isEmpty(): boolean {\n    return this._length === 0;\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   */\n  front(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyHead.prev!.value;\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue it.\n   */\n  back(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyTail.next!.value;\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length(): number {\n    return this._length;\n  }\n}\n`;function c(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",img:\"img\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Queues should be implemented with linked lists which are essentially a chain of connected nodes. To simplify handling of linked list manipulation of empty queues, we make use of doubly-linked lists (nodes have both \",(0,t.jsx)(e.code,{children:\"prev\"}),\" and \",(0,t.jsx)(e.code,{children:\"next\"}),` pointers) and dummy/sentinel head/tail nodes. With the usage of dummy nodes, the linked list will never be \"empty\" and we don't have to separately handle the case of enqueuing into empty queues and dequeuing a queue with only one item.`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/queue/empty-queue.png\",alt:\"Empty Queue\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"enqueue()\"}),\"-ing involves creating a new \",(0,t.jsx)(e.code,{children:\"Node\"}),\" and adding it between the \",(0,t.jsx)(e.code,{children:\"_dummyTail\"}),\" node and \",(0,t.jsx)(e.code,{children:\"_dummyTail.next\"}),\" (which is \",(0,t.jsx)(e.code,{children:\"_dummyHead\"}),\" in the case of empty queues).\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/queue/enqueue-a.png\",alt:\"Enqueue one item\"})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/queue/enqueue-b.png\",alt:\"Enqueue second item\"})}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"dequeue()\"}),\"-ing involves removing the node between the \",(0,t.jsx)(e.code,{children:\"_dummyHead\"}),\" node and \",(0,t.jsx)(e.code,{children:\"_dummyHead.prev\"}),\". This should be a no-op if the queue is empty otherwise \",(0,t.jsx)(e.code,{children:\"_dummyTail\"}),\" will get dequeued.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/queue/dequeue.png\",alt:\"Dequeue\"})}),`\n`,(0,t.jsxs)(e.p,{children:[\"Since the time complexity of \",(0,t.jsx)(e.code,{children:\"length()\"}),\" has to be O(1) and counting the number of items in a linked list will take O(n), we need to separately track the number of items in the list with a \",(0,t.jsx)(e.code,{children:\"_length\"}),\" instance property and update it within the \",(0,t.jsx)(e.code,{children:\"enqueue()\"}),\" and \",(0,t.jsx)(e.code,{children:\"dequeue()\"}),\" methods.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Note that the autograder doesn't check if the time complexity of your \",(0,t.jsx)(e.code,{children:\"enqueue()\"}),\" and \",(0,t.jsx)(e.code,{children:\"dequeue()\"}),\" operations are O(1), but if you're only using a single JavaScript array to solve this question, then it's almost certainly not achieving O(1) time complexity for either of those operations.\"]}),`\n`,(0,t.jsx)(m,{languages:{jsx:l,tsx:a}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Calling \",(0,t.jsx)(e.code,{children:\"dequeue()\"}),\" on empty stacks.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Calling \",(0,t.jsx)(e.code,{children:\"front()\"}),\" on empty stacks.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Calling \",(0,t.jsx)(e.code,{children:\"back()\"}),\" on empty stacks.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Object-oriented programming.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Linked list manipulation.\"}),`\n`]})]})}function k(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(c,n)})):c(n)}var H=k;return w(N);})();\n;return Component;",
  "workspace": {
    "main": "/src/queue.ts",
    "run": "/src/queue.run.test.ts",
    "submit": "/src/queue.submit.test.ts"
  }
}