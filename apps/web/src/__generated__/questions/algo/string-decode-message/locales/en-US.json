{
  "description": "var Component=(()=>{var g=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},o=(t,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!f.call(t,r)&&r!==i&&s(t,r,{get:()=>e[r],enumerable:!(d=u(e,r))||d.enumerable});return t};var y=(t,e,i)=>(i=t!=null?g(x(t)):{},o(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),j=t=>o(s({},\"__esModule\",{value:!0}),t);var c=b((C,a)=>{a.exports=_jsx_runtime});var _={};w(_,{default:()=>T,frontmatter:()=>B});var n=y(c());var l=MDXTestExamples;var h=[{input:[[\"str\",\"225\"]],output:3,explanation:\"'225' can be decoded as 'BY' (2 26), 'VE' (22 5), or 'BBE' (2 2 5).\"},{input:[[\"str\",\"10\"]],output:1,explanation:\"'10' can be decoded as 'J' (10).\"},{input:[[\"str\",\"1106\"]],output:1,explanation:\"'1106' can be decoded as 'AJF' (1 10 6). The grouping (11 06) is invalid because '06' is not a valid code.\"}];var B={title:\"Decode Message\",excerpt:\"Implement a function to count ways to decode a numeric string\"};function p(t){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h3:\"h3\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"A secret message is encoded as a string of digits, where each digit or pair of digits represents a letter according to the following mapping:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"'1' \\u2192 'A', '2' \\u2192 'B', ..., '26' \\u2192 'Z'\"})}),`\n`,(0,n.jsx)(e.p,{children:'The message can be decoded in multiple ways depending on how the digits are grouped. For example, the string \"226\" can be interpreted as:'}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:`\"2 26\" \\u2192 'BZ'`}),`\n`,(0,n.jsx)(e.li,{children:`\"22 6\" \\u2192 'VF'`}),`\n`,(0,n.jsx)(e.li,{children:`\"2 2 6\" \\u2192 'BBF'`}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Given a string \",(0,n.jsx)(e.code,{children:\"str\"}),\" that contains only digits, find out how many ways it can be decoded. If the string cannot be decoded in any valid way, return \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str: string\"}),\": String consisting only of digits to decode\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The test cases are designed so that the answer fits within a 32-bit integer\"}),`\n`,(0,n.jsx)(e.li,{children:\"There may be strings that are impossible to decode\"}),`\n`,(0,n.jsx)(e.li,{children:'Not all digit groupings are valid. For example, \"06\" is invalid since numbers cannot have leading zeros'}),`\n`]}),`\n`,(0,n.jsx)(l,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"str.length\"}),\" <= 100\"]}),`\n`]})]})}function F(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var T=F;return j(_);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to count ways to decode a numeric string",
    "title": "Decode Message"
  },
  "solution": "var Component=(()=>{var g=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var t in e)o(n,t,{get:e[t],enumerable:!0})},s=(n,e,t,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!w.call(n,r)&&r!==t&&o(n,r,{get:()=>e[r],enumerable:!(d=f(e,r))||d.enumerable});return n};var T=(n,e,t)=>(t=n!=null?g(y(n)):{},s(e||!n||!n.__esModule?o(t,\"default\",{value:n,enumerable:!0}):t,n)),I=n=>s(o({},\"__esModule\",{value:!0}),n);var h=v((W,l)=>{l.exports=_jsx_runtime});var k={};x(k,{default:()=>O});var i=T(h());var c=MDXCodeBlock;var a=`export default function decodeMessage(str: string): number {\n  // DP array to store the subproblem results\n  const dp: number[] = new Array(str.length + 1).fill(0);\n\n  // Base case: There's one way to decode an empty string\n  dp[0] = 1;\n\n  // Ways to decode a string of size 1 is 1, unless the string is '0'\n  dp[1] = str[0] === '0' ? 0 : 1;\n\n  // Iterate through the string to fill the DP array\n  for (let i = 2; i <= str.length; i++) {\n    // Check if successful single digit decode is possible\n    if (str[i - 1] !== '0') {\n      dp[i] += dp[i - 1];\n    }\n\n    // Check if successful two-digit decode is possible\n    const twoDigit = parseInt(str.substring(i - 2, i), 10);\n    if (twoDigit >= 10 && twoDigit <= 26) {\n      dp[i] += dp[i - 2];\n    }\n  }\n\n  // The last element in the DP array contains the number of ways to decode the entire string\n  return dp[str.length];\n}\n`;var u=`// Recursive function with memoization to count the number of ways to decode a string\nfunction recursiveWithMemo(\n  index: number, // Current index in the string\n  str: string, // The input string to decode\n  memo: Map<number, number>, // Memoization map to store previously computed results\n): number {\n  // If the result for the current index is already computed, return it from the memo\n  if (memo.has(index)) {\n    return memo.get(index)!;\n  }\n  // If the current index has reached the end of the string, return 1 (valid decode)\n  if (index === str.length) {\n    return 1;\n  }\n  // If the current character is '0', return 0 (no valid decode)\n  if (str.charAt(index) === '0') {\n    return 0;\n  }\n  // If the current index is the last character, return 1 (single valid decode)\n  if (index === str.length - 1) {\n    return 1;\n  }\n\n  // Initialize the answer by decoding one character\n  let ans = recursiveWithMemo(index + 1, str, memo);\n\n  // Check if the next two characters form a valid number <= 26 and decode it\n  if (parseInt(str.substring(index, index + 2)) <= 26) {\n    ans += recursiveWithMemo(index + 2, str, memo);\n  }\n\n  // Store the computed result in the memo map\n  memo.set(index, ans);\n  return ans;\n}\n\nexport default function decodeMessage(str: string): number {\n  let memo = new Map<number, number>();\n  return recursiveWithMemo(0, str, memo);\n}\n`;var m=`export default function decodeMessage(str: string): number {\n  // Handle edge case: empty string\n  if (str.length === 0) return 0;\n\n  // Variables to store the last two results\n  let prev = 1; // Represents dp[i-2], initialized for empty string\n  let curr = str[0] === '0' ? 0 : 1; // Represents dp[i-1]\n\n  // Iterate through the string\n  for (let i = 2; i <= str.length; i++) {\n    let temp = 0; // Temporarily store the current dp[i]\n\n    // Check if successful single-digit decode is possible\n    if (str[i - 1] !== '0') {\n      temp += curr;\n    }\n\n    // Check if successful two-digit decode is possible\n    const twoDigit = parseInt(str.substring(i - 2, i), 10);\n    if (twoDigit >= 10 && twoDigit <= 26) {\n      temp += prev;\n    }\n\n    // Update prev and curr for the next iteration\n    prev = curr;\n    curr = temp;\n  }\n\n  // The last value of curr contains the result\n  return curr;\n}\n`;function p(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"1. Top-Down Dynamic Programming\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The problem of decoding a string into possible letter combinations can be visualized as navigating a decision tree. Each step in the string offers two choices: decode a single character or decode two characters (if they form a valid number between \",(0,i.jsx)(e.code,{children:\"10\"}),\" and \",(0,i.jsx)(e.code,{children:\"26\"}),\"). The goal is to count all valid decoding paths from the beginning to the end of the string.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Using a brute force recursive approach leads to redundant calculations because the same subproblem (e.g., decoding a substring starting at a specific index) is solved multiple times. This redundancy can be avoided by storing results of previously computed subproblems in a memoization map. The memoized solution optimally navigates the decision tree, ensuring each subproblem is solved only once, significantly improving efficiency.\"}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Define a recursive function \",(0,i.jsx)(e.code,{children:\"recursiveWithMemo\"}),\" that:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Takes the current index, the input string, and a memoization map as arguments.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Checks if the result for the current index exists in the \",(0,i.jsx)(e.code,{children:\"memo\"}),\" and returns it if found.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Returns \",(0,i.jsx)(e.code,{children:\"1\"}),\" if the index reaches the end of the string (valid decode).\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Returns \",(0,i.jsx)(e.code,{children:\"0\"}),\" if the current character is \",(0,i.jsx)(e.code,{children:\"'0'\"}),\" (invalid decode).\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Returns \",(0,i.jsx)(e.code,{children:\"1\"}),\" if the current index points to the last character (valid decode).\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize a variable \",(0,i.jsx)(e.code,{children:\"ans\"}),\" with the result of decoding the single character at the current index by calling \",(0,i.jsx)(e.code,{children:\"recursiveWithMemo\"}),\" with \",(0,i.jsx)(e.code,{children:\"index + 1\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Check if the next two characters form a valid number between \",(0,i.jsx)(e.code,{children:\"10\"}),\" and \",(0,i.jsx)(e.code,{children:\"26\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If valid, add the result of decoding two characters by calling \",(0,i.jsx)(e.code,{children:\"recursiveWithMemo\"}),\" with \",(0,i.jsx)(e.code,{children:\"index + 2\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Store the computed result for the current index in the \",(0,i.jsx)(e.code,{children:\"memo\"}),\" map.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Return the value stored in \",(0,i.jsx)(e.code,{children:\"memo\"}),\" for the current index.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Implement a wrapper function \",(0,i.jsx)(e.code,{children:\"decodeMessage\"}),\" that:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initializes an empty \",(0,i.jsx)(e.code,{children:\"Map\"}),\" for memoization.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Calls \",(0,i.jsx)(e.code,{children:\"recursiveWithMemo\"}),\" with the initial index \",(0,i.jsx)(e.code,{children:\"0\"}),\" and the input string.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(c,{children:u}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each index is processed only once due to memoization.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,i.jsx)(e.code,{children:\"Map\"}),\" stores up to \",(0,i.jsx)(e.code,{children:\"n\"}),\" entries, and the recursion stack requires O(n) space in the worst case.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{children:\"2. Bottom-Up Dynamic Programming\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Instead of solving subproblems recursively, this approach iteratively computes the number of ways to decode the string by using results from smaller substrings. The intuition is to maintain a \",(0,i.jsx)(e.code,{children:\"dp\"}),\" array where each entry represents the number of ways to decode the substring up to that index.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"This approach avoids the overhead of recursion and memoization by iteratively filling the \",(0,i.jsx)(e.code,{children:\"dp\"}),\" array in a single pass. The iterative nature ensures that each subproblem is solved only once, significantly optimizing both time and space.\"]}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize a \",(0,i.jsx)(e.code,{children:\"dp\"}),\" array of size \",(0,i.jsx)(e.code,{children:\"str.length + 1\"}),\" with all values set to \",(0,i.jsx)(e.code,{children:\"0\"}),\".\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Set \",(0,i.jsx)(e.code,{children:\"dp[0]\"}),\" to \",(0,i.jsx)(e.code,{children:\"1\"}),\" since there is one way to decode an empty string.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Set \",(0,i.jsx)(e.code,{children:\"dp[1]\"}),\" to \",(0,i.jsx)(e.code,{children:\"1\"}),\" if the first character is not \",(0,i.jsx)(e.code,{children:\"'0'\"}),\", otherwise set it to \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Iterate from index \",(0,i.jsx)(e.code,{children:\"2\"}),\" to \",(0,i.jsx)(e.code,{children:\"str.length\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If the current character is not \",(0,i.jsx)(e.code,{children:\"'0'\"}),\", add \",(0,i.jsx)(e.code,{children:\"dp[i - 1]\"}),\" to \",(0,i.jsx)(e.code,{children:\"dp[i]\"}),\" for single-digit decoding.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Extract the last two characters as a two-digit number. If it is between \",(0,i.jsx)(e.code,{children:\"10\"}),\" and \",(0,i.jsx)(e.code,{children:\"26\"}),\", add \",(0,i.jsx)(e.code,{children:\"dp[i - 2]\"}),\" to \",(0,i.jsx)(e.code,{children:\"dp[i]\"}),\" for two-digit decoding.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Return the value in \",(0,i.jsx)(e.code,{children:\"dp[str.length]\"}),\", which represents the number of ways to decode the entire string.\"]}),`\n`]}),`\n`,(0,i.jsx)(c,{children:a}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm iterates through the string once.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,i.jsx)(e.code,{children:\"dp\"}),\" array stores intermediate results for each index of the string.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{children:\"3. Bottom-Up Dynamic Programming With Constant Space\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"This solution improves the bottom-up dynamic programming approach by reducing the space complexity to O(1). Instead of maintaining a \",(0,i.jsx)(e.code,{children:\"dp\"}),\" array to store the results for all indices, this approach keeps track of only the last two results (\",(0,i.jsx)(e.code,{children:\"dp[i-2]\"}),\" and \",(0,i.jsx)(e.code,{children:\"dp[i-1]\"}),\"). This optimization is possible because the number of ways to decode a string at any position depends only on the results of the previous two positions.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"The previous bottom-up solution used an array that required O(n) space. By replacing the array with two variables, this solution reduces space usage without affecting the correctness or time complexity. This improvement is particularly useful when processing large strings.\"}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Handle the edge case where the string is empty by returning \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize two variables:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"prev\"}),\" to represent \",(0,i.jsx)(e.code,{children:\"dp[i-2]\"}),\", set to \",(0,i.jsx)(e.code,{children:\"1\"}),\" for the base case of an empty string.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"curr\"}),\" to represent \",(0,i.jsx)(e.code,{children:\"dp[i-1]\"}),\", set to \",(0,i.jsx)(e.code,{children:\"1\"}),\" if the first character is not \",(0,i.jsx)(e.code,{children:\"'0'\"}),\", otherwise set to \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Iterate from index \",(0,i.jsx)(e.code,{children:\"2\"}),\" to \",(0,i.jsx)(e.code,{children:\"str.length\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize a temporary variable \",(0,i.jsx)(e.code,{children:\"temp\"}),\" to store the current result.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"If the current character is not \",(0,i.jsx)(e.code,{children:\"'0'\"}),\", add \",(0,i.jsx)(e.code,{children:\"curr\"}),\" to \",(0,i.jsx)(e.code,{children:\"temp\"}),\" for single-digit decoding.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Extract the last two characters as a two-digit number. If it is between \",(0,i.jsx)(e.code,{children:\"10\"}),\" and \",(0,i.jsx)(e.code,{children:\"26\"}),\", add \",(0,i.jsx)(e.code,{children:\"prev\"}),\" to \",(0,i.jsx)(e.code,{children:\"temp\"}),\" for two-digit decoding.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Update \",(0,i.jsx)(e.code,{children:\"prev\"}),\" to \",(0,i.jsx)(e.code,{children:\"curr\"}),\" and \",(0,i.jsx)(e.code,{children:\"curr\"}),\" to \",(0,i.jsx)(e.code,{children:\"temp\"}),\" for the next iteration.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Return the value of \",(0,i.jsx)(e.code,{children:\"curr\"}),\", which contains the number of ways to decode the entire string.\"]}),`\n`]}),`\n`,(0,i.jsx)(c,{children:m}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The solution iterates through the string once.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". Only two variables are used to store intermediate results.\"]}),`\n`]})]})}function C(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(p,n)})):p(n)}var O=C;return I(k);})();\n;return Component;"
}