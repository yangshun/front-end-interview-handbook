{
  "description": "var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var k=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=>{for(var t in e)l(i,t,{get:e[t],enumerable:!0})},r=(i,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of f(e))!g.call(i,s)&&s!==t&&l(i,s,{get:()=>e[s],enumerable:!(o=m(e,s))||o.enumerable});return i};var L=(i,e,t)=>(t=i!=null?u(x(i)):{},r(e||!i||!i.__esModule?l(t,\"default\",{value:i,enumerable:!0}):t,i)),y=i=>r(l({},\"__esModule\",{value:!0}),i);var a=k((M,d)=>{d.exports=_jsx_runtime});var C={};b(C,{default:()=>j,frontmatter:()=>N});var n=L(a());var c=MDXTestExamples;var h=[{input:[[\"lists\",[[10,20,30],[5,15,25],[2,12,22]]]],output:[2,5,10,12,15,20,22,25,30],explanation:\"The lists are combined into a single sorted list with elements in increasing order.\"},{input:[[\"lists\",[[1],[3],[2]]]],output:[1,2,3],explanation:\"Each list contains a single element, so they are combined into a sorted list.\"},{input:[[\"lists\",[[1,2,3],[4,5,6],[7,8,9]]]],output:[1,2,3,4,5,6,7,8,9],explanation:\"All lists are already in ascending order and combined directly.\"}];var N={title:\"Linked Lists Combine K Sorted\",excerpt:\"Implement a function to combine k sorted linked lists\"};function p(i){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",strong:\"strong\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Linked_list\",children:\"linked lists\"}),\", \",(0,n.jsx)(e.code,{children:\"lists\"}),\", where each linked list's node values are in \",(0,n.jsx)(e.strong,{children:\"ascending order\"}),\", combine all these linked lists into a single sorted linked list and return the head node of the combined linked list.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The linked list is represented by a sequence of \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\"s, where each node points to the next node in the sequence, or \",(0,n.jsx)(e.code,{children:\"null\"}),\" if it is the last node.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"lists: ListNode[]\"}),\": Array of head nodes of linked lists. Examples display each linked list as an array of values within the list\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"lists.length\"}),\" <= 100\"]}),`\n`,(0,n.jsx)(e.li,{children:\"0 <= Number of nodes per list <= 100\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10,000 <= \",(0,n.jsx)(e.code,{children:\"ListNode.val\"}),\" <= 10,000\"]}),`\n`]})]})}function _(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(p,i)})):p(i)}var j=_;return y(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to combine k sorted linked lists",
    "title": "Linked Lists Combine K Sorted"
  },
  "solution": "var Component=(()=>{var p=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var i in e)r(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of f(e))!v.call(t,l)&&l!==i&&r(t,l,{get:()=>e[l],enumerable:!(d=g(e,l))||d.enumerable});return t};var k=(t,e,i)=>(i=t!=null?p(b(t)):{},s(e||!t||!t.__esModule?r(i,\"default\",{value:t,enumerable:!0}):i,t)),w=t=>s(r({},\"__esModule\",{value:!0}),t);var a=y((A,h)=>{h.exports=_jsx_runtime});var T={};x(T,{default:()=>M});var n=k(a());var o=MDXCodeBlock;var c=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function linkedListCombineKSorted(\n  lists: (ListNode | null)[],\n): ListNode | null {\n  let amount: number = lists.length; // Number of lists to combine\n  let interval: number = 1; // Interval for merging lists in pairs\n\n  // Continue combining in pairs, doubling the interval each time\n  while (interval < amount) {\n    // Merge lists in pairs\n    for (let i = 0; i < amount - interval; i += interval * 2) {\n      lists[i] = merge2Lists(lists[i], lists[i + interval]);\n    }\n    interval *= 2; // Double the interval\n  }\n\n  return amount > 0 ? lists[0] : null; // Return the combined list or null if there are no lists\n}\n\n// Helper function to combine two sorted linked lists\nfunction merge2Lists(\n  l1: ListNode | null,\n  l2: ListNode | null,\n): ListNode | null {\n  let head: ListNode = { val: 0, next: null }; // Dummy node to simplify the combining process\n  let point: ListNode = head; // Pointer to build the new combined list\n\n  // Merge the two lists while both are non-empty\n  while (l1 && l2) {\n    if (l1.val <= l2.val) {\n      point.next = l1; // Link the smaller node in the first list to the combined list\n      l1 = l1.next; // Move to the next node in the first list\n    } else {\n      point.next = l2; // Link the smaller node in the second list to the combined list\n      l2 = l1; // Move to the next node in the second list\n      l1 = point.next.next; // Correct the next pointer of l1\n    }\n    point = point.next; // Move to the next node in the combined list\n  }\n\n  // If one of the lists is empty, link the remaining nodes from the other list\n  if (!l1) {\n    point.next = l2;\n  } else {\n    point.next = l1;\n  }\n\n  return head.next; // Return the head of the combined list, skipping the dummy node\n}\n`;var m=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function linkedListCombineKSorted(\n  lists: (ListNode | null)[],\n): ListNode | null {\n  // Array to hold all node values from the linked lists\n  let nodes: number[] = [];\n\n  // Create a dummy node to serve as the starting point for the combined list\n  let dummy: ListNode = { val: 0, next: null };\n  let combinedHead: ListNode = dummy; // Head node to build the new combined list\n\n  // Traverse each linked list in the input array\n  lists.forEach((l) => {\n    // Traverse the current linked list\n    while (l) {\n      // Collect all node values in the array\n      nodes.push(l.val);\n      l = l.next; // Move to the next node in the current list\n    }\n  });\n\n  // Sort the collected node values in ascending order\n  nodes\n    .sort((a, b) => a - b)\n    .forEach((n) => {\n      // Create a new node with the sorted value and link it to the combined list\n      combinedHead.next = { val: n, next: null };\n      combinedHead = combinedHead.next; // Move the pointer to the newly added node\n    });\n\n  // Return the combined list, skipping the dummy node\n  return dummy.next;\n}\n`;function u(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute force approach\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"A naive approach is to extract all values from the \",(0,n.jsx)(e.code,{children:\"k\"}),\" linked lists into an array, sorts them, and reconstructs a new sorted linked list from the sorted array.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Create an empty array \",(0,n.jsx)(e.code,{children:\"nodes\"}),\" to store all the node values from the linked lists.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Create a dummy node to serve as the starting point for building the new linked list.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate over each linked list in the \",(0,n.jsx)(e.code,{children:\"lists\"}),\" array.\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Traverse the current linked list.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Append each node's value to the \",(0,n.jsx)(e.code,{children:\"nodes\"}),\" array.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Sort the \",(0,n.jsx)(e.code,{children:\"nodes\"}),\" array in ascending order.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate over the sorted \",(0,n.jsx)(e.code,{children:\"nodes\"}),\" array.\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Create a new node for each value and link it to the combined linked list.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Move the pointer to the newly added node.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the combined linked list, skipping the dummy node.\"}),`\n`]}),`\n`,(0,n.jsx)(o,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Extracting the values requires O(n), where \",(0,n.jsx)(e.code,{children:\"n\"}),\" is the total number of nodes in all \",(0,n.jsx)(e.code,{children:\"k\"}),\" linked lists. Sorting the array requires O(n log n).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". Additional space is used to store the \",(0,n.jsx)(e.code,{children:\"nodes\"}),\" array of size \",(0,n.jsx)(e.code,{children:\"n\"}),\" and the new linked list.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Divide and conquer approach\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Instead of trying to merge all \",(0,n.jsx)(e.code,{children:\"k\"}),\" lists in one step, the divide and conquer approach breaks the problem into smaller parts. Adjacent lists are merged in pairs, reducing the number of lists by half in each round.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This process can be visualized as building a binary tree. At the bottom level, each of the \",(0,n.jsx)(e.code,{children:\"k\"}),\" lists is treated as a separate node. At the next level, adjacent pairs of lists are merged to form \",(0,n.jsx)(e.code,{children:\"k/2\"}),\" merged lists. This pairing and merging continue until there is only one list remaining, which forms the root of the tree.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Each pairwise merge operation processes all the nodes in the two lists being merged. This ensures that no extra comparisons are made, leveraging the sorted order of the lists.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The number of levels in the merge process corresponds to the height of the binary tree, which is proportional to \",(0,n.jsx)(e.code,{children:\"log k\"}),\". This hierarchical reduction significantly reduces the number of comparisons compared to a brute force approach.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"amount\"}),\" as the number of linked lists to combine.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"interval\"}),\" to 1, which represents the pairwise merge distance.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"While \",(0,n.jsx)(e.code,{children:\"interval\"}),\" is less than \",(0,n.jsx)(e.code,{children:\"amount\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the \",(0,n.jsx)(e.code,{children:\"lists\"}),\" array, merging pairs of linked lists that are \",(0,n.jsx)(e.code,{children:\"interval\"}),\" apart.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Replace the first list in each pair with the merged result.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Double the \",(0,n.jsx)(e.code,{children:\"interval\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the first list in the \",(0,n.jsx)(e.code,{children:\"lists\"}),\" array if \",(0,n.jsx)(e.code,{children:\"amount\"}),\" is greater than 0; otherwise, return \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The helper function \",(0,n.jsx)(e.code,{children:\"merge2Lists\"}),\" performs the merging of two sorted linked lists:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Initialize a dummy node and a pointer to build the new combined list.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Traverse both input lists:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Compare the current nodes of both lists and append the smaller node to the combined list.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Move to the next node in the list from which the smaller node was chosen.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Attach any remaining nodes from the non-empty list to the combined list.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Return the combined list, skipping the dummy node.\"}),`\n`]}),`\n`,(0,n.jsx)(o,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log k)\"}),\". Each merge operation for two lists is O(n), where \",(0,n.jsx)(e.code,{children:\"n\"}),\" is the total number of nodes in the two lists. The number of merge levels is O(log k), where \",(0,n.jsx)(e.code,{children:\"k\"}),\" is the number of lists.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The merging process is performed in-place without requiring additional space beyond the pointers.\"]}),`\n`]})]})}function N(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var M=N;return w(T);})();\n;return Component;"
}