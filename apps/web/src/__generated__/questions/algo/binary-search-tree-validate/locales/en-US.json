{
  "description": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of T(e))!v.call(t,l)&&l!==r&&i(t,l,{get:()=>e[l],enumerable:!(o=f(e,l))||o.enumerable});return t};var w=(t,e,r)=>(r=t!=null?p(m(t)):{},a(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),g=t=>a(i({},\"__esModule\",{value:!0}),t);var h=b((C,s)=>{s.exports=_jsx_runtime});var _={};x(_,{default:()=>S,frontmatter:()=>B});var n=w(h());var d=MDXTestExamples;var c=[{input:[[\"root\",[10,5,15,1,8,12,20]]],output:!0,explanation:\"The tree is a valid BST because all nodes follow the BST properties.\"},{input:[[\"root\",[5,1,4,null,null,null,3]]],output:!1,explanation:\"The tree is not a valid BST because the node with value 3 is in the right subtree of the node with value 4, which violates the BST property.\"},{input:[[\"root\",[3,2,4,1,null,null,5]]],output:!0,explanation:\"The tree is a valid BST because all nodes follow the BST properties.\"}];var B={title:\"Validate Binary Search Tree\",excerpt:\"Implement a function to validate whether a binary tree is a valid binary search tree\"};function u(t){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",pre:\"pre\",h3:\"h3\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the \",(0,n.jsx)(e.code,{children:\"root\"}),\" of a binary tree, determine whether it is a valid binary search tree (BST).\"]}),`\n`,(0,n.jsx)(e.p,{children:\"For a tree to qualify as a valid BST, it must satisfy the following conditions:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The left subtree of a node only contains nodes with values less than the node's value\"}),`\n`,(0,n.jsx)(e.li,{children:\"The right subtree of a node only contains nodes with values greater than the node's value\"}),`\n`,(0,n.jsx)(e.li,{children:\"Both the left and right subtrees are also valid BSTs\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"root: TreeNode\"}),\": Root node of the tree. Examples display a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`]}),`\n`,(0,n.jsx)(d,{testCases:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 1000\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"-1,000,000 <= \",(0,n.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 1,000,000\"]}),`\n`]})]})}function N(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var S=N;return g(_);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to validate whether a binary tree is a valid binary search tree",
    "title": "Validate Binary Search Tree"
  },
  "solution": "var Component=(()=>{var p=Object.create;var r=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var b=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),y=(i,e)=>{for(var l in e)r(i,l,{get:e[l],enumerable:!0})},h=(i,e,l,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of m(e))!w.call(i,t)&&t!==l&&r(i,t,{get:()=>e[t],enumerable:!(d=f(e,t))||d.enumerable});return i};var T=(i,e,l)=>(l=i!=null?p(v(i)):{},h(e||!i||!i.__esModule?r(l,\"default\",{value:i,enumerable:!0}):l,i)),k=i=>h(r({},\"__esModule\",{value:!0}),i);var c=b((R,a)=>{a.exports=_jsx_runtime});var N={};y(N,{default:()=>A});var n=T(c());var o=MDXCodeBlock;var s=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binarySearchTreeValidate(\n  root: TreeNode | null,\n): boolean {\n  // Helper function to recursively check each node within the allowed range\n  function checkNodeInRange(\n    node: TreeNode | null,\n    minAllowed: number,\n    maxAllowed: number,\n  ): boolean {\n    // Base case: an empty node is a valid BST\n    if (node == null) {\n      return true;\n    }\n\n    // The current node's value must lie between minAllowed and maxAllowed\n    if (node.val <= minAllowed || node.val >= maxAllowed) {\n      return false;\n    }\n\n    // Recursively check the left and right subtrees with updated ranges\n    const isLeftValid = checkNodeInRange(node.left, minAllowed, node.val);\n    const isRightValid = checkNodeInRange(node.right, node.val, maxAllowed);\n\n    // Both left and right subtrees must be valid\n    return isLeftValid && isRightValid;\n  }\n\n  // Initial call with the entire range of valid values for a 32-bit signed integer\n  return checkNodeInRange(root, -Infinity, Infinity);\n}\n`;var u=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binarySearchTreeValidate(\n  root: TreeNode | null,\n): boolean {\n  // Stack to hold nodes during iterative traversal\n  const stack: (TreeNode | null | undefined)[] = [];\n  // Stack to hold the lower limits for node values\n  const lowerLimits: (number | null | undefined)[] = [];\n  // Stack to hold the upper limits for node values\n  const upperLimits: (number | null | undefined)[] = [];\n\n  function update(\n    node: TreeNode | null,\n    low?: number | null,\n    high?: number | null,\n  ) {\n    stack.push(node);\n    lowerLimits.push(low);\n    upperLimits.push(high);\n  }\n\n  // Initialize the stack with the root node and null limits\n  update(root, null, null);\n\n  // Iterate while there are nodes in the stack\n  while (stack.length > 0) {\n    // Pop the top node and its corresponding limits\n    const node = stack.pop()!;\n    const low = lowerLimits.pop();\n    const high = upperLimits.pop();\n\n    // If the node is null, continue to the next iteration\n    if (node === null) {\n      continue;\n    }\n\n    const val = node.val;\n\n    // Ensure low and high are defined before comparison\n    if (low != null && val <= low) {\n      return false; // Invalid if value is less than or equal to the lower limit\n    }\n    if (high != null && val >= high) {\n      return false; // Invalid if value is greater than or equal to the upper limit\n    }\n\n    // Push the right child with updated limits\n    update(node.right, val, high);\n\n    // Push the left child with updated limits\n    update(node.left, low, val);\n  }\n\n  // If no violations are found, return true\n  return true;\n}\n`;function g(i){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h3:\"h3\",ol:\"ol\",strong:\"strong\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Recursion\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem of validating a binary search tree (BST) ensures that for every node, the value of all nodes in the left subtree is smaller, and the value of all nodes in the right subtree is larger. This recursive approach leverages range checking to validate the BST property.\"}),`\n`,(0,n.jsx)(e.p,{children:\"For each node, a range is maintained:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The node's value must lie within the range defined by its ancestors.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"For the left child, the range is updated to \",(0,n.jsx)(e.code,{children:\"[minAllowed, node.val)\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For the right child, the range is updated to \",(0,n.jsx)(e.code,{children:\"(node.val, maxAllowed]\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The algorithm recursively checks each node, ensuring it lies within its allowable range. If any node violates the range constraint, the tree is not a valid BST.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The algorithm traverses each node exactly once and ensures correctness by propagating range constraints through recursive calls.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"checkNodeInRange\"}),\" that:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Takes a \",(0,n.jsx)(e.code,{children:\"node\"}),\", \",(0,n.jsx)(e.code,{children:\"minAllowed\"}),\", and \",(0,n.jsx)(e.code,{children:\"maxAllowed\"}),\" as arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the node and its subtrees satisfy the BST properties.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For each node:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the \",(0,n.jsx)(e.code,{children:\"node\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\", return \",(0,n.jsx)(e.code,{children:\"true\"}),\" (base case for recursion).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the \",(0,n.jsx)(e.code,{children:\"node.val\"}),\" is outside the range defined by \",(0,n.jsx)(e.code,{children:\"minAllowed\"}),\" and \",(0,n.jsx)(e.code,{children:\"maxAllowed\"}),\". If true, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Recursively validate the left subtree with the range \",(0,n.jsx)(e.code,{children:\"[minAllowed, node.val)\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Recursively validate the right subtree with the range \",(0,n.jsx)(e.code,{children:\"(node.val, maxAllowed]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" only if both left and right subtrees are valid.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Start the validation from the root node with the full range \",(0,n.jsx)(e.code,{children:\"[-Infinity, Infinity]\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the result of the helper function.\"}),`\n`]}),`\n`,(0,n.jsx)(o,{children:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node is visited exactly once.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The recursion stack requires space proportional to the height of the tree, where \",(0,n.jsx)(e.code,{children:\"h\"}),\" is the height of the BST.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Iteration\"}),`\n`,(0,n.jsx)(e.p,{children:\"The iterative approach for validating a binary search tree (BST) ensures that all nodes comply with the BST property: all values in the left subtree are less than the root, and all values in the right subtree are greater than the root. This solution uses a stack to manage nodes and their corresponding valid value ranges during traversal.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Each node is associated with a range (\",(0,n.jsx)(e.code,{children:\"low\"}),\" and \",(0,n.jsx)(e.code,{children:\"high\"}),\") representing the allowable values based on its ancestors.\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For the left child, the range is updated to \",(0,n.jsx)(e.code,{children:\"[low, node.val)\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For the right child, the range is updated to \",(0,n.jsx)(e.code,{children:\"(node.val, high]\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"A stack is used to maintain nodes yet to be validated along with their valid ranges. The iterative process avoids recursion and ensures that all nodes are validated in compliance with the BST rules.\"}),`\n`,(0,n.jsx)(e.p,{children:\"For each node, its value is compared with its assigned range. If the value violates the range constraints, the tree is invalid.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The algorithm processes each node exactly once and uses a stack to manage the traversal, making it both time and space-efficient.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize three stacks:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"stack\"}),\" to store nodes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"lowerLimits\"}),\" to store the lower range for each node.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"upperLimits\"}),\" to store the upper range for each node.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"update\"}),\" that:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Pushes a node along with its updated range (\",(0,n.jsx)(e.code,{children:\"low\"}),\", \",(0,n.jsx)(e.code,{children:\"high\"}),\") into the respective stacks.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Push the root node into the stack with initial limits of \",(0,n.jsx)(e.code,{children:\"null\"}),\" (no constraints).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"While \",(0,n.jsx)(e.code,{children:\"stack\"}),\" is not empty:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Pop the top node and its corresponding range (\",(0,n.jsx)(e.code,{children:\"low\"}),\", \",(0,n.jsx)(e.code,{children:\"high\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Skip if the node is \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Validate the node's value:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the value is less than or equal to \",(0,n.jsx)(e.code,{children:\"low\"}),\" or greater than or equal to \",(0,n.jsx)(e.code,{children:\"high\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"false\"}),\" if any condition is violated.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Push the right child into the stack with updated limits \",(0,n.jsx)(e.code,{children:\"[node.val, high]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Push the left child into the stack with updated limits \",(0,n.jsx)(e.code,{children:\"[low, node.val]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If no violations are found, return \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node is processed exactly once.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The stack holds up to \",(0,n.jsx)(e.code,{children:\"h\"}),\" nodes simultaneously, where \",(0,n.jsx)(e.code,{children:\"h\"}),\" is the height of the tree.\"]}),`\n`]})]})}function S(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(g,i)})):g(i)}var A=S;return k(N);})();\n;return Component;"
}