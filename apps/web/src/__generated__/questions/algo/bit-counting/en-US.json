{
  "description": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var y=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),g=(t,n)=>{for(var i in n)o(t,i,{get:n[i],enumerable:!0})},a=(t,n,i,s)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of m(n))!x.call(t,r)&&r!==i&&o(t,r,{get:()=>n[r],enumerable:!(s=b(n,r))||s.enumerable});return t};var j=(t,n,i)=>(i=t!=null?p(f(t)):{},a(n||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),_=t=>a(o({},\"__esModule\",{value:!0}),t);var d=y((X,c)=>{c.exports=_jsx_runtime});var w={};g(w,{default:()=>v,frontmatter:()=>T});var e=j(d());var l=MDXTestExamples;var u=[{input:[[\"n\",1]],output:[0,1],explanation:\"The number of set bits in 0 (binary: 0) is 0, and in 1 (binary: 1) is 1.\"},{input:[[\"n\",2]],output:[0,1,1],explanation:\"The number of set bits in 0 (binary: 0) is 0, in 1 (binary: 1) is 1, and in 2 (binary: 10) is 1.\"},{input:[[\"n\",3]],output:[0,1,1,2],explanation:\"The number of set bits in 0 (binary: 0) is 0, in 1 (binary: 1) is 1, in 2 (binary: 10) is 1, and in 3 (binary: 11) is 2.\"}];var T={title:\"Bit Counting\",excerpt:\"Implement a function to find number of set bits from 0 to n\"};function h(t){let n=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"Given a non-negative integer \",(0,e.jsx)(n.code,{children:\"n\"}),\", write a function that takes the non-negative integer \",(0,e.jsx)(n.code,{children:\"n\"}),\" and return an array \",(0,e.jsx)(n.code,{children:\"result\"}),\" of size \",(0,e.jsx)(n.code,{children:\"n + 1\"}),\" where \",(0,e.jsx)(n.code,{children:\"result[i]\"}),\" represents the number of active bits (set bits to 1) in the binary representation of the integer \",(0,e.jsx)(n.code,{children:\"i\"}),\" (where 0 <= \",(0,e.jsx)(n.code,{children:\"i\"}),\" <= \",(0,e.jsx)(n.code,{children:\"n\"}),\").\"]}),`\n`,(0,e.jsx)(n.h3,{children:\"Input\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"n: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,e.jsx)(l,{testCases:u}),`\n`,(0,e.jsx)(n.h3,{children:\"Constraints\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"0 <= \",(0,e.jsx)(n.code,{children:\"n\"}),\" <= 10,000\"]}),`\n`]})]})}function M(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(h,t)})):h(t)}var v=M;return _(w);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find number of set bits from 0 to n",
    "title": "Bit Counting"
  },
  "solution": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var w=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),v=(i,e)=>{for(var r in e)o(i,r,{get:e[r],enumerable:!0})},h=(i,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of f(e))!x.call(i,t)&&t!==r&&o(i,t,{get:()=>e[t],enumerable:!(l=g(e,t))||l.enumerable});return i};var T=(i,e,r)=>(r=i!=null?p(y(i)):{},h(e||!i||!i.__esModule?o(r,\"default\",{value:i,enumerable:!0}):r,i)),C=i=>h(o({},\"__esModule\",{value:!0}),i);var a=w((D,d)=>{d.exports=_jsx_runtime});var A={};v(A,{default:()=>k});var n=T(a());var c=MDXCodeBlock;var s=`export default function bitCounting(n: number): number[] {\n  // Initialize the counting result vector with 0s for all values from 0 to n\n  const counts: number[] = new Array(n + 1).fill(0);\n\n  // Build the table using dynamic programming\n  for (let i = 1; i <= n; i++) {\n    // Least significant bit (LSB) can be obtained using bitwise AND with 1\n    const leastSignificantBit = i & 1;\n    // Inherit the count from the previous even number (i / 2)\n    counts[i] = counts[Math.floor(i / 2)] + leastSignificantBit;\n  }\n\n  return counts;\n}\n`;var u=`export default function bitCounting(n: number): number[] {\n  // Initialize the counting answer vector with 0s for all values from 0 to n\n  const ans: number[] = new Array(n + 1).fill(0);\n  let x = 0;\n  let b = 1;\n\n  // Iterate through ranges [0, b), [b, 2b), ..., up to n\n  while (b <= n) {\n    // Generate values for [b, 2b) based on values from [0, b)\n    while (x < b && x + b <= n) {\n      ans[x + b] = ans[x] + 1;\n      ++x;\n    }\n    x = 0; // Reset x to start from the beginning\n    b <<= 1; // Double the range (b = 2b)\n  }\n\n  return ans;\n}\n`;var m=`export default function bitCounting(n: number): number[] {\n  const ans: number[] = [];\n\n  // Iterate through each number from 0 to n\n  for (let i = 0; i <= n; i++) {\n    // Count the number of 1s in the binary representation of i\n    let count = 0;\n    let num = i;\n\n    while (num > 0) {\n      count += num & 1; // Add the least significant bit\n      num >>= 1; // Right shift to process the next bit\n    }\n\n    ans.push(count);\n  }\n\n  return ans;\n}\n`;function b(i){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Population Count\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This approach uses a simple bitwise manipulation technique to compute the count of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s for each number. The key intuition is that the binary representation of a number can be processed bit by bit by examining its least significant bit and then right-shifting the number to examine the next bit. This process continues until the number becomes \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This approach iterates through all numbers from \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"n\"}),\" and processes each number in O(k) time, where \",(0,n.jsx)(e.code,{children:\"k\"}),\" is the number of bits in the number.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an empty array \",(0,n.jsx)(e.code,{children:\"ans\"}),\" to store the results.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through all numbers from \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"n\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Set a variable \",(0,n.jsx)(e.code,{children:\"count\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" to track the number of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s for the current number.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Assign the current number to a temporary variable \",(0,n.jsx)(e.code,{children:\"num\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use a \",(0,n.jsx)(e.code,{children:\"while\"}),\" loop to process the number:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Add the least significant bit (\",(0,n.jsx)(e.code,{children:\"num & 1\"}),\") to \",(0,n.jsx)(e.code,{children:\"count\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Right-shift the number by one position using \",(0,n.jsx)(e.code,{children:\"num >>= 1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Append \",(0,n.jsx)(e.code,{children:\"count\"}),\" to the \",(0,n.jsx)(e.code,{children:\"ans\"}),\" array.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the array \",(0,n.jsx)(e.code,{children:\"ans\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n.k)\"}),\". The algorithm processes each number from \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"n\"}),\", where \",(0,n.jsx)(e.code,{children:\"k\"}),\" is the number of bits in the binary representation of the number.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The array \",(0,n.jsx)(e.code,{children:\"ans\"}),\" stores the results for all numbers from \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"n\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Dynamic Programming and MSB\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The dynamic programming approach with the most significant bit improves efficiency by using previously computed results. The key intuition is that the number of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s in the binary representation of a number can be determined by adding \",(0,n.jsx)(e.code,{children:\"1\"}),\" to the count of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s in a number from a smaller range. Specifically, if \",(0,n.jsx)(e.code,{children:\"b\"}),\" is a power of 2, then any number in the range \",(0,n.jsx)(e.code,{children:\"[b, 2b)\"}),\" has the same bit pattern as a number in \",(0,n.jsx)(e.code,{children:\"[0, b)\"}),\" with an additional most significant bit set to \",(0,n.jsx)(e.code,{children:\"1\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This approach removes the need to repeatedly process each bit of every number, as in the naive solution. Instead, it dynamically builds the result by doubling the range and reusing previously computed counts, reducing redundant work.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an array \",(0,n.jsx)(e.code,{children:\"ans\"}),\" of size \",(0,n.jsx)(e.code,{children:\"n + 1\"}),\" with all values set to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"x\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" to \",(0,n.jsx)(e.code,{children:\"1\"}),\", where \",(0,n.jsx)(e.code,{children:\"b\"}),\" represents the current power of 2 range.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use a \",(0,n.jsx)(e.code,{children:\"while\"}),\" loop to process ranges:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"While \",(0,n.jsx)(e.code,{children:\"b\"}),\" is less than or equal to \",(0,n.jsx)(e.code,{children:\"n\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through numbers in the range \",(0,n.jsx)(e.code,{children:\"[b, 2b)\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each number \",(0,n.jsx)(e.code,{children:\"x + b\"}),\" within bounds, calculate the count of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s as \",(0,n.jsx)(e.code,{children:\"ans[x] + 1\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Increment \",(0,n.jsx)(e.code,{children:\"x\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Reset \",(0,n.jsx)(e.code,{children:\"x\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" and double \",(0,n.jsx)(e.code,{children:\"b\"}),\" to process the next range.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the array \",(0,n.jsx)(e.code,{children:\"ans\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each number is processed once as the range doubles incrementally.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"ans\"}),\" array requires space proportional to the input size \",(0,n.jsx)(e.code,{children:\"n\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"3. Using Dynamic Programming and LSB\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another solution uses least significant bit combined with dynamic programming approach to calculate the number of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s in the binary representation of integers from \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"n\"}),\". The key intuition is that the number of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s in a number \",(0,n.jsx)(e.code,{children:\"i\"}),\" can be derived from the number of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s in \",(0,n.jsx)(e.code,{children:\"i / 2\"}),\" (right-shifted value of \",(0,n.jsx)(e.code,{children:\"i\"}),\") and the least significant bit of \",(0,n.jsx)(e.code,{children:\"i\"}),\". The least significant bit can be determined using \",(0,n.jsx)(e.code,{children:\"i & 1\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an array \",(0,n.jsx)(e.code,{children:\"counts\"}),\" of size \",(0,n.jsx)(e.code,{children:\"n + 1\"}),\" with all values set to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through numbers from \",(0,n.jsx)(e.code,{children:\"1\"}),\" to \",(0,n.jsx)(e.code,{children:\"n\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Compute the least significant bit of the current number using \",(0,n.jsx)(e.code,{children:\"i & 1\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use the dynamic programming formula \",(0,n.jsx)(e.code,{children:\"counts[i] = counts[Math.floor(i / 2)] + least significant bit\"}),\" to compute the count of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the array \",(0,n.jsx)(e.code,{children:\"counts\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each number from \",(0,n.jsx)(e.code,{children:\"1\"}),\" to \",(0,n.jsx)(e.code,{children:\"n\"}),\" is processed exactly once, and the operations for each number are constant time.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The array \",(0,n.jsx)(e.code,{children:\"counts\"}),\" requires space proportional to the input size \",(0,n.jsx)(e.code,{children:\"n\"}),\".\"]}),`\n`]})]})}function S(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(b,i)})):b(i)}var k=S;return C(A);})();\n;return Component;"
}