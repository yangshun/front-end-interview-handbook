{
  "description": "var Component=(()=>{var p=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var k=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)l(t,i,{get:e[i],enumerable:!0})},d=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of f(e))!g.call(t,s)&&s!==i&&l(t,s,{get:()=>e[s],enumerable:!(o=m(e,s))||o.enumerable});return t};var w=(t,e,i)=>(i=t!=null?p(x(t)):{},d(e||!t||!t.__esModule?l(i,\"default\",{value:t,enumerable:!0}):i,t)),L=t=>d(l({},\"__esModule\",{value:!0}),t);var a=k((A,r)=>{r.exports=_jsx_runtime});var j={};b(j,{default:()=>_,frontmatter:()=>N});var n=w(a());var c=MDXTestExamples;var h=[{input:[[\"listA\",[-3,-1,9,10]],[\"listB\",[-10,3,4,6,9]]],output:[-10,-3,-1,3,4,6,9,9,10],explanation:\"Combining the sorted lists [-3, -1, 9, 10] and [-10, 3, 4, 6, 9] results in a single sorted list [-10, -3, -1, 3, 4, 6, 9, 9, 10].\"},{input:[[\"listA\",[1,2,4]],[\"listB\",[1,3,4]]],output:[1,1,2,3,4,4],explanation:\"Combining the sorted lists [1, 2, 4] and [1, 3, 4] results in a single sorted list [1, 1, 2, 3, 4, 4].\"},{input:[[\"listA\",[]],[\"listB\",[0]]],output:[0],explanation:\"Combining the empty list [] with the sorted list [0] results in the list [0].\"}];var N={title:\"Linked Lists Combine Two Sorted\",excerpt:\"Implement a function to combine two sorted linked list\"};function u(t){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",strong:\"strong\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Linked_list\",children:\"linked list\"}),\", \",(0,n.jsx)(e.code,{children:\"lists\"}),\", where each linked list's node values are in \",(0,n.jsx)(e.strong,{children:\"ascending order\"}),\", combine all these linked lists into a single sorted linked list and return the head node of the combined linked list.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The linked list is represented by a sequence of \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\"s, where each node points to the next node in the sequence, or \",(0,n.jsx)(e.code,{children:\"null\"}),\" if it is the last node.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"listA: ListNode\"}),\": Head node of the first linked list. Examples display each linked list as an array of values within the list\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"listB: ListNode\"}),\": Head node of the second linked list. Examples display each linked list as an array of values within the list\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 50\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"-100 <= \",(0,n.jsx)(e.code,{children:\"ListNode.val\"}),\" <= 100\"]}),`\n`]})]})}function y(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var _=y;return L(j);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to combine two sorted linked list",
    "title": "Linked Lists Combine Two Sorted"
  },
  "solution": "var Component=(()=>{var p=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,A=Object.prototype.hasOwnProperty;var x=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),B=(i,e)=>{for(var n in e)s(i,n,{get:e[n],enumerable:!0})},d=(i,e,n,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of g(e))!A.call(i,l)&&l!==n&&s(i,l,{get:()=>e[l],enumerable:!(r=f(e,l))||r.enumerable});return i};var b=(i,e,n)=>(n=i!=null?p(v(i)):{},d(e||!i||!i.__esModule?s(n,\"default\",{value:i,enumerable:!0}):n,i)),y=i=>d(s({},\"__esModule\",{value:!0}),i);var c=x((N,h)=>{h.exports=_jsx_runtime});var k={};B(k,{default:()=>C});var t=b(c());var o=MDXCodeBlock;var a=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function linkedListCombineTwoSorted(\n  listA: ListNode | null,\n  listB: ListNode | null,\n): ListNode | null {\n  // Dummy node to act as the previous node to the head of the combined list\n  let dummy: ListNode = { val: -1, next: null };\n\n  // Pointer to the last node in the combined list, initially set to dummy\n  let prev: ListNode = dummy;\n\n  // Iterate while both listA and listB are not null\n  while (listA !== null && listB !== null) {\n    // Compare the values of listA and listB nodes\n    if (listA.val <= listB.val) {\n      // If listA node is smaller or equal, add it to the combined list\n      prev.next = listA;\n      listA = listA.next; // Move to the next node in listA\n    } else {\n      // If listB node is smaller, add it to the combined list\n      prev.next = listB;\n      listB = listB.next; // Move to the next node in listB\n    }\n    // Move prev to the next node in the combined list\n    prev = prev.next!;\n  }\n\n  // At least one of listA and listB can still have nodes, add the remaining nodes to the combined list\n  if (listA !== null) {\n    prev.next = listA;\n  } else {\n    prev.next = listB;\n  }\n\n  // The combined list is next to the dummy node\n  return dummy.next;\n}\n`;var u=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function linkedListCombineTwoSorted(\n  listA: ListNode | null,\n  listB: ListNode | null,\n): ListNode | null {\n  // If listA is null, return listB because the combined list is just listB\n  if (listA === null) {\n    return listB;\n  }\n\n  // If listB is null, return listA because the combined list is just listA\n  if (listB === null) {\n    return listA;\n  }\n\n  // If listA's value is less than listB's value\n  if (listA.val < listB.val) {\n    // Recursively combine listA.next and listB, and set the next of listA to the combined list\n    listA.next = linkedListCombineTwoSorted(listA.next, listB);\n    // Return listA as the head of the combined list\n    return listA;\n  }\n\n  // If listB's value is less than or equal to listA's value\n  // Recursively combine listA and listB.next, and set the next of listB to the combined list\n  listB.next = linkedListCombineTwoSorted(listA, listB.next);\n\n  // Return listB as the head of the combined list\n  return listB;\n}\n`;function m(i){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Iterative Method\"}),`\n`,(0,t.jsx)(e.p,{children:\"The iterative approach for merging two sorted linked lists focuses on maintaining efficiency by using the already sorted nature of the input lists. The strategy involves traversing both lists simultaneously, comparing their current nodes, and building the combined list node by node. This ensures that the merged list remains sorted without requiring additional sorting steps.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Create a \",(0,t.jsx)(e.code,{children:\"dummy\"}),\" node with a placeholder value and set \",(0,t.jsx)(e.code,{children:\"prev\"}),\" to point to \",(0,t.jsx)(e.code,{children:\"dummy\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"While both \",(0,t.jsx)(e.code,{children:\"listA\"}),\" and \",(0,t.jsx)(e.code,{children:\"listB\"}),\" are non-\",(0,t.jsx)(e.code,{children:\"null\"}),\":\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Compare the current nodes of \",(0,t.jsx)(e.code,{children:\"listA\"}),\" and \",(0,t.jsx)(e.code,{children:\"listB\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Append the smaller node to the merged list by updating \",(0,t.jsx)(e.code,{children:\"prev.next\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Move the pointer of the list from which the smaller node was taken to its next node.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Update \",(0,t.jsx)(e.code,{children:\"prev\"}),\" to point to the last node in the merged list.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"After exiting the loop, append the remaining nodes of either \",(0,t.jsx)(e.code,{children:\"listA\"}),\" or \",(0,t.jsx)(e.code,{children:\"listB\"}),\" (whichever is non-\",(0,t.jsx)(e.code,{children:\"null\"}),\") to the merged list.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"dummy.next\"}),\", which points to the head of the merged list.\"]}),`\n`]}),`\n`,(0,t.jsx)(o,{children:a}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(m + n)\"}),\". Each node in both lists is processed exactly once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses only a constant amount of extra space.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Recursive Method\"}),`\n`,(0,t.jsx)(e.p,{children:\"The recursive approach for merging two sorted linked lists relies on using recursion to simplify the process of combining the lists. The strategy involves comparing the current nodes of the two lists and making recursive calls to merge the rest of the lists. This ensures that the merged list is built in a sorted order as the recursion is called.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"At each step, the algorithm compares the current nodes of \",(0,t.jsx)(e.code,{children:\"listA\"}),\" and \",(0,t.jsx)(e.code,{children:\"listB\"}),\". The smaller of the two nodes is chosen as the head of the merged list. This process is repeated recursively for the remaining nodes in the lists.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The recursion terminates when either \",(0,t.jsx)(e.code,{children:\"listA\"}),\" or \",(0,t.jsx)(e.code,{children:\"listB\"}),\" becomes \",(0,t.jsx)(e.code,{children:\"null\"}),\". At this point, the non-\",(0,t.jsx)(e.code,{children:\"null\"}),\" list is appended to the merged list since it is already sorted.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The recursive approach effectively reduces the problem size at each step by processing one node at a time. Each node is processed exactly once, ensuring that the algorithm is linear with respect to the total number of nodes.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Check if \",(0,t.jsx)(e.code,{children:\"listA\"}),\" is \",(0,t.jsx)(e.code,{children:\"null\"}),\". If it is, return \",(0,t.jsx)(e.code,{children:\"listB\"}),\" as the merged list.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Check if \",(0,t.jsx)(e.code,{children:\"listB\"}),\" is \",(0,t.jsx)(e.code,{children:\"null\"}),\". If it is, return \",(0,t.jsx)(e.code,{children:\"listA\"}),\" as the merged list.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Compare the values of the current nodes in \",(0,t.jsx)(e.code,{children:\"listA\"}),\" and \",(0,t.jsx)(e.code,{children:\"listB\"}),\".\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"listA.val\"}),\" is less than \",(0,t.jsx)(e.code,{children:\"listB.val\"}),\":\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Set \",(0,t.jsx)(e.code,{children:\"listA.next\"}),\" to the result of recursively merging \",(0,t.jsx)(e.code,{children:\"listA.next\"}),\" and \",(0,t.jsx)(e.code,{children:\"listB\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"listA\"}),\" as the head of the merged list.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"listB.val\"}),\" is less than or equal to \",(0,t.jsx)(e.code,{children:\"listA.val\"}),\":\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Set \",(0,t.jsx)(e.code,{children:\"listB.next\"}),\" to the result of recursively merging \",(0,t.jsx)(e.code,{children:\"listA\"}),\" and \",(0,t.jsx)(e.code,{children:\"listB.next\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"listB\"}),\" as the head of the merged list.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(o,{children:u}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(m + n)\"}),\". Each node in both lists is visited exactly once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(m + n)\"}),\". The recursion depth depends on the total number of nodes, which results in additional stack space proportional to \",(0,t.jsx)(e.code,{children:\"m + n\"}),\".\"]}),`\n`]})]})}function L(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(m,i)})):m(i)}var C=L;return y(k);})();\n;return Component;"
}