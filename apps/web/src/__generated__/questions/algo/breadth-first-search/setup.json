{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/breadth-first-search\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/breadth-first-search.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/breadth-first-search.run.test.ts": "import breadthFirstSearch from './breadth-first-search';\n\ndescribe('breadthFirstSearch', () => {\n  test('single node graph', () => {\n    expect(breadthFirstSearch({ A: [] }, 'A')).toEqual(['A']);\n  });\n\n  test('two node graph', () => {\n    expect(breadthFirstSearch({ A: ['B'], B: [] }, 'A')).toEqual(['A', 'B']);\n  });\n\n  test('multiple node graph', () => {\n    const graph = {\n      A: ['B', 'C'],\n      B: ['D', 'E'],\n      C: ['F', 'G'],\n      D: [],\n      E: [],\n      F: [],\n      G: [],\n    };\n    expect(breadthFirstSearch(graph, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n      'D',\n      'E',\n      'F',\n      'G',\n    ]);\n  });\n});\n",
    "/src/breadth-first-search.submit.test.ts": "import breadthFirstSearch from './breadth-first-search';\n\ndescribe('breadthFirstSearch', () => {\n  test('empty graph', () => {\n    expect(breadthFirstSearch({}, '')).toEqual([]);\n  });\n\n  test('graphs with one node', () => {\n    expect(breadthFirstSearch({ A: [] }, 'A')).toEqual(['A']);\n  });\n\n  test('graphs with two nodes', () => {\n    expect(breadthFirstSearch({ A: ['B'], B: [] }, 'A')).toEqual(['A', 'B']);\n    expect(breadthFirstSearch({ A: ['A', 'B'], B: [] }, 'A')).toEqual([\n      'A',\n      'B',\n    ]);\n    expect(breadthFirstSearch({ A: ['A', 'B'], B: [] }, 'B')).toEqual(['B']);\n    expect(breadthFirstSearch({ A: ['A', 'B'], B: ['A'] }, 'B')).toEqual([\n      'B',\n      'A',\n    ]);\n  });\n\n  test('graphs with multiple nodes', () => {\n    expect(breadthFirstSearch({ A: ['B'], B: ['C'], C: [] }, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(breadthFirstSearch({ A: ['B', 'C'], B: [], C: [] }, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(\n      breadthFirstSearch(\n        { A: ['B', 'C'], B: [], C: [], D: ['B'], E: ['C'] },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'C']);\n    expect(\n      breadthFirstSearch(\n        { A: ['D', 'E'], B: [], C: [], D: ['B'], E: ['C'] },\n        'A',\n      ),\n    ).toEqual(['A', 'D', 'E', 'B', 'C']);\n    expect(\n      breadthFirstSearch(\n        {\n          A: ['D', 'E'],\n          B: ['A', 'B', 'C', 'D', 'E'],\n          C: [],\n          D: ['B'],\n          E: ['C'],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'D', 'E', 'B', 'C']);\n    // Graph taken from https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/\n    const graph = {\n      A: ['B', 'C'],\n      B: ['A', 'D', 'E'],\n      C: ['A', 'E'],\n      D: ['B', 'E', 'F'],\n      E: ['B', 'C', 'D', 'F'],\n      F: ['D', 'E'],\n    };\n    expect(breadthFirstSearch(graph, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n      'D',\n      'E',\n      'F',\n    ]);\n    expect(breadthFirstSearch(graph, 'B')).toEqual([\n      'B',\n      'A',\n      'D',\n      'E',\n      'C',\n      'F',\n    ]);\n    expect(breadthFirstSearch(graph, 'C')).toEqual([\n      'C',\n      'A',\n      'E',\n      'B',\n      'D',\n      'F',\n    ]);\n    expect(breadthFirstSearch(graph, 'D')).toEqual([\n      'D',\n      'B',\n      'E',\n      'F',\n      'A',\n      'C',\n    ]);\n  });\n\n  test('disjoint graphs', () => {\n    const disjoinGraph = { A: ['B'], B: [], C: [], D: ['C'] };\n    expect(breadthFirstSearch(disjoinGraph, 'A')).toEqual(['A', 'B']);\n    expect(breadthFirstSearch(disjoinGraph, 'C')).toEqual(['C']);\n    expect(breadthFirstSearch(disjoinGraph, 'D')).toEqual(['D', 'C']);\n  });\n\n  test('cyclic graphs', () => {\n    expect(breadthFirstSearch({ A: ['A'] }, 'A')).toEqual(['A']);\n    const cyclicGraphOne = {\n      A: ['B', 'C', 'D'],\n      B: ['E', 'F'],\n      C: ['G', 'H'],\n      D: ['I', 'J'],\n      E: ['D'],\n      F: [],\n      G: [],\n      H: [],\n      I: [],\n      J: [],\n    };\n    const cyclicGraphTwo = {\n      A: ['B', 'C'],\n      B: ['D', 'E'],\n      C: ['F', 'G'],\n      D: [],\n      E: [],\n      F: [],\n      G: [],\n    };\n    expect(breadthFirstSearch(cyclicGraphOne, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n      'D',\n      'E',\n      'F',\n      'G',\n      'H',\n      'I',\n      'J',\n    ]);\n    expect(breadthFirstSearch(cyclicGraphOne, 'B')).toEqual([\n      'B',\n      'E',\n      'F',\n      'D',\n      'I',\n      'J',\n    ]);\n    expect(breadthFirstSearch(cyclicGraphTwo, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n      'D',\n      'E',\n      'F',\n      'G',\n    ]);\n    expect(breadthFirstSearch(cyclicGraphTwo, 'E')).toEqual(['E']);\n  });\n});\n",
    "/src/breadth-first-search.ts": "export default function breadthFirstSearch(\n  graph: Record<string, Array<string>>,\n  source: string,\n): Array<string> {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Create a queue to store the nodes to be visited.\n  // Add the root node since we're doing a level-order BFS.\n  const queue = new Queue<string>();\n  queue.enqueue(source);\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set<string>();\n\n  // While there are nodes to visit.\n  while (!queue.isEmpty()) {\n    // Dequeue the node at the front of the queue.\n    const node = queue.dequeue()!;\n\n    // Mark the node as visited.\n    visited.add(node);\n\n    // Enqueue the neighbors of the current node.\n    graph[node].forEach((neighbor) => {\n      // Skip nodes that have already been visited.\n      if (visited.has(neighbor)) {\n        return;\n      }\n\n      queue.enqueue(neighbor);\n    });\n  }\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n\n/*  Auxiliary classes */\n\n/**\n * A Queue class with O(1) enqueue and dequeue is provided for you.\n * You can use it directly should you wish to.\n *\n * Example usage:\n * const q = new Queue();\n * q.enqueue('a');\n * q.enqueue('b');\n * q.dequeue(); //'a'\n * q.isEmpty(); // False\n */\nclass Node<T> {\n  value: T;\n  next: Node<T> | null;\n\n  constructor(value: T) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass Queue<T> {\n  head: Node<T> | null;\n  tail: Node<T> | null;\n  length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  enqueue(item: T): void {\n    const newNode = new Node(item);\n    if (this.isEmpty()) {\n      this.head = newNode;\n    } else if (this.tail) {\n      this.tail.next = newNode;\n    }\n    this.tail = newNode;\n    this.length++;\n  }\n\n  dequeue(): T | null {\n    if (this.isEmpty() || !this.head) {\n      return null;\n    } else {\n      const removedNode = this.head;\n      this.head = this.head.next;\n      removedNode.next = null;\n      this.length--;\n      if (this.isEmpty()) {\n        this.tail = null;\n      }\n      return removedNode.value;\n    }\n  }\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Record<string, Array<string>} graph The adjacency list representing the graph.\n * @param {string} source The source node to start traversal from. Has to be a valid node if graph is non-empty.\n * @return {Array<string>} A BFS-traversed order of nodes.\n */\nexport default function breadthFirstSearch(graph, source) {\n  throw 'Not implemented!';\n}\n\n/*  Auxiliary classes */\n\n/**\n * A Queue class with O(1) enqueue and dequeue is provided for you.\n * You can use it directly should you wish to.\n *\n * Example usage:\n * const q = new Queue();\n * q.enqueue('a');\n * q.enqueue('b');\n * q.dequeue(); //'a'\n * q.isEmpty(); // False\n */\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass Queue {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  isEmpty() {\n    return this.length === 0;\n  }\n\n  enqueue(item) {\n    const newNode = new Node(item);\n    if (this.isEmpty()) {\n      this.head = newNode;\n    } else if (this.tail) {\n      this.tail.next = newNode;\n    }\n    this.tail = newNode;\n    this.length++;\n  }\n\n  dequeue() {\n    if (this.isEmpty() || !this.head) {\n      return null;\n    } else {\n      const removedNode = this.head;\n      this.head = this.head.next;\n      removedNode.next = null;\n      this.length--;\n      if (this.isEmpty()) {\n        this.tail = null;\n      }\n      return removedNode.value;\n    }\n  }\n}",
    "ts": "/**\n * @param graph The adjacency list representing the graph.\n * @param source The source node to start traversal from. Has to be a valid node if graph is non-empty.\n * @return A BFS-traversed order of nodes.\n */\nexport default function breadthFirstSearch(\n  graph: Record<string, Array<string>>,\n  source: string,\n): Array<string> {\n  throw 'Not implemented!';\n}\n\n/*  Auxiliary classes */\n\n/**\n * A Queue class with O(1) enqueue and dequeue is provided for you.\n * You can use it directly should you wish to.\n *\n * Example usage:\n * const q = new Queue();\n * q.enqueue('a');\n * q.enqueue('b');\n * q.dequeue(); //'a'\n * q.isEmpty(); // False\n */\nclass Node<T> {\n  value: T;\n  next: Node<T> | null;\n\n  constructor(value: T) {\n    this.value = value;\n    this.next = null;\n  }\n}\n\nclass Queue<T> {\n  head: Node<T> | null;\n  tail: Node<T> | null;\n  length: number;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  enqueue(item: T): void {\n    const newNode = new Node(item);\n    if (this.isEmpty()) {\n      this.head = newNode;\n    } else if (this.tail) {\n      this.tail.next = newNode;\n    }\n    this.tail = newNode;\n    this.length++;\n  }\n\n  dequeue(): T | null {\n    if (this.isEmpty() || !this.head) {\n      return null;\n    } else {\n      const removedNode = this.head;\n      this.head = this.head.next;\n      removedNode.next = null;\n      this.length--;\n      if (this.isEmpty()) {\n        this.tail = null;\n      }\n      return removedNode.value;\n    }\n  }\n}"
  },
  "workspace": {
    "main": "/src/breadth-first-search.ts",
    "run": "/src/breadth-first-search.run.test.ts",
    "submit": "/src/breadth-first-search.submit.test.ts"
  }
}