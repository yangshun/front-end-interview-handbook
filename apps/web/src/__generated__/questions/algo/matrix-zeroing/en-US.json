{
  "description": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!g.call(t,o)&&o!==r&&i(t,o,{get:()=>e[o],enumerable:!(c=x(e,o))||c.enumerable});return t};var T=(t,e,r)=>(r=t!=null?u(f(t)):{},a(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>a(i({},\"__esModule\",{value:!0}),t);var s=w((X,l)=>{l.exports=_jsx_runtime});var b={};j(b,{default:()=>D,frontmatter:()=>M});var n=T(s());var d=MDXTestExamples;var m=[{input:[[\"matrix\",[[1,2,0],[4,0,6],[7,8,9]]]],output:[[0,0,0],[0,0,0],[7,0,0]],explanation:\"The elements at (row 0, column 2) and (row 1, column 1) are 0, so their corresponding rows and columns are set to 0.\"},{input:[[\"matrix\",[[1,2,3],[4,5,6],[7,8,9]]]],output:[[1,2,3],[4,5,6],[7,8,9]],explanation:\"There are no zeroes in the matrix, so no changes are made.\"},{input:[[\"matrix\",[[1,2],[3,4],[5,0],[7,8]]]],output:[[1,0],[3,0],[0,0],[7,0]],explanation:\"The element at (row 2, column 1) is 0, so its corresponding rows and columns are set to 0.\"}];var M={title:\"Matrix Zeroing\",excerpt:\"Implement a function to set matrix rows and columns to zero\"};function h(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a \",(0,n.jsx)(e.code,{children:\"matrix\"}),\" of size \",(0,n.jsx)(e.code,{children:\"m\"}),\" x \",(0,n.jsx)(e.code,{children:\"n\"}),\", modify the matrix such that if an element is \",(0,n.jsx)(e.code,{children:\"0\"}),\", its entire row and column are set to \",(0,n.jsx)(e.code,{children:\"0\"}),\". The changes should be made in-place, i.e. directly to the original matrix.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"matrix: number[][]\"}),\": A 2D array \",(0,n.jsx)(e.code,{children:\"matrix\"}),\" of size \",(0,n.jsx)(e.code,{children:\"m\"}),\" x \",(0,n.jsx)(e.code,{children:\"n\"})]}),`\n`]}),`\n`,(0,n.jsx)(d,{testCases:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"m\"}),\", \",(0,n.jsx)(e.code,{children:\"n\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-1000 <= \",(0,n.jsx)(e.code,{children:\"matrix[row][col]\"}),\" <= 1000\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Challenge: Use only O(1) extra space\"}),`\n`]})]})}function y(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var D=y;return _(b);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to set matrix rows and columns to zero",
    "title": "Matrix Zeroing"
  },
  "solution": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var j=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),k=(n,e)=>{for(var t in e)o(n,t,{get:e[t],enumerable:!0})},d=(n,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!w.call(n,r)&&r!==t&&o(n,r,{get:()=>e[r],enumerable:!(c=x(e,r))||c.enumerable});return n};var b=(n,e,t)=>(t=n!=null?u(g(n)):{},d(e||!n||!n.__esModule?o(t,\"default\",{value:n,enumerable:!0}):t,n)),z=n=>d(o({},\"__esModule\",{value:!0}),n);var a=j((I,s)=>{s.exports=_jsx_runtime});var O={};k(O,{default:()=>C});var i=b(a());var l=MDXCodeBlock;var h=`export default function matrixZeroing(matrix: number[][]): void {\n  // Flag to indicate if the first column should be zeroed\n  let isCol = false;\n  const ROWS = matrix.length;\n  const COLS = matrix[0].length;\n\n  // Iterate through the matrix\n  for (let i = 0; i < ROWS; i++) {\n    // Check if the first column needs to be zeroed\n    if (matrix[i][0] === 0) {\n      isCol = true;\n    }\n    // Check each cell in the row starting from the second column\n    for (let j = 1; j < COLS; j++) {\n      if (matrix[i][j] === 0) {\n        // Mark the corresponding row and column in the first row and column\n        matrix[0][j] = 0;\n        matrix[i][0] = 0;\n      }\n    }\n  }\n\n  // Use the markers to set zeroes in the matrix (excluding the first row and column)\n  for (let i = 1; i < ROWS; i++) {\n    for (let j = 1; j < COLS; j++) {\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\n        matrix[i][j] = 0;\n      }\n    }\n  }\n\n  // If the first cell of the matrix is zero, set the entire first row to zero\n  if (matrix[0][0] === 0) {\n    for (let j = 0; j < COLS; j++) {\n      matrix[0][j] = 0;\n    }\n  }\n\n  // If the first column needs to be zeroed, set the entire first column to zero\n  if (isCol) {\n    for (let i = 0; i < ROWS; i++) {\n      matrix[i][0] = 0;\n    }\n  }\n}\n`;var m=`export default function matrixZeroing(matrix: number[][]): void {\n  const rows = new Set<number>(); // Set to keep track of rows that need to be zeroed\n  const cols = new Set<number>(); // Set to keep track of columns that need to be zeroed\n\n  // First pass: Identify all rows and columns that contain a zero\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[0].length; j++) {\n      if (matrix[i][j] === 0) {\n        rows.add(i); // Mark this row for zeroing\n        cols.add(j); // Mark this column for zeroing\n      }\n    }\n  }\n\n  // Second pass: Update the matrix based on identified rows and columns\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[0].length; j++) {\n      if (rows.has(i) || cols.has(j)) {\n        matrix[i][j] = 0; // Set element to zero if its row or column is marked\n      }\n    }\n  }\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ol:\"ol\",li:\"li\",h3:\"h3\",ul:\"ul\",strong:\"strong\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"1. Using Extra Space\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The problem requires modifying a matrix so that if any cell contains a \",(0,i.jsx)(e.code,{children:\"0\"}),\", all cells in the same row and column are set to \",(0,i.jsx)(e.code,{children:\"0\"}),\". This solution uses additional sets to track rows and columns that need to be zeroed.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"The approach involves two passes through the matrix:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"In the first pass, identify all rows and columns containing at least one \",(0,i.jsx)(e.code,{children:\"0\"}),\" and store them in separate sets. This avoids immediate modification of the matrix, which could interfere with subsequent checks.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"In the second pass, update the matrix by setting all cells in the identified rows and columns to \",(0,i.jsx)(e.code,{children:\"0\"}),\" based on the information stored in the sets.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"This separation of identifying and modifying ensures correctness and avoids prematurely zeroing elements that could affect later computations.\"}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize two sets:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"rows\"}),\" to track row indices that contain at least one \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"cols\"}),\" to track column indices that contain at least one \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Perform the first pass through the matrix:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"For each cell \",(0,i.jsx)(e.code,{children:\"(i, j)\"}),\", if the cell contains \",(0,i.jsx)(e.code,{children:\"0\"}),\", add \",(0,i.jsx)(e.code,{children:\"i\"}),\" to \",(0,i.jsx)(e.code,{children:\"rows\"}),\" and \",(0,i.jsx)(e.code,{children:\"j\"}),\" to \",(0,i.jsx)(e.code,{children:\"cols\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Perform the second pass through the matrix:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"For each cell \",(0,i.jsx)(e.code,{children:\"(i, j)\"}),\", check if \",(0,i.jsx)(e.code,{children:\"i\"}),\" is in \",(0,i.jsx)(e.code,{children:\"rows\"}),\" or \",(0,i.jsx)(e.code,{children:\"j\"}),\" is in \",(0,i.jsx)(e.code,{children:\"cols\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"If either condition is true, set \",(0,i.jsx)(e.code,{children:\"matrix[i][j]\"}),\" to \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.li,{children:\"The matrix is now updated with all relevant rows and columns zeroed.\"}),`\n`]}),`\n`,(0,i.jsx)(l,{children:m}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". The algorithm involves two passes through the matrix, each visiting all \",(0,i.jsx)(e.code,{children:\"m.n\"}),\" elements.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(m + n)\"}),\". The additional sets \",(0,i.jsx)(e.code,{children:\"rows\"}),\" and \",(0,i.jsx)(e.code,{children:\"cols\"}),\" store at most \",(0,i.jsx)(e.code,{children:\"m\"}),\" row indices and \",(0,i.jsx)(e.code,{children:\"n\"}),\" column indices.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{children:\"2. Space Efficient Solution\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The task requires modifying a matrix such that if any cell contains a \",(0,i.jsx)(e.code,{children:\"0\"}),\", all cells in the same row and column are set to \",(0,i.jsx)(e.code,{children:\"0\"}),\". This solution achieves the goal in a space-efficient manner by using the first row and first column of the matrix as markers instead of allocating extra space.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"The approach involves three main steps:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Iterate through the matrix and use the first row and first column to mark which rows and columns need to be zeroed. A separate flag is used to determine if the first column needs to be zeroed.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Traverse the matrix again, excluding the first row and column, and update the elements based on the markers.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Update the first row and first column if necessary, based on the markers and the separate flag.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"This method ensures that no extra space beyond the input matrix is required, making it space-efficient.\"}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize a flag \",(0,i.jsx)(e.code,{children:\"isCol\"}),\" to \",(0,i.jsx)(e.code,{children:\"false\"}),\" to track if the first column needs to be zeroed.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Perform the first pass through the matrix:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"For each cell \",(0,i.jsx)(e.code,{children:\"(i, j)\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If the cell is in the first column and contains \",(0,i.jsx)(e.code,{children:\"0\"}),\", set \",(0,i.jsx)(e.code,{children:\"isCol\"}),\" to \",(0,i.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"If the cell is not in the first column and contains \",(0,i.jsx)(e.code,{children:\"0\"}),\", set the corresponding first row and first column markers to \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Perform the second pass through the matrix:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"For each cell \",(0,i.jsx)(e.code,{children:\"(i, j)\"}),\" where \",(0,i.jsx)(e.code,{children:\"i > 0\"}),\" and \",(0,i.jsx)(e.code,{children:\"j > 0\"}),\":\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"If the corresponding markers in the first row or first column are \",(0,i.jsx)(e.code,{children:\"0\"}),\", set \",(0,i.jsx)(e.code,{children:\"matrix[i][j]\"}),\" to \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"If the first cell of the matrix (\",(0,i.jsx)(e.code,{children:\"matrix[0][0]\"}),\") is \",(0,i.jsx)(e.code,{children:\"0\"}),\", set the entire first row to \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"If \",(0,i.jsx)(e.code,{children:\"isCol\"}),\" is \",(0,i.jsx)(e.code,{children:\"true\"}),\", set the entire first column to \",(0,i.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`,(0,i.jsx)(l,{children:h}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". The algorithm involves two passes through the matrix, each visiting all \",(0,i.jsx)(e.code,{children:\"m.n\"}),\" elements.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional space is used apart from the input matrix and a single flag.\"]}),`\n`]})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(f,n)})):f(n)}var C=v;return z(O);})();\n;return Component;"
}