{
  "description": "var Component=(()=>{var p=Object.create;var s=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(n,r)=>()=>(r||n((r={exports:{}}).exports,r),r.exports),f=(n,r)=>{for(var a in r)s(n,a,{get:r[a],enumerable:!0})},c=(n,r,a,o)=>{if(r&&typeof r==\"object\"||typeof r==\"function\")for(let e of m(r))!y.call(n,e)&&e!==a&&s(n,e,{get:()=>r[e],enumerable:!(o=g(r,e))||o.enumerable});return n};var j=(n,r,a)=>(a=n!=null?p(x(n)):{},c(r||!n||!n.__esModule?s(a,\"default\",{value:n,enumerable:!0}):a,n)),w=n=>c(s({},\"__esModule\",{value:!0}),n);var l=b((M,i)=>{i.exports=_jsx_runtime});var C={};f(C,{default:()=>v,frontmatter:()=>z});var t=j(l());var h=MDXTestExamples;var d=[{input:[[\"strs\",[\"abc\",\"bca\",\"cab\",\"xyz\",\"zyx\"]]],output:[[\"abc\",\"bca\",\"cab\"],[\"xyz\",\"zyx\"]],explanation:\"Two anagram groups: 'abc'-'bca'-'cab' and 'xyz'-'zyx'.\"},{input:[[\"strs\",[\"rat\",\"tar\",\"art\",\"car\",\"arc\"]]],output:[[\"arc\",\"car\"],[\"art\",\"rat\",\"tar\"]],explanation:\"Two anagram groups: 'car'-'arc' and 'rat'-'tar'-'art'.\"},{input:[[\"strs\",[\"kxac\",\"swavb\",\"lmq\",\"lvhc\",\"sjey\"]]],output:[[\"kxac\"],[\"lmq\"],[\"lvhc\"],[\"sjey\"],[\"swavb\"]],explanation:\"Each word has no anagram in the list.\"}];var z={title:\"String Anagram Groups\",excerpt:\"Implement a function to group an array of strings into anagrams\"};function u(n){let r=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(r.p,{children:[\"Given an array of strings \",(0,t.jsx)(r.code,{children:\"strs\"}),\", group the strings that are anagrams of each other. The result can be returned in any order.\"]}),`\n`,(0,t.jsx)(r.p,{children:\"An anagram is a word or phrase formed by rearranging the letters of another word or phrase, using all the original letters exactly once.\"}),`\n`,(0,t.jsx)(r.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(r.ul,{children:[`\n`,(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.code,{children:\"strs: string[]\"}),\": An array of strings\"]}),`\n`]}),`\n`,(0,t.jsx)(h,{testCases:d}),`\n`,(0,t.jsx)(r.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(r.ul,{children:[`\n`,(0,t.jsxs)(r.li,{children:[\"1 <= \",(0,t.jsx)(r.code,{children:\"strs.length\"}),\" <= 1000\"]}),`\n`,(0,t.jsxs)(r.li,{children:[\"1 <= \",(0,t.jsx)(r.code,{children:\"strs[i].length\"}),\" <= 100\"]}),`\n`,(0,t.jsxs)(r.li,{children:[\"Each string \",(0,t.jsx)(r.code,{children:\"strs[i]\"}),\" contains only lowercase English letters\"]}),`\n`]})]})}function T(n={}){let{wrapper:r}=n.components||{};return r?(0,t.jsx)(r,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var v=T;return w(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to group an array of strings into anagrams",
    "title": "String Anagram Groups"
  },
  "solution": "var Component=(()=>{var y=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var t in e)i(n,t,{get:e[t],enumerable:!0})},h=(n,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of f(e))!k.call(n,a)&&a!==t&&i(n,a,{get:()=>e[a],enumerable:!(o=p(e,a))||o.enumerable});return n};var b=(n,e,t)=>(t=n!=null?y(m(n)):{},h(e||!n||!n.__esModule?i(t,\"default\",{value:n,enumerable:!0}):t,n)),C=n=>h(i({},\"__esModule\",{value:!0}),n);var l=v((M,c)=>{c.exports=_jsx_runtime});var A={};x(A,{default:()=>j});var r=b(l());var s=MDXCodeBlock;var d=`export default function anagramGroups(strs: string[]): string[][] {\n  // Create a map to store the anagrams.\n  // The keys are the sorted versions of the strings,\n  // and the values are arrays containing the original strings (anagrams).\n  let map = new Map<string, string[]>();\n\n  // Iterate over each string in the input array\n  for (let str of strs) {\n    // Convert the string to a character array and sort it alphabetically\n    let chars = Array.from(str);\n    chars.sort();\n\n    // Join the sorted characters to form a key\n    // This key will be the same for all anagrams\n    let key = chars.join('');\n\n    // If the key doesn't exist in the map, add it with an empty array as the value\n    if (!map.has(key)) map.set(key, []);\n\n    // Add the original string to the array of anagrams for this key\n    map.get(key)!.push(str);\n  }\n\n  // Convert the map's values to an array and return it.\n  // Each element in the array is a group of anagrams.\n  return Array.from(map.values());\n}\n`;var g=`export default function anagramGroups(strs: string[]): string[][] {\n  // If the input array is empty, return an empty array\n  if (strs.length === 0) return [];\n\n  // Initialize an object to store groups of anagrams\n  // The keys are unique representations of the character counts\n  // The values are arrays of strings that match the key's character count\n  let ans: { [key: string]: string[] } = {};\n\n  // Iterate over each string in the input array\n  for (let s of strs) {\n    // Create an array to count occurrences of each character (26 letters of the alphabet)\n    let count: number[] = Array(26).fill(0);\n\n    // Increment the corresponding index in the count array for each character in the string\n    for (let c of s) count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    // Create a key string based on the character counts\n    // The key is formatted as a series of \"#count\" for each character\n    let key = '';\n    for (let i = 0; i < 26; i++) {\n      key += '#';\n      key += count[i];\n    }\n\n    // If the key doesn't exist in the map, initialize it with an empty array\n    if (!ans[key]) ans[key] = [];\n\n    // Add the original string to the array associated with the key\n    ans[key].push(s);\n  }\n\n  // Return the values of the map, which are the groups of anagrams\n  return Object.values(ans);\n}\n`;function u(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Using Sorting\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"A naive approach might involve checking all possible pairs of strings, which would be inefficient. However, this optimized solution uses the sorted version of each string as a unique key for grouping. Sorting ensures that all anagrams produce identical keys, simplifying the identification of groups. Sorting each string reduces the problem to key generation, which is straightforward to handle using a \",(0,r.jsx)(e.code,{children:\"Map\"}),\".\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize an empty \",(0,r.jsx)(e.code,{children:\"Map\"}),\" to store groups of anagrams.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"The keys represent the sorted version of strings, and the values are arrays of original strings.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate over the input array of strings.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"For each string, convert it into a character array and sort it alphabetically.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Join the sorted characters to create a key.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Check if the key already exists in the \",(0,r.jsx)(e.code,{children:\"Map\"}),\".\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"If the key does not exist, initialize it with an empty array.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Append the original string to the array corresponding to the key.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Convert the values of the \",(0,r.jsx)(e.code,{children:\"Map\"}),\" into an array of arrays and return it.\"]}),`\n`]}),`\n`,(0,r.jsx)(s,{children:d}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n.m log m)\"}),\". Sorting each string of length \",(0,r.jsx)(e.code,{children:\"m\"}),\" takes O(m log m), and there are \",(0,r.jsx)(e.code,{children:\"n\"}),\" strings.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(n.m)\"}),\". The \",(0,r.jsx)(e.code,{children:\"Map\"}),\" stores all strings, and the space required for keys and values depends on the total characters in the input.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"2. Using Frequency Count\"}),`\n`,(0,r.jsx)(e.p,{children:\"Instead of sorting strings to generate keys like previous solution, a frequency array of fixed size (26 for the English alphabet) is used to count occurrences of each character. This solution optimizes the process by representing each string using its character frequency count. This eliminates the need for sorting, which is the bottleneck in the sorting-based approach.\"}),`\n`,(0,r.jsx)(e.p,{children:\"The key for each group is derived from the frequency count, formatted as a concatenated string with counts of all characters. This ensures all anagrams map to the same key while avoiding sorting overhead, improving the efficiency of the solution.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Check if the input array is empty.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"If the array is empty, return an empty array.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize an empty object to store groups of anagrams.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"The keys represent character count patterns, and the values are arrays of strings matching the pattern.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate over each string in the input array.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Initialize a count array of size 26 to represent character frequencies.\"}),`\n`,(0,r.jsx)(e.li,{children:\"For each character in the string, increment the corresponding index in the count array.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Generate a key string from the count array.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Concatenate \",(0,r.jsx)(e.code,{children:\"#\"}),\" and the count of each character to form the key.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Check if the key exists in the object.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"If the key does not exist, initialize it with an empty array.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Append the string to the array corresponding to the key.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.li,{children:\"Return the values of the object as an array of groups of anagrams.\"}),`\n`]}),`\n`,(0,r.jsx)(s,{children:g}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n.m)\"}),\". Counting characters for each string of length \",(0,r.jsx)(e.code,{children:\"m\"}),\" takes O(m), and there are \",(0,r.jsx)(e.code,{children:\"n\"}),\" strings.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(n.m)\"}),\". The object stores all strings, and additional space is used for character counts and keys.\"]}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(u,n)})):u(n)}var j=T;return C(A);})();\n;return Component;"
}