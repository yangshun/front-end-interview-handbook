{
  "description": "var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),N=(n,e)=>{for(var o in e)i(n,o,{get:e[o],enumerable:!0})},a=(n,e,o,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!T.call(n,r)&&r!==o&&i(n,r,{get:()=>e[r],enumerable:!(l=f(e,r))||l.enumerable});return n};var b=(n,e,o)=>(o=n!=null?m(x(n)):{},a(e||!n||!n.__esModule?i(o,\"default\",{value:n,enumerable:!0}):o,n)),_=n=>a(i({},\"__esModule\",{value:!0}),n);var d=g((D,h)=>{h.exports=_jsx_runtime});var M={};N(M,{default:()=>y,frontmatter:()=>v});var t=b(d());var s=MDXTestExamples;var c=[{input:[[\"root\",[1,2,3,4,5,6,7]]],output:3,explanation:\"The tree has a maximum depth of 3. The longest path from root (1) to leaves (4, 5, 6, or 7) is of length 3.\"},{input:[[\"root\",[1,null,2]]],output:2,explanation:\"The tree has a maximum depth of 2. The longest path from root (1) to leaf (2) is of length 2.\"},{input:[[\"root\",[10,5,15,null,null,12,20]]],output:3,explanation:\"The tree has a maximum depth of 3. The longest path from root (10) to leaves (12 or 20) is of length 3.\"}];var v={title:\"Binary Tree Maximum Depth\",excerpt:\"Implement a function to find the maximum depth of a binary tree\"};function p(n){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given the \",(0,t.jsx)(e.code,{children:\"root\"}),\" of a binary tree, determine the depth of the tree, which is defined as the number of nodes along the longest path from the root to the most distant leaf node.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,t.jsx)(e.code,{children:\"left\"}),\" and \",(0,t.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"root: TreeNode\"}),\": Root node of the tree. Examples display a \",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`]}),`\n`,(0,t.jsx)(s,{testCases:c}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"1 <= Number of nodes <= 10,000\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"-100 <= \",(0,t.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 100\"]}),`\n`]})]})}function w(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var y=w;return _(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the maximum depth of a binary tree",
    "title": "Binary Tree Maximum Depth"
  },
  "solution": "var Component=(()=>{var m=Object.create;var h=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var r in e)h(n,r,{get:e[r],enumerable:!0})},a=(n,e,r,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!b.call(n,i)&&i!==r&&h(n,i,{get:()=>e[i],enumerable:!(d=f(e,i))||d.enumerable});return n};var T=(n,e,r)=>(r=n!=null?m(x(n)):{},a(e||!n||!n.__esModule?h(r,\"default\",{value:n,enumerable:!0}):r,n)),k=n=>a(h({},\"__esModule\",{value:!0}),n);var s=y((O,l)=>{l.exports=_jsx_runtime});var D={};v(D,{default:()=>N});var t=T(s());var o=MDXCodeBlock;var c=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeMaximumDepth(root: TreeNode | null): number {\n  // Base case: if the root is null, the depth is 0\n  if (root === null) {\n    return 0;\n  }\n\n  // Recursively compute the depth of the left subtree\n  const left_height = binaryTreeMaximumDepth(root.left);\n\n  // Recursively compute the depth of the right subtree\n  const right_height = binaryTreeMaximumDepth(root.right);\n\n  // The depth of the current node is 1 (for the current node)\n  // plus the maximum depth of the left and right subtrees\n  return 1 + Math.max(left_height, right_height);\n}\n`;var u=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeMaximumDepth(root: TreeNode | null): number {\n  // If the root is null, the depth is 0\n  if (root == null) {\n    return 0;\n  }\n\n  // Initialize a stack for iterative traversal.\n  // The stack holds tuples of (TreeNode, current_depth)\n  let stack: [TreeNode | null, number][] = [];\n\n  // Start with the root node at depth 1\n  stack.push([root, 1]);\n\n  // Variable to keep track of the maximum depth encountered\n  let depth = 0;\n\n  // Iterate while there are nodes in the stack\n  while (stack.length !== 0) {\n    // Pop a node and its associated depth from the stack\n    let [node, current_depth] = stack.pop() as [TreeNode, number];\n\n    // If the node is not null, process it\n    if (node != null) {\n      // Update the maximum depth if the current depth is greater\n      depth = Math.max(depth, current_depth);\n\n      // Push left child and right child into the stack with updated depth\n      stack.push([node.left, current_depth + 1]);\n      stack.push([node.right, current_depth + 1]);\n    }\n  }\n\n  // Return the maximum depth found\n  return depth;\n}\n`;function p(n){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Recursion\"}),`\n`,(0,t.jsx)(e.p,{children:\"The maximum depth of a binary tree is determined by finding the longest path from the root node to a leaf node. A recursive approach is well-suited for this problem because the depth of a node is 1 plus the maximum depth of its left and right subtrees. Starting at the root, the algorithm explores both left and right subtrees, computes their depths, and selects the larger value, effectively traversing all nodes in a divide-and-conquer manner.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Begin at the root node.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the current node is \",(0,t.jsx)(e.code,{children:\"null\"}),\", return a depth of 0, as there are no nodes below it.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively calculate the depth of the left subtree.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively calculate the depth of the right subtree.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Compute the depth of the current node by adding 1 (for the current node itself) to the maximum of the depths of its left and right subtrees.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Continue this process until all nodes have been visited.\"}),`\n`]}),`\n`,(0,t.jsx)(o,{children:c}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node in the tree is visited exactly once to calculate its depth.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The recursive stack size depends on the height of the tree, where \",(0,t.jsx)(e.code,{children:\"h\"}),\" is the height of the tree.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Iteration\"}),`\n`,(0,t.jsx)(e.p,{children:\"The iterative approach to finding the maximum depth of a binary tree uses a stack to simulate the depth-first traversal. Each stack entry contains a node and its current depth. This avoids recursion and explicitly manages the traversal using the stack. Starting with the root node at depth 1, the algorithm iterates through all nodes in the tree, updating the maximum depth as it processes each node. Nodes are added to the stack with their depths incremented by 1, representing the next level of the tree. This approach ensures every path from the root to a leaf is considered, and the maximum depth is recorded.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Initialize a stack with the root node and its initial depth set to 1.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Use a variable to keep track of the maximum depth encountered during traversal.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"While the stack is not empty:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Pop the top node and its associated depth.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Update the maximum depth if the current depth is greater.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Push the left and right children of the node into the stack with their depths incremented by 1.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Continue until all nodes have been processed.\"}),`\n`]}),`\n`,(0,t.jsx)(o,{children:u}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node in the tree is visited exactly once during the traversal.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The stack size depends on the height of the tree, where \",(0,t.jsx)(e.code,{children:\"h\"}),\" is the height of the tree.\"]}),`\n`]})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var N=M;return k(D);})();\n;return Component;"
}