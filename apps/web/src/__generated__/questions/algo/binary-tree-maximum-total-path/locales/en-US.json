{
  "description": "var Component=(()=>{var u=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var o in e)a(t,o,{get:e[o],enumerable:!0})},l=(t,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!T.call(t,r)&&r!==o&&a(t,r,{get:()=>e[r],enumerable:!(i=m(e,r))||i.enumerable});return t};var b=(t,e,o)=>(o=t!=null?u(x(t)):{},l(e||!t||!t.__esModule?a(o,\"default\",{value:t,enumerable:!0}):o,t)),w=t=>l(a({},\"__esModule\",{value:!0}),t);var h=y((D,d)=>{d.exports=_jsx_runtime});var M={};g(M,{default:()=>j,frontmatter:()=>v});var n=b(h());var s=MDXTestExamples;var c=[{input:[[\"root\",[4,3,5]]],output:12,explanation:\"The optimal path is 3 -> 4 -> 5 with a sum of 12.\"},{input:[[\"root\",[-2,1]]],output:1,explanation:\"The optimal path is the single node with value 1.\"},{input:[[\"root\",[-30,8,22,null,null,17,8]]],output:47,explanation:\"The optimal path is 17 -> 22 -> 8 with a sum of 47.\"}];var v={title:\"Binary Tree Maximum Total Path\",excerpt:\"Implement a function to find the maximum total of nodes in a binary tree path\"};function p(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the \",(0,n.jsx)(e.code,{children:\"root\"}),\" of a binary tree, determine the maximum possible sum of any non-empty path within the tree.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In a binary tree, a path is defined as a sequence of nodes where each consecutive pair of nodes in the sequence is directly connected by an edge. A node can appear in the path sequence only once, and the path does not necessarily need to include the root. The sum of a path is calculated by adding up the values of all nodes present in that path.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"root: TreeNode\"}),\": Root node of the tree. Examples display a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`]}),`\n`,(0,n.jsx)(s,{testCases:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 10,000\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"-100 <= \",(0,n.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 100\"]}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var j=_;return w(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the maximum total of nodes in a binary tree path",
    "title": "Binary Tree Maximum Total Path"
  },
  "solution": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var a in e)i(n,a,{get:e[a],enumerable:!0})},h=(n,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!x.call(n,r)&&r!==a&&i(n,r,{get:()=>e[r],enumerable:!(o=g(e,r))||o.enumerable});return n};var y=(n,e,a)=>(a=n!=null?d(p(n)):{},h(e||!n||!n.__esModule?i(a,\"default\",{value:n,enumerable:!0}):a,n)),S=n=>h(i({},\"__esModule\",{value:!0}),n);var m=b((_,s)=>{s.exports=_jsx_runtime});var R={};v(R,{default:()=>T});var t=y(m());var u=MDXCodeBlock;var l=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\n// Main function to find the maximum path sum in a binary tree\nexport default function binaryTreeMaximumPathSum(\n  root: TreeNode | null,\n): number {\n  // Initialize maxSum as a very small value (negative infinity)\n  let maxSum = -Infinity;\n\n  // Helper function to perform a post-order traversal of the tree\n  // and calculate the maximum gain from each subtree\n  function gainFromSubtree(node: TreeNode | null): number {\n    // Base case: If the node is null, return 0 (no gain)\n    if (node === null) {\n      return 0;\n    }\n\n    // Recursively calculate the maximum gain from the left subtree\n    // If the gain is negative, consider it as 0 (ignore it)\n    const gainFromLeft = Math.max(gainFromSubtree(node.left), 0);\n\n    // Recursively calculate the maximum gain from the right subtree\n    // If the gain is negative, consider it as 0 (ignore it)\n    const gainFromRight = Math.max(gainFromSubtree(node.right), 0);\n\n    // Calculate the maximum path sum including the current node\n    // and update maxSum if this path has the highest sum so far\n    maxSum = Math.max(maxSum, gainFromLeft + gainFromRight + node.val);\n\n    // Return the maximum gain that can be obtained by including the current node\n    // and either its left or right subtree (but not both, to keep the path continuous)\n    return Math.max(gainFromLeft + node.val, gainFromRight + node.val);\n  }\n\n  // Start the traversal from the root node to calculate maxSum\n  gainFromSubtree(root);\n\n  // Return the maximum path sum found\n  return maxSum;\n}\n`;function c(n){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\",code:\"code\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Post Order DFS\"}),`\n`,(0,t.jsx)(e.p,{children:\"The maximum path sum in a binary tree is the largest sum of node values in any path. A path can start and end at any nodes in the tree, but it must follow parent-child connections. The strategy uses post-order depth-first search (DFS) to explore each subtree and calculate the maximum gain from the left and right subtrees at each node. For each node, the potential maximum path sum is calculated as the sum of the node's value and the maximum gains from its left and right subtrees. Negative gains from a subtree are ignored to ensure that only paths with positive contributions are included. By traversing the entire tree, the global maximum path sum is determined.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Perform a post-order traversal of the tree to process each node only after processing its left and right subtrees.\"}),`\n`,(0,t.jsx)(e.li,{children:\"For each node, compute the maximum gain from its left and right subtrees. If a subtree contributes a negative gain, it is ignored by treating it as 0.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Calculate the path sum for the current node as the sum of its value and the maximum gains from its left and right subtrees.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Update the global maximum path sum if the calculated path sum for the current node is greater.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Return the maximum gain that can be passed to the parent node, which includes the node's value and the larger gain from either its left or right subtree.\"}),`\n`]}),`\n`,(0,t.jsx)(u,{children:l}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node is visited once during the traversal.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The space required for the recursion stack is proportional to the height of the tree, where \",(0,t.jsx)(e.code,{children:\"h\"}),\" is the height of the tree.\"]}),`\n`]})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(c,n)})):c(n)}var T=M;return S(R);})();\n;return Component;"
}