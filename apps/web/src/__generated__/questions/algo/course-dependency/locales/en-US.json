{
  "description": "var Component=(()=>{var p=Object.create;var n=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var x=(s,e)=>()=>(e||s((e={exports:{}}).exports,e),e.exports),g=(s,e)=>{for(var t in e)n(s,t,{get:e[t],enumerable:!0})},o=(s,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of f(e))!q.call(s,i)&&i!==t&&n(s,i,{get:()=>e[i],enumerable:!(c=m(e,i))||c.enumerable});return s};var w=(s,e,t)=>(t=s!=null?p(b(s)):{},o(e||!s||!s.__esModule?n(t,\"default\",{value:s,enumerable:!0}):t,s)),T=s=>o(n({},\"__esModule\",{value:!0}),s);var l=x((v,u)=>{u.exports=_jsx_runtime});var C={};g(C,{default:()=>_,frontmatter:()=>j});var r=w(l());var a=MDXTestExamples;var d=[{input:[[\"courses\",4],[\"prerequisites\",[[1,0],[2,1],[3,2],[1,3]]]],output:!1,explanation:\"There are 4 courses labeled from 0 to 3. The prerequisite relationships are as follows: course 1 requires course 0 to be completed first, course 2 requires course 1, course 3 requires course 2, and course 1 requires course 3. This creates a circular dependency: course 1 depends on course 3, which in turn depends on course 2, which then depends on course 1 again. Since it is impossible to break this cycle and complete all courses, the output is false.\"},{input:[[\"courses\",2],[\"prerequisites\",[[1,0]]]],output:!0,explanation:\"The prerequisite [1, 0] indicates that course 0 must be completed before course 1. Since there are no other dependencies or cycles, it is straightforward to complete the courses in the order: course 0, then course 1. Therefore, the output is true.\"}];var j={title:\"Course Dependency\",excerpt:\"Implement a function to check if all courses can be completed given prerequisites\"};function h(s){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},s.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"There are a set of courses numbered from \",(0,r.jsx)(e.code,{children:\"0\"}),\" to \",(0,r.jsx)(e.code,{children:\"courses - 1\"}),\". Each course may have prerequisites that dictate the order in which the courses must be taken. These prerequisites are given as a list of pairs, where each pair \",(0,r.jsx)(e.code,{children:\"[a, b]\"}),\" indicates that course \",(0,r.jsx)(e.code,{children:\"b\"}),\" must be completed before course \",(0,r.jsx)(e.code,{children:\"a\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Determine if it is possible to complete all courses without violating any prerequisite constraints. Return \",(0,r.jsx)(e.code,{children:\"true\"}),\" if it is possible to complete all the courses; otherwise, return \",(0,r.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"courses: number\"}),\": An integer representing the total number of courses\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"prerequisites: Array<[number, number]>\"}),\": A 2D array where each element \",(0,r.jsx)(e.code,{children:\"[a, b]\"}),\" indicates that course \",(0,r.jsx)(e.code,{children:\"b\"}),\" is a prerequisite for course \",(0,r.jsx)(e.code,{children:\"a\"})]}),`\n`]}),`\n`,(0,r.jsx)(a,{testCases:d}),`\n`,(0,r.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"1 <= \",(0,r.jsx)(e.code,{children:\"courses\"}),\" <= 1000\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"0 <= \",(0,r.jsx)(e.code,{children:\"prerequisites.length\"}),\" <= 1000\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"prerequisites[i].length\"}),\" == 2\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"0 <= \",(0,r.jsx)(e.code,{children:\"a\"}),\", \",(0,r.jsx)(e.code,{children:\"b\"}),\" < courses\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"All pairs \",(0,r.jsx)(e.code,{children:\"[a, b]\"}),\" in \",(0,r.jsx)(e.code,{children:\"prerequisites\"}),\" are unique\"]}),`\n`]})]})}function D(s={}){let{wrapper:e}=s.components||{};return e?(0,r.jsx)(e,Object.assign({},s,{children:(0,r.jsx)(h,s)})):h(s)}var _=D;return T(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to check if all courses can be completed given prerequisites",
    "title": "Course Dependency"
  },
  "solution": "var Component=(()=>{var p=Object.create;var t=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),q=(n,e)=>{for(var i in e)t(n,i,{get:e[i],enumerable:!0})},d=(n,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of m(e))!y.call(n,c)&&c!==i&&t(n,c,{get:()=>e[c],enumerable:!(o=g(e,c))||o.enumerable});return n};var k=(n,e,i)=>(i=n!=null?p(b(n)):{},d(e||!n||!n.__esModule?t(i,\"default\",{value:n,enumerable:!0}):i,n)),j=n=>d(t({},\"__esModule\",{value:!0}),n);var a=v((O,l)=>{l.exports=_jsx_runtime});var x={};q(x,{default:()=>T});var r=k(a());var s=MDXCodeBlock;var h=`export default function canCompleteCourse(\n  courses: number,\n  prerequisites: number[][],\n): boolean {\n  const indegree: number[] = new Array(courses).fill(0);\n  const adj: number[][] = new Array(courses).fill(0).map(() => []);\n\n  // Build the adjacency list and the indegree array\n  for (const prerequisite of prerequisites) {\n    adj[prerequisite[1]].push(prerequisite[0]);\n    indegree[prerequisite[0]]++;\n  }\n\n  const queue: number[] = [];\n  // Push all the nodes with indegree zero into the queue.\n  for (let i = 0; i < courses; i++) {\n    if (indegree[i] === 0) {\n      queue.push(i);\n    }\n  }\n\n  let nodesVisited = 0;\n  // Process the queue\n  while (queue.length > 0) {\n    const node = queue.shift()!;\n    nodesVisited++;\n\n    for (const neighbor of adj[node]) {\n      // Decrease the indegree of the neighbor\n      indegree[neighbor]--;\n      if (indegree[neighbor] === 0) {\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  // If we visited all the courses, return true\n  return nodesVisited === courses;\n}\n`;var u=`/**\n * Performs a depth-first search to detect cycles in the graph.\n * @param node - The current node being visited.\n * @param adj - The adjacency list representing the graph.\n * @param visit - Array to track visited nodes.\n * @param inStack - Array to track nodes in the current recursion stack.\n * @returns True if a cycle is detected, false otherwise.\n */\nfunction dfs(\n  node: number,\n  adj: number[][],\n  visit: boolean[],\n  inStack: boolean[],\n): boolean {\n  // If the node is already in the stack, we have a cycle.\n  if (inStack[node]) {\n    return true;\n  }\n  // If the node is already visited, no need to visit it again.\n  if (visit[node]) {\n    return false;\n  }\n  // Mark the current node as visited and part of the current recursion stack.\n  visit[node] = true;\n  inStack[node] = true;\n  // Visit all the neighbors of the current node.\n  for (const neighbor of adj[node]) {\n    if (dfs(neighbor, adj, visit, inStack)) {\n      return true;\n    }\n  }\n  // Remove the node from the recursion stack.\n  inStack[node] = false;\n  return false;\n}\n\n/**\n * Determines if it is possible to finish all courses given the prerequisites.\n * @param courses - The total number of courses.\n * @param prerequisites - The list of prerequisite pairs.\n * @returns True if it is possible to finish all courses, false otherwise.\n */\nexport default function canCompleteCourse(\n  courses: number,\n  prerequisites: number[][],\n): boolean {\n  const adj: number[][] = Array.from({ length: courses }, () => []);\n\n  // Build the adjacency list from the prerequisites.\n  for (const prerequisite of prerequisites) {\n    adj[prerequisite[1]].push(prerequisite[0]);\n  }\n\n  const visit: boolean[] = new Array(courses).fill(false);\n  const inStack: boolean[] = new Array(courses).fill(false);\n\n  // Perform DFS for each course to check for cycles.\n  for (let i = 0; i < courses; i++) {\n    if (dfs(i, adj, visit, inStack)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",h3:\"h3\",ol:\"ol\",code:\"code\",strong:\"strong\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Kahn's Topological Sort\"}),`\n`,(0,r.jsx)(e.p,{children:\"The problem involves determining if all courses can be completed given a set of prerequisites. This is a classic cycle detection problem in a directed graph. If there is a cycle, not all courses can be completed. Kahn's algorithm, a topological sorting method, is used to solve the problem by systematically removing nodes with no incoming edges.\"}),`\n`,(0,r.jsx)(e.p,{children:\"The key idea is:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Build the graph using an adjacency list.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Track the number of prerequisites (indegree) for each course.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Start with courses that have no prerequisites.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Process each course, reducing the indegree of its neighbors. If a neighbor's indegree becomes 0, add it to the processing queue.\"}),`\n`,(0,r.jsx)(e.li,{children:\"If all courses are processed without any unvisited nodes, it means there is no cycle.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize an \",(0,r.jsx)(e.code,{children:\"indegree\"}),\" array to count the number of prerequisites for each course.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize an adjacency list (\",(0,r.jsx)(e.code,{children:\"adj\"}),\") to represent the directed graph.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Populate the adjacency list and \",(0,r.jsx)(e.code,{children:\"indegree\"}),\" array by iterating through the prerequisites:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"For each pair \",(0,r.jsx)(e.code,{children:\"[a, b]\"}),\", add \",(0,r.jsx)(e.code,{children:\"a\"}),\" as a neighbor of \",(0,r.jsx)(e.code,{children:\"b\"}),\" in \",(0,r.jsx)(e.code,{children:\"adj\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Increment the indegree of \",(0,r.jsx)(e.code,{children:\"a\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize a queue and add all courses with \",(0,r.jsx)(e.code,{children:\"indegree\"}),\" 0 to the queue.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize a counter \",(0,r.jsx)(e.code,{children:\"nodesVisited\"}),\" to track the number of courses processed.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Perform BFS:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Remove a course from the queue and increment \",(0,r.jsx)(e.code,{children:\"nodesVisited\"}),\".\"]}),`\n`,(0,r.jsx)(e.li,{children:\"For each neighbor of the current course, decrement its indegree.\"}),`\n`,(0,r.jsx)(e.li,{children:\"If a neighbor's indegree becomes 0, add it to the queue.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"After processing all nodes, check if \",(0,r.jsx)(e.code,{children:\"nodesVisited\"}),\" equals the total number of courses:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If true, return \",(0,r.jsx)(e.code,{children:\"true\"}),\" (all courses can be completed).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Otherwise, return \",(0,r.jsx)(e.code,{children:\"false\"}),\" (a cycle exists).\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(s,{children:h}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(v + e)\"}),\". The graph is built in O(e), where \",(0,r.jsx)(e.code,{children:\"e\"}),\" is the number of prerequisites. BFS traversal processes each course and edge once, taking O(v + e), where \",(0,r.jsx)(e.code,{children:\"v\"}),\" is the number of courses.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(v + e)\"}),\". The adjacency list and queue require O(v + e) space.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"2. Using DFS\"}),`\n`,(0,r.jsx)(e.p,{children:\"The problem involves determining if all courses can be completed given a set of prerequisites. This is a graph cycle detection problem in a directed graph. If a cycle exists, not all courses can be completed since at least one course depends on itself, either directly or indirectly.\"}),`\n`,(0,r.jsx)(e.p,{children:\"The algorithm uses depth-first search (DFS) to detect cycles:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Each course is represented as a node in the graph.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Prerequisites are represented as directed edges between nodes.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"During DFS, nodes are marked as visited and added to a recursion stack (\",(0,r.jsx)(e.code,{children:\"inStack\"}),\") to detect cycles. If a node is revisited while it is still in the recursion stack, a cycle is detected.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"If no cycles are found after visiting all nodes, all courses can be completed.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize an adjacency list \",(0,r.jsx)(e.code,{children:\"adj\"}),\" to represent the graph.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Build the graph by iterating over the \",(0,r.jsx)(e.code,{children:\"prerequisites\"}),\" array:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"For each pair \",(0,r.jsx)(e.code,{children:\"[a, b]\"}),\", add \",(0,r.jsx)(e.code,{children:\"a\"}),\" as a neighbor of \",(0,r.jsx)(e.code,{children:\"b\"}),\" in \",(0,r.jsx)(e.code,{children:\"adj\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize two arrays:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"visit\"}),\" to track whether a node has been visited.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"inStack\"}),\" to track whether a node is in the current recursion stack.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Define a \",(0,r.jsx)(e.code,{children:\"dfs\"}),\" function to perform the following:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If the current node is in the recursion stack (\",(0,r.jsx)(e.code,{children:\"inStack\"}),\"), return \",(0,r.jsx)(e.code,{children:\"true\"}),\" (cycle detected).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the current node is already visited, return \",(0,r.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Mark the current node as visited and add it to the recursion stack.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"For each neighbor of the current node, recursively call \",(0,r.jsx)(e.code,{children:\"dfs\"}),\". If any call detects a cycle, return \",(0,r.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Remove the current node from the recursion stack and return \",(0,r.jsx)(e.code,{children:\"false\"}),\" (no cycle detected).\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Perform DFS on each node:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If a cycle is detected, return \",(0,r.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If all nodes are processed without detecting a cycle, return \",(0,r.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`,(0,r.jsx)(s,{children:u}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(v + e)\"}),\". Building the graph takes O(e), where \",(0,r.jsx)(e.code,{children:\"e\"}),\" is the number of prerequisites. DFS visits each node and edge once, taking O(v + e), where \",(0,r.jsx)(e.code,{children:\"v\"}),\" is the number of courses.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(v + e)\"}),\". The adjacency list requires O(e) space, and the \",(0,r.jsx)(e.code,{children:\"visit\"}),\" and \",(0,r.jsx)(e.code,{children:\"inStack\"}),\" arrays require O(v) space.\"]}),`\n`]})]})}function I(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(f,n)})):f(n)}var T=I;return j(x);})();\n;return Component;"
}