{
  "description": "var Component=(()=>{var u=Object.create;var a=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},r=(t,e,i,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of p(e))!g.call(t,l)&&l!==i&&a(t,l,{get:()=>e[l],enumerable:!(s=m(e,l))||s.enumerable});return t};var y=(t,e,i)=>(i=t!=null?u(x(t)):{},r(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),C=t=>r(a({},\"__esModule\",{value:!0}),t);var h=f((X,o)=>{o.exports=_jsx_runtime});var v={};b(v,{default:()=>M,frontmatter:()=>T});var n=y(h());var c=MDXTestExamples;var d=[{input:[[\"walls\",[1,4,2,3]]],output:6,explanation:\"Consider two walls (i=1 & i=3) with heights 4 and 3. The water is limited by the shorter wall with height 3, so the container holds 2 (distance) * 3 (shorter height) = 6 units. All other combination of walls result in smaller area.\"},{input:[[\"walls\",[1,1]]],output:1,explanation:\"Consider two walls (i=0 & i=1) with heights 1 and 1. The water is limited by the shorter wall (both same in this case i.e. 1), so the container holds 1 (distance) * 1 (shorter height) = 1 unit\"},{input:[[\"walls\",[1,0]]],output:0,explanation:\"Consider two walls (i=0 & i=1) with heights 1 and 0. The water is limited by the shorter wall with height 0, so the container holds 1 (distance) * 0 (shorter height) = 0 unit\"}];var T={title:\"Maximum Water Trapped Between Walls\",excerpt:\"Implement a function to find the maximum water volume between two walls in an array of walls\"};function w(t){let e=Object.assign({p:\"p\",code:\"code\",strong:\"strong\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array \",(0,n.jsx)(e.code,{children:\"walls\"}),\" of wall heights, calculate the maximum volume of water that will be trapped between \",(0,n.jsx)(e.strong,{children:\"two walls\"}),\" and the x-axis after a heavy downpour.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"walls: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"2 <= \",(0,n.jsx)(e.code,{children:\"walls.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"walls[i]\"}),\" <= 10,000\"]}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(w,t)})):w(t)}var M=_;return C(v);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the maximum water volume between two walls in an array of walls",
    "title": "Maximum Water Trapped Between Walls"
  },
  "solution": "var Component=(()=>{var u=Object.create;var n=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),y=(a,e)=>{for(var l in e)n(a,l,{get:e[l],enumerable:!0})},o=(a,e,l,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!x.call(a,r)&&r!==l&&n(a,r,{get:()=>e[r],enumerable:!(h=p(e,r))||h.enumerable});return a};var A=(a,e,l)=>(l=a!=null?u(g(a)):{},o(e||!a||!a.__esModule?n(l,\"default\",{value:a,enumerable:!0}):l,a)),v=a=>o(n({},\"__esModule\",{value:!0}),a);var s=b((I,c)=>{c.exports=_jsx_runtime});var O={};y(O,{default:()=>M});var t=A(s());var i=MDXCodeBlock;var d=`export default function maximumWaterBetweenWalls(walls: number[]): number {\n  // Initialize variables for pointers and maximum area\n  let left = 0;\n  let right = walls.length - 1;\n  let maxWaterArea = 0;\n\n  // Iterate while left and right pointers haven't crossed\n  while (left < right) {\n    // Calculate the area formed between the walls pointed by 'left' and 'right'.\n    // The height is limited by the shorter wall, and the width is (right - left).\n    const currentArea = (right - left) * Math.min(walls[left], walls[right]);\n    maxWaterArea = Math.max(maxWaterArea, currentArea);\n\n    // Move the pointer with the shorter height towards the center\n    // By doing this, we give a chance to find a taller wall and potentially increase the area.\n    if (walls[left] < walls[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n\n  return maxWaterArea;\n}\n`;var m=`export default function maximumWaterBetweenWalls(walls: number[]): number {\n  // Initialize the maximum area to 0\n  let maxArea = 0;\n\n  // Iterate over each pair of walls\n  for (let left = 0; left < walls.length; left++) {\n    for (let right = left + 1; right < walls.length; right++) {\n      // Calculate the width between the walls\n      const width = right - left;\n\n      // Calculate the area using the shorter wall\n      const currentArea = Math.min(walls[left], walls[right]) * width;\n\n      // Update maxArea if the current area is larger\n      maxArea = Math.max(maxArea, currentArea);\n    }\n  }\n\n  // Return the maximum area found\n  return maxArea;\n}\n`;function w(a){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},a.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Brute Force Approach\"}),`\n`,(0,t.jsx)(e.p,{children:\"A brute force approach is to find the maximum water that can be trapped between two walls. The idea is to evaluate every possible pair of walls in the input array and calculate the amount of water that can be held between them. The water held is determined by the shorter wall in the pair and the distance between the two walls.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The brute force approach ensures all pairs of walls are considered, making. The algorithm iterates through each possible pair of walls using nested loops and calculates the area for each pair. The largest area found during this process is returned as the result.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize a variable \",(0,t.jsx)(e.code,{children:\"maxArea\"}),\" to \",(0,t.jsx)(e.code,{children:\"0\"}),\" to keep track of the maximum water area found.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Use a nested loop to iterate over all pairs of walls:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The outer loop represents the left wall, iterating from the first wall to the second-last wall.\"}),`\n`,(0,t.jsx)(e.li,{children:\"The inner loop represents the right wall, iterating from one wall after the left wall to the last wall.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"For each pair of walls, calculate the width between the walls as \",(0,t.jsx)(e.code,{children:\"right - left\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Determine the height of the container using the shorter wall by calling \",(0,t.jsx)(e.code,{children:\"Math.min(walls[left], walls[right])\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Calculate the area of water that can be held by multiplying the height and width.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Update \",(0,t.jsx)(e.code,{children:\"maxArea\"}),\" with the larger value between the current \",(0,t.jsx)(e.code,{children:\"maxArea\"}),\" and the newly calculated area.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"After completing the nested loops, return \",(0,t.jsx)(e.code,{children:\"maxArea\"}),\" as the result.\"]}),`\n`]}),`\n`,(0,t.jsx)(i,{children:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,t.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The nested loops iterate over all pairs of walls, leading to a quadratic time complexity.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional space is used beyond a few variables for tracking the maximum area and calculating values.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Two Pointers\"}),`\n`,(0,t.jsx)(e.p,{children:\"This solution uses the two-pointer technique to optimize the process of finding the maximum water that can be trapped between two walls. The idea is to use two pointers, one starting at the leftmost wall and the other at the rightmost wall, and calculate the area between them. The area is determined by the shorter wall, as it limits the height, and the width between the two walls.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Instead of evaluating every possible pair of walls, as in the brute force approach, the two-pointer technique eliminates unnecessary comparisons by moving the pointers. By always moving the pointer of the shorter wall inward, the algorithm ensures that the width decreases while trying to find a taller wall that could potentially increase the area. This approach avoids unnecessary or duplicated work, reducing the time complexity from O(n\",(0,t.jsx)(\"sup\",{children:\"2\"}),\") to O(n).\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize two pointers, \",(0,t.jsx)(e.code,{children:\"left\"}),\" at the start of the array and \",(0,t.jsx)(e.code,{children:\"right\"}),\" at the end of the array.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize a variable \",(0,t.jsx)(e.code,{children:\"maxWaterArea\"}),\" to store the maximum water area found.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Use a \",(0,t.jsx)(e.code,{children:\"while\"}),\" loop to iterate as long as \",(0,t.jsx)(e.code,{children:\"left\"}),\" is less than \",(0,t.jsx)(e.code,{children:\"right\"}),\":\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Calculate the area between the walls pointed to by \",(0,t.jsx)(e.code,{children:\"left\"}),\" and \",(0,t.jsx)(e.code,{children:\"right\"}),\". The height is the smaller of the two walls, and the width is the distance between the pointers (\",(0,t.jsx)(e.code,{children:\"right - left\"}),\").\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Update \",(0,t.jsx)(e.code,{children:\"maxWaterArea\"}),\" with the larger value between the current \",(0,t.jsx)(e.code,{children:\"maxWaterArea\"}),\" and the newly calculated area.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move the pointer with the shorter wall inward:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"walls[left]\"}),\" is smaller, increment \",(0,t.jsx)(e.code,{children:\"left\"}),\" to find a taller wall.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Otherwise, decrement \",(0,t.jsx)(e.code,{children:\"right\"}),\" to find a taller wall on the right.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"maxWaterArea\"}),\" as the maximum water area found.\"]}),`\n`]}),`\n`,(0,t.jsx)(i,{children:d}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each pointer moves at most \",(0,t.jsx)(e.code,{children:\"n\"}),\" steps, leading to a linear runtime.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional space is required beyond a few variables for tracking pointers and area calculations.\"]}),`\n`]})]})}function B(a={}){let{wrapper:e}=a.components||{};return e?(0,t.jsx)(e,Object.assign({},a,{children:(0,t.jsx)(w,a)})):w(a)}var M=B;return v(O);})();\n;return Component;"
}