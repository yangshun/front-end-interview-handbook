{
  "description": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var r in e)i(n,r,{get:e[r],enumerable:!0})},a=(n,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of f(e))!b.call(n,o)&&o!==r&&i(n,o,{get:()=>e[o],enumerable:!(s=p(e,o))||s.enumerable});return n};var y=(n,e,r)=>(r=n!=null?u(x(n)):{},a(e||!n||!n.__esModule?i(r,\"default\",{value:n,enumerable:!0}):r,n)),w=n=>a(i({},\"__esModule\",{value:!0}),n);var d=g((E,l)=>{l.exports=_jsx_runtime});var D={};v(D,{default:()=>C,frontmatter:()=>M});var t=y(d());var h=MDXTestExamples;var m=[{input:[[\"numbers\",[4,1,0,0,2,3]]],output:!0,explanation:\"Move from index 0 to 4, then move 1 position to the last index.\"},{input:[[\"numbers\",[1,0,0,0]]],output:!1,explanation:\"Can only move from index 0 to index 1 and no further movements thereafter, so it impossible to reach the last index.\"},{input:[[\"numbers\",[2,3,1,1,4]]],output:!0,explanation:\"Move 1 position forward from index 0 to index 1 (it is allowed to move up to 2 positions, but going to index 1 first allows us to move further). From index 1, move 3 positions to reach the last index.\"}];var M={title:\"End of Array Reachable\",excerpt:\"Implement a function to determine if the end of the array is reachable\"};function c(n){let e=Object.assign({p:\"p\",code:\"code\",strong:\"strong\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given an array of integers \",(0,t.jsx)(e.code,{children:\"numbers\"}),\" where each element in the array represents the \",(0,t.jsx)(e.strong,{children:\"maximum\"}),\" number of positions that can be moved forward from that index; it is acceptable to move by fewer positions.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Determine whether it is possible to reach the last index of the array by starting from the first index. Return \",(0,t.jsx)(e.code,{children:\"true\"}),\" if it can be reached and \",(0,t.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers, each index's value is the maximum number of positions reachable from that index\"]}),`\n`]}),`\n`,(0,t.jsx)(h,{testCases:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"1 <= \",(0,t.jsx)(e.code,{children:\"numbers.length\"}),\" <= 10,000\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"0 <= \",(0,t.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 100,000\"]}),`\n`]})]})}function _(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(c,n)})):c(n)}var C=_;return w(D);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to determine if the end of the array is reachable",
    "title": "End of Array Reachable"
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,O=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),D=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!O.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(h=b(e,r))||h.enumerable});return t};var w=(t,e,i)=>(i=t!=null?f(g(t)):{},s(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),I=t=>s(o({},\"__esModule\",{value:!0}),t);var l=x((T,c)=>{c.exports=_jsx_runtime});var v={};D(v,{default:()=>P});var n=w(l());var a=MDXCodeBlock;var d=`export default function arrayReachableEnd(numbers: number[]): boolean {\n  // Initialize a variable to track the farthest reachable position (last element initially)\n  let farthestReachable = numbers.length - 1;\n\n  // Iterate backwards through the array (from the end)\n  for (\n    let currentPosition = numbers.length - 1;\n    currentPosition >= 0;\n    currentPosition--\n  ) {\n    // Check if the current position can reach the farthest reachable position\n    if (currentPosition + numbers[currentPosition] >= farthestReachable) {\n      // Update the farthest reachable position if the current position can reach it\n      farthestReachable = currentPosition;\n    }\n  }\n\n  // Return true if the farthest reachable position is the\n  // first element (meaning you can reach the end)\n  return farthestReachable === 0;\n}\n`;var m=`// Memoization array to store the state of each position\nlet memo: string[];\n\n/**\n * Helper function to determine if you can reach to the last position from the current position.\n *\n * @param {number} position - The current position in the array.\n * @param {number[]} numbers - An array of numbers representing maximum movement lengths at each index.\n * @returns {boolean} - True if you can reach the last element from the current position, false otherwise.\n */\nconst canReachLastPosition = (position: number, numbers: number[]): boolean => {\n  // Check the memoization array to see if the result is already computed\n  if (memo[position] !== 'UNKNOWN') {\n    return memo[position] === 'GOOD';\n  }\n\n  // If current position is a stuck position, directly return false\n  if (numbers[position] === 0) {\n    memo[position] = 'BAD';\n    return false;\n  }\n\n  // Calculate the furthest position that can be reached from the current position\n  const furthestPosition = Math.min(\n    position + numbers[position],\n    numbers.length - 1,\n  );\n\n  // Iterate through all positions that can be reached from the current position\n  // Iterate backward for better efficiency (reduce redundant calls)\n  for (\n    let nextPosition = furthestPosition;\n    nextPosition > position;\n    nextPosition--\n  ) {\n    if (canReachLastPosition(nextPosition, numbers)) {\n      memo[position] = 'GOOD';\n      return true;\n    }\n  }\n\n  // If none of the next positions can reach the last position, mark the current position as \"BAD\"\n  memo[position] = 'BAD';\n  return false;\n};\n\n/**\n * Determines if you can reach the last element in an array, where each element represents\n * the maximum positions you can reach from that index.\n *\n * @param {number[]} numbers - An array of numbers representing maximum positions reachable from that index.\n * @returns {boolean} - True if you can reach the last index, false otherwise.\n */\nexport default function arrayReachableEnd(numbers: number[]): boolean {\n  // Initialize the memoization array with \"UNKNOWN\"\n  memo = new Array(numbers.length).fill('UNKNOWN');\n\n  // The last position is always \"GOOD\" because we are already there\n  memo[memo.length - 1] = 'GOOD';\n\n  // Start the recursion from the first position\n  return canReachLastPosition(0, numbers);\n}\n`;var u=`// Enum to represent the state of each index in the array\nenum Index {\n  GOOD, // Represents a position from which you can reach the last position\n  BAD, // Represents a position from which you cannot reach the last position\n  UNKNOWN, // Represents an unknown state\n}\n\n/**\n * Determines if you can reach the last element in an array, where each element represents\n * the maximum positions you can reach from that index.\n *\n * @param {number[]} numbers - An array of numbers representing maximum positions reachable from that index.\n * @returns {boolean} - True if you can reach the last index, false otherwise.\n */\nexport default function arrayReachableEnd(numbers: number[]): boolean {\n  // Initialize the memoization array with \"UNKNOWN\"\n  let memo: Index[] = Array(numbers.length).fill(Index.UNKNOWN);\n\n  // The last position is always \"GOOD\" because we are already there\n  memo[memo.length - 1] = Index.GOOD;\n\n  // Iterate from the second last position to the first position\n  for (let i = numbers.length - 2; i >= 0; i--) {\n    // Calculate the furthest position that can be reached from the current position\n    let furthestPosition: number = Math.min(i + numbers[i], numbers.length - 1);\n\n    // Check if any reachable position from the current position is \"GOOD\"\n    for (let j = i + 1; j <= furthestPosition; j++) {\n      if (memo[j] === Index.GOOD) {\n        // Mark the current position as \"GOOD\" if a reachable position is \"GOOD\"\n        memo[i] = Index.GOOD;\n        break;\n      }\n    }\n  }\n\n  // Return true if the first position is \"GOOD\", meaning you can reach the last element\n  return memo[0] === Index.GOOD;\n}\n`;function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Bottom-Up Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:\"A naive solution would involve recursively exploring all possible paths from the first position to check if the last position can be reached. This approach suffers from redundant computations and an exponential time complexity, as it explores overlapping subproblems multiple times.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The bottom-up dynamic programming approach optimizes this by iterating from the second-last position to the first position while maintaining a \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array that records whether each position is \",(0,n.jsx)(e.code,{children:\"GOOD\"}),\", \",(0,n.jsx)(e.code,{children:\"BAD\"}),\", or \",(0,n.jsx)(e.code,{children:\"UNKNOWN\"}),\". A position is \",(0,n.jsx)(e.code,{children:\"GOOD\"}),\" if it can reach the last position or a position already marked as \",(0,n.jsx)(e.code,{children:\"GOOD\"}),\". The optimization eliminates redundant checks by using previously computed results in the \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define an enumeration \",(0,n.jsx)(e.code,{children:\"Index\"}),\" with states \",(0,n.jsx)(e.code,{children:\"GOOD\"}),\", \",(0,n.jsx)(e.code,{children:\"BAD\"}),\", and \",(0,n.jsx)(e.code,{children:\"UNKNOWN\"}),\" to represent the state of each index.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array of the same length as the input array with all values set to \",(0,n.jsx)(e.code,{children:\"Index.UNKNOWN\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set the last position in \",(0,n.jsx)(e.code,{children:\"memo\"}),\" to \",(0,n.jsx)(e.code,{children:\"Index.GOOD\"}),\" since the last position can trivially reach itself.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate backward through the input array from the second-last position to the first position:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the furthest position reachable from the current index using the minimum of \",(0,n.jsx)(e.code,{children:\"i + numbers[i]\"}),\" and the last index.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check all positions between the current index and the furthest reachable position:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If any of these positions is marked as \",(0,n.jsx)(e.code,{children:\"Index.GOOD\"}),\" in \",(0,n.jsx)(e.code,{children:\"memo\"}),\", mark the current position as \",(0,n.jsx)(e.code,{children:\"Index.GOOD\"}),\" and break the inner loop.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the first position is marked as \",(0,n.jsx)(e.code,{children:\"Index.GOOD\"}),\" in \",(0,n.jsx)(e.code,{children:\"memo\"}),\", indicating the last position is reachable. Otherwise, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". For each position, the inner loop checks up to \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" positions, leading to a worst-case quadratic complexity.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array of size \",(0,n.jsx)(e.code,{children:\"n\"}),\" is used for dynamic programming storage.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Top-Down Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:\"There is another top-down dynamic programming approach, where the process begins from the first position and uses recursion to determine whether subsequent reachable positions can lead to the last position. The memoization array ensures that previously computed results are reused, avoiding redundant calculations and improving efficiency.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array of the same length as the input array with all values set to \",(0,n.jsx)(e.code,{children:\"'UNKNOWN'\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set the last position in the \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array to \",(0,n.jsx)(e.code,{children:\"'GOOD'\"}),\" because it can trivially reach itself.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"canReachLastPosition\"}),\" that takes the current position and the input array as arguments:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the current position is already marked in \",(0,n.jsx)(e.code,{children:\"memo\"}),\", return the corresponding result.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the value at the current position is \",(0,n.jsx)(e.code,{children:\"0\"}),\", mark it as \",(0,n.jsx)(e.code,{children:\"'BAD'\"}),\" and return \",(0,n.jsx)(e.code,{children:\"false\"}),\" because it cannot proceed further.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the furthest position reachable from the current position as the minimum of \",(0,n.jsx)(e.code,{children:\"position + numbers[position]\"}),\" and the last index.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate backward through all reachable positions from the current position:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If any reachable position is \",(0,n.jsx)(e.code,{children:\"'GOOD'\"}),\", mark the current position as \",(0,n.jsx)(e.code,{children:\"'GOOD'\"}),\" and return \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If none of the reachable positions are \",(0,n.jsx)(e.code,{children:\"'GOOD'\"}),\", mark the current position as \",(0,n.jsx)(e.code,{children:\"'BAD'\"}),\" and return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Start the recursion from the first position using the helper function.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the first position is \",(0,n.jsx)(e.code,{children:\"'GOOD'\"}),\", indicating the last position is reachable. Otherwise, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The worst-case scenario involves checking all reachable positions for each index, resulting in quadratic complexity.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array of size \",(0,n.jsx)(e.code,{children:\"n\"}),\" is used for storing intermediate results, and the recursion stack may go up to \",(0,n.jsx)(e.code,{children:\"n\"}),\" calls.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"3. Greedy Approach\"}),`\n`,(0,n.jsx)(e.p,{children:\"In the greedy approach, the algorithm starts from the last position and iterates backward. For each position, it checks if the current position can reach the farthest reachable position. If it can, the farthest reachable position is updated to the current position. If, after processing the entire array, the farthest reachable position becomes the first index, it means the last position is reachable.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a variable \",(0,n.jsx)(e.code,{children:\"farthestReachable\"}),\" to the last index of the array (\",(0,n.jsx)(e.code,{children:\"numbers.length - 1\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate backward through the array starting from the last index:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each position, check if \",(0,n.jsx)(e.code,{children:\"currentPosition + numbers[currentPosition]\"}),\" is greater than or equal to \",(0,n.jsx)(e.code,{children:\"farthestReachable\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If true, update \",(0,n.jsx)(e.code,{children:\"farthestReachable\"}),\" to \",(0,n.jsx)(e.code,{children:\"currentPosition\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After the iteration, check if \",(0,n.jsx)(e.code,{children:\"farthestReachable\"}),\" equals \",(0,n.jsx)(e.code,{children:\"0\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if \",(0,n.jsx)(e.code,{children:\"farthestReachable\"}),\" is \",(0,n.jsx)(e.code,{children:\"0\"}),\", indicating the last position is reachable from the first position.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Otherwise, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(a,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm iterates through the array once in reverse order.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional space is used other than a constant number of variables.\"]}),`\n`]})]})}function R(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var P=R;return I(v);})();\n;return Component;"
}