{
  "description": "var Component=(()=>{var u=Object.create;var c=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var r in e)c(t,r,{get:e[r],enumerable:!0})},s=(t,e,r,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!b.call(t,i)&&i!==r&&c(t,i,{get:()=>e[i],enumerable:!(d=g(e,i))||d.enumerable});return t};var j=(t,e,r)=>(r=t!=null?u(f(t)):{},s(e||!t||!t.__esModule?c(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>s(c({},\"__esModule\",{value:!0}),t);var l=x((E,o)=>{o.exports=_jsx_runtime});var D={};w(D,{default:()=>M,frontmatter:()=>T});var n=j(l());var a=MDXTestExamples;var h=[{input:[[\"str\",\"greatfrontendgreat\"],[\"dict\",[\"frontend\",\"great\"]]],output:!0,explanation:\"The string can be segmented as 'great' + 'frontend' + 'great' as we can re-use 'great'.\"},{input:[[\"str\",\"abcd\"],[\"dict\",[\"a\",\"abc\",\"b\",\"cd\"]]],output:!0,explanation:\"The string can be segmented as 'a' + 'b' + 'cd'.\"},{input:[[\"str\",\"a\"],[\"dict\",[\"b\"]]],output:!1,explanation:\"The single character 'a' is not in the word dictionary.\"}];var T={title:\"Segment Words\",excerpt:\"Implement a function to check whether a string be formed from dictionary words\"};function m(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a string \",(0,n.jsx)(e.code,{children:\"str\"}),\" and a list of words \",(0,n.jsx)(e.code,{children:\"dict\"}),\", determine if \",(0,n.jsx)(e.code,{children:\"str\"}),\" can be segmented into a sequence of one or more words from \",(0,n.jsx)(e.code,{children:\"dict\"}),\". Words from \",(0,n.jsx)(e.code,{children:\"dict\"}),\" can be reused multiple times in the segmentation.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if it is possible to segment \",(0,n.jsx)(e.code,{children:\"str\"}),\", and \",(0,n.jsx)(e.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str: string\"}),\": A string representing the string to be segmented\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"dict: string[]\"}),\": An array of strings representing the dictionary of available words\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Words from \",(0,n.jsx)(e.code,{children:\"dict\"}),\" can be used multiple times in the segmentation\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"str.length\"}),\" <= 300\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"dict.length\"}),\" <= 300\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"dict[i].length\"}),\" <= 300\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str\"}),\" and \",(0,n.jsx)(e.code,{children:\"dict[i]\"}),\" consist of only lowercase English letters\"]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var M=C;return _(D);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to check whether a string be formed from dictionary words",
    "title": "Segment Words"
  },
  "solution": "var Component=(()=>{var m=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var k=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!y.call(t,r)&&r!==i&&s(t,r,{get:()=>e[r],enumerable:!(o=p(e,r))||o.enumerable});return t};var w=(t,e,i)=>(i=t!=null?m(b(t)):{},c(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),v=t=>c(s({},\"__esModule\",{value:!0}),t);var a=k((B,h)=>{h.exports=_jsx_runtime});var I={};x(I,{default:()=>C});var n=w(a());var d=MDXCodeBlock;var l=`export default function segmentWords(str: string, dict: string[]): boolean {\n  // Create a set from the word dictionary for quick lookup\n  const dictSet = new Set(dict);\n\n  // Create a DP array initialized to false, with an extra space for the base case\n  const dp: boolean[] = new Array(str.length + 1).fill(false);\n  dp[0] = true; // Base case: an empty string can always be segmented\n\n  // Iterate over the end positions of the substring\n  for (let end = 1; end <= str.length; end++) {\n    // Iterate over the start positions of the substring\n    for (let start = 0; start < end; start++) {\n      // If the substring from start to end can be segmented\n      if (dp[start] && dictSet.has(str.substring(start, end))) {\n        dp[end] = true; // Mark the end position as true\n        break; // No need to check further start positions for this end\n      }\n    }\n  }\n\n  // The last element in dp represents whether the entire string can be segmented\n  return dp[str.length];\n}\n`;var u=`export default function segmentWords(str: string, dict: string[]): boolean {\n  // Convert dict to a set for O(1) average time complexity lookups\n  const words = new Set(dict);\n\n  // Check for empty string as a base case\n  if (str.length === 0) return true;\n\n  // Initialize variables\n  const queue: number[] = [0];\n  const seen = new Set<number>();\n\n  // Breadth-first search loop\n  while (queue.length !== 0) {\n    // Check if queue is empty before dequeueing\n    if (queue.length === 0) return false; // String cannot be formed from words\n\n    const start = queue.shift()!; // Use non-null assertion after the check\n\n    // If we reached the end of the string, return true\n    if (start === str.length) return true;\n\n    // Iterate over all possible end indices from start + 1 to end of string\n    for (let end = start + 1; end <= str.length; end++) {\n      // Skip already processed end indices\n      if (seen.has(end)) continue;\n\n      // Check if substring from start to end exists in dict\n      if (words.has(str.substring(start, end))) {\n        // If found, enqueue the end index and mark as visited\n        queue.push(end);\n        seen.add(end);\n      }\n    }\n  }\n\n  // If no segmentation found, return false\n  return false;\n}\n`;function g(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Dynamic Programming\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The dynamic programming approach solves the problem of segmenting a string into words from a given dictionary by breaking it into smaller subproblems. The key intuition is that if a prefix of the string can be segmented and the remaining substring exists in the dictionary, then the entire string can be segmented. A \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array is used to store whether a substring ending at each position can be segmented.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"dp[i]\"}),\" represents whether the substring \",(0,n.jsx)(e.code,{children:\"str[0...i-1]\"}),\" can be segmented into valid words from the dictionary. This method ensures that overlapping subproblems are solved only once, avoiding redundant computations.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Convert the word dictionary into a \",(0,n.jsx)(e.code,{children:\"Set\"}),\" for fast lookup of words.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Create a \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array of size \",(0,n.jsx)(e.code,{children:\"str.length + 1\"}),\" initialized to \",(0,n.jsx)(e.code,{children:\"false\"}),\".\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"dp[0]\"}),\" to \",(0,n.jsx)(e.code,{children:\"true\"}),\" because an empty string can always be segmented.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the string to check substrings ending at each position \",(0,n.jsx)(e.code,{children:\"end\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each \",(0,n.jsx)(e.code,{children:\"end\"}),\", iterate through possible starting positions \",(0,n.jsx)(e.code,{children:\"start\"}),\" of substrings.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the substring \",(0,n.jsx)(e.code,{children:\"str[start...end-1]\"}),\" exists in the dictionary and if \",(0,n.jsx)(e.code,{children:\"dp[start]\"}),\" is \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If both conditions are satisfied, set \",(0,n.jsx)(e.code,{children:\"dp[end]\"}),\" to \",(0,n.jsx)(e.code,{children:\"true\"}),\" and break the inner loop.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the value of \",(0,n.jsx)(e.code,{children:\"dp[str.length]\"}),\", which indicates whether the entire string can be segmented.\"]}),`\n`]}),`\n`,(0,n.jsx)(d,{children:l}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n.m.k)\"}),\". Calculating whether the substring exists in the dictionary costs O(m.k), where \",(0,n.jsx)(e.code,{children:\"m\"}),\" is the size of the dictionary and \",(0,n.jsx)(e.code,{children:\"k\"}),\" is the average word length. Since there are O(n) states to calculate, the total time complexity is O(n.m.k).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array requires O(n) space.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using BFS\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The breadth-first search (BFS) approach solves the string segmentation problem by exploring all possible segmentations as levels in a graph. The key intuition is that the problem can be represented as navigating from the start to the end of the string, where each valid substring corresponds to an edge connecting two nodes (indices). A queue is used to perform BFS, starting from index \",(0,n.jsx)(e.code,{children:\"0\"}),\", and exploring all possible substrings that exist in the dictionary.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The use of BFS ensures that the solution checks all valid paths systematically. To prevent redundant computations, a \",(0,n.jsx)(e.code,{children:\"seen\"}),\" set is used to track already visited indices.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Convert the dictionary \",(0,n.jsx)(e.code,{children:\"dict\"}),\" into a \",(0,n.jsx)(e.code,{children:\"Set\"}),\" for O(1) average time complexity lookups.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check the base case where the string is empty. If the string is empty, return \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a queue with the starting index \",(0,n.jsx)(e.code,{children:\"0\"}),\" and a \",(0,n.jsx)(e.code,{children:\"seen\"}),\" set to track visited indices.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform BFS:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Dequeue the front element of the queue, representing the current starting index.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the starting index equals the length of the string, return \",(0,n.jsx)(e.code,{children:\"true\"}),\", as the string can be segmented.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate over all possible ending indices from \",(0,n.jsx)(e.code,{children:\"start + 1\"}),\" to \",(0,n.jsx)(e.code,{children:\"str.length\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Skip indices that are already in the \",(0,n.jsx)(e.code,{children:\"seen\"}),\" set.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the substring from \",(0,n.jsx)(e.code,{children:\"start\"}),\" to \",(0,n.jsx)(e.code,{children:\"end\"}),\" exists in the dictionary:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Add the \",(0,n.jsx)(e.code,{children:\"end\"}),\" index to the queue.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Mark the \",(0,n.jsx)(e.code,{children:\"end\"}),\" index as visited in the \",(0,n.jsx)(e.code,{children:\"seen\"}),\" set.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the queue is exhausted and no valid segmentation is found, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(d,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"3\"}),\" + m\\u22C5k)\"]}),\". There are O(n) nodes, and each node is visited at most once due to the \",(0,n.jsx)(e.code,{children:\"seen\"}),\" set. At each node, the algorithm iterates over the nodes in front of the current node (O(n)) and creates substrings (O(n)), resulting in O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\") per node. Thus, the BFS costs O(n\",(0,n.jsx)(\"sup\",{children:\"3\"}),\"). Additionally, creating the \",(0,n.jsx)(e.code,{children:\"words\"}),\" set from the dictionary costs O(m\\u22C5k), where \",(0,n.jsx)(e.code,{children:\"m\"}),\" is the size of the dictionary and \",(0,n.jsx)(e.code,{children:\"k\"}),\" is the average word length.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n + m\\u22C5k)\"}),\". The \",(0,n.jsx)(e.code,{children:\"queue\"}),\" and \",(0,n.jsx)(e.code,{children:\"seen\"}),\" set require O(n) space, while the \",(0,n.jsx)(e.code,{children:\"words\"}),\" set requires O(m\\u22C5k) space.\"]}),`\n`]})]})}function q(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(g,t)})):g(t)}var C=q;return v(I);})();\n;return Component;"
}