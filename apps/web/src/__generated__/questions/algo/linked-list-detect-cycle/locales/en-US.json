{
  "description": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var k=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),w=(n,e)=>{for(var i in e)o(n,i,{get:e[i],enumerable:!0})},a=(n,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of m(e))!x.call(n,s)&&s!==i&&o(n,s,{get:()=>e[s],enumerable:!(l=f(e,s))||l.enumerable});return n};var T=(n,e,i)=>(i=n!=null?p(k(n)):{},a(e||!n||!n.__esModule?o(i,\"default\",{value:n,enumerable:!0}):i,n)),b=n=>a(o({},\"__esModule\",{value:!0}),n);var r=y((C,c)=>{c.exports=_jsx_runtime});var _={};w(_,{default:()=>N,frontmatter:()=>v});var t=T(r());var h=MDXTestExamples;var d=[{input:[[\"list\",[1,2,3]],[\"pos\",0]],output:!0,explanation:\"The linked list is constructed from the array [1, 2, 3] with the pos = 0, which means the last node (value 3) connects back to the 0th node (value 1). The structure of the linked list is: 1 -> 2 -> 3 -> (back to 1). This forms a cycle starting from node 1. Hence, the output is true.\"},{input:[[\"list\",[1]],[\"pos\",-1]],output:!1,explanation:\"The linked list has only one node with the value 1. The pos = -1 indicates that the last node does not connect to any other node. The structure of the linked list is: 1 -> null. Since the list terminates with null and does not loop back to any earlier node, it does not contain a cycle. Hence, the output is false.\"},{input:[[\"list\",[3,2,0,-4]],[\"pos\",1]],output:!0,explanation:\"The linked list is constructed from the array [3, 2, 0, -4] with the pos = 1, which means the last node (value -4) connects back to the 1st node (value 2). The structure of the linked list is: 3 -> 2 -> 0 -> -4 -> (back to 2). This forms a cycle starting at node 2. Hence, the output is true.\"}];var v={title:\"Linked List Detect Cycle\",excerpt:\"Implement a function to detect if there are cycles in a linked list\"};function u(n){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given the head node of a \",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Linked_list\",children:\"linked list\"}),\", determine whether the list contains a cycle. Return \",(0,t.jsx)(e.code,{children:\"true\"}),\" if the list contains a cycle; otherwise, return \",(0,t.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,t.jsx)(e.p,{children:\"A linked list has a cycle if there exists a node that can be revisited by continuously following the next pointers.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The linked list is represented by a sequence of \",(0,t.jsx)(e.code,{children:\"ListNode\"}),\"s, where each node points to the next node in the sequence, or \",(0,t.jsx)(e.code,{children:\"null\"}),\" if it is the last node.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.code,{children:\"ListNode\"}),\" has the following interface:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ts\",children:`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"head: ListNode\"}),\": Head of the linked list. Examples display each linked list as an array of values within the list\"]}),`\n`]}),`\n`,(0,t.jsx)(h,{testCases:d}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"0 <= Number of nodes <= 1000\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"-1000 <= \",(0,t.jsx)(e.code,{children:\"ListNode.val\"}),\" <= 1000\"]}),`\n`]})]})}function L(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var N=L;return b(_);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to detect if there are cycles in a linked list",
    "title": "Linked List Detect Cycle"
  },
  "solution": "var Component=(()=>{var p=Object.create;var r=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var i in e)r(n,i,{get:e[i],enumerable:!0})},s=(n,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!g.call(n,l)&&l!==i&&r(n,l,{get:()=>e[l],enumerable:!(c=y(e,l))||c.enumerable});return n};var k=(n,e,i)=>(i=n!=null?p(w(n)):{},s(e||!n||!n.__esModule?r(i,\"default\",{value:n,enumerable:!0}):i,n)),S=n=>s(r({},\"__esModule\",{value:!0}),n);var h=v((O,d)=>{d.exports=_jsx_runtime});var L={};x(L,{default:()=>C});var t=k(h());var o=MDXCodeBlock;var a=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function linkedListDetectCycle(head: ListNode | null): boolean {\n  // Create a Set to track nodes that have been visited\n  const nodesSeen = new Set<ListNode>();\n  // Start with the head of the linked list\n  let current = head;\n\n  // Traverse the linked list\n  while (current !== null) {\n    // If the current node has been seen before, a cycle is present\n    if (nodesSeen.has(current)) {\n      return true;\n    }\n\n    // Add the current node to the Set of seen nodes\n    nodesSeen.add(current);\n\n    // Move to the next node in the linked list\n    current = current.next;\n  }\n\n  // If the end of the list is reached without finding a cycle, return false\n  return false;\n}\n`;var f=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function linkedListDetectCycle(head: ListNode | null): boolean {\n  // If the list is empty or has only one node without a cycle, return false\n  if (head === null) {\n    return false;\n  }\n\n  // Initialize two pointers: slow and fast\n  // Slow pointer advances by one step at a time\n  let slow: ListNode | null = head;\n  // Fast pointer advances by two steps at a time\n  let fast: ListNode | null = head.next;\n\n  // Traverse the list\n  while (fast !== null && fast.next !== null) {\n    // Move slow pointer by one step\n    if (slow === null) {\n      // This check is for TypeScript to satisfy non-null assertions\n      return false;\n    }\n    slow = slow.next;\n\n    // Move fast pointer by two steps\n    fast = fast.next.next;\n\n    // If slow and fast pointers meet, a cycle is detected\n    if (slow === fast) {\n      return true;\n    }\n  }\n\n  // If fast pointer reaches the end of the list, no cycle exists\n  return false;\n}\n`;function u(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Set\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The approach for detecting a cycle in a linked list using a \",(0,t.jsx)(e.code,{children:\"Set\"}),\" uses the property that a cycle causes repeated traversal of certain nodes. By storing visited nodes in a \",(0,t.jsx)(e.code,{children:\"Set\"}),\", the algorithm efficiently checks if a node has already been seen. If a node is revisited, a cycle exists. Otherwise, if the traversal reaches the end of the list, no cycle is present.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"Set\"}),\" provides an efficient way to store and check for the existence of nodes. The time complexity of insertion and lookup in a \",(0,t.jsx)(e.code,{children:\"Set\"}),\" is O(1), making it well-suited for this task.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"During traversal, each node is added to the \",(0,t.jsx)(e.code,{children:\"Set\"}),\". If a node is encountered that is already present in the \",(0,t.jsx)(e.code,{children:\"Set\"}),\", it means the list has cycled back to a previously visited node.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"As soon as a cycle is detected (a repeated node is found), the traversal stops, ensuring the algorithm is efficient.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"If the end of the list (\",(0,t.jsx)(e.code,{children:\"null\"}),\") is reached without encountering a repeated node, it confirms there is no cycle in the list.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This approach is simple and uses additional space to track visited nodes.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Create a \",(0,t.jsx)(e.code,{children:\"Set\"}),\" named \",(0,t.jsx)(e.code,{children:\"nodesSeen\"}),\" to store nodes that have been visited.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize a variable \",(0,t.jsx)(e.code,{children:\"current\"}),\" to point to the head of the linked list.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Traverse the list using a \",(0,t.jsx)(e.code,{children:\"while\"}),\" loop until \",(0,t.jsx)(e.code,{children:\"current\"}),\" becomes \",(0,t.jsx)(e.code,{children:\"null\"}),\":\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Check if \",(0,t.jsx)(e.code,{children:\"current\"}),\" is already in \",(0,t.jsx)(e.code,{children:\"nodesSeen\"}),\".\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"true\"}),\", return \",(0,t.jsx)(e.code,{children:\"true\"}),\" as a cycle is detected.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Add \",(0,t.jsx)(e.code,{children:\"current\"}),\" to \",(0,t.jsx)(e.code,{children:\"nodesSeen\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move \",(0,t.jsx)(e.code,{children:\"current\"}),\" to the next node in the list.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the loop ends without detecting a cycle, return \",(0,t.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(o,{children:a}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node in the list is visited once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,t.jsx)(e.code,{children:\"Set\"}),\" stores up to \",(0,t.jsx)(e.code,{children:\"n\"}),\" nodes in the worst case (when there is no cycle).\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Floyd Cycle Algorithm\"}),`\n`,(0,t.jsxs)(e.p,{children:['The Floyd Cycle Detection Algorithm, also known as the \"Tortoise and Hare\" algorithm, is an efficient method for detecting a cycle in a linked list. The algorithm uses two pointers, a ',(0,t.jsx)(e.code,{children:\"slow\"}),\" pointer and a \",(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer, which traverse the list at different speeds. If a cycle exists, the two pointers will eventually meet. Otherwise, the \",(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer will reach the end of the list.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The \",(0,t.jsx)(e.code,{children:\"slow\"}),\" pointer moves one step at a time, while the \",(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer moves two steps at a time. This difference in speed ensures that if there is a cycle, the \",(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer will eventually catch up to the \",(0,t.jsx)(e.code,{children:\"slow\"}),\" pointer.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If the two pointers meet during traversal, it confirms the presence of a cycle. This is because the \",(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer loops around the cycle and catches up to the \",(0,t.jsx)(e.code,{children:\"slow\"}),\" pointer.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"If the \",(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer reaches the end of the list (\",(0,t.jsx)(e.code,{children:\"null\"}),\"), it means there is no cycle in the list. This ensures the algorithm terminates efficiently for acyclic lists.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The algorithm operates in linear time and uses constant space, making it optimal for detecting cycles in linked lists.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Check if the head of the list is \",(0,t.jsx)(e.code,{children:\"null\"}),\". If true, return \",(0,t.jsx)(e.code,{children:\"false\"}),\" as an empty list cannot have a cycle.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize two pointers:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"slow\"}),\" pointer set to the head of the list.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer set to \",(0,t.jsx)(e.code,{children:\"head.next\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Traverse the list using a \",(0,t.jsx)(e.code,{children:\"while\"}),\" loop:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Check if \",(0,t.jsx)(e.code,{children:\"fast\"}),\" or \",(0,t.jsx)(e.code,{children:\"fast.next\"}),\" is \",(0,t.jsx)(e.code,{children:\"null\"}),\". If true, return \",(0,t.jsx)(e.code,{children:\"false\"}),\" as there is no cycle.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move the \",(0,t.jsx)(e.code,{children:\"slow\"}),\" pointer one step forward (\",(0,t.jsx)(e.code,{children:\"slow = slow.next\"}),\").\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move the \",(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer two steps forward (\",(0,t.jsx)(e.code,{children:\"fast = fast.next.next\"}),\").\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Check if the \",(0,t.jsx)(e.code,{children:\"slow\"}),\" pointer is equal to the \",(0,t.jsx)(e.code,{children:\"fast\"}),\" pointer. If true, return \",(0,t.jsx)(e.code,{children:\"true\"}),\" as a cycle is detected.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the loop ends without the pointers meeting, return \",(0,t.jsx)(e.code,{children:\"false\"}),\" as no cycle exists.\"]}),`\n`]}),`\n`,(0,t.jsx)(o,{children:f}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each pointer traverses the list at most once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses only two pointers, regardless of the size of the list.\"]}),`\n`]})]})}function b(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var C=b;return S(L);})();\n;return Component;"
}