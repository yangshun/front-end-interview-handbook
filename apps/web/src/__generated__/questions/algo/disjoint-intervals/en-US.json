{
  "description": "var Component=(()=>{var m=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!f.call(t,i)&&i!==r&&a(t,i,{get:()=>e[i],enumerable:!(o=u(e,i))||o.enumerable});return t};var j=(t,e,r)=>(r=t!=null?m(x(t)):{},l(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>l(a({},\"__esModule\",{value:!0}),t);var d=g((I,s)=>{s.exports=_jsx_runtime});var F={};b(F,{default:()=>D,frontmatter:()=>_});var n=j(d());var c=MDXTestExamples;var h=[{input:[[\"intervals\",[[1,5],[2,3],[3,4],[4,6]]]],output:1,explanation:\"[1,5] overlaps with multiple intervals, and removing it makes the rest non-overlapping. Since only one interval needs to be removed, the result is 1.\"},{input:[[\"intervals\",[[1,15],[3,5],[6,8],[8,10],[9,11]]]],output:2,explanation:\"[1,15] overlaps with all other intervals, and [9,11] overlaps with [8,10]. Removing these two intervals makes the rest non-overlapping. Since two intervals need to be removed, the result is 2.\"},{input:[[\"intervals\",[[1,4],[4,8]]]],output:0,explanation:\"[1,4] and [4,8] are already non-overlapping, so no intervals need to be removed. Hence, the result is 0.\"}];var _={title:\"Disjoint Intervals\",excerpt:\"Implement a function to determine the minimum amount of removals to get non-overlapping intervals\"};function p(t){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h3:\"h3\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of \",(0,n.jsx)(e.code,{children:\"intervals\"}),\" where each interval is represented as \",(0,n.jsx)(e.code,{children:\"[start, end]\"}),\". Each pair denotes the start and end of an interval on a number line. For example, \",(0,n.jsx)(e.code,{children:\"[1, 3]\"}),\" represents an interval that starts at 1 and ends at 3.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Find the minimum number of intervals that need to be removed so that the remaining intervals are disjoint.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Intervals are considered disjoint if no two intervals overlap on the number line. For example:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"[1, 3]\"}),\" and \",(0,n.jsx)(e.code,{children:\"[4, 6]\"}),\" are disjoint because they do not share any common points\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"[1, 5]\"}),\" and \",(0,n.jsx)(e.code,{children:\"[4, 6]\"}),\" are not disjoint because they overlap at points between 4 and 5\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"intervals: Array<[number, number]>\"}),\": An array of integer pairs\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"intervals.length\"}),\" <= 100\"]}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"intervals[i].length == 2\"})}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"start\"}),\" <= \",(0,n.jsx)(e.code,{children:\"end\"}),\" <= 10,000\"]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var D=C;return w(F);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to determine the minimum amount of removals to get non-overlapping intervals",
    "title": "Disjoint Intervals"
  },
  "solution": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),k=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!g.call(t,i)&&i!==r&&o(t,i,{get:()=>e[i],enumerable:!(l=p(e,i))||l.enumerable});return t};var x=(t,e,r)=>(r=t!=null?u(f(t)):{},a(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),y=t=>a(o({},\"__esModule\",{value:!0}),t);var h=b((_,s)=>{s.exports=_jsx_runtime});var j={};k(j,{default:()=>S});var n=x(h());var c=MDXCodeBlock;var d=`const compareSecondElement = (a: number[], b: number[]): number => {\n  return a[1] - b[1]; // Return the difference between the second elements\n};\n\nexport default function disjointIntervals(intervals: number[][]): number {\n  // Sort intervals by the second element\n  intervals.sort(compareSecondElement);\n\n  // Initialize answer to count overlaps and k to track the end of the last interval\n  let ans = 0;\n  let k = Number.MIN_SAFE_INTEGER;\n\n  // Iterate through the intervals\n  for (const interval of intervals) {\n    const x = interval[0];\n    const y = interval[1];\n\n    if (x >= k) {\n      // Case 1: No overlap, update k to the end of the current interval\n      k = y;\n    } else {\n      // Case 2: Overlap, increment the answer\n      ans++;\n    }\n  }\n\n  // Return the number of overlaps\n  return ans;\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Greedy Approach\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem is to find the minimum number of intervals to remove so that the remaining intervals are non-overlapping. The greedy approach optimizes this by always choosing the interval with the earliest ending time, as this leaves the most room for subsequent intervals. Sorting by the second element ensures that intervals with the smallest end times are prioritized.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"compareSecondElement\"}),\" to compare the second elements of two intervals and return their difference.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Sort the input \",(0,n.jsx)(e.code,{children:\"intervals\"}),\" array using the \",(0,n.jsx)(e.code,{children:\"compareSecondElement\"}),\" function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"ans\"}),\" to track the number of intervals removed and \",(0,n.jsx)(e.code,{children:\"k\"}),\" to track the end time of the last non-overlapping interval.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through each interval in the sorted list:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Extract the start (\",(0,n.jsx)(e.code,{children:\"x\"}),\") and end (\",(0,n.jsx)(e.code,{children:\"y\"}),\") of the current interval.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the start of the current interval is greater than or equal to \",(0,n.jsx)(e.code,{children:\"k\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"k\"}),\" to the end time of the current interval as there is no overlap.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Otherwise, increment \",(0,n.jsx)(e.code,{children:\"ans\"}),\" as the interval overlaps and needs to be removed.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"ans\"}),\", which holds the count of intervals removed to make the intervals disjoint.\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Sorting the intervals takes O(n log n), and the subsequent iteration through the intervals takes O(n).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm operates in constant space as it processes the input array in-place.\"]}),`\n`]})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var S=O;return y(j);})();\n;return Component;"
}