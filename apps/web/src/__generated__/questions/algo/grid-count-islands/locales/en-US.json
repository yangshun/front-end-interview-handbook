{
  "description": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var y=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=>{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},c=(i,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let d of g(e))!x.call(i,d)&&d!==t&&r(i,d,{get:()=>e[d],enumerable:!(o=p(e,d))||o.enumerable});return i};var j=(i,e,t)=>(t=i!=null?m(f(i)):{},c(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),_=i=>c(r({},\"__esModule\",{value:!0}),i);var a=y((X,s)=>{s.exports=_jsx_runtime});var M={};b(M,{default:()=>T,frontmatter:()=>C});var n=j(a());var l=MDXTestExamples;var h=[{input:[[\"grid\",[[1,0],[0,0],[0,1],[0,1],[1,1]]]],output:2,explanation:\"There are 2 islands formed by connecting adjacent lands\"},{input:[[\"grid\",[[1,0,0],[1,1,1],[0,0,1]]]],output:1,explanation:\"There is one island formed by connecting adjacent lands\"},{input:[[\"grid\",[[1,1,1],[0,0,0],[0,0,0]]]],output:1,explanation:\"There is one island formed by connecting adjacent lands\"}];var C={title:\"Count Islands in a Grid\",excerpt:\"Implement a function to count distinct islands in a 2D binary grid\"};function u(i){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a two-dimensional binary grid \",(0,n.jsx)(e.code,{children:\"grid\"}),\" displaying a map where \",(0,n.jsx)(e.code,{children:\"1\"}),\"s signify land and \",(0,n.jsx)(e.code,{children:\"0\"}),\"s signify water, determine the number of distinct islands.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"An island is defined as a group of \",(0,n.jsx)(e.code,{children:\"1\"}),\"s connected horizontally or vertically, and is surrounded by \",(0,n.jsx)(e.code,{children:\"0\"}),\"s or the edge of the grid. It is assumed that the grid is completely surrounded by water.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid: number[][]\"}),\": A 2D array of where each element is \",(0,n.jsx)(e.code,{children:\"1\"}),\" or \",(0,n.jsx)(e.code,{children:\"0\"})]}),`\n`]}),`\n`,(0,n.jsx)(l,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"grid.length\"}),\", \",(0,n.jsx)(e.code,{children:\"grid[i].length\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid[i][j]\"}),\" is \",(0,n.jsx)(e.code,{children:\"0\"}),\" or \",(0,n.jsx)(e.code,{children:\"1\"})]}),`\n`]})]})}function D(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(u,i)})):u(i)}var T=D;return _(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to count distinct islands in a 2D binary grid",
    "title": "Count Islands in a Grid"
  },
  "solution": "var Component=(()=>{var m=Object.create;var t=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var b=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),y=(i,e)=>{for(var r in e)t(i,r,{get:e[r],enumerable:!0})},d=(i,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of w(e))!v.call(i,l)&&l!==r&&t(i,l,{get:()=>e[l],enumerable:!(c=f(e,l))||c.enumerable});return i};var I=(i,e,r)=>(r=i!=null?m(p(i)):{},d(e||!i||!i.__esModule?t(r,\"default\",{value:i,enumerable:!0}):r,i)),k=i=>d(t({},\"__esModule\",{value:!0}),i);var h=b((C,s)=>{s.exports=_jsx_runtime});var B={};y(B,{default:()=>D});var n=I(h());var o=MDXCodeBlock;var a=`// Helper function for Depth-First Search (DFS)\nfunction dfs(grid: number[][], row: number, col: number): void {\n  // Get the number of rows and columns\n  const rows = grid.length;\n  const cols = grid[0].length;\n\n  // Mark the current cell as visited by setting it to 0\n  grid[row][col] = 0;\n\n  // Check and visit the cell above the current cell\n  if (row - 1 >= 0 && grid[row - 1][col] === 1) {\n    dfs(grid, row - 1, col);\n  }\n\n  // Check and visit the cell below the current cell\n  if (row + 1 < rows && grid[row + 1][col] === 1) {\n    dfs(grid, row + 1, col);\n  }\n\n  // Check and visit the cell to the left of the current cell\n  if (col - 1 >= 0 && grid[row][col - 1] === 1) {\n    dfs(grid, row, col - 1);\n  }\n\n  // Check and visit the cell to the right of the current cell\n  if (col + 1 < cols && grid[row][col + 1] === 1) {\n    dfs(grid, row, col + 1);\n  }\n}\n\n// Main function to count the number of islands\nexport default function countGridIslands(grid: number[][]): number {\n  const rows = grid.length; // Get the number of rows\n  if (rows === 0) {\n    return 0; // If grid is empty, return 0\n  }\n\n  const cols = grid[0].length; // Get the number of columns\n\n  let numIslands = 0; // Initialize island count\n\n  // Iterate through each cell in the grid\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      // If the cell is land ('1'), it's part of an island\n      if (grid[row][col] === 1) {\n        ++numIslands; // Increment island count\n        dfs(grid, row, col); // Perform DFS to mark the entire island\n      }\n    }\n  }\n\n  return numIslands; // Return the total number of islands\n}\n`;var u=`export default function countGridIslands(grid: number[][]): number {\n  const rows = grid.length; // Get the number of rows\n  if (rows === 0) return 0; // If grid is empty, return 0\n  const cols = grid[0].length; // Get the number of columns\n\n  let numIslands = 0; // Initialize island count\n\n  // Iterate through each cell in the grid\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      // If the cell is land ('1'), it's part of an island\n      if (grid[row][col] === 1) {\n        ++numIslands; // Increment island count\n        grid[row][col] = 0; // Mark the current cell as visited by setting it to '0'\n        const neighbors: [number, number][] = [[row, col]]; // Initialize a queue for BFS\n\n        // Perform Breadth-First Search (BFS)\n        while (neighbors.length > 0) {\n          const [row, col] = neighbors.shift()!; // Dequeue a cell\n\n          // Check and visit the cell above the current cell\n          if (row - 1 >= 0 && grid[row - 1][col] === 1) {\n            neighbors.push([row - 1, col]);\n            grid[row - 1][col] = 0;\n          }\n\n          // Check and visit the cell below the current cell\n          if (row + 1 < rows && grid[row + 1][col] === 1) {\n            neighbors.push([row + 1, col]);\n            grid[row + 1][col] = 0;\n          }\n\n          // Check and visit the cell to the left of the current cell\n          if (col - 1 >= 0 && grid[row][col - 1] === 1) {\n            neighbors.push([row, col - 1]);\n            grid[row][col - 1] = 0;\n          }\n\n          // Check and visit the cell to the right of the current cell\n          if (col + 1 < cols && grid[row][col + 1] === 1) {\n            neighbors.push([row, col + 1]);\n            grid[row][col + 1] = 0;\n          }\n        }\n      }\n    }\n  }\n\n  return numIslands; // Return the total number of islands\n}\n`;function g(i){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using DFS\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The problem requires counting the number of islands in a 2D grid where each cell is either land (\",(0,n.jsx)(e.code,{children:\"1\"}),\") or water (\",(0,n.jsx)(e.code,{children:\"0\"}),\"). An island is defined as a group of adjacent land cells connected horizontally or vertically. The task is to count all distinct islands in the grid.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The approach uses depth-first search (DFS) to traverse and mark all cells of an island starting from a land cell. The grid is modified in place to mark visited cells as water (\",(0,n.jsx)(e.code,{children:\"0\"}),\") to avoid revisiting them. Each time an unvisited land cell is encountered, it indicates a new island, and a DFS is initiated to explore all connected land cells. This ensures that every island is counted exactly once.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This method eliminates unnecessary checks for already visited cells and avoids redundant processing by modifying the grid directly.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Retrieve the number of rows and columns from the grid dimensions.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a counter \",(0,n.jsx)(e.code,{children:\"numIslands\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" to store the total number of islands.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through every cell in the grid:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the cell value is \",(0,n.jsx)(e.code,{children:\"1\"}),\" (land), increment the \",(0,n.jsx)(e.code,{children:\"numIslands\"}),\" counter.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform a DFS from the current cell to explore the entire island and mark all connected land cells as visited by setting their values to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a recursive \",(0,n.jsx)(e.code,{children:\"dfs\"}),\" function:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Mark the current cell as visited by setting its value to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Recursively check and visit all adjacent cells (up, down, left, right) if they are within bounds and their value is \",(0,n.jsx)(e.code,{children:\"1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After processing all cells in the grid, return the \",(0,n.jsx)(e.code,{children:\"numIslands\"}),\" counter.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:a}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Every cell in the grid is visited once, either during the main iteration or during the DFS traversal.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(m.n)\"}),\". The recursion stack may grow up to the size of the grid in the worst case when the grid contains one large connected island.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using BFS\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This approach uses breadth-first search (BFS) to traverse the grid. The approach starts from any unvisited land cell, which marks the beginning of a new island. A BFS traversal is performed to visit all connected land cells, marking them as visited by setting their value to \",(0,n.jsx)(e.code,{children:\"0\"}),\". This ensures that each island is counted exactly once. The grid is modified in place to save additional space for tracking visited cells.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This approach systematically explores each island while avoiding redundant checks, making it efficient for large grids.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Retrieve the number of rows and columns from the grid dimensions.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a counter \",(0,n.jsx)(e.code,{children:\"numIslands\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" to keep track of the number of islands.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through every cell in the grid:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the cell value is \",(0,n.jsx)(e.code,{children:\"1\"}),\" (land), increment the \",(0,n.jsx)(e.code,{children:\"numIslands\"}),\" counter.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set the cell value to \",(0,n.jsx)(e.code,{children:\"0\"}),\" to mark it as visited.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Initialize a queue for BFS traversal and add the current cell to the queue.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform BFS using the queue:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Dequeue a cell from the queue.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"For each of its neighbors (up, down, left, right):\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the neighbor is within bounds and its value is \",(0,n.jsx)(e.code,{children:\"1\"}),\", enqueue it and mark it as visited by setting its value to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After all cells in the grid are processed, return the \",(0,n.jsx)(e.code,{children:\"numIslands\"}),\" counter.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Each cell in the grid is visited exactly once, either during the BFS traversal or during the main loop.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(min(m, n))\"}),\". The BFS queue can grow up to the size of the smaller dimension in the worst case, such as when the grid has a single row or column of land.\"]}),`\n`]})]})}function x(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(g,i)})):g(i)}var D=x;return k(B);})();\n;return Component;"
}