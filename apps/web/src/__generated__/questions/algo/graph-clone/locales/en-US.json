{
  "description": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var x=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),j=(a,e)=>{for(var t in e)i(a,t,{get:e[t],enumerable:!0})},o=(a,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!y.call(a,r)&&r!==t&&i(a,r,{get:()=>e[r],enumerable:!(c=g(e,r))||c.enumerable});return a};var b=(a,e,t)=>(t=a!=null?u(m(a)):{},o(e||!a||!a.__esModule?i(t,\"default\",{value:a,enumerable:!0}):t,a)),N=a=>o(i({},\"__esModule\",{value:!0}),a);var h=x((D,d)=>{d.exports=_jsx_runtime});var w={};j(w,{default:()=>v,frontmatter:()=>T});var n=b(h());var l=MDXTestExamples;var s=[{input:[[\"adjList\",[[1,2,3],[0,4,6],[0,6],[0,5],[1],[3],[1,2]]]],output:[[1,2,3],[0,4,6],[0,6],[0,5],[1],[3],[1,2]],explanation:\"The input and output adjacency lists are identical because the given graph has been accurately cloned\"},{input:[[\"adjList\",[[1,2,3,8],[0,4,6],[0],[0,5],[1,10,9],[3,7,9,11],[1],[5],[0],[5,4],[4],[5]]]],output:[[1,2,3,8],[0,4,6],[0],[0,5],[1,10,9],[3,7,9,11],[1],[5],[0],[5,4],[4],[5]],explanation:\"The input and output adjacency lists are identical because the given graph has been accurately cloned\"},{input:[[\"adjList\",[[1,2,3,8],[0,4,6,5],[0],[0,5],[1],[3,7,1],[1],[5],[0]]]],output:[[1,2,3,8],[0,4,6,5],[0],[0,5],[1],[3,7,1],[1],[5],[0]],explanation:\"The input and output adjacency lists are identical because the given graph has been accurately cloned\"}];var T={title:\"Graph Clone\",excerpt:\"Implement a function to deeply clone a connected and undirected graph\"};function p(a){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a reference to a node in a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Connectivity_(graph_theory)\",children:\"connected, undirected graph\"}),\", create and return a deep copy of that cloned graph node.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The deep copy must replicate the entire structure of the original graph, ensuring all nodes and their connections are duplicated accurately without referencing the original graph.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The graph is represented by a collection of \",(0,n.jsx)(e.code,{children:\"GraphNode\"}),\"s, where each node has a list of \",(0,n.jsx)(e.code,{children:\"neighbors\"}),\", which are also \",(0,n.jsx)(e.code,{children:\"GraphNode\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"GraphNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface GraphNode {\n  val: number;\n  neighbors: GraphNode[];\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"node: GraphNode\"}),\": Node in a connected, undirected graph. Examples display an \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Adjacency_list\",children:\"adjacency list\"}),\" representation of the graph\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{testCases:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Do not return any nodes of the original graph\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"0 <= Number of nodes <= 100\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"GraphNode.val\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"GraphNode.val\"}),\" is unique for each node\"]}),`\n`,(0,n.jsx)(e.li,{children:\"The graph has no repeated edges or self-loops\"}),`\n`,(0,n.jsx)(e.li,{children:\"The graph is connected, meaning all nodes are reachable starting from the given node\"}),`\n`]})]})}function _(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(p,a)})):p(a)}var v=_;return N(w);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to deeply clone a connected and undirected graph",
    "title": "Graph Clone"
  },
  "solution": "var Component=(()=>{var g=Object.create;var r=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var y=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),w=(o,e)=>{for(var i in e)r(o,i,{get:e[i],enumerable:!0})},l=(o,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of v(e))!m.call(o,t)&&t!==i&&r(o,t,{get:()=>e[t],enumerable:!(d=f(e,t))||d.enumerable});return o};var N=(o,e,i)=>(i=o!=null?g(b(o)):{},l(e||!o||!o.__esModule?r(i,\"default\",{value:o,enumerable:!0}):i,o)),G=o=>l(r({},\"__esModule\",{value:!0}),o);var s=y((F,a)=>{a.exports=_jsx_runtime});var S={};w(S,{default:()=>T});var n=N(s());var h=MDXCodeBlock;var c=`class GraphNode {\n  val: number;\n  neighbors: GraphNode[];\n\n  constructor(val?: number, neighbors?: GraphNode[]) {\n    this.val = val ?? 0;\n    this.neighbors = neighbors ?? [];\n  }\n}\n\nexport default function graphClone(node: GraphNode | null): GraphNode | null {\n  if (node === null) {\n    return null;\n  }\n\n  const visited = new Map<GraphNode, GraphNode>();\n\n  function dfs(node: GraphNode): GraphNode {\n    // If the node was already visited before\n    // Return the clone from the visited dictionary\n    if (visited.has(node)) {\n      return visited.get(node)!;\n    }\n\n    // Create a clone for the given node\n    // Note that we don't have cloned neighbors as of now, hence []\n    let cloneNode = new GraphNode(node.val, []);\n    // The key is original node and value being the clone node\n    visited.set(node, cloneNode);\n\n    // Iterate through each neighbor and push the clone of the neighbor\n    // to the neighbors of the cloned node\n    for (let neighbor of node.neighbors) {\n      cloneNode.neighbors.push(dfs(neighbor));\n    }\n\n    return cloneNode;\n  }\n\n  return dfs(node);\n}\n`;var u=`class GraphNode {\n  val: number;\n  neighbors: GraphNode[];\n\n  constructor(val?: number, neighbors?: GraphNode[]) {\n    this.val = val ?? 0;\n    this.neighbors = neighbors ?? [];\n  }\n}\n\nexport default function graphClone(node: GraphNode | null): GraphNode | null {\n  if (!node) {\n    return node;\n  }\n\n  // Dictionary to save the visited node and it's respective clone\n  // as key and value respectively. This helps to avoid cycles\n  let visited: Map<GraphNode, GraphNode> = new Map();\n\n  // Put the first node in the queue\n  let queue: GraphNode[] = [];\n  queue.push(node);\n\n  // Clone the node and put it in the visited dictionary\n  visited.set(node, new GraphNode(node.val, []));\n\n  // Start BFS traversal\n  while (queue.length > 0) {\n    // Pop a node from the from the front of the queue\n    let node_: GraphNode = queue.shift()!;\n\n    // Iterate through all the neighbors of the node\n    for (let neighbor of node_.neighbors) {\n      if (!visited.has(neighbor)) {\n        // Clone the neighbor and put in the visited, if not present already\n        visited.set(neighbor, new GraphNode(neighbor.val, []));\n        // Add the newly encountered node to the queue\n        queue.push(neighbor);\n      }\n\n      // Add the clone of the neighbor to the neighbors of the cloned node\n      visited.get(node_)?.neighbors.push(visited.get(neighbor) as GraphNode);\n    }\n  }\n\n  // Return the clone of the node from visited\n  return visited.get(node) ?? null;\n}\n`;function p(o){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using DFS\"}),`\n`,(0,n.jsx)(e.p,{children:\"The task is to create a deep clone of a graph. A graph consists of nodes, each of which has a value and a list of neighbors. The challenge is to ensure that every node in the new graph is a completely independent copy, with all connections between nodes accurately replicated.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The intuition is based on a depth-first search (DFS) traversal of the graph. Starting from a node, the algorithm recursively visits all its neighbors, creating new cloned nodes as it encounters unvisited ones. To avoid redundant work and ensure nodes are not cloned multiple times, a \",(0,n.jsx)(e.code,{children:\"Map\"}),\" is used to store the relationship between original nodes and their cloned counterparts. This ensures that when a node is revisited (due to cycles or shared neighbors), the algorithm reuses the existing clone from the \",(0,n.jsx)(e.code,{children:\"Map\"}),\" instead of creating a new one.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This approach mirrors how the graph is naturally connected, building up the cloned graph incrementally as each node and its connections are processed. By recursively handling neighbors and leveraging the \",(0,n.jsx)(e.code,{children:\"Map\"}),\" for efficiency, the solution avoids unnecessary duplication of work and guarantees the correctness of the cloned graph structure.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the input node is \",(0,n.jsx)(e.code,{children:\"null\"}),\". If it is, return \",(0,n.jsx)(e.code,{children:\"null\"}),\" because there is no graph to clone.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"Map\"}),\" to store the mapping between original nodes and their cloned counterparts.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a recursive \",(0,n.jsx)(e.code,{children:\"dfs\"}),\" function:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the current node has already been visited, return the corresponding cloned node from the \",(0,n.jsx)(e.code,{children:\"Map\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Create a new \",(0,n.jsx)(e.code,{children:\"GraphNode\"}),\" with the value of the current node and an empty list for neighbors.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Add the current node and its clone to the \",(0,n.jsx)(e.code,{children:\"Map\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For each neighbor of the current node, recursively clone the neighbor using the \",(0,n.jsx)(e.code,{children:\"dfs\"}),\" function and add it to the neighbors list of the cloned node.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Start the cloning process by calling \",(0,n.jsx)(e.code,{children:\"dfs\"}),\" on the input node.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the cloned graph's root node.\"}),`\n`]}),`\n`,(0,n.jsx)(h,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(v + e)\"}),\". Each node (\",(0,n.jsx)(e.code,{children:\"v\"}),\") and edge (\",(0,n.jsx)(e.code,{children:\"e\"}),\") in the graph is visited exactly once during the DFS traversal.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(v)\"}),\". The \",(0,n.jsx)(e.code,{children:\"Map\"}),\" stores a mapping for each node, and the recursion stack can grow up to the number of nodes in the graph.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using BFS\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This approach uses a breadth-first search (BFS) traversal to systematically visit all nodes and clone them. BFS ensures that nodes are visited level by level, and each node is processed only once. A \",(0,n.jsx)(e.code,{children:\"Map\"}),\" is used to store the relationship between original nodes and their clones. This prevents redundant cloning and handles cycles in the graph efficiently. As the traversal proceeds, neighbors of each node are cloned and added to the corresponding clone's neighbors list. This ensures that the cloned graph maintains the same structure as the original graph.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This method works intuitively by processing nodes layer by layer, cloning nodes and their connections as they are encountered, and avoiding duplication through the use of the \",(0,n.jsx)(e.code,{children:\"Map\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the input node is \",(0,n.jsx)(e.code,{children:\"null\"}),\". If it is, return \",(0,n.jsx)(e.code,{children:\"null\"}),\" because there is no graph to clone.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"Map\"}),\" to store the mapping between original nodes and their cloned counterparts.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Create a queue and add the input node to it for BFS traversal.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Clone the input node and store it in the \",(0,n.jsx)(e.code,{children:\"Map\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"While the queue is not empty:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Remove a node from the front of the queue.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the neighbors of the current node.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If a neighbor has not been cloned yet:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Clone the neighbor and add it to the \",(0,n.jsx)(e.code,{children:\"Map\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Add the neighbor to the queue for further processing.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Add the clone of the neighbor to the neighbors list of the current node's clone.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the clone of the input node from the \",(0,n.jsx)(e.code,{children:\"Map\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(h,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(v + e)\"}),\". Each node (\",(0,n.jsx)(e.code,{children:\"v\"}),\") and edge (\",(0,n.jsx)(e.code,{children:\"e\"}),\") in the graph is visited exactly once during the BFS traversal.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(v)\"}),\". The \",(0,n.jsx)(e.code,{children:\"Map\"}),\" stores a mapping for each node, and the queue holds up to \",(0,n.jsx)(e.code,{children:\"v\"}),\" nodes in the worst case.\"]}),`\n`]})]})}function C(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(p,o)})):p(o)}var T=C;return G(S);})();\n;return Component;"
}