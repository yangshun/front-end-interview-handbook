{
  "description": "var Component=(()=>{var u=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var o in e)r(t,o,{get:e[o],enumerable:!0})},s=(t,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!x.call(t,i)&&i!==o&&r(t,i,{get:()=>e[i],enumerable:!(a=p(e,i))||a.enumerable});return t};var b=(t,e,o)=>(o=t!=null?u(f(t)):{},s(e||!t||!t.__esModule?r(o,\"default\",{value:t,enumerable:!0}):o,t)),w=t=>s(r({},\"__esModule\",{value:!0}),t);var c=v((D,l)=>{l.exports=_jsx_runtime});var C={};y(C,{default:()=>_,frontmatter:()=>T});var n=b(c());var m=MDXTestExamples;var d=[{input:[[\"intervals\",[[83,99]]]],output:1,explanation:\"Since there is only one meeting, only one room is required. There is no overlap, so just one room can accommodate the meeting.\"},{input:[[\"intervals\",[[1,5],[2,6],[8,9]]]],output:2,explanation:\"There are two overlapping meetings: [1, 5] and [2, 6]. To accommodate both meetings simultaneously, at least two rooms are needed. The other meeting [8, 9] do not overlap with the earlier ones, so only two rooms are required in total.\"},{input:[[\"intervals\",[[5,10],[10,15],[15,20]]]],output:1,explanation:\"The meetings are back-to-back, meaning they do not overlap. Since the end of one meeting coincides with the start of the next, only one room is sufficient to host all the meetings.\"}];var T={title:\"Minimum Meeting Rooms Needed\",excerpt:\"Implement a function to find the minimum number of required conference rooms\"};function h(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of meeting time \",(0,n.jsx)(e.code,{children:\"intervals\"}),\", where each interval is represented as \",(0,n.jsx)(e.code,{children:\"[start, end]\"}),\" which represents a meeting starting at time \",(0,n.jsx)(e.code,{children:\"start\"}),\" and ending at time \",(0,n.jsx)(e.code,{children:\"end\"}),\", determine the minimum number of meeting rooms required to accommodate all the meetings without any overlap.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"intervals: Array<[number, number]>\"}),\": An array of integers pairs\"]}),`\n`]}),`\n`,(0,n.jsx)(m,{testCases:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"intervals.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"intervals[i].length\"}),\" == 2\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"start\"}),\" < \",(0,n.jsx)(e.code,{children:\"end\"}),\" <= 1,000,000\"]}),`\n`]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var _=M;return w(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the minimum number of required conference rooms",
    "title": "Minimum Meeting Rooms Needed"
  },
  "solution": "var Component=(()=>{var g=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),w=(n,e)=>{for(var r in e)o(n,r,{get:e[r],enumerable:!0})},h=(n,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!v.call(n,i)&&i!==r&&o(n,i,{get:()=>e[i],enumerable:!(s=f(e,i))||s.enumerable});return n};var P=(n,e,r)=>(r=n!=null?g(y(n)):{},h(e||!n||!n.__esModule?o(r,\"default\",{value:n,enumerable:!0}):r,n)),x=n=>h(o({},\"__esModule\",{value:!0}),n);var d=b((T,l)=>{l.exports=_jsx_runtime});var M={};w(M,{default:()=>A});var t=P(d());var a=MDXCodeBlock;var c=`export default function minMeetingRoomsNeeded(intervals: number[][]): number {\n  // Check for the base case. If there are no intervals, return 0\n  if (intervals.length === 0) {\n    return 0;\n  }\n\n  // Separate start and end times into their own arrays\n  const start: number[] = new Array(intervals.length);\n  const end: number[] = new Array(intervals.length);\n\n  for (let i = 0; i < intervals.length; i++) {\n    start[i] = intervals[i][0];\n    end[i] = intervals[i][1];\n  }\n\n  // Sort the start and end times\n  start.sort((a, b) => a - b);\n  end.sort((a, b) => a - b);\n\n  // The two pointers in the algorithm: endPointer and startPointer\n  let startPointer = 0,\n    endPointer = 0;\n\n  // Variable to keep track of the maximum number of rooms used\n  let usedRooms = 0;\n\n  // Iterate over the intervals\n  while (startPointer < intervals.length) {\n    // If there is a meeting that has ended by the time the meeting at startPointer starts\n    if (start[startPointer] >= end[endPointer]) {\n      usedRooms -= 1;\n      endPointer += 1;\n    }\n\n    // Regardless of whether a room frees up or not, we allocate a room for the current meeting\n    usedRooms += 1;\n    startPointer += 1;\n  }\n\n  return usedRooms;\n}\n`;var m=`// Importing the PriorityQueue from a suitable library\nimport { MinPriorityQueue } from '@datastructures-js/priority-queue';\n\nexport default function minMeetingRoomsNeeded(intervals: number[][]): number {\n  // Check for the base case. If there are no intervals, return 0\n  if (intervals.length === 0) {\n    return 0;\n  }\n\n  // Min heap to track the end time of meetings\n  const allocator = new MinPriorityQueue<number>();\n\n  // Sort the intervals by start time\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  // Add the first meeting's end time to the heap\n  allocator.enqueue(intervals[0][1]);\n\n  // Iterate over remaining intervals\n  for (let i = 1; i < intervals.length; i++) {\n    // If the room due to free up the earliest is free, assign that room to this meeting\n    if (intervals[i][0] >= allocator.front()) {\n      allocator.dequeue();\n    }\n\n    // Add the current meeting's end time to the heap\n    allocator.enqueue(intervals[i][1]);\n  }\n\n  // The size of the heap tells us the minimum rooms required for all the meetings\n  return allocator.size();\n}\n`;function u(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Two Pointer Approach\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This approach determines the minimum number of meeting rooms needed by separating and sorting the start and end times of the intervals. By using two pointers, one for the \",(0,t.jsx)(e.code,{children:\"start\"}),\" times and one for the \",(0,t.jsx)(e.code,{children:\"end\"}),\" times, the algorithm efficiently tracks the number of concurrent meetings.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The intuition is that a meeting room becomes free when a meeting ends, which is represented by the \",(0,t.jsx)(e.code,{children:\"endPointer\"}),\". For each meeting start (\",(0,t.jsx)(e.code,{children:\"startPointer\"}),\"), the algorithm checks if the meeting can reuse an available room (by comparing the start time with the earliest end time). If a room is free, the \",(0,t.jsx)(e.code,{children:\"endPointer\"}),\" is moved forward to mark the room as available. Otherwise, a new room is allocated.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This method avoids comparing all pairs of intervals directly, using sorted arrays and two pointers to achieve optimal efficiency.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Handle the base case by returning \",(0,t.jsx)(e.code,{children:\"0\"}),\" if the \",(0,t.jsx)(e.code,{children:\"intervals\"}),\" array is empty.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Create two arrays, \",(0,t.jsx)(e.code,{children:\"start\"}),\" and \",(0,t.jsx)(e.code,{children:\"end\"}),\", to store the start and end times of each interval.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Populate the \",(0,t.jsx)(e.code,{children:\"start\"}),\" and \",(0,t.jsx)(e.code,{children:\"end\"}),\" arrays by iterating through the \",(0,t.jsx)(e.code,{children:\"intervals\"}),\" array.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Sort both \",(0,t.jsx)(e.code,{children:\"start\"}),\" and \",(0,t.jsx)(e.code,{children:\"end\"}),\" arrays in ascending order.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize two pointers, \",(0,t.jsx)(e.code,{children:\"startPointer\"}),\" and \",(0,t.jsx)(e.code,{children:\"endPointer\"}),\", to traverse the \",(0,t.jsx)(e.code,{children:\"start\"}),\" and \",(0,t.jsx)(e.code,{children:\"end\"}),\" arrays respectively. Also, initialize a variable \",(0,t.jsx)(e.code,{children:\"usedRooms\"}),\" to track the number of rooms currently in use.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through the \",(0,t.jsx)(e.code,{children:\"start\"}),\" array:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If the start time of the current meeting is greater than or equal to the earliest end time (indicated by \",(0,t.jsx)(e.code,{children:\"end[endPointer]\"}),\"), free a room by decrementing \",(0,t.jsx)(e.code,{children:\"usedRooms\"}),\" and moving \",(0,t.jsx)(e.code,{children:\"endPointer\"}),\" forward.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Allocate a room for the current meeting by incrementing \",(0,t.jsx)(e.code,{children:\"usedRooms\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move the \",(0,t.jsx)(e.code,{children:\"startPointer\"}),\" forward to process the next meeting.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return the value of \",(0,t.jsx)(e.code,{children:\"usedRooms\"}),\", which represents the maximum number of rooms needed at any time.\"]}),`\n`]}),`\n`,(0,t.jsx)(a,{children:c}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Sorting the \",(0,t.jsx)(e.code,{children:\"start\"}),\" and \",(0,t.jsx)(e.code,{children:\"end\"}),\" arrays dominates the runtime, while the linear scan to process the intervals takes O(n).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". Two additional arrays, \",(0,t.jsx)(e.code,{children:\"start\"}),\" and \",(0,t.jsx)(e.code,{children:\"end\"}),\", are used to store the start and end times of the intervals.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Priority Queue (Min-Heap)\"}),`\n`,(0,t.jsx)(e.p,{children:\"The approach uses a min heap to efficiently track the end times of ongoing meetings, ensuring that the earliest finishing meeting is always processed first. This allows determining if a room becomes free when a new meeting starts. Sorting the intervals by start time ensures that meetings are processed in chronological order.\"}),`\n`,(0,t.jsx)(e.p,{children:\"A min heap is used because it supports efficient insertion and extraction of the smallest element. At any point, the heap contains the end times of all active meetings. When a meeting starts, its start time is compared to the smallest end time in the heap (the meeting that finishes the earliest). If the new meeting can reuse the room (its start time is greater than or equal to the smallest end time), the end time is removed from the heap. Otherwise, a new room is allocated, and the meeting's end time is added to the heap.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Handle the base case by returning \",(0,t.jsx)(e.code,{children:\"0\"}),\" if the \",(0,t.jsx)(e.code,{children:\"intervals\"}),\" array is empty.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Sort the \",(0,t.jsx)(e.code,{children:\"intervals\"}),\" array by the start times of the meetings in ascending order.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize a min heap (\",(0,t.jsx)(e.code,{children:\"allocator\"}),\") to store the end times of meetings currently occupying rooms.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Add the end time of the first meeting to the heap.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through the remaining intervals:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"If the current meeting's start time is greater than or equal to the smallest end time in the heap, remove the smallest end time from the heap (indicating a room is freed).\"}),`\n`,(0,t.jsx)(e.li,{children:\"Add the current meeting's end time to the heap, allocating a room for it.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"After processing all intervals, the size of the heap represents the minimum number of rooms required, as each element in the heap corresponds to a currently active meeting.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Return the size of the heap.\"}),`\n`]}),`\n`,(0,t.jsx)(a,{children:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Sorting the intervals takes O(n log n), and each insertion and removal operation in the heap takes O(log n), resulting in O(n log n) for heap operations over all intervals.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The min heap can contain up to \",(0,t.jsx)(e.code,{children:\"n\"}),\" elements in the worst case.\"]}),`\n`]})]})}function R(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var A=R;return x(M);})();\n;return Component;"
}