{
  "description": "var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)r(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,u)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of x(e))!f.call(t,o)&&o!==i&&r(t,o,{get:()=>e[o],enumerable:!(u=m(e,o))||u.enumerable});return t};var j=(t,e,i)=>(i=t!=null?h(b(t)):{},s(e||!t||!t.__esModule?r(i,\"default\",{value:t,enumerable:!0}):i,t)),_=t=>s(r({},\"__esModule\",{value:!0}),t);var a=g((T,c)=>{c.exports=_jsx_runtime});var q={};w(q,{default:()=>X,frontmatter:()=>M});var n=j(a());var l=MDXTestExamples;var d=[{input:[[\"a\",1],[\"b\",2]],output:3,explanation:\"a:=1 plus b:=2 equals 3 which is the expected output.\"},{input:[[\"a\",-1],[\"b\",-2]],output:-3,explanation:\"a:=-1 plus b:=-2 equals -3 which is the expected output.\"},{input:[[\"a\",0],[\"b\",0]],output:0,explanation:\"a:=0 plus b:=0 equals 0 which is the expected output.\"}];var M={title:\"Sum Without Addition\",excerpt:\"Implement a function to find the sum of two integers without using + and - operator\"};function p(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given two integers \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\", compute their sum without using addition or subtraction operators.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"a: number\"}),\": An integer\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"b: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{testCases:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"-1000 <= \",(0,n.jsx)(e.code,{children:\"a\"}),\", \",(0,n.jsx)(e.code,{children:\"b\"}),\" <= 1000\"]}),`\n`]})]})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var X=D;return _(q);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the sum of two integers without using + and - operator",
    "title": "Sum Without Addition"
  },
  "solution": "var Component=(()=>{var b=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var n in e)o(t,n,{get:e[n],enumerable:!0})},c=(t,e,n,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!g.call(t,r)&&r!==n&&o(t,r,{get:()=>e[r],enumerable:!(a=p(e,r))||a.enumerable});return t};var w=(t,e,n)=>(n=t!=null?b(m(t)):{},c(e||!t||!t.__esModule?o(n,\"default\",{value:t,enumerable:!0}):n,t)),O=t=>c(o({},\"__esModule\",{value:!0}),t);var l=f((D,h)=>{h.exports=_jsx_runtime});var X={};x(X,{default:()=>T});var i=w(l());var d=MDXCodeBlock;var s=`export default function sumWithoutAddition(a: number, b: number): number {\n  // Initialize a variable carry to hold the carry bits generated during each iteration\n  let carry: number = 0;\n\n  // Loop continues as long as there's a carry bit or bits to process in a or b\n  while (b !== 0 || carry !== 0) {\n    // Extract the carry bit from the AND operation of a and b\n    carry = a & b;\n\n    // Use the XOR operation to add a and b without the carry bit\n    a = a ^ b;\n\n    // Left shift the carry bit for the next iteration\n    b = carry << 1;\n  }\n\n  // Return the final result, which is stored in 'a' after all carry bits have been processed\n  return a;\n}\n`;function u(t){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h3:\"h3\",ol:\"ol\",strong:\"strong\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"1. Using Bit Manipulation\"}),`\n`,(0,i.jsx)(e.p,{children:\"The given solution uses bit manipulation to calculate the sum of two numbers without using the addition operator. The key idea relies on understanding how binary addition works:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"The XOR operation (\",(0,i.jsx)(e.code,{children:\"^\"}),\") performs addition without carry. For example, in binary \",(0,i.jsx)(e.code,{children:\"1 ^ 1 = 0\"}),\" and \",(0,i.jsx)(e.code,{children:\"0 ^ 1 = 1\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"The AND operation (\",(0,i.jsx)(e.code,{children:\"&\"}),\") identifies where carry bits are generated. For example, in binary \",(0,i.jsx)(e.code,{children:\"1 & 1 = 1\"}),\" and \",(0,i.jsx)(e.code,{children:\"0 & 1 = 0\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"The left-shift operation (\",(0,i.jsx)(e.code,{children:\"<<\"}),\") moves the carry bits to the next higher position so they can be added in the subsequent iteration.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"By iteratively applying these operations, the algorithm processes the carry bits until no carry remains, yielding the sum.\"}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize the \",(0,i.jsx)(e.code,{children:\"carry\"}),\" variable to hold carry bits generated during each iteration.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Continue looping as long as there are bits to process in \",(0,i.jsx)(e.code,{children:\"b\"}),\" or there is a carry bit.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Extract the carry bits using the \",(0,i.jsx)(e.code,{children:\"a & b\"}),\" operation and store the result in \",(0,i.jsx)(e.code,{children:\"carry\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Use the XOR operation (\",(0,i.jsx)(e.code,{children:\"a ^ b\"}),\") to compute the sum without the carry bit and update \",(0,i.jsx)(e.code,{children:\"a\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Left-shift the \",(0,i.jsx)(e.code,{children:\"carry\"}),\" by one position (\",(0,i.jsx)(e.code,{children:\"carry << 1\"}),\") to align it with the next higher bit and assign the result to \",(0,i.jsx)(e.code,{children:\"b\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Repeat steps 3\\u20135 until both \",(0,i.jsx)(e.code,{children:\"b\"}),\" and \",(0,i.jsx)(e.code,{children:\"carry\"}),\" are zero.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Return \",(0,i.jsx)(e.code,{children:\"a\"}),\", which holds the final sum.\"]}),`\n`]}),`\n`,(0,i.jsx)(d,{children:s}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(1)\"}),\". Each integer contains 32 bits.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses constant space as it operates directly on the input variables.\"]}),`\n`]})]})}function v(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(u,t)})):u(t)}var T=v;return O(X);})();\n;return Component;"
}