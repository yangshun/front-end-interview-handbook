{
  "description": "var Component=(()=>{var m=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},d=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!b.call(t,i)&&i!==r&&a(t,i,{get:()=>e[i],enumerable:!(o=p(e,i))||o.enumerable});return t};var j=(t,e,r)=>(r=t!=null?m(x(t)):{},d(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>d(a({},\"__esModule\",{value:!0}),t);var c=f((X,s)=>{s.exports=_jsx_runtime});var M={};y(M,{default:()=>D,frontmatter:()=>v});var n=j(c());var l=MDXTestExamples;var h=[{input:[[\"numbers\",[0,1,2,3,4]],[\"target\",2]],output:2,explanation:\"The original array [0,1,2,3,4] was rotated 0 times and 2 is present at 2nd index in given array\"},{input:[[\"numbers\",[2,3,4,0,1]],[\"target\",0]],output:3,explanation:\"The original array [0,1,2,3,4] was rotated 3 times and became [2,3,4,0,1]. 0 is present at 3rd index in given array\"},{input:[[\"numbers\",[4]],[\"target\",2]],output:-1,explanation:\"The original array [4] was rotated 0 times and became [4]. 2 is not present in the given array\"}];var v={title:\"Find Element in Rotated Array\",excerpt:\"Implement a function to find an integer in a rotated sorted array\"};function u(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a sorted and rotated array \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" containing unique elements and an integer \",(0,n.jsx)(e.code,{children:\"target\"}),\", return the index of \",(0,n.jsx)(e.code,{children:\"target\"}),\" if it is in \",(0,n.jsx)(e.code,{children:\"numbers\"}),\", or \",(0,n.jsx)(e.code,{children:\"-1\"}),\" if it is not.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Rotating an array \",(0,n.jsx)(e.code,{children:\"[a[0], a[1], a[2], ..., a[n-1]]\"}),\" once results in \",(0,n.jsx)(e.code,{children:\"[a[n-1], a[0], a[1], a[2], ..., a[n-2]]\"}),\". Rotating it a second time results in \",(0,n.jsx)(e.code,{children:\"[a[n-2], a[n-1], a[0], a[1], ..., a[n-3]]\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Develop an algorithm that runs in O(log n) time complexity.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"target: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsx)(l,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10,000 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 10,000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10,000 <= \",(0,n.jsx)(e.code,{children:\"target\"}),\" <= 10,000\"]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var D=C;return _(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find an integer in a rotated sorted array",
    "title": "Find Element in Rotated Array"
  },
  "solution": "var Component=(()=>{var u=Object.create;var h=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var w=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),v=(i,e)=>{for(var n in e)h(i,n,{get:e[n],enumerable:!0})},l=(i,e,n,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!b.call(i,r)&&r!==n&&h(i,r,{get:()=>e[r],enumerable:!(a=g(e,r))||a.enumerable});return i};var x=(i,e,n)=>(n=i!=null?u(y(i)):{},l(e||!i||!i.__esModule?h(n,\"default\",{value:i,enumerable:!0}):n,i)),I=i=>l(h({},\"__esModule\",{value:!0}),i);var c=w((D,d)=>{d.exports=_jsx_runtime});var C={};v(C,{default:()=>k});var t=x(c());var o=MDXCodeBlock;var s=`export default function findInRotatedArray(\n  numbers: number[],\n  target: number,\n): number {\n  let low: number = 0;\n  let high: number = numbers.length - 1;\n\n  while (low <= high) {\n    let mid: number = Math.floor((low + high) / 2);\n\n    // Check if the middle element is the target value\n    if (numbers[mid] === target) {\n      return mid;\n    }\n\n    // Determine if the left half of the array is sorted\n    if (numbers[low] <= numbers[mid]) {\n      // Check if the target is within the sorted left half\n      if (numbers[low] <= target && target <= numbers[mid]) {\n        // If target is in the left half, adjust the search range to exclude the right half\n        high = mid - 1;\n      } else {\n        // If target is not in the left half, adjust to search in the right half\n        low = mid + 1;\n      }\n    } else {\n      // The right half must be sorted\n      // Check if the target is within the sorted right half\n      if (target <= numbers[high] && target >= numbers[mid]) {\n        // If target is in the right half, adjust the search range to exclude the left half\n        low = mid + 1;\n      } else {\n        // If target is not in the right half, adjust to search in the left half\n        high = mid - 1;\n      }\n    }\n  }\n\n  // If we exit the loop, it means the target was not found in the array\n  // Return -1 to indicate that the target is not present\n  return -1;\n}\n`;var m=`export default function findInRotatedArray(\n  numbers: number[],\n  target: number,\n): number {\n  // Helper function to find the pivot index\n  function findPivotIndex(nums: number[]): number {\n    let low = 0;\n    let high = nums.length - 1;\n\n    while (low < high) {\n      let mid = Math.floor((low + high) / 2);\n\n      // Pivot point is where the rotation happens; find the smallest element\n      if (nums[mid] > nums[high]) {\n        low = mid + 1;\n      } else {\n        high = mid;\n      }\n    }\n    return low; // Pivot index where the smallest element is located\n  }\n\n  // Helper function to perform binary search\n  function binarySearch(\n    nums: number[],\n    target: number,\n    low: number,\n    high: number,\n  ): number {\n    while (low <= high) {\n      let mid = Math.floor((low + high) / 2);\n\n      if (nums[mid] === target) {\n        return mid;\n      } else if (nums[mid] < target) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return -1; // Target not found\n  }\n\n  const n = numbers.length;\n  if (n === 0) return -1;\n\n  const pivot = findPivotIndex(numbers);\n\n  // Decide which part of the array to search\n  if (numbers[pivot] <= target && target <= numbers[n - 1]) {\n    // Search in the right (rotated) half\n    return binarySearch(numbers, target, pivot, n - 1);\n  } else {\n    // Search in the left (non-rotated) half\n    return binarySearch(numbers, target, 0, pivot - 1);\n  }\n}\n`;function f(i){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Pivot Index With Binary Search\"}),`\n`,(0,t.jsx)(e.p,{children:\"The solution tackles the problem of finding a target in a rotated sorted array by combining two efficient techniques: identifying the pivot index and performing binary search. In a naive approach, scanning the entire array linearly is the primary bottleneck, as it leads to a time complexity of O(n). This solution eliminates unnecessary work by using the fact that the array is sorted but rotated.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The first step is finding the pivot index, which is the smallest element in the array. This index also represents the rotation point where the sorted array is divided into two subarrays. Knowing this pivot index helps in determining which part of the array to search for the target.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Once the pivot index is determined, binary search is used to search for the target efficiently. The search space is divided based on the value of the target relative to the pivot. This allows focusing only on the relevant half of the array. Using binary search reduces the overall runtime from O(n) to O(log n), making the solution optimal.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"Define a helper function \",(0,t.jsx)(e.code,{children:\"findPivotIndex\"}),\" to locate the pivot point where the array is rotated.\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize two pointers \",(0,t.jsx)(e.code,{children:\"low\"}),\" and \",(0,t.jsx)(e.code,{children:\"high\"}),\" at the start and end of the array, respectively.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Use a loop to adjust the pointers:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Calculate the middle index \",(0,t.jsx)(e.code,{children:\"mid\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"numbers[mid]\"}),\" is greater than \",(0,t.jsx)(e.code,{children:\"numbers[high]\"}),\", the pivot is to the right. Update \",(0,t.jsx)(e.code,{children:\"low\"}),\" to \",(0,t.jsx)(e.code,{children:\"mid + 1\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Otherwise, the pivot is to the left or at \",(0,t.jsx)(e.code,{children:\"mid\"}),\". Update \",(0,t.jsx)(e.code,{children:\"high\"}),\" to \",(0,t.jsx)(e.code,{children:\"mid\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"When the loop ends, \",(0,t.jsx)(e.code,{children:\"low\"}),\" points to the pivot index.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"Define a helper function \",(0,t.jsx)(e.code,{children:\"binarySearch\"}),\" to search for the target in a sorted subarray.\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize \",(0,t.jsx)(e.code,{children:\"low\"}),\" and \",(0,t.jsx)(e.code,{children:\"high\"}),\" pointers to the start and end of the subarray.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Use a loop to perform binary search:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Calculate the middle index \",(0,t.jsx)(e.code,{children:\"mid\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"numbers[mid]\"}),\" matches the target, return \",(0,t.jsx)(e.code,{children:\"mid\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"numbers[mid]\"}),\" is less than the target, adjust \",(0,t.jsx)(e.code,{children:\"low\"}),\" to \",(0,t.jsx)(e.code,{children:\"mid + 1\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Otherwise, adjust \",(0,t.jsx)(e.code,{children:\"high\"}),\" to \",(0,t.jsx)(e.code,{children:\"mid - 1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the loop ends without finding the target, return \",(0,t.jsx)(e.code,{children:\"-1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[\"Find the pivot index using \",(0,t.jsx)(e.code,{children:\"findPivotIndex\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"Decide which part of the array to search based on the target.\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If the target lies within the range of the rotated part (from \",(0,t.jsx)(e.code,{children:\"pivot\"}),\" to the end of the array), perform binary search on that part.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Otherwise, perform binary search on the non-rotated part (from the start of the array to \",(0,t.jsx)(e.code,{children:\"pivot - 1\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsx)(e.p,{children:\"Return the result of the binary search.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(o,{children:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(log n)\"}),\". The pivot finding operation and the binary search both take O(log n) time, resulting in an overall time complexity of O(log n).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm operates in constant space, using only a few variables for the pointer manipulations.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Modified Binary Search\"}),`\n`,(0,t.jsx)(e.p,{children:\"The given solution improves upon the previous approach by eliminating the explicit pivot index computation. Instead of splitting the array into two parts and performing two separate binary searches, this approach uses a single binary search with additional logic to handle the rotated sorted array.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The key insight is that in a rotated sorted array, at least one half (left or right) of the array is always sorted. By checking which half is sorted at each step, the algorithm determines whether the target lies within the sorted range. If it does, the search range is adjusted to exclude the unsorted half. Otherwise, the search continues in the unsorted half. This approach avoids the overhead of explicitly finding the pivot index, directly narrowing down the search space.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize two pointers \",(0,t.jsx)(e.code,{children:\"low\"}),\" and \",(0,t.jsx)(e.code,{children:\"high\"}),\" to the start and end of the array, respectively.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Use a loop to perform binary search while \",(0,t.jsx)(e.code,{children:\"low\"}),\" is less than or equal to \",(0,t.jsx)(e.code,{children:\"high\"}),\":\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Calculate the middle index \",(0,t.jsx)(e.code,{children:\"mid\"}),\" as the floor of the average of \",(0,t.jsx)(e.code,{children:\"low\"}),\" and \",(0,t.jsx)(e.code,{children:\"high\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"numbers[mid]\"}),\" equals the target, return \",(0,t.jsx)(e.code,{children:\"mid\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Determine if the left half of the array is sorted by comparing \",(0,t.jsx)(e.code,{children:\"numbers[low]\"}),\" and \",(0,t.jsx)(e.code,{children:\"numbers[mid]\"}),\".\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If the left half is sorted, check if the target lies within this range. If it does, adjust \",(0,t.jsx)(e.code,{children:\"high\"}),\" to \",(0,t.jsx)(e.code,{children:\"mid - 1\"}),\". Otherwise, adjust \",(0,t.jsx)(e.code,{children:\"low\"}),\" to \",(0,t.jsx)(e.code,{children:\"mid + 1\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the left half is not sorted, the right half must be sorted. Check if the target lies within this range. If it does, adjust \",(0,t.jsx)(e.code,{children:\"low\"}),\" to \",(0,t.jsx)(e.code,{children:\"mid + 1\"}),\". Otherwise, adjust \",(0,t.jsx)(e.code,{children:\"high\"}),\" to \",(0,t.jsx)(e.code,{children:\"mid - 1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the loop ends without finding the target, return \",(0,t.jsx)(e.code,{children:\"-1\"}),\" to indicate that the target is not present in the array.\"]}),`\n`]}),`\n`,(0,t.jsx)(o,{children:s}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(log n)\"}),\". The binary search divides the search space by half at each step, resulting in logarithmic time complexity.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of extra space for variables, as it operates directly on the input array.\"]}),`\n`]})]})}function T(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(f,i)})):f(i)}var k=T;return I(C);})();\n;return Component;"
}