{
  "description": "var Component=(()=>{var l=Object.create;var s=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},h=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!p.call(t,r)&&r!==i&&s(t,r,{get:()=>e[r],enumerable:!(a=g(e,r))||a.enumerable});return t};var v=(t,e,i)=>(i=t!=null?l(m(t)):{},h(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),j=t=>h(s({},\"__esModule\",{value:!0}),t);var d=f((A,o)=>{o.exports=_jsx_runtime});var D={};w(D,{default:()=>k,frontmatter:()=>b});var n=v(d()),b={title:\"Dijkstra's Algorithm\",excerpt:\"Implement Dijkstra's algorithm to find the shortest paths from a source vertex in a graph represented as an adjacency list.\"};function c(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\",pre:\"pre\",h2:\"h2\",ol:\"ol\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a weighted directed graph represented as an adjacency list (\",(0,n.jsx)(e.code,{children:\"graph\"}),\") and a starting node (\",(0,n.jsx)(e.code,{children:\"source\"}),\"), implement Dijkstra's algorithm to find the shortest path distances from \",(0,n.jsx)(e.code,{children:\"source\"}),\" to all other nodes in the graph. The graph contains nodes and weighted edges.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"graph\"}),\": An object representing the adjacency list of the graph. Each key is a node identifier (e.g. \",(0,n.jsx)(e.code,{children:\"'A'\"}),\", \",(0,n.jsx)(e.code,{children:\"'B'\"}),\"), and its value is another object that maps each neighboring node to the non-negative weight of the edge connecting them.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"source\"}),\": The identifier of the starting node from which to calculate shortest paths.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Output\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"An object where keys are node identifiers and values represent the shortest distance from \",(0,n.jsx)(e.code,{children:\"source\"}),\" to that node. Nodes that are unreachable from \",(0,n.jsx)(e.code,{children:\"source\"}),\" should have their distance set to \",(0,n.jsx)(e.code,{children:\"Infinity\"}),\" (use the built-in \",(0,n.jsx)(e.code,{children:\"Infinity\"}),\" constant).\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const graph1 = {\n  A: { B: 1, C: 4 },\n  B: { E: 3, F: 2 },\n  C: { G: 2 },\n  D: { C: 3, J: 5 },\n  E: { D: 2 },\n  F: {},\n  G: { H: 1 },\n  H: { F: 4, J: 3 },\n  I: {},\n  J: {},\n};\n\ndijkstra(graph1, 'A'); // Returns distances: { A: 0, B: 1, C: 4, D: 6, E: 4, F: 3, G: 6, H: 7, I: Infinity, J: 10 }\n\nconst graph2 = {\n  A: { B: 2, C: 5 },\n  B: { D: 1, E: 4 },\n  C: { F: 3, G: 2 },\n  D: {},\n  E: {},\n  F: {},\n  G: {},\n};\n\ndijkstra(graph2, 'A'); // Returns distances: { A: 0, B: 2, C: 5, D: 3, E: 6, F: 8, G: 7 }\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 1000\"}),`\n`,(0,n.jsx)(e.li,{children:\"0 <= Edge weight <= 10000\"}),`\n`,(0,n.jsx)(e.li,{children:\"The graph may contain cycles\"}),`\n`,(0,n.jsx)(e.li,{children:\"The graph may be disconnected\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Recap (Hint)\"}),`\n`,(0,n.jsx)(e.p,{children:\"Dijkstra's algorithm is a basic algorithm used to find the shortest path between nodes in a weighted graph. This algorithm can handle graphs with non-negative weights and is commonly used in routing and as a subroutine in other graph algorithms. Here are some typical use cases:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"In GPS systems to find the shortest driving route between locations.\"}),`\n`,(0,n.jsx)(e.li,{children:\"In network routing algorithms to find the shortest path for data packets.\"}),`\n`,(0,n.jsx)(e.li,{children:\"In scheduling theory to find the shortest (least time-consuming) path through a series of tasks.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Generating a minimum spanning tree (MST) of a weighted graph.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Here's how Dijkstra's algorithm works:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Start with a set of all nodes in the graph, and assign them a tentative distance value: zero for the initial node, and infinity for all other nodes. Set the initial node as the current node.\"}),`\n`,(0,n.jsx)(e.li,{children:\"For the current node, consider all of its unvisited neighbors and calculate their tentative distances. Compare the newly calculated tentative distance to the current assigned value and assign the smaller one.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Once we have considered all the unvisited neighbors of the current node, mark the current node as visited. A visited node will not be checked again.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the destination node has been marked visited or if the smallest tentative distance among the nodes in the unvisited set is infinity (occurs when there is no connection between the initial node and remaining unvisited nodes), then stop. The algorithm has finished.\"}),`\n`,(0,n.jsx)(e.li,{children:'Otherwise, select the unvisited node that is marked with the smallest tentative distance, set it as the new \"current node,\" and go back to step 2.'}),`\n`,(0,n.jsx)(e.li,{children:\"The result is a map of the shortest distances from the initial node to all other nodes.\"}),`\n`]})]})}function y(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(c,t)})):c(t)}var k=y;return j(D);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/dijkstra\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/dijkstra.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/dijkstra.run.test.ts": "import dijkstra from './dijkstra';\n\ndescribe('dijkstra', () => {\n  test('empty graph', () => {\n    expect(dijkstra({}, 'A')).toEqual({});\n  });\n\n  test('graph with one node', () => {\n    expect(dijkstra({ A: {} }, 'A')).toEqual({ A: 0 });\n  });\n\n  test('graph with two nodes', () => {\n    expect(dijkstra({ A: { B: 1 }, B: {} }, 'A')).toEqual({ A: 0, B: 1 });\n  });\n});\n",
    "/src/dijkstra.submit.test.ts": "import dijkstra from './dijkstra';\n\ndescribe('dijkstra', () => {\n  test('empty graph', () => {\n    expect(dijkstra({}, 'A')).toEqual({});\n  });\n\n  test('graph with one node', () => {\n    expect(dijkstra({ A: {} }, 'A')).toEqual({ A: 0 });\n  });\n\n  test('graph with two nodes', () => {\n    expect(dijkstra({ A: { B: 1 }, B: {} }, 'A')).toEqual({ A: 0, B: 1 });\n    expect(dijkstra({ A: { B: 5 }, B: { A: 2 } }, 'A')).toEqual({ A: 0, B: 5 });\n    expect(dijkstra({ A: { B: 5 }, B: { A: 2 } }, 'B')).toEqual({ A: 2, B: 0 });\n  });\n\n  test('graphs with multiple nodes', () => {\n    expect(\n      dijkstra({ A: { B: 1, C: 4 }, B: { D: 1 }, C: {}, D: {} }, 'A'),\n    ).toEqual({\n      A: 0,\n      B: 1,\n      C: 4,\n      D: 2,\n    });\n    expect(\n      dijkstra({ A: { B: 2, C: 5 }, B: { C: 3 }, C: { D: 1 }, D: {} }, 'A'),\n    ).toEqual({\n      A: 0,\n      B: 2,\n      C: 5,\n      D: 6,\n    });\n    expect(\n      dijkstra(\n        { A: { B: 1, C: 2 }, B: { C: 1, D: 2 }, C: { D: 5 }, D: {} },\n        'A',\n      ),\n    ).toEqual({\n      A: 0,\n      B: 1,\n      C: 2,\n      D: 3,\n    });\n  });\n\n  test('disjoint graphs', () => {\n    expect(dijkstra({ A: { B: 3 }, B: {}, C: { D: 1 }, D: {} }, 'A')).toEqual({\n      A: 0,\n      B: 3,\n      C: Infinity,\n      D: Infinity,\n    });\n    expect(dijkstra({ A: { B: 3 }, B: {}, C: { D: 1 }, D: {} }, 'C')).toEqual({\n      A: Infinity,\n      B: Infinity,\n      C: 0,\n      D: 1,\n    });\n  });\n\n  test('graph with cycles', () => {\n    expect(\n      dijkstra(\n        { A: { B: 1, C: 2 }, B: { A: 2 }, C: { D: 3 }, D: { A: 1 } },\n        'A',\n      ),\n    ).toEqual({\n      A: 0,\n      B: 1,\n      C: 2,\n      D: 5,\n    });\n    expect(\n      dijkstra(\n        { A: { B: 4, C: 1 }, B: { C: 2, D: 2 }, C: { D: 2 }, D: { A: 7 } },\n        'A',\n      ),\n    ).toEqual({\n      A: 0,\n      B: 4,\n      C: 1,\n      D: 3,\n    });\n  });\n});\n",
    "/src/dijkstra.ts": "type HeapItem = { vertex: string; weight: number };\n\n/**\n * MinHeap: A minimum heap implementation to serve as a priority queue.\n * Each heap element is of type HeapItem.\n */\nclass MinHeap {\n  private heap: HeapItem[];\n  private position: { [vertex: string]: number };\n\n  constructor() {\n    this.heap = [];\n    this.position = {};\n  }\n\n  // Helper method to swap two elements and update their positions.\n  private swap(i: number, j: number): void {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    this.position[this.heap[i].vertex] = i;\n    this.position[this.heap[j].vertex] = j;\n  }\n\n  // Bubbles up the element at index i to restore heap property.\n  private percolateUp(i: number): void {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.heap[parent].weight > this.heap[i].weight) {\n        this.swap(i, parent);\n        i = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Bubbles down the element at index i to restore heap property.\n  private percolateDown(i: number): void {\n    const n = this.heap.length;\n    while (true) {\n      const left = 2 * i + 1;\n      const right = 2 * i + 2;\n      let smallest = i;\n\n      if (left < n && this.heap[left].weight < this.heap[smallest].weight) {\n        smallest = left;\n      }\n      if (right < n && this.heap[right].weight < this.heap[smallest].weight) {\n        smallest = right;\n      }\n      if (smallest !== i) {\n        this.swap(i, smallest);\n        i = smallest;\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Inserts a new item into the heap or updates it if it already exists.\n   * @param item The item to insert or update.\n   */\n  public insert(item: HeapItem): void {\n    // If the vertex already exists, perform a decrease-key operation.\n    if (this.position.hasOwnProperty(item.vertex)) {\n      const i = this.position[item.vertex];\n      if (item.weight < this.heap[i].weight) {\n        this.heap[i].weight = item.weight;\n        this.percolateUp(i);\n      }\n      return;\n    }\n    // Otherwise, add it as a new item.\n    this.heap.push(item);\n    const idx = this.heap.length - 1;\n    this.position[item.vertex] = idx;\n    this.percolateUp(idx);\n  }\n\n  /**\n   * Removes and returns the minimum element (the root) from the heap.\n   * @returns The removed element or undefined if the heap is empty.\n   */\n  public delete(): HeapItem | undefined {\n    if (this.heap.length === 0) return undefined;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    // Remove mapping for the vertex being removed.\n    delete this.position[min.vertex];\n    if (this.heap.length > 0 && last !== undefined) {\n      this.heap[0] = last;\n      this.position[last.vertex] = 0;\n      this.percolateDown(0);\n    }\n    return min;\n  }\n\n  /**\n   * Checks if the heap is empty.\n   * @returns True if the heap is empty; otherwise, false.\n   */\n  public isEmpty(): boolean {\n    return this.heap.length === 0;\n  }\n\n  /**\n   * Returns the minimum element of the heap without removing it.\n   * @returns The minimum element, or undefined if the heap is empty.\n   */\n  public findMin(): HeapItem | undefined {\n    return this.heap.length > 0 ? this.heap[0] : undefined;\n  }\n}\n\n/**\n * Executes Dijkstra's algorithm to find the shortest paths from a source node\n * in a weighted graph.\n *\n * @param graph - The adjacency list representing the graph with weights.\n * @param source - The source node from which to calculate shortest paths.\n * @returns A dictionary where keys are node labels and values represent the shortest distances from the source node.\n */\nexport default function dijkstra(\n  graph: Record<string, Record<string, number>>,\n  source: string,\n): Record<string, number> {\n  const distances: Record<string, number> = {};\n  const minHeap = new MinHeap();\n\n  // Initialize distances for every vertex.\n  for (const vertex in graph) {\n    distances[vertex] = vertex === source ? 0 : Infinity;\n    minHeap.insert({ vertex, weight: distances[vertex] });\n  }\n\n  const visited = new Set<string>();\n\n  while (!minHeap.isEmpty()) {\n    // Extract the vertex with the smallest tentative distance.\n    const current = minHeap.delete();\n    if (!current) break;\n    const { vertex: u } = current;\n    if (visited.has(u)) continue;\n    visited.add(u);\n\n    // For each neighbor of u, update its distance if a shorter path is found.\n    for (const neighbor in graph[u]) {\n      const newDist = distances[u] + graph[u][neighbor];\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        minHeap.insert({ vertex: neighbor, weight: newDist });\n      }\n    }\n  }\n\n  return distances;\n}\n"
  },
  "info": {
    "excerpt": "Implement Dijkstra's algorithm to find the shortest paths from a source vertex in a graph represented as an adjacency list.",
    "title": "Dijkstra's Algorithm"
  },
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1745539200,
    "difficulty": "medium",
    "duration": 20,
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/dijkstra",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "depth-first-search"
    ],
    "slug": "dijkstra",
    "subtitle": null,
    "topics": [
      "dfs",
      "graph"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Record<string, Record<string, number>>} graph The adjacency list representing the graph with weights.\n * @param {string} source The source node from which to calculate shortest paths.\n * @return {Record<string, number>} A dictionary where keys are node labels and values are the shortest distances from the source node.\n */\nexport default function dijkstra(graph, source) {\n  throw 'Not implemented!';\n}",
    "ts": "/**\n * @param {Record<string, Record<string, number>>} graph The adjacency list representing the graph with weights.\n * @param {string} source The source node from which to calculate shortest paths.\n * @return {Record<string, number>} A dictionary where keys are node labels and values are the shortest distances from the source node.\n */\nexport default function dijkstra(\n  graph: Record<string, Record<string, number>>,\n  source: string,\n): Record<string, number> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var u=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var x=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),y=(i,e)=>{for(var n in e)r(i,n,{get:e[n],enumerable:!0})},a=(i,e,n,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of f(e))!v.call(i,s)&&s!==n&&r(i,s,{get:()=>e[s],enumerable:!(h=g(e,s))||h.enumerable});return i};var b=(i,e,n)=>(n=i!=null?u(w(i)):{},a(e||!i||!i.__esModule?r(n,\"default\",{value:i,enumerable:!0}):n,i)),j=i=>a(r({},\"__esModule\",{value:!0}),i);var p=x((R,o)=>{o.exports=_jsx_runtime});var T={};y(T,{default:()=>I});var t=b(p());var l=MDXCodeBlock;var d=`/**\n * MinHeap: A minimum heap implementation to serve as a priority queue.\n * Each heap element is an object of the form { vertex, weight }.\n */\nclass MinHeap {\n  constructor() {\n    this.heap = [];\n    this.position = {}; // Maps each vertex to its index in the heap.\n  }\n\n  // Helper method to swap two elements and update their positions.\n  swap(i, j) {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    this.position[this.heap[i].vertex] = i;\n    this.position[this.heap[j].vertex] = j;\n  }\n\n  // Bubbles up the element at index i to restore heap property.\n  percolateUp(i) {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.heap[parent].weight > this.heap[i].weight) {\n        this.swap(i, parent);\n        i = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Bubbles down the element at index i to restore heap property.\n  percolateDown(i) {\n    const n = this.heap.length;\n    while (true) {\n      const left = 2 * i + 1;\n      const right = 2 * i + 2;\n      let smallest = i;\n\n      if (left < n && this.heap[left].weight < this.heap[smallest].weight) {\n        smallest = left;\n      }\n      if (right < n && this.heap[right].weight < this.heap[smallest].weight) {\n        smallest = right;\n      }\n      if (smallest !== i) {\n        this.swap(i, smallest);\n        i = smallest;\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Inserts a new item into the heap or updates it if it already exists.\n   * @param {{vertex: string, weight: number}} item The item to insert or update.\n   */\n  insert(item) {\n    // If the vertex exists, perform a decrease-key operation.\n    if (this.position.hasOwnProperty(item.vertex)) {\n      const i = this.position[item.vertex];\n      if (item.weight < this.heap[i].weight) {\n        this.heap[i].weight = item.weight;\n        this.percolateUp(i);\n      }\n      return;\n    }\n    // Otherwise, add it as a new item.\n    this.heap.push(item);\n    const idx = this.heap.length - 1;\n    this.position[item.vertex] = idx;\n    this.percolateUp(idx);\n  }\n\n  /**\n   * Removes and returns the minimum element (the root) from the heap.\n   * @return {{vertex: string, weight: number}|undefined} The removed element.\n   */\n  delete() {\n    if (this.heap.length === 0) return undefined;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    // Remove mapping for the vertex being removed.\n    delete this.position[min.vertex];\n    if (this.heap.length > 0) {\n      this.heap[0] = last;\n      this.position[last.vertex] = 0;\n      this.percolateDown(0);\n    }\n    return min;\n  }\n\n  /**\n   * Checks if the heap is empty.\n   * @return {boolean} True if the heap is empty; otherwise, false.\n   */\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  /**\n   * Returns the minimum element of the heap without removing it.\n   * @return {{vertex: string, weight: number}|undefined}\n   */\n  findMin() {\n    return this.heap.length > 0 ? this.heap[0] : undefined;\n  }\n}\n\n/**\n * Executes Dijkstra's algorithm to find the shortest paths from a source node\n * in a weighted graph.\n *\n * @param {Record<string, Record<string, number>>} graph - The adjacency list representing the graph with weights.\n * @param {string} source - The source node from which to calculate shortest paths.\n * @return {Record<string, number>} - A dictionary where keys are node labels and values represent the shortest distances from the source node.\n */\nexport default function dijkstra(graph, source) {\n  const distances = {};\n  const minHeap = new MinHeap();\n\n  // Initialize distances for every vertex.\n  for (const vertex in graph) {\n    // Set the source distance to 0 and all others to Infinity.\n    distances[vertex] = vertex === source ? 0 : Infinity;\n    // Insert the source with weight 0.\n    // Optionally, we can insert only the source and then add vertices as needed.\n    minHeap.insert({ vertex, weight: distances[vertex] });\n  }\n\n  const visited = new Set();\n\n  while (!minHeap.isEmpty()) {\n    // Extract the vertex with the smallest tentative distance.\n    const { vertex: u, weight } = minHeap.delete();\n    if (visited.has(u)) continue;\n    visited.add(u);\n\n    // For each neighbor of u, try to update its distance.\n    for (const neighbor in graph[u]) {\n      const newDist = distances[u] + graph[u][neighbor];\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        minHeap.insert({ vertex: neighbor, weight: newDist });\n      }\n    }\n  }\n\n  return distances;\n}\n`;var c=`type HeapItem = { vertex: string; weight: number };\n\n/**\n * MinHeap: A minimum heap implementation to serve as a priority queue.\n * Each heap element is of type HeapItem.\n */\nclass MinHeap {\n  private heap: HeapItem[];\n  private position: { [vertex: string]: number };\n\n  constructor() {\n    this.heap = [];\n    this.position = {};\n  }\n\n  // Helper method to swap two elements and update their positions.\n  private swap(i: number, j: number): void {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    this.position[this.heap[i].vertex] = i;\n    this.position[this.heap[j].vertex] = j;\n  }\n\n  // Bubbles up the element at index i to restore heap property.\n  private percolateUp(i: number): void {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.heap[parent].weight > this.heap[i].weight) {\n        this.swap(i, parent);\n        i = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Bubbles down the element at index i to restore heap property.\n  private percolateDown(i: number): void {\n    const n = this.heap.length;\n    while (true) {\n      const left = 2 * i + 1;\n      const right = 2 * i + 2;\n      let smallest = i;\n\n      if (left < n && this.heap[left].weight < this.heap[smallest].weight) {\n        smallest = left;\n      }\n      if (right < n && this.heap[right].weight < this.heap[smallest].weight) {\n        smallest = right;\n      }\n      if (smallest !== i) {\n        this.swap(i, smallest);\n        i = smallest;\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Inserts a new item into the heap or updates it if it already exists.\n   * @param item The item to insert or update.\n   */\n  public insert(item: HeapItem): void {\n    // If the vertex already exists, perform a decrease-key operation.\n    if (this.position.hasOwnProperty(item.vertex)) {\n      const i = this.position[item.vertex];\n      if (item.weight < this.heap[i].weight) {\n        this.heap[i].weight = item.weight;\n        this.percolateUp(i);\n      }\n      return;\n    }\n    // Otherwise, add it as a new item.\n    this.heap.push(item);\n    const idx = this.heap.length - 1;\n    this.position[item.vertex] = idx;\n    this.percolateUp(idx);\n  }\n\n  /**\n   * Removes and returns the minimum element (the root) from the heap.\n   * @returns The removed element or undefined if the heap is empty.\n   */\n  public delete(): HeapItem | undefined {\n    if (this.heap.length === 0) return undefined;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    // Remove mapping for the vertex being removed.\n    delete this.position[min.vertex];\n    if (this.heap.length > 0 && last !== undefined) {\n      this.heap[0] = last;\n      this.position[last.vertex] = 0;\n      this.percolateDown(0);\n    }\n    return min;\n  }\n\n  /**\n   * Checks if the heap is empty.\n   * @returns True if the heap is empty; otherwise, false.\n   */\n  public isEmpty(): boolean {\n    return this.heap.length === 0;\n  }\n\n  /**\n   * Returns the minimum element of the heap without removing it.\n   * @returns The minimum element, or undefined if the heap is empty.\n   */\n  public findMin(): HeapItem | undefined {\n    return this.heap.length > 0 ? this.heap[0] : undefined;\n  }\n}\n\n/**\n * Executes Dijkstra's algorithm to find the shortest paths from a source node\n * in a weighted graph.\n *\n * @param graph - The adjacency list representing the graph with weights.\n * @param source - The source node from which to calculate shortest paths.\n * @returns A dictionary where keys are node labels and values represent the shortest distances from the source node.\n */\nexport default function dijkstra(\n  graph: Record<string, Record<string, number>>,\n  source: string,\n): Record<string, number> {\n  const distances: Record<string, number> = {};\n  const minHeap = new MinHeap();\n\n  // Initialize distances for every vertex.\n  for (const vertex in graph) {\n    distances[vertex] = vertex === source ? 0 : Infinity;\n    minHeap.insert({ vertex, weight: distances[vertex] });\n  }\n\n  const visited = new Set<string>();\n\n  while (!minHeap.isEmpty()) {\n    // Extract the vertex with the smallest tentative distance.\n    const current = minHeap.delete();\n    if (!current) break;\n    const { vertex: u } = current;\n    if (visited.has(u)) continue;\n    visited.add(u);\n\n    // For each neighbor of u, update its distance if a shorter path is found.\n    for (const neighbor in graph[u]) {\n      const newDist = distances[u] + graph[u][neighbor];\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        minHeap.insert({ vertex: neighbor, weight: newDist });\n      }\n    }\n  }\n\n  return distances;\n}\n`;function m(i){let e=Object.assign({h3:\"h3\",p:\"p\",ol:\"ol\",li:\"li\",strong:\"strong\",img:\"img\",h2:\"h2\",ul:\"ul\",code:\"code\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h3,{children:\"Reasoning\"}),`\n`,(0,t.jsx)(e.p,{children:\"Dijkstra\\u2019s algorithm computes the shortest paths from a source node in a graph with non-negative edge weights. It uses a greedy approach: at each step, it selects the unvisited node with the smallest known distance. A min-heap efficiently performs this selection. When a shorter path to a neighbor is found, the algorithm updates its distance (relaxation) and pushes it into the heap. This strategy guarantees correctness because all edge weights are non-negative.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Dijkstra's algorithm assumes non-negative weights. For graphs with negative weights, other algorithms like Bellman-Ford are needed.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsx)(e.p,{children:\"The provided solution implements Dijkstra's algorithm using a priority queue (min-heap) for efficiency.\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Initialization\"}),\": Start with distances to all nodes set to infinity, except the source node which is set to zero.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Priority queue\"}),\": Use a priority queue to greedily select the next node with the smallest known distance.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Relaxation\"}),\": For each selected node, update the shortest distance to its neighboring nodes if a shorter path is found via the current node. Subsequently add or or update that neighbor's distance in the priority queue.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Termination\"}),\": The algorithm terminates when the priority queue is empty, indicating all reachable nodes have been processed.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/dijkstra/dijkstra.png\",alt:\"Dijkstra Illustration\"})}),`\n`,(0,t.jsx)(l,{languages:{jsx:d,tsx:c}}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Empty graphs\"}),\": Return an empty dictionary or map without crashing\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Graphs with one or two nodes\"}),\": Ensure that the algorithm can handle small graphs\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Graphs with non-connected components\"}),\": Nodes not reachable from the source should have their distance remain as infinity\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Graphs with zero-weight edges\"}),\": Confirm that zero-weight edges do not cause issues with the algorithm's logic\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O((V + E) log V)\"}),\". Using a min-heap, extracting the minimum takes O(log V) (done up to V times), and relaxing each of the E edges may also trigger a O(log V) heap update.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(v)\"}),\". Storing distances (\",(0,t.jsx)(e.code,{children:\"O(v)\"}),\"), the visited set (\",(0,t.jsx)(e.code,{children:\"O(v)\"}),\"), and the priority queue (\",(0,t.jsx)(e.code,{children:\"O(v)\"}),\" in the worst case).\"]}),`\n`]})]})}function D(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(m,i)})):m(i)}var I=D;return j(T);})();\n;return Component;",
  "workspace": {
    "main": "/src/dijkstra.ts",
    "run": "/src/dijkstra.run.test.ts",
    "submit": "/src/dijkstra.submit.test.ts"
  }
}