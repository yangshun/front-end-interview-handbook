{
  "description": "var Component=(()=>{var a=Object.create;var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var j=Object.getPrototypeOf,D=Object.prototype.hasOwnProperty;var g=(i,n)=>()=>(n||i((n={exports:{}}).exports,n),n.exports),m=(i,n)=>{for(var r in n)l(i,r,{get:n[r],enumerable:!0})},h=(i,n,r,d)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let c of p(n))!D.call(i,c)&&c!==r&&l(i,c,{get:()=>n[c],enumerable:!(d=u(n,c))||d.enumerable});return i};var x=(i,n,r)=>(r=i!=null?a(j(i)):{},h(n||!i||!i.__esModule?l(r,\"default\",{value:i,enumerable:!0}):r,i)),C=i=>h(l({},\"__esModule\",{value:!0}),i);var o=g((G,t)=>{t.exports=_jsx_runtime});var A={};m(A,{default:()=>k,frontmatter:()=>F});var e=x(o()),F={title:\"Dijkstra \\u7B97\\u6CD5\",excerpt:\"\\u5B9E\\u73B0 Dijkstra \\u7B97\\u6CD5\\uFF0C\\u4EE5\\u627E\\u5230\\u56FE\\u4E2D\\u4ECE\\u6E90\\u9876\\u70B9\\u5F00\\u59CB\\u7684\\u6700\\u77ED\\u8DEF\\u5F84\\uFF0C\\u8BE5\\u56FE\\u8868\\u793A\\u4E3A\\u90BB\\u63A5\\u8868\\u3002\"};function s(i){let n=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\",pre:\"pre\",h2:\"h2\",ol:\"ol\"},i.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"\\u7ED9\\u5B9A\\u4E00\\u4E2A\\u52A0\\u6743\\u6709\\u5411\\u56FE\\uFF0C\\u8868\\u793A\\u4E3A\\u90BB\\u63A5\\u8868 (\",(0,e.jsx)(n.code,{children:\"graph\"}),\") \\u548C\\u4E00\\u4E2A\\u8D77\\u59CB\\u8282\\u70B9 (\",(0,e.jsx)(n.code,{children:\"source\"}),\")\\uFF0C\\u5B9E\\u73B0 Dijkstra \\u7B97\\u6CD5\\u4EE5\\u627E\\u5230\\u4ECE \",(0,e.jsx)(n.code,{children:\"source\"}),\" \\u5230\\u56FE\\u4E2D\\u6240\\u6709\\u5176\\u4ED6\\u8282\\u70B9\\u7684\\u6700\\u77ED\\u8DEF\\u5F84\\u8DDD\\u79BB\\u3002\\u8BE5\\u56FE\\u5305\\u542B\\u8282\\u70B9\\u548C\\u52A0\\u6743\\u8FB9\\u3002\"]}),`\n`,(0,e.jsx)(n.h3,{children:\"\\u8F93\\u5165\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"graph\"}),\"\\uFF1A\\u4E00\\u4E2A\\u8868\\u793A\\u56FE\\u7684\\u90BB\\u63A5\\u8868\\u7684\\u5BF9\\u8C61\\u3002\\u6BCF\\u4E2A\\u952E\\u90FD\\u662F\\u4E00\\u4E2A\\u8282\\u70B9\\u6807\\u8BC6\\u7B26\\uFF08\\u4F8B\\u5982 \",(0,e.jsx)(n.code,{children:\"'A'\"}),\"\\u3001\",(0,e.jsx)(n.code,{children:\"'B'\"}),\"\\uFF09\\uFF0C\\u5176\\u503C\\u662F\\u53E6\\u4E00\\u4E2A\\u5BF9\\u8C61\\uFF0C\\u5C06\\u6BCF\\u4E2A\\u76F8\\u90BB\\u8282\\u70B9\\u6620\\u5C04\\u5230\\u8FDE\\u63A5\\u5B83\\u4EEC\\u7684\\u8FB9\\u7684\\u975E\\u8D1F\\u6743\\u91CD\\u3002\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"source\"}),\"\\uFF1A\\u7528\\u4E8E\\u8BA1\\u7B97\\u6700\\u77ED\\u8DEF\\u5F84\\u7684\\u8D77\\u59CB\\u8282\\u70B9\\u7684\\u6807\\u8BC6\\u7B26\\u3002\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"\\u8F93\\u51FA\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"\\u4E00\\u4E2A\\u5BF9\\u8C61\\uFF0C\\u5176\\u4E2D\\u952E\\u662F\\u8282\\u70B9\\u6807\\u8BC6\\u7B26\\uFF0C\\u503C\\u8868\\u793A\\u4ECE \",(0,e.jsx)(n.code,{children:\"source\"}),\" \\u5230\\u8BE5\\u8282\\u70B9\\u7684\\u6700\\u77ED\\u8DDD\\u79BB\\u3002\\u4ECE \",(0,e.jsx)(n.code,{children:\"source\"}),\" \\u65E0\\u6CD5\\u5230\\u8FBE\\u7684\\u8282\\u70B9\\u5E94\\u5C06\\u5176\\u8DDD\\u79BB\\u8BBE\\u7F6E\\u4E3A \",(0,e.jsx)(n.code,{children:\"Infinity\"}),\"\\uFF08\\u4F7F\\u7528\\u5185\\u7F6E\\u7684 \",(0,e.jsx)(n.code,{children:\"Infinity\"}),\" \\u5E38\\u91CF\\uFF09\\u3002\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"\\u4F8B\\u5B50\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const graph1 = {\n  A: { B: 1, C: 4 },\n  B: { E: 3, F: 2 },\n  C: { G: 2 },\n  D: { C: 3, J: 5 },\n  E: { D: 2 },\n  F: {},\n  G: { H: 1 },\n  H: { F: 4, J: 3 },\n  I: {},\n  J: {},\n};\n\ndijkstra(graph1, 'A'); // Returns distances: { A: 0, B: 1, C: 4, D: 6, E: 4, F: 3, G: 6, H: 7, I: Infinity, J: 10 }\n\nconst graph2 = {\n  A: { B: 2, C: 5 },\n  B: { D: 1, E: 4 },\n  C: { F: 3, G: 2 },\n  D: {},\n  E: {},\n  F: {},\n  G: {},\n};\n\ndijkstra(graph2, 'A'); // Returns distances: { A: 0, B: 2, C: 5, D: 3, E: 6, F: 8, G: 7 }\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"\\u7EA6\\u675F\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"1 <= \\u8282\\u70B9\\u6570 <= 1000\"}),`\n`,(0,e.jsx)(n.li,{children:\"0 <= \\u8FB9\\u6743\\u91CD <= 10000\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u56FE\\u53EF\\u80FD\\u5305\\u542B\\u5FAA\\u73AF\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u56FE\\u53EF\\u80FD\\u65AD\\u5F00\\u8FDE\\u63A5\"}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"\\u56DE\\u987E\\uFF08\\u63D0\\u793A\\uFF09\"}),`\n`,(0,e.jsx)(n.p,{children:\"Dijkstra \\u7B97\\u6CD5\\u662F\\u4E00\\u79CD\\u7528\\u4E8E\\u67E5\\u627E\\u52A0\\u6743\\u56FE\\u4E2D\\u8282\\u70B9\\u4E4B\\u95F4\\u6700\\u77ED\\u8DEF\\u5F84\\u7684\\u57FA\\u672C\\u7B97\\u6CD5\\u3002\\u8BE5\\u7B97\\u6CD5\\u53EF\\u4EE5\\u5904\\u7406\\u5177\\u6709\\u975E\\u8D1F\\u6743\\u91CD\\u7684\\u56FE\\uFF0C\\u901A\\u5E38\\u7528\\u4E8E\\u8DEF\\u7531\\u4EE5\\u53CA\\u5176\\u4ED6\\u56FE\\u7B97\\u6CD5\\u7684\\u5B50\\u7A0B\\u5E8F\\u3002\\u4EE5\\u4E0B\\u662F\\u4E00\\u4E9B\\u5178\\u578B\\u7684\\u7528\\u4F8B\\uFF1A\"}),`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsx)(n.li,{children:\"\\u5728 GPS \\u7CFB\\u7EDF\\u4E2D\\uFF0C\\u7528\\u4E8E\\u67E5\\u627E\\u4F4D\\u7F6E\\u4E4B\\u95F4\\u7684\\u6700\\u77ED\\u9A7E\\u9A76\\u8DEF\\u7EBF\\u3002\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u5728\\u7F51\\u7EDC\\u8DEF\\u7531\\u7B97\\u6CD5\\u4E2D\\uFF0C\\u7528\\u4E8E\\u67E5\\u627E\\u6570\\u636E\\u5305\\u7684\\u6700\\u77ED\\u8DEF\\u5F84\\u3002\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u5728\\u8C03\\u5EA6\\u7406\\u8BBA\\u4E2D\\uFF0C\\u7528\\u4E8E\\u67E5\\u627E\\u901A\\u8FC7\\u4E00\\u7CFB\\u5217\\u4EFB\\u52A1\\u7684\\u6700\\u77ED\\uFF08\\u8017\\u65F6\\u6700\\u5C11\\uFF09\\u8DEF\\u5F84\\u3002\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u751F\\u6210\\u52A0\\u6743\\u56FE\\u7684\\u6700\\u5C0F\\u751F\\u6210\\u6811 (MST)\\u3002\"}),`\n`]}),`\n`,(0,e.jsx)(n.p,{children:\"\\u4EE5\\u4E0B\\u662F Dijkstra \\u7B97\\u6CD5\\u7684\\u5DE5\\u4F5C\\u539F\\u7406\\uFF1A\"}),`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsx)(n.li,{children:\"\\u4ECE\\u56FE\\u4E2D\\u6240\\u6709\\u8282\\u70B9\\u7684\\u96C6\\u5408\\u5F00\\u59CB\\uFF0C\\u4E3A\\u5B83\\u4EEC\\u5206\\u914D\\u4E00\\u4E2A\\u6682\\u5B9A\\u7684\\u8DDD\\u79BB\\u503C\\uFF1A\\u5BF9\\u4E8E\\u521D\\u59CB\\u8282\\u70B9\\u4E3A\\u96F6\\uFF0C\\u5BF9\\u4E8E\\u6240\\u6709\\u5176\\u4ED6\\u8282\\u70B9\\u4E3A\\u65E0\\u7A77\\u5927\\u3002\\u5C06\\u521D\\u59CB\\u8282\\u70B9\\u8BBE\\u7F6E\\u4E3A\\u5F53\\u524D\\u8282\\u70B9\\u3002\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u5BF9\\u4E8E\\u5F53\\u524D\\u8282\\u70B9\\uFF0C\\u8003\\u8651\\u5176\\u6240\\u6709\\u672A\\u8BBF\\u95EE\\u7684\\u90BB\\u5C45\\u5E76\\u8BA1\\u7B97\\u5B83\\u4EEC\\u7684\\u6682\\u5B9A\\u8DDD\\u79BB\\u3002\\u5C06\\u65B0\\u8BA1\\u7B97\\u7684\\u6682\\u5B9A\\u8DDD\\u79BB\\u4E0E\\u5F53\\u524D\\u5206\\u914D\\u7684\\u503C\\u8FDB\\u884C\\u6BD4\\u8F83\\uFF0C\\u5E76\\u5206\\u914D\\u8F83\\u5C0F\\u7684\\u4E00\\u4E2A\\u3002\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u4E00\\u65E6\\u6211\\u4EEC\\u8003\\u8651\\u4E86\\u5F53\\u524D\\u8282\\u70B9\\u7684\\u6240\\u6709\\u672A\\u8BBF\\u95EE\\u90BB\\u5C45\\uFF0C\\u5C31\\u5C06\\u5F53\\u524D\\u8282\\u70B9\\u6807\\u8BB0\\u4E3A\\u5DF2\\u8BBF\\u95EE\\u3002\\u5DF2\\u8BBF\\u95EE\\u7684\\u8282\\u70B9\\u5C06\\u4E0D\\u518D\\u88AB\\u68C0\\u67E5\\u3002\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u5982\\u679C\\u76EE\\u6807\\u8282\\u70B9\\u5DF2\\u88AB\\u6807\\u8BB0\\u4E3A\\u5DF2\\u8BBF\\u95EE\\uFF0C\\u6216\\u8005\\u672A\\u8BBF\\u95EE\\u96C6\\u5408\\u4E2D\\u8282\\u70B9\\u4E4B\\u95F4\\u7684\\u6700\\u5C0F\\u6682\\u5B9A\\u8DDD\\u79BB\\u4E3A\\u65E0\\u7A77\\u5927\\uFF08\\u5F53\\u521D\\u59CB\\u8282\\u70B9\\u548C\\u5269\\u4F59\\u672A\\u8BBF\\u95EE\\u8282\\u70B9\\u4E4B\\u95F4\\u6CA1\\u6709\\u8FDE\\u63A5\\u65F6\\u53D1\\u751F\\uFF09\\uFF0C\\u5219\\u505C\\u6B62\\u3002\\u7B97\\u6CD5\\u5DF2\\u5B8C\\u6210\\u3002\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u5426\\u5219\\uFF0C\\u9009\\u62E9\\u6807\\u6709\\u6700\\u5C0F\\u6682\\u5B9A\\u8DDD\\u79BB\\u7684\\u672A\\u8BBF\\u95EE\\u8282\\u70B9\\uFF0C\\u5C06\\u5176\\u8BBE\\u7F6E\\u4E3A\\u65B0\\u7684\\u201C\\u5F53\\u524D\\u8282\\u70B9\\u201D\\uFF0C\\u7136\\u540E\\u8FD4\\u56DE\\u5230\\u6B65\\u9AA4 2\\u3002\"}),`\n`,(0,e.jsx)(n.li,{children:\"\\u7ED3\\u679C\\u662F\\u4ECE\\u521D\\u59CB\\u8282\\u70B9\\u5230\\u6240\\u6709\\u5176\\u4ED6\\u8282\\u70B9\\u7684\\u6700\\u77ED\\u8DDD\\u79BB\\u7684\\u6620\\u5C04\\u3002\"}),`\n`]})]})}function f(i={}){let{wrapper:n}=i.components||{};return n?(0,e.jsx)(n,Object.assign({},i,{children:(0,e.jsx)(s,i)})):s(i)}var k=f;return C(A);})();\n;return Component;",
  "info": {
    "excerpt": "实现 Dijkstra 算法，以找到图中从源顶点开始的最短路径，该图表示为邻接表。",
    "title": "Dijkstra 算法"
  },
  "solution": "var Component=(()=>{var u=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var x=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),b=(i,e)=>{for(var n in e)r(i,n,{get:e[n],enumerable:!0})},a=(i,e,n,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of f(e))!v.call(i,s)&&s!==n&&r(i,s,{get:()=>e[s],enumerable:!(h=g(e,s))||h.enumerable});return i};var y=(i,e,n)=>(n=i!=null?u(w(i)):{},a(e||!i||!i.__esModule?r(n,\"default\",{value:i,enumerable:!0}):n,i)),j=i=>a(r({},\"__esModule\",{value:!0}),i);var p=x((R,o)=>{o.exports=_jsx_runtime});var M={};b(M,{default:()=>I});var t=y(p());var l=MDXCodeBlock;var d=`/**\n * MinHeap: A minimum heap implementation to serve as a priority queue.\n * Each heap element is an object of the form { vertex, weight }.\n */\nclass MinHeap {\n  constructor() {\n    this.heap = [];\n    this.position = {}; // Maps each vertex to its index in the heap.\n  }\n\n  // Helper method to swap two elements and update their positions.\n  swap(i, j) {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    this.position[this.heap[i].vertex] = i;\n    this.position[this.heap[j].vertex] = j;\n  }\n\n  // Bubbles up the element at index i to restore heap property.\n  percolateUp(i) {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.heap[parent].weight > this.heap[i].weight) {\n        this.swap(i, parent);\n        i = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Bubbles down the element at index i to restore heap property.\n  percolateDown(i) {\n    const n = this.heap.length;\n    while (true) {\n      const left = 2 * i + 1;\n      const right = 2 * i + 2;\n      let smallest = i;\n\n      if (left < n && this.heap[left].weight < this.heap[smallest].weight) {\n        smallest = left;\n      }\n      if (right < n && this.heap[right].weight < this.heap[smallest].weight) {\n        smallest = right;\n      }\n      if (smallest !== i) {\n        this.swap(i, smallest);\n        i = smallest;\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Inserts a new item into the heap or updates it if it already exists.\n   * @param {{vertex: string, weight: number}} item The item to insert or update.\n   */\n  insert(item) {\n    // If the vertex exists, perform a decrease-key operation.\n    if (this.position.hasOwnProperty(item.vertex)) {\n      const i = this.position[item.vertex];\n      if (item.weight < this.heap[i].weight) {\n        this.heap[i].weight = item.weight;\n        this.percolateUp(i);\n      }\n      return;\n    }\n    // Otherwise, add it as a new item.\n    this.heap.push(item);\n    const idx = this.heap.length - 1;\n    this.position[item.vertex] = idx;\n    this.percolateUp(idx);\n  }\n\n  /**\n   * Removes and returns the minimum element (the root) from the heap.\n   * @return {{vertex: string, weight: number}|undefined} The removed element.\n   */\n  delete() {\n    if (this.heap.length === 0) return undefined;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    // Remove mapping for the vertex being removed.\n    delete this.position[min.vertex];\n    if (this.heap.length > 0) {\n      this.heap[0] = last;\n      this.position[last.vertex] = 0;\n      this.percolateDown(0);\n    }\n    return min;\n  }\n\n  /**\n   * Checks if the heap is empty.\n   * @return {boolean} True if the heap is empty; otherwise, false.\n   */\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  /**\n   * Returns the minimum element of the heap without removing it.\n   * @return {{vertex: string, weight: number}|undefined}\n   */\n  findMin() {\n    return this.heap.length > 0 ? this.heap[0] : undefined;\n  }\n}\n\n/**\n * Executes Dijkstra's algorithm to find the shortest paths from a source node\n * in a weighted graph.\n *\n * @param {Record<string, Record<string, number>>} graph - The adjacency list representing the graph with weights.\n * @param {string} source - The source node from which to calculate shortest paths.\n * @return {Record<string, number>} - A dictionary where keys are node labels and values represent the shortest distances from the source node.\n */\nexport default function dijkstra(graph, source) {\n  const distances = {};\n  const minHeap = new MinHeap();\n\n  // Initialize distances for every vertex.\n  for (const vertex in graph) {\n    // Set the source distance to 0 and all others to Infinity.\n    distances[vertex] = vertex === source ? 0 : Infinity;\n    // Insert the source with weight 0.\n    // Optionally, we can insert only the source and then add vertices as needed.\n    minHeap.insert({ vertex, weight: distances[vertex] });\n  }\n\n  const visited = new Set();\n\n  while (!minHeap.isEmpty()) {\n    // Extract the vertex with the smallest tentative distance.\n    const { vertex: u, weight } = minHeap.delete();\n    if (visited.has(u)) continue;\n    visited.add(u);\n\n    // For each neighbor of u, try to update its distance.\n    for (const neighbor in graph[u]) {\n      const newDist = distances[u] + graph[u][neighbor];\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        minHeap.insert({ vertex: neighbor, weight: newDist });\n      }\n    }\n  }\n\n  return distances;\n}\n`;var c=`type HeapItem = { vertex: string; weight: number };\n\n/**\n * MinHeap: A minimum heap implementation to serve as a priority queue.\n * Each heap element is of type HeapItem.\n */\nclass MinHeap {\n  private heap: HeapItem[];\n  private position: { [vertex: string]: number };\n\n  constructor() {\n    this.heap = [];\n    this.position = {};\n  }\n\n  // Helper method to swap two elements and update their positions.\n  private swap(i: number, j: number): void {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    this.position[this.heap[i].vertex] = i;\n    this.position[this.heap[j].vertex] = j;\n  }\n\n  // Bubbles up the element at index i to restore heap property.\n  private percolateUp(i: number): void {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.heap[parent].weight > this.heap[i].weight) {\n        this.swap(i, parent);\n        i = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Bubbles down the element at index i to restore heap property.\n  private percolateDown(i: number): void {\n    const n = this.heap.length;\n    while (true) {\n      const left = 2 * i + 1;\n      const right = 2 * i + 2;\n      let smallest = i;\n\n      if (left < n && this.heap[left].weight < this.heap[smallest].weight) {\n        smallest = left;\n      }\n      if (right < n && this.heap[right].weight < this.heap[smallest].weight) {\n        smallest = right;\n      }\n      if (smallest !== i) {\n        this.swap(i, smallest);\n        i = smallest;\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Inserts a new item into the heap or updates it if it already exists.\n   * @param item The item to insert or update.\n   */\n  public insert(item: HeapItem): void {\n    // If the vertex already exists, perform a decrease-key operation.\n    if (this.position.hasOwnProperty(item.vertex)) {\n      const i = this.position[item.vertex];\n      if (item.weight < this.heap[i].weight) {\n        this.heap[i].weight = item.weight;\n        this.percolateUp(i);\n      }\n      return;\n    }\n    // Otherwise, add it as a new item.\n    this.heap.push(item);\n    const idx = this.heap.length - 1;\n    this.position[item.vertex] = idx;\n    this.percolateUp(idx);\n  }\n\n  /**\n   * Removes and returns the minimum element (the root) from the heap.\n   * @returns The removed element or undefined if the heap is empty.\n   */\n  public delete(): HeapItem | undefined {\n    if (this.heap.length === 0) return undefined;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    // Remove mapping for the vertex being removed.\n    delete this.position[min.vertex];\n    if (this.heap.length > 0 && last !== undefined) {\n      this.heap[0] = last;\n      this.position[last.vertex] = 0;\n      this.percolateDown(0);\n    }\n    return min;\n  }\n\n  /**\n   * Checks if the heap is empty.\n   * @returns True if the heap is empty; otherwise, false.\n   */\n  public isEmpty(): boolean {\n    return this.heap.length === 0;\n  }\n\n  /**\n   * Returns the minimum element of the heap without removing it.\n   * @returns The minimum element, or undefined if the heap is empty.\n   */\n  public findMin(): HeapItem | undefined {\n    return this.heap.length > 0 ? this.heap[0] : undefined;\n  }\n}\n\n/**\n * Executes Dijkstra's algorithm to find the shortest paths from a source node\n * in a weighted graph.\n *\n * @param graph - The adjacency list representing the graph with weights.\n * @param source - The source node from which to calculate shortest paths.\n * @returns A dictionary where keys are node labels and values represent the shortest distances from the source node.\n */\nexport default function dijkstra(\n  graph: Record<string, Record<string, number>>,\n  source: string,\n): Record<string, number> {\n  const distances: Record<string, number> = {};\n  const minHeap = new MinHeap();\n\n  // Initialize distances for every vertex.\n  for (const vertex in graph) {\n    distances[vertex] = vertex === source ? 0 : Infinity;\n    minHeap.insert({ vertex, weight: distances[vertex] });\n  }\n\n  const visited = new Set<string>();\n\n  while (!minHeap.isEmpty()) {\n    // Extract the vertex with the smallest tentative distance.\n    const current = minHeap.delete();\n    if (!current) break;\n    const { vertex: u } = current;\n    if (visited.has(u)) continue;\n    visited.add(u);\n\n    // For each neighbor of u, update its distance if a shorter path is found.\n    for (const neighbor in graph[u]) {\n      const newDist = distances[u] + graph[u][neighbor];\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        minHeap.insert({ vertex: neighbor, weight: newDist });\n      }\n    }\n  }\n\n  return distances;\n}\n`;function m(i){let e=Object.assign({h3:\"h3\",p:\"p\",strong:\"strong\",ol:\"ol\",li:\"li\",img:\"img\",h2:\"h2\",ul:\"ul\",code:\"code\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h3,{children:\"\\u7406\\u7531\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Dijkstra \\u7B97\\u6CD5\\u8BA1\\u7B97\\u56FE\\u4E2D\\u4ECE\\u5177\\u6709\\u975E\\u8D1F\\u8FB9\\u6743\\u91CD\\u7684\\u6E90\\u8282\\u70B9\\u7684\",(0,t.jsx)(e.strong,{children:\"\\u6700\\u77ED\\u8DEF\\u5F84\"}),\"\\u3002\\u5B83\\u4F7F\\u7528\\u8D2A\\u5FC3\\u65B9\\u6CD5\\uFF1A\\u5728\\u6BCF\\u4E00\\u6B65\\u4E2D\\uFF0C\\u5B83\\u9009\\u62E9\\u5177\\u6709\\u6700\\u5C0F\\u5DF2\\u77E5\\u8DDD\\u79BB\\u7684\\u672A\\u8BBF\\u95EE\\u8282\\u70B9\\u3002 \\u6700\\u5C0F\\u5806\\u53EF\\u4EE5\\u6709\\u6548\\u5730\\u6267\\u884C\\u6B64\\u9009\\u62E9\\u3002 \\u5F53\\u627E\\u5230\\u5230\\u90BB\\u5C45\\u7684\\u66F4\\u77ED\\u8DEF\\u5F84\\u65F6\\uFF0C\\u7B97\\u6CD5\\u4F1A\\u66F4\\u65B0\\u5176\\u8DDD\\u79BB\\uFF08\\u677E\\u5F1B\\uFF09\\u5E76\\u5C06\\u5176\\u63A8\\u5165\\u5806\\u4E2D\\u3002 \\u8FD9\\u79CD\\u7B56\\u7565\\u4FDD\\u8BC1\\u4E86\\u6B63\\u786E\\u6027\\uFF0C\\u56E0\\u4E3A\\u6240\\u6709\\u8FB9\\u6743\\u91CD\\u90FD\\u662F\\u975E\\u8D1F\\u7684\\u3002\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Dijkstra \\u7B97\\u6CD5\\u5047\\u8BBE\\u975E\\u8D1F\\u6743\\u91CD\\u3002 \\u5BF9\\u4E8E\\u5177\\u6709\\u8D1F\\u6743\\u91CD\\u7684\\u56FE\\uFF0C\\u9700\\u8981\\u4F7F\\u7528\\u5176\\u4ED6\\u7B97\\u6CD5\\uFF0C\\u5982 Bellman-Ford\\u3002\"}),`\n`,(0,t.jsx)(e.h3,{children:\"\\u7B97\\u6CD5\"}),`\n`,(0,t.jsx)(e.p,{children:\"\\u63D0\\u4F9B\\u7684\\u89E3\\u51B3\\u65B9\\u6848\\u4F7F\\u7528\\u4F18\\u5148\\u7EA7\\u961F\\u5217\\uFF08\\u6700\\u5C0F\\u5806\\uFF09\\u6765\\u5B9E\\u73B0 Dijkstra \\u7B97\\u6CD5\\uFF0C\\u4EE5\\u63D0\\u9AD8\\u6548\\u7387\\u3002\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u521D\\u59CB\\u5316\"}),\"\\uFF1A\\u4ECE\\u6240\\u6709\\u8282\\u70B9\\u8BBE\\u7F6E\\u4E3A\\u65E0\\u7A77\\u5927\\u7684\\u8DDD\\u79BB\\u5F00\\u59CB\\uFF0C\\u9664\\u4E86\\u6E90\\u8282\\u70B9\\u8BBE\\u7F6E\\u4E3A\\u96F6\\u3002\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u4F18\\u5148\\u7EA7\\u961F\\u5217\"}),\"\\uFF1A\\u4F7F\\u7528\\u4F18\\u5148\\u7EA7\\u961F\\u5217\\u8D2A\\u5A6A\\u5730\\u9009\\u62E9\\u5177\\u6709\\u6700\\u5C0F\\u5DF2\\u77E5\\u8DDD\\u79BB\\u7684\\u4E0B\\u4E00\\u4E2A\\u8282\\u70B9\\u3002\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u677E\\u5F1B\"}),\"\\uFF1A\\u5BF9\\u4E8E\\u6BCF\\u4E2A\\u9009\\u5B9A\\u7684\\u8282\\u70B9\\uFF0C\\u5982\\u679C\\u901A\\u8FC7\\u5F53\\u524D\\u8282\\u70B9\\u627E\\u5230\\u66F4\\u77ED\\u7684\\u8DEF\\u5F84\\uFF0C\\u5219\\u66F4\\u65B0\\u5230\\u5176\\u76F8\\u90BB\\u8282\\u70B9\\u7684\\u6700\\u77ED\\u8DDD\\u79BB\\u3002 \\u968F\\u540E\\u5728\\u4F18\\u5148\\u7EA7\\u961F\\u5217\\u4E2D\\u6DFB\\u52A0\\u6216\\u66F4\\u65B0\\u8BE5\\u90BB\\u5C45\\u7684\\u8DDD\\u79BB\\u3002\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u7EC8\\u6B62\"}),\"\\uFF1A\\u5F53\\u4F18\\u5148\\u7EA7\\u961F\\u5217\\u4E3A\\u7A7A\\u65F6\\uFF0C\\u7B97\\u6CD5\\u7EC8\\u6B62\\uFF0C\\u8868\\u660E\\u6240\\u6709\\u53EF\\u5230\\u8FBE\\u7684\\u8282\\u70B9\\u90FD\\u5DF2\\u5904\\u7406\\u5B8C\\u6BD5\\u3002\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/dijkstra/dijkstra.png\",alt:\"Dijkstra Illustration\"})}),`\n`,(0,t.jsx)(l,{languages:{jsx:d,tsx:c}}),`\n`,(0,t.jsx)(e.h2,{children:\"\\u8FB9\\u7F18\\u60C5\\u51B5\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u7A7A\\u56FE\"}),\"\\uFF1A\\u8FD4\\u56DE\\u4E00\\u4E2A\\u7A7A\\u5B57\\u5178\\u6216\\u6620\\u5C04\\uFF0C\\u800C\\u4E0D\\u4F1A\\u5D29\\u6E83\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u4E00\\u4E2A\\u6216\\u4E24\\u4E2A\\u8282\\u70B9\\u7684\\u56FE\"}),\"\\uFF1A\\u786E\\u4FDD\\u7B97\\u6CD5\\u53EF\\u4EE5\\u5904\\u7406\\u5C0F\\u56FE\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u5177\\u6709\\u975E\\u8FDE\\u63A5\\u7EC4\\u4EF6\\u7684\\u56FE\"}),\"\\uFF1A\\u4ECE\\u6E90\\u65E0\\u6CD5\\u5230\\u8FBE\\u7684\\u8282\\u70B9\\u5E94\\u4FDD\\u6301\\u5176\\u8DDD\\u79BB\\u4E3A\\u65E0\\u7A77\\u5927\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u5177\\u6709\\u96F6\\u6743\\u91CD\\u8FB9\\u7684\\u56FE\"}),\"\\uFF1A\\u786E\\u8BA4\\u96F6\\u6743\\u91CD\\u8FB9\\u4E0D\\u4F1A\\u5BFC\\u81F4\\u7B97\\u6CD5\\u903B\\u8F91\\u51FA\\u73B0\\u95EE\\u9898\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O \\u5206\\u6790\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF1AO((V + E) log V)\"}),\"\\u3002 \\u4F7F\\u7528\\u6700\\u5C0F\\u5806\\uFF0C\\u63D0\\u53D6\\u6700\\u5C0F\\u503C\\u9700\\u8981 O(log V)\\uFF08\\u6700\\u591A\\u6267\\u884C V \\u6B21\\uFF09\\uFF0C\\u5E76\\u4E14\\u677E\\u5F1B\\u6BCF\\u4E2A E \\u8FB9\\u4E5F\\u53EF\\u80FD\\u89E6\\u53D1 O(log V) \\u5806\\u66F4\\u65B0\\u3002\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\uFF1AO(v)\"}),\"\\u3002 \\u5B58\\u50A8\\u8DDD\\u79BB\\uFF08\",(0,t.jsx)(e.code,{children:\"O(v)\"}),\"\\uFF09\\u3001\\u5DF2\\u8BBF\\u95EE\\u96C6\\u5408\\uFF08\",(0,t.jsx)(e.code,{children:\"O(v)\"}),\"\\uFF09\\u548C\\u4F18\\u5148\\u7EA7\\u961F\\u5217\\uFF08\\u6700\\u574F\\u60C5\\u51B5\\u4E0B\\u4E3A \",(0,t.jsx)(e.code,{children:\"O(v)\"}),\"\\uFF09\\u3002\"]}),`\n`]})]})}function D(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(m,i)})):m(i)}var I=D;return j(M);})();\n;return Component;"
}