{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/dijkstra\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/dijkstra.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/dijkstra.run.test.ts": "import dijkstra from './dijkstra';\n\ndescribe('dijkstra', () => {\n  test('empty graph', () => {\n    expect(dijkstra({}, 'A')).toEqual({});\n  });\n\n  test('graph with one node', () => {\n    expect(dijkstra({ A: {} }, 'A')).toEqual({ A: 0 });\n  });\n\n  test('graph with two nodes', () => {\n    expect(dijkstra({ A: { B: 1 }, B: {} }, 'A')).toEqual({ A: 0, B: 1 });\n  });\n});\n",
    "/src/dijkstra.submit.test.ts": "import dijkstra from './dijkstra';\n\ndescribe('dijkstra', () => {\n  test('empty graph', () => {\n    expect(dijkstra({}, 'A')).toEqual({});\n  });\n\n  test('graph with one node', () => {\n    expect(dijkstra({ A: {} }, 'A')).toEqual({ A: 0 });\n  });\n\n  test('graph with two nodes', () => {\n    expect(dijkstra({ A: { B: 1 }, B: {} }, 'A')).toEqual({ A: 0, B: 1 });\n    expect(dijkstra({ A: { B: 5 }, B: { A: 2 } }, 'A')).toEqual({ A: 0, B: 5 });\n    expect(dijkstra({ A: { B: 5 }, B: { A: 2 } }, 'B')).toEqual({ A: 2, B: 0 });\n  });\n\n  test('graphs with multiple nodes', () => {\n    expect(\n      dijkstra({ A: { B: 1, C: 4 }, B: { D: 1 }, C: {}, D: {} }, 'A'),\n    ).toEqual({\n      A: 0,\n      B: 1,\n      C: 4,\n      D: 2,\n    });\n    expect(\n      dijkstra({ A: { B: 2, C: 5 }, B: { C: 3 }, C: { D: 1 }, D: {} }, 'A'),\n    ).toEqual({\n      A: 0,\n      B: 2,\n      C: 5,\n      D: 6,\n    });\n    expect(\n      dijkstra(\n        { A: { B: 1, C: 2 }, B: { C: 1, D: 2 }, C: { D: 5 }, D: {} },\n        'A',\n      ),\n    ).toEqual({\n      A: 0,\n      B: 1,\n      C: 2,\n      D: 3,\n    });\n  });\n\n  test('disjoint graphs', () => {\n    expect(dijkstra({ A: { B: 3 }, B: {}, C: { D: 1 }, D: {} }, 'A')).toEqual({\n      A: 0,\n      B: 3,\n      C: Infinity,\n      D: Infinity,\n    });\n    expect(dijkstra({ A: { B: 3 }, B: {}, C: { D: 1 }, D: {} }, 'C')).toEqual({\n      A: Infinity,\n      B: Infinity,\n      C: 0,\n      D: 1,\n    });\n  });\n\n  test('graph with cycles', () => {\n    expect(\n      dijkstra(\n        { A: { B: 1, C: 2 }, B: { A: 2 }, C: { D: 3 }, D: { A: 1 } },\n        'A',\n      ),\n    ).toEqual({\n      A: 0,\n      B: 1,\n      C: 2,\n      D: 5,\n    });\n    expect(\n      dijkstra(\n        { A: { B: 4, C: 1 }, B: { C: 2, D: 2 }, C: { D: 2 }, D: { A: 7 } },\n        'A',\n      ),\n    ).toEqual({\n      A: 0,\n      B: 4,\n      C: 1,\n      D: 3,\n    });\n  });\n});\n",
    "/src/dijkstra.ts": "type HeapItem = { vertex: string; weight: number };\n\n/**\n * MinHeap: A minimum heap implementation to serve as a priority queue.\n * Each heap element is of type HeapItem.\n */\nclass MinHeap {\n  private heap: HeapItem[];\n  private position: { [vertex: string]: number };\n\n  constructor() {\n    this.heap = [];\n    this.position = {};\n  }\n\n  // Helper method to swap two elements and update their positions.\n  private swap(i: number, j: number): void {\n    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];\n    this.position[this.heap[i].vertex] = i;\n    this.position[this.heap[j].vertex] = j;\n  }\n\n  // Bubbles up the element at index i to restore heap property.\n  private percolateUp(i: number): void {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.heap[parent].weight > this.heap[i].weight) {\n        this.swap(i, parent);\n        i = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Bubbles down the element at index i to restore heap property.\n  private percolateDown(i: number): void {\n    const n = this.heap.length;\n    while (true) {\n      const left = 2 * i + 1;\n      const right = 2 * i + 2;\n      let smallest = i;\n\n      if (left < n && this.heap[left].weight < this.heap[smallest].weight) {\n        smallest = left;\n      }\n      if (right < n && this.heap[right].weight < this.heap[smallest].weight) {\n        smallest = right;\n      }\n      if (smallest !== i) {\n        this.swap(i, smallest);\n        i = smallest;\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Inserts a new item into the heap or updates it if it already exists.\n   * @param item The item to insert or update.\n   */\n  public insert(item: HeapItem): void {\n    // If the vertex already exists, perform a decrease-key operation.\n    if (this.position.hasOwnProperty(item.vertex)) {\n      const i = this.position[item.vertex];\n      if (item.weight < this.heap[i].weight) {\n        this.heap[i].weight = item.weight;\n        this.percolateUp(i);\n      }\n      return;\n    }\n    // Otherwise, add it as a new item.\n    this.heap.push(item);\n    const idx = this.heap.length - 1;\n    this.position[item.vertex] = idx;\n    this.percolateUp(idx);\n  }\n\n  /**\n   * Removes and returns the minimum element (the root) from the heap.\n   * @returns The removed element or undefined if the heap is empty.\n   */\n  public delete(): HeapItem | undefined {\n    if (this.heap.length === 0) return undefined;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    // Remove mapping for the vertex being removed.\n    delete this.position[min.vertex];\n    if (this.heap.length > 0 && last !== undefined) {\n      this.heap[0] = last;\n      this.position[last.vertex] = 0;\n      this.percolateDown(0);\n    }\n    return min;\n  }\n\n  /**\n   * Checks if the heap is empty.\n   * @returns True if the heap is empty; otherwise, false.\n   */\n  public isEmpty(): boolean {\n    return this.heap.length === 0;\n  }\n\n  /**\n   * Returns the minimum element of the heap without removing it.\n   * @returns The minimum element, or undefined if the heap is empty.\n   */\n  public findMin(): HeapItem | undefined {\n    return this.heap.length > 0 ? this.heap[0] : undefined;\n  }\n}\n\n/**\n * Executes Dijkstra's algorithm to find the shortest paths from a source node\n * in a weighted graph.\n *\n * @param graph - The adjacency list representing the graph with weights.\n * @param source - The source node from which to calculate shortest paths.\n * @returns A dictionary where keys are node labels and values represent the shortest distances from the source node.\n */\nexport default function dijkstra(\n  graph: Record<string, Record<string, number>>,\n  source: string,\n): Record<string, number> {\n  const distances: Record<string, number> = {};\n  const minHeap = new MinHeap();\n\n  // Initialize distances for every vertex.\n  for (const vertex in graph) {\n    distances[vertex] = vertex === source ? 0 : Infinity;\n    minHeap.insert({ vertex, weight: distances[vertex] });\n  }\n\n  const visited = new Set<string>();\n\n  while (!minHeap.isEmpty()) {\n    // Extract the vertex with the smallest tentative distance.\n    const current = minHeap.delete();\n    if (!current) break;\n    const { vertex: u } = current;\n    if (visited.has(u)) continue;\n    visited.add(u);\n\n    // For each neighbor of u, update its distance if a shorter path is found.\n    for (const neighbor in graph[u]) {\n      const newDist = distances[u] + graph[u][neighbor];\n      if (newDist < distances[neighbor]) {\n        distances[neighbor] = newDist;\n        minHeap.insert({ vertex: neighbor, weight: newDist });\n      }\n    }\n  }\n\n  return distances;\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Record<string, Record<string, number>>} graph The adjacency list representing the graph with weights.\n * @param {string} source The source node from which to calculate shortest paths.\n * @return {Record<string, number>} A dictionary where keys are node labels and values are the shortest distances from the source node.\n */\nexport default function dijkstra(graph, source) {\n  throw 'Not implemented!';\n}",
    "ts": "/**\n * @param {Record<string, Record<string, number>>} graph The adjacency list representing the graph with weights.\n * @param {string} source The source node from which to calculate shortest paths.\n * @return {Record<string, number>} A dictionary where keys are node labels and values are the shortest distances from the source node.\n */\nexport default function dijkstra(\n  graph: Record<string, Record<string, number>>,\n  source: string,\n): Record<string, number> {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/dijkstra.ts",
    "run": "/src/dijkstra.run.test.ts",
    "submit": "/src/dijkstra.submit.test.ts"
  }
}