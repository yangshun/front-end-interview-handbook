{
  "description": "var Component=(()=>{var g=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var x=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),w=(t,n)=>{for(var r in n)i(t,r,{get:n[r],enumerable:!0})},a=(t,n,r,c)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let s of m(n))!f.call(t,s)&&s!==r&&i(t,s,{get:()=>n[s],enumerable:!(c=p(n,s))||c.enumerable});return t};var z=(t,n,r)=>(r=t!=null?g(b(t)):{},a(n||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),j=t=>a(i({},\"__esModule\",{value:!0}),t);var l=x((F,o)=>{o.exports=_jsx_runtime});var A={};w(A,{default:()=>M,frontmatter:()=>y});var e=z(l());var d=MDXTestExamples;var h=[{input:[[\"str\",\"cauumzssz\"]],output:\"zssz\",explanation:\"'zssz' is the longest palindromic substring within 'cauumzssz'.\"},{input:[[\"str\",\"racecar\"]],output:\"racecar\",explanation:\"The entire string 'racecar' is a palindrome and is the longest.\"},{input:[[\"str\",\"cacae\"]],output:\"cac\",explanation:\"Both 'cac' and 'aca' are valid palindromic substrings of the same length, and either can be returned.\"}];var y={title:\"Find the Longest Palindromic Substring\",excerpt:\"Implement a function to find the longest palindromic substring\"};function u(t){let n=Object.assign({p:\"p\",code:\"code\",strong:\"strong\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"Given a string \",(0,e.jsx)(n.code,{children:\"str\"}),\", return the longest contiguous substring that is a palindrome. If there are multiple such substrings, return any one of them.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"A \",(0,e.jsx)(n.strong,{children:\"palindrome\"}),\" is a sequence of characters that reads the same forward and backward (e.g., \",(0,e.jsx)(n.code,{children:\"racecar\"}),\").\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"A \",(0,e.jsx)(n.strong,{children:\"substring\"}),\" is any contiguous sequence of characters within a string. For example, the substrings of string \",(0,e.jsx)(n.code,{children:\"abc\"}),\" are \",(0,e.jsx)(n.code,{children:\"a\"}),\", \",(0,e.jsx)(n.code,{children:\"b\"}),\", \",(0,e.jsx)(n.code,{children:\"c\"}),\", \",(0,e.jsx)(n.code,{children:\"ab\"}),\", \",(0,e.jsx)(n.code,{children:\"bc\"}),\", and \",(0,e.jsx)(n.code,{children:\"abc\"}),\". A substring is formed by selecting a starting and ending point without skipping characters in between.\"]}),`\n`,(0,e.jsx)(n.h3,{children:\"Input\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"str: string\"}),\": A string\"]}),`\n`]}),`\n`,(0,e.jsx)(d,{testCases:h}),`\n`,(0,e.jsx)(n.h3,{children:\"Constraints\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"1 <= \",(0,e.jsx)(n.code,{children:\"str.length\"}),\" <= 1000\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"str\"}),\" contains only lowercase English letters\"]}),`\n`]})]})}function C(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(u,t)})):u(t)}var M=C;return j(A);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the longest palindromic substring",
    "title": "Find the Longest Palindromic Substring"
  },
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var i in e)l(t,i,{get:e[i],enumerable:!0})},o=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!v.call(t,r)&&r!==i&&l(t,r,{get:()=>e[r],enumerable:!(a=m(e,r))||a.enumerable});return t};var w=(t,e,i)=>(i=t!=null?f(x(t)):{},o(e||!t||!t.__esModule?l(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>o(l({},\"__esModule\",{value:!0}),t);var d=y((P,h)=>{h.exports=_jsx_runtime});var S={};j(S,{default:()=>O});var n=w(d());var s=MDXCodeBlock;var c=`export default function longestPalindromeSubstring(str: string): string {\n  const n = str.length;\n\n  // Initialize a 2D array \\`dp\\` where dp[i][j] will be true if the substring s[i..j] is a palindrome\n  const dp: boolean[][] = Array.from(Array(n), () => Array(n).fill(false));\n\n  // \\`ans\\` will store the starting and ending indices of the longest palindromic substring found\n  let ans = [0, 0];\n\n  // Every single character is a palindrome, so set dp[i][i] to true for all i\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = true;\n  }\n\n  // Check for palindromes of length 2 (i.e., pairs of consecutive characters)\n  for (let i = 0; i < n - 1; i++) {\n    if (str[i] === str[i + 1]) {\n      dp[i][i + 1] = true;\n      ans = [i, i + 1]; // Update the longest palindrome indices\n    }\n  }\n\n  // Check for palindromes of length 3 and greater\n  for (let diff = 2; diff < n; diff++) {\n    for (let i = 0; i < n - diff; i++) {\n      let j = i + diff;\n      // If the characters at the start and end of the substring are equal\n      // and the substring s[i+1..j-1] is a palindrome, then s[i..j] is a palindrome\n      if (str[i] === str[j] && dp[i + 1][j - 1]) {\n        dp[i][j] = true;\n        ans = [i, j]; // Update the longest palindrome indices\n      }\n    }\n  }\n\n  // Extract the longest palindromic substring from the string using the indices stored in \\`ans\\`\n  const i = ans[0];\n  const j = ans[1];\n  return str.slice(i, j + 1);\n}\n`;var g=`export default function longestPalindromeSubstring(str: string): string {\n  // Helper function to check if the substring s[i:j] is a palindrome\n  const check = (i: number, j: number) => {\n    let left = i; // Start pointer\n    let right = j - 1; // End pointer (one less because j is exclusive)\n\n    // Check characters from both ends moving towards the center\n    while (left < right) {\n      // If the characters at the current pointers don't match, it's not a palindrome\n      if (str.charAt(left) !== str.charAt(right)) {\n        return false;\n      }\n\n      // Move pointers closer to the center\n      left++;\n      right--;\n    }\n\n    // If all characters matched, it's a palindrome\n    return true;\n  };\n\n  // Iterate over possible lengths of the substring, starting from the longest\n  for (let length = str.length; length > 0; length--) {\n    // For each length, iterate over all possible starting points of the substring\n    for (let start = 0; start <= str.length - length; start++) {\n      // If the substring s[start:start+length] is a palindrome, return it\n      if (check(start, start + length)) {\n        return str.substring(start, start + length);\n      }\n    }\n  }\n\n  // If no palindrome is found (though technically it shouldn't happen), return an empty string\n  return '';\n}\n`;var u=`export default function longestPalindromeSubstring(str: string): string {\n  // Helper function to expand around a center and find the longest palindromic substring\n  function expand(i: number, j: number): string {\n    let left: number = i; // Start pointer for the left side of the potential palindrome\n    let right: number = j; // Start pointer for the right side of the potential palindrome\n\n    // Expand outwards while the characters on both sides are equal\n    // and the pointers are within bounds of the string\n    while (left >= 0 && right < str.length && str[left] === str[right]) {\n      left--; // Move left pointer to the left\n      right++; // Move right pointer to the right\n    }\n\n    // Return the substring that is the palindrome found\n    // Note: left + 1 and right are used to get the correct bounds of the palindrome\n    return str.slice(left + 1, right);\n  }\n\n  let ans: string = ''; // Initialize the variable to store the longest palindromic substring\n\n  // Iterate through each character in the string as potential centers of palindromes\n  for (let i = 0; i < str.length; i++) {\n    // Find the longest odd-length palindrome with center at \\`i\\`\n    let odd: string = expand(i, i);\n    // Update the result if the found palindrome is longer than the previous longest\n    if (odd.length > ans.length) {\n      ans = odd;\n    }\n\n    // Find the longest even-length palindrome with centers at \\`i\\` and \\`i + 1\\`\n    let even: string = expand(i, i + 1);\n    // Update the result if the found palindrome is longer than the previous longest\n    if (even.length > ans.length) {\n      ans = even;\n    }\n  }\n\n  // Return the longest palindromic substring found\n  return ans;\n}\n`;function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. BruteForce\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem requires finding the longest palindromic substring in a given string. A brute force approach systematically examines all possible substrings and checks whether each substring is a palindrome. This ensures that the algorithm correctly identifies palindromes and returns the longest one.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"check(i, j)\"}),\" to determine whether the substring from index \",(0,n.jsx)(e.code,{children:\"i\"}),\" to \",(0,n.jsx)(e.code,{children:\"j-1\"}),\" is a palindrome:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two pointers, \",(0,n.jsx)(e.code,{children:\"left\"}),\" at \",(0,n.jsx)(e.code,{children:\"i\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" at \",(0,n.jsx)(e.code,{children:\"j-1\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compare characters at \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" while moving the pointers toward the center.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"false\"}),\" if any pair of characters does not match; otherwise, return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the pointers meet or cross.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate over possible lengths of substrings in descending order:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Start with the maximum possible length of the string and decrease the length until \",(0,n.jsx)(e.code,{children:\"1\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"For each length, iterate over all possible starting indices for the substring.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For each substring, call the helper function \",(0,n.jsx)(e.code,{children:\"check\"}),\" to determine if it is a palindrome:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"If the substring is a palindrome, return it immediately as the longest palindrome.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"If no palindrome is found, return an empty string (this scenario does not occur with valid input).\"}),`\n`]}),`\n`,(0,n.jsx)(s,{children:g}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"3\"}),\")\"]}),\". The algorithm checks all substrings using two nested loops, and the palindrome check takes O(n) for each substring.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of extra space regardless of the input size.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Dynamic Programming\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"A dynamic programming (DP) approach optimizes the brute force method by reducing redundant checks. Instead of re-evaluating overlapping substrings, the DP approach stores intermediate results in a table \",(0,n.jsx)(e.code,{children:\"dp\"}),\", where \",(0,n.jsx)(e.code,{children:\"dp[i][j]\"}),\" is \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the substring \",(0,n.jsx)(e.code,{children:\"s[i..j]\"}),\" is a palindrome.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The dynamic programming approach iteratively builds the solution by considering substrings of increasing lengths. It starts by marking single characters as palindromes, then checks pairs of consecutive characters, and finally evaluates substrings of length 3 or more. The DP table eliminates the need for repetitive computations by ensuring that results for smaller substrings are reused when evaluating larger substrings.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a 2D array \",(0,n.jsx)(e.code,{children:\"dp\"}),\" of size \",(0,n.jsx)(e.code,{children:\"n x n\"}),\", where \",(0,n.jsx)(e.code,{children:\"n\"}),\" is the length of the string. Set all values to \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Mark all single-character substrings as palindromes by setting \",(0,n.jsx)(e.code,{children:\"dp[i][i] = true\"}),\" for all \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check for two-character substrings:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For indices \",(0,n.jsx)(e.code,{children:\"i\"}),\" and \",(0,n.jsx)(e.code,{children:\"i + 1\"}),\", if \",(0,n.jsx)(e.code,{children:\"str[i] === str[i + 1]\"}),\", set \",(0,n.jsx)(e.code,{children:\"dp[i][i + 1] = true\"}),\" and update the indices of the longest palindrome.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate over possible lengths of substrings starting from 3:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each length, iterate over possible starting indices \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compute the ending index \",(0,n.jsx)(e.code,{children:\"j = i + length - 1\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"str[i] === str[j]\"}),\" and \",(0,n.jsx)(e.code,{children:\"dp[i + 1][j - 1]\"}),\" is \",(0,n.jsx)(e.code,{children:\"true\"}),\", set \",(0,n.jsx)(e.code,{children:\"dp[i][j] = true\"}),\" and update the indices of the longest palindrome.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Extract the substring using the indices of the longest palindrome stored in the variable \",(0,n.jsx)(e.code,{children:\"ans\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the extracted substring.\"}),`\n`]}),`\n`,(0,n.jsx)(s,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The algorithm iterates over all substrings of the string, and each substring evaluation takes constant time due to the use of the DP table.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Space complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The DP table requires storage proportional to the square of the string length.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"3. Expanding from Centers\"}),`\n`,(0,n.jsx)(e.p,{children:\"The expanding around the center approach is an efficient solution that avoids constructing a dynamic programming table or checking all substrings. The key idea is to treat each character (or pair of characters) as the center of a potential palindrome and expand outward to find the largest palindrome around that center.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This method avoids unnecessary work by using the property of palindromes, which expand symmetrically around a center. For every character (or pair of characters for even-length palindromes), the algorithm expands outward until a mismatch occurs. This approach reduces redundant checks and eliminates the need to store intermediate results.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"expand(i, j)\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two pointers, \",(0,n.jsx)(e.code,{children:\"left\"}),\" at \",(0,n.jsx)(e.code,{children:\"i\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" at \",(0,n.jsx)(e.code,{children:\"j\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Expand the pointers outward while \",(0,n.jsx)(e.code,{children:\"left\"}),\" is non-negative, \",(0,n.jsx)(e.code,{children:\"right\"}),\" is within bounds, and the characters at \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" are equal.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the substring bounded by \",(0,n.jsx)(e.code,{children:\"left + 1\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" as the palindrome.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a variable \",(0,n.jsx)(e.code,{children:\"ans\"}),\" to store the longest palindromic substring found.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through each character in the string:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Treat the character at index \",(0,n.jsx)(e.code,{children:\"i\"}),\" as the center of an odd-length palindrome. Call \",(0,n.jsx)(e.code,{children:\"expand(i, i)\"}),\" and update \",(0,n.jsx)(e.code,{children:\"ans\"}),\" if the returned palindrome is longer than the current value of \",(0,n.jsx)(e.code,{children:\"ans\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Treat the characters at indices \",(0,n.jsx)(e.code,{children:\"i\"}),\" and \",(0,n.jsx)(e.code,{children:\"i + 1\"}),\" as the centers of an even-length palindrome. Call \",(0,n.jsx)(e.code,{children:\"expand(i, i + 1)\"}),\" and update \",(0,n.jsx)(e.code,{children:\"ans\"}),\" if the returned palindrome is longer than the current value of \",(0,n.jsx)(e.code,{children:\"ans\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the value of \",(0,n.jsx)(e.code,{children:\"ans\"}),\" after processing all characters.\"]}),`\n`]}),`\n`,(0,n.jsx)(s,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". For each character, the expansion may run in O(n) in the worst case, resulting in O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\") overall.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of extra space, excluding the space required for the output.\"]}),`\n`]})]})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var O=D;return k(S);})();\n;return Component;"
}