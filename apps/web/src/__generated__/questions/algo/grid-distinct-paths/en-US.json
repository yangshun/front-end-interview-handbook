{
  "description": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),D=(e,n)=>{for(var i in n)r(e,i,{get:n[i],enumerable:!0})},a=(e,n,i,c)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let o of g(n))!b.call(e,o)&&o!==i&&r(e,o,{get:()=>n[o],enumerable:!(c=p(n,o))||c.enumerable});return e};var w=(e,n,i)=>(i=e!=null?m(x(e)):{},a(n||!e||!e.__esModule?r(i,\"default\",{value:e,enumerable:!0}):i,e)),j=e=>a(r({},\"__esModule\",{value:!0}),e);var d=f((q,h)=>{h.exports=_jsx_runtime});var M={};D(M,{default:()=>C,frontmatter:()=>_});var t=w(d());var l=MDXTestExamples;var s=[{input:[[\"m\",3],[\"n\",2]],output:3,explanation:\"The robot has 3 unique paths to reach the target point in a 3x2 grid: Right-Down-Down, Down-Down-Right, Down-Right-Down.\"},{input:[[\"m\",5],[\"n\",7]],output:210,explanation:\"The robot can navigate a 5x7 grid using 210 unique paths to reach the target point.\"},{input:[[\"m\",10],[\"n\",4]],output:220,explanation:\"The robot can navigate a 10x4 grid using 220 unique paths to reach the target point.\"}];var _={title:\"Distinct Paths in Grid\",excerpt:\"Implement a function to calculate distinct paths for a robot moving on an m x n grid\"};function u(e){let n=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[\"A robot is situated on an \",(0,t.jsx)(n.code,{children:\"m\"}),\" x \",(0,t.jsx)(n.code,{children:\"n\"}),\" grid, starting at the top-left corner (\",(0,t.jsx)(n.code,{children:\"grid[0][0]\"}),\") with the goal of reaching the bottom-right corner (\",(0,t.jsx)(n.code,{children:\"grid[m - 1][n - 1]\"}),\"). In one step, the robot can only either move down or right by a single cell.\"]}),`\n`,(0,t.jsxs)(n.p,{children:[\"Given the integers \",(0,t.jsx)(n.code,{children:\"m\"}),\" and \",(0,t.jsx)(n.code,{children:\"n\"}),\", determine the number of distinct paths the robot can take to reach the bottom-right corner.\"]}),`\n`,(0,t.jsx)(n.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(n.ul,{children:[`\n`,(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:\"m: number\"}),\": An integer\"]}),`\n`,(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:\"n: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,t.jsx)(l,{testCases:s}),`\n`,(0,t.jsx)(n.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(n.ul,{children:[`\n`,(0,t.jsx)(n.li,{children:\"The result will not exceed 2^31\"}),`\n`,(0,t.jsxs)(n.li,{children:[\"1 <= \",(0,t.jsx)(n.code,{children:\"m\"}),\", \",(0,t.jsx)(n.code,{children:\"n\"}),\" <= 100\"]}),`\n`]})]})}function v(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(u,e)})):u(e)}var C=v;return j(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to calculate distinct paths for a robot moving on an m x n grid",
    "title": "Distinct Paths in Grid"
  },
  "solution": "var Component=(()=>{var p=Object.create;var l=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var y=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),v=(o,e)=>{for(var r in e)l(o,r,{get:e[r],enumerable:!0})},h=(o,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of b(e))!w.call(o,n)&&n!==r&&l(o,n,{get:()=>e[n],enumerable:!(c=f(e,n))||c.enumerable});return o};var x=(o,e,r)=>(r=o!=null?p(g(o)):{},h(e||!o||!o.__esModule?l(r,\"default\",{value:o,enumerable:!0}):r,o)),D=o=>h(l({},\"__esModule\",{value:!0}),o);var s=y((j,a)=>{a.exports=_jsx_runtime});var O={};v(O,{default:()=>A});var t=x(s());var i=MDXCodeBlock;var d=`export default function gridDistinctPaths(m: number, n: number): number {\n  // Create a 2D DP table (d) to store the number of unique paths reaching each cell.\n  // Initialize all cells to 1, representing 1 path (straight down or right from the top/left edge).\n  const d = new Array(m).fill(0).map(() => new Array(n).fill(1));\n\n  // Iterate through the table (excluding the first row and column since they already have 1 path).\n  for (let col = 1; col < m; col++) {\n    for (let row = 1; row < n; row++) {\n      // The number of unique paths reaching this cell (col, row) is the sum of:\n      //   - Paths reaching the cell above (col-1, row) - only one possible move (down).\n      //   - Paths reaching the cell to the left (col, row-1) - only one possible move (right).\n      d[col][row] = d[col - 1][row] + d[col][row - 1];\n    }\n  }\n\n  // The final element (d[m-1][n-1]) represents the total number of unique paths reaching the bottom-right corner.\n  return d[m - 1][n - 1];\n}\n`;var m=`export default function gridDistinctPaths(m: number, n: number): number {\n  // Create a memoization table to store previously calculated results (optional for top-down approach)\n  const memo = new Array(m).fill(null).map(() => new Array(n).fill(null));\n\n  // Recursive helper function to calculate the number of paths from a specific cell\n  function helper(row: number, col: number): number {\n    // Base cases:\n    if (row === m - 1 && col === n - 1) return 1; // Reached the destination (bottom-right) - 1 path\n    if (row >= m || col >= n) return 0; // Outside the grid - no paths possible\n\n    // Check if the value has already been calculated and stored in the memo table\n    if (memo[row][col] !== null) {\n      return memo[row][col];\n    }\n\n    // Calculate the number of paths by combining paths from below and to the right\n    const pathsDown = helper(row + 1, col);\n    const pathsRight = helper(row, col + 1);\n\n    // Memoize the result for future use\n    memo[row][col] = pathsDown + pathsRight;\n\n    return memo[row][col];\n  }\n\n  // Call the helper function to start from the top-left corner\n  return helper(0, 0);\n}\n`;function u(o){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},o.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Bottom-Up Dynamic Programming\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The problem requires finding the number of distinct paths from the top-left corner to the bottom-right corner of a grid with dimensions \",(0,t.jsx)(e.code,{children:\"m x n\"}),\". Movement is restricted to either down or right at any point in time.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The approach uses bottom-up dynamic programming to solve the problem efficiently. The intuition is that the number of ways to reach a specific cell in the grid is the sum of the number of ways to reach the cell directly above it and the cell directly to its left. This is because the only valid moves to the current cell are either from above or from the left. A 2D table is used to store the number of ways to reach each cell, avoiding redundant computations.\"}),`\n`,(0,t.jsx)(e.p,{children:\"This method eliminates unnecessary recursion and overlapping subproblems by iteratively building the solution in a table.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize a 2D array \",(0,t.jsx)(e.code,{children:\"d\"}),\" of size \",(0,t.jsx)(e.code,{children:\"m x n\"}),\" with all cells set to \",(0,t.jsx)(e.code,{children:\"1\"}),\". This represents that there is exactly one way to reach any cell in the first row or the first column.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through the grid starting from the second row and second column:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"For each cell \",(0,t.jsx)(e.code,{children:\"(col, row)\"}),\", calculate the number of paths to this cell as the sum of the paths to the cell above it (\",(0,t.jsx)(e.code,{children:\"d[col-1][row]\"}),\") and the paths to the cell to its left (\",(0,t.jsx)(e.code,{children:\"d[col][row-1]\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Continue this process until all cells are filled.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return the value of the bottom-right cell \",(0,t.jsx)(e.code,{children:\"d[m-1][n-1]\"}),\", which represents the total number of unique paths from the top-left to the bottom-right corner.\"]}),`\n`]}),`\n`,(0,t.jsx)(i,{children:d}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Every cell in the grid is processed once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(m.n)\"}),\". A 2D array of size \",(0,t.jsx)(e.code,{children:\"m x n\"}),\" is used to store the number of unique paths for each cell.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Top-Down Dynamic Programming\"}),`\n`,(0,t.jsx)(e.p,{children:\"This approach uses top-down dynamic programming with memoization to avoid redundant computations. The recursive function calculates the number of paths to the destination from a given cell by summing the paths from the cell directly below and the cell directly to the right. A memoization table stores the results of previously computed cells, ensuring that each subproblem is solved only once. This eliminates unnecessary duplicate work, optimizing the solution.\"}),`\n`,(0,t.jsx)(e.p,{children:\"This method efficiently breaks the problem into overlapping subproblems while storing intermediate results to reduce overall computation time.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Create a memoization table \",(0,t.jsx)(e.code,{children:\"memo\"}),\" of size \",(0,t.jsx)(e.code,{children:\"m x n\"}),\" initialized with \",(0,t.jsx)(e.code,{children:\"null\"}),\" to store results for subproblems.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Define a recursive helper function \",(0,t.jsx)(e.code,{children:\"helper(row, col)\"}),\":\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If the current cell is the bottom-right corner (\",(0,t.jsx)(e.code,{children:\"row === m-1\"}),\" and \",(0,t.jsx)(e.code,{children:\"col === n-1\"}),\"), return \",(0,t.jsx)(e.code,{children:\"1\"}),\" because there is exactly one path to the destination.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the current cell is outside the grid (\",(0,t.jsx)(e.code,{children:\"row >= m\"}),\" or \",(0,t.jsx)(e.code,{children:\"col >= n\"}),\"), return \",(0,t.jsx)(e.code,{children:\"0\"}),\" because no paths are possible.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the result for the current cell is already stored in \",(0,t.jsx)(e.code,{children:\"memo[row][col]\"}),\", return the stored value to avoid redundant computation.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Calculate the number of paths as the sum of paths from the cell below (\",(0,t.jsx)(e.code,{children:\"helper(row+1, col)\"}),\") and the cell to the right (\",(0,t.jsx)(e.code,{children:\"helper(row, col+1)\"}),\").\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Store the calculated result in \",(0,t.jsx)(e.code,{children:\"memo[row][col]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Start the computation by calling \",(0,t.jsx)(e.code,{children:\"helper(0, 0)\"}),\" for the top-left corner.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Return the result from the recursive call, which represents the total number of paths from the top-left to the bottom-right corner.\"}),`\n`]}),`\n`,(0,t.jsx)(i,{children:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Each cell is computed at most once due to memoization, resulting in a total of \",(0,t.jsx)(e.code,{children:\"m.n\"}),\" subproblems.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(m.n)\"}),\". The memoization table requires \",(0,t.jsx)(e.code,{children:\"m.n\"}),\" space, and the recursion stack can grow up to \",(0,t.jsx)(e.code,{children:\"m + n\"}),\" levels in the worst case.\"]}),`\n`]})]})}function C(o={}){let{wrapper:e}=o.components||{};return e?(0,t.jsx)(e,Object.assign({},o,{children:(0,t.jsx)(u,o)})):u(o)}var A=C;return D(O);})();\n;return Component;"
}