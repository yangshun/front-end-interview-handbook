{
  "description": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of g(e))!b.call(t,s)&&s!==r&&i(t,s,{get:()=>e[s],enumerable:!(a=p(e,s))||a.enumerable});return t};var j=(t,e,r)=>(r=t!=null?d(x(t)):{},o(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>o(i({},\"__esModule\",{value:!0}),t);var l=f((X,u)=>{u.exports=_jsx_runtime});var w={};y(w,{default:()=>v,frontmatter:()=>M});var n=j(l());var c=MDXTestExamples;var h=[{input:[[\"numbers\",[-1,5,-3,9,-11]]],output:11,explanation:\"The subarray [5, -3, 9] has the largest sum i.e 11.\"},{input:[[\"numbers\",[9]]],output:9,explanation:\"The single-element subarray [9] has the largest sum i.e 9.\"},{input:[[\"numbers\",[1,2,3,4]]],output:10,explanation:\"The subarray [1,2,3,4] has the largest sum i.e 10.\"}];var M={title:\"Maximum Sum in Contiguous Array\",excerpt:\"Implement a function to find the subarray with the maximum sum\"};function m(t){let e=Object.assign({p:\"p\",code:\"code\",strong:\"strong\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of integers \",(0,n.jsx)(e.code,{children:\"numbers\"}),\", determine the subarray that has the highest sum and return that sum.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.strong,{children:\"subarray\"}),\" is a contiguous segment of an array where all elements are taken from consecutive indices, preserving their order, such as \",(0,n.jsx)(e.code,{children:\"[2, 3]\"}),\" in \",(0,n.jsx)(e.code,{children:\"[1, 2, 3, 4]\"}),\", while non-contiguous selections like \",(0,n.jsx)(e.code,{children:\"[1, 3]\"}),\" are not valid subarray.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 10,000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10,000 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 10,000\"]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var v=T;return _(w);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the subarray with the maximum sum",
    "title": "Maximum Sum in Contiguous Array"
  },
  "solution": "var Component=(()=>{var b=Object.create;var i=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),S=(n,e)=>{for(var a in e)i(n,a,{get:e[a],enumerable:!0})},c=(n,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!g.call(n,t)&&t!==a&&i(n,t,{get:()=>e[t],enumerable:!(o=y(e,t))||o.enumerable});return n};var I=(n,e,a)=>(a=n!=null?b(x(n)):{},c(e||!n||!n.__esModule?i(a,\"default\",{value:n,enumerable:!0}):a,n)),v=n=>c(i({},\"__esModule\",{value:!0}),n);var l=f((U,s)=>{s.exports=_jsx_runtime});var O={};S(O,{default:()=>w});var r=I(l());var u=MDXCodeBlock;var d=`export default function maxSumSubArray(numbers: number[]): number {\n  let currentSum = 0;\n  let maxSum = -Infinity; // Use -Infinity to represent the smallest possible number\n\n  for (let num of numbers) {\n    // Update current sum, considering starting a new subarray if necessary\n    currentSum = Math.max(num, currentSum + num);\n    // Update max sum if current sum is larger\n    maxSum = Math.max(maxSum, currentSum);\n  }\n\n  return maxSum;\n}\n`;var m=`export default function maxSumSubArray(numbers: number[]): number {\n  // Initialize the maximum subarray sum to negative infinity\n  let maxSubarray = Number.NEGATIVE_INFINITY;\n\n  // Iterate through each element in the array\n  for (let i = 0; i < numbers.length; i++) {\n    // Initialize current subarray sum to zero\n    let currentSubarray = 0;\n\n    // Iterate through the subarray starting from index i\n    for (let j = i; j < numbers.length; j++) {\n      // Add the current element to the current subarray sum\n      currentSubarray += numbers[j];\n\n      // Update the maximum subarray sum if the current subarray sum is larger\n      maxSubarray = Math.max(maxSubarray, currentSubarray);\n    }\n  }\n\n  // Return the maximum subarray sum found\n  return maxSubarray;\n}\n`;function h(n){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Efficient Brute Force Approach\"}),`\n`,(0,r.jsx)(e.p,{children:\"A brute force approach for finding the maximum sum contiguous subarray checks every possible subarray. This involves iterating over each element as a starting point and then expanding the subarray by including subsequent elements one by one. As each subarray is formed, its sum is computed, and the maximum sum found so far is updated. This ensures that every subarray sum is evaluated and compared.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize a variable \",(0,r.jsx)(e.code,{children:\"maxSubarray\"}),\" to \",(0,r.jsx)(e.code,{children:\"Number.NEGATIVE_INFINITY\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Use a loop index \",(0,r.jsx)(e.code,{children:\"i\"}),\" to iterate from the start of the array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"For each \",(0,r.jsx)(e.code,{children:\"i\"}),\", initialize \",(0,r.jsx)(e.code,{children:\"currentSubarray\"}),\" to 0.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Use another loop index \",(0,r.jsx)(e.code,{children:\"j\"}),\" to iterate from \",(0,r.jsx)(e.code,{children:\"i\"}),\" to the end of the array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Add \",(0,r.jsx)(e.code,{children:\"numbers[j]\"}),\" to \",(0,r.jsx)(e.code,{children:\"currentSubarray\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Update \",(0,r.jsx)(e.code,{children:\"maxSubarray\"}),\" with the maximum between \",(0,r.jsx)(e.code,{children:\"maxSubarray\"}),\" and \",(0,r.jsx)(e.code,{children:\"currentSubarray\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"After both loops finish, return \",(0,r.jsx)(e.code,{children:\"maxSubarray\"}),\".\"]}),`\n`]}),`\n`,(0,r.jsx)(u,{children:m}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n\\xB2)\"}),\". There are two nested loops being used to consider all possible subarrays.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". Only a constant amount of extra space is used.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"2. Using Kadane's Algorithm\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The previous brute force approach enumerates all possible subarrays and computes their sums. This process involves repeated summation of overlapping subarrays, creating unnecessary work that leads to O(n\\xB2) complexity. Kadane's algorithm addresses this by maintaining a running \",(0,r.jsx)(e.code,{children:\"currentSum\"}),\" and updating it at each step. Instead of recalculating entire subarray sums, the algorithm decides whether to extend the existing subarray or start a new one from the current element. The global \",(0,r.jsx)(e.code,{children:\"maxSum\"}),\" is continuously updated, ensuring that the largest encountered sum is tracked without enumerating every possible subarray. This eliminates unnecessary repeated work and reduces the complexity to O(n).\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize \",(0,r.jsx)(e.code,{children:\"currentSum\"}),\" to \",(0,r.jsx)(e.code,{children:\"0\"}),\" and \",(0,r.jsx)(e.code,{children:\"maxSum\"}),\" to \",(0,r.jsx)(e.code,{children:\"-Infinity\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate through each element \",(0,r.jsx)(e.code,{children:\"num\"}),\" in the array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Update \",(0,r.jsx)(e.code,{children:\"currentSum\"}),\" to \",(0,r.jsx)(e.code,{children:\"Math.max(num, currentSum + num)\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Update \",(0,r.jsx)(e.code,{children:\"maxSum\"}),\" to \",(0,r.jsx)(e.code,{children:\"Math.max(maxSum, currentSum)\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Return \",(0,r.jsx)(e.code,{children:\"maxSum\"}),\".\"]}),`\n`]}),`\n`,(0,r.jsx)(u,{children:d}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each element is visited once.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional space is required apart from a few variables.\"]}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(h,n)})):h(n)}var w=T;return v(O);})();\n;return Component;"
}