{
  "description": "var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),M=(t,e)=>{for(var d in e)l(t,d,{get:e[d],enumerable:!0})},a=(t,e,d,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of f(e))!x.call(t,i)&&i!==d&&l(t,i,{get:()=>e[i],enumerable:!(r=p(e,i))||r.enumerable});return t};var w=(t,e,d)=>(d=t!=null?u(g(t)):{},a(e||!t||!t.__esModule?l(d,\"default\",{value:t,enumerable:!0}):d,t)),T=t=>a(l({},\"__esModule\",{value:!0}),t);var s=b((y,o)=>{o.exports=_jsx_runtime});var C={};M(C,{default:()=>A,frontmatter:()=>v});var n=w(s());var h=MDXTestExamples;var c=[{input:[[\"methods\",[\"add\",\"getMedian\"]],[\"params\",[4,null]]],output:[null,4],explanation:\"Add 4 to the stream, then find the median, which is 4.\"},{input:[[\"methods\",[\"add\",\"add\",\"getMedian\"]],[\"params\",[10,20,null]]],output:[null,null,15],explanation:\"Add 10 and 20 to the stream. The median of [10, 20] is (10 + 20) / 2 = 15.\"},{input:[[\"methods\",[\"add\",\"add\",\"add\",\"getMedian\"]],[\"params\",[1,2,3,null]]],output:[null,null,null,2],explanation:\"Add 1, 2, 3 to the stream. The median of [1, 2, 3] is 2.\"}];var v={title:\"Number Stream Median\",excerpt:\"Implement a function to find the median of a dynamic stream of integers\"};function m(t){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h3:\"h3\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"The median of a list of numbers is defined as the middle value in a sorted list. When the list has an even number of elements, the median is the average of the two middle values.\"}),`\n`,(0,n.jsx)(e.p,{children:\"For example:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For the list \",(0,n.jsx)(e.code,{children:\"[1, 2, 3]\"}),\", the median is 2\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For the list \",(0,n.jsx)(e.code,{children:\"[1, 2]\"}),\", the median is (1 + 2) / 2 = 1.5\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"NumberStream\"}),\" class with the following methods:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"add(num: number): void\"}),\": Adds an integer num to the data structure\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"getMedian(): number\"}),\": Returns the median of all numbers added so far\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"NumberStream\"}),\" instance will have its methods called with various parameters based on these:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"methods: string[]\"}),\": An array of \",(0,n.jsx)(e.code,{children:\"NumberStream\"}),\" method names\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"params: (number | null)[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"methods[i]\"}),\" will be called with \",(0,n.jsx)(e.code,{children:\"params[i]\"}),\".\"]}),`\n`,(0,n.jsx)(h,{testCases:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"num\"}),\" <= 100,000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"methods.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"There will be at least one element in the data structure before calling \",(0,n.jsx)(e.code,{children:\"getMedian()\"})]}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var A=_;return T(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the median of a dynamic stream of integers",
    "title": "Number Stream Median"
  },
  "solution": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var H=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var a in e)i(t,a,{get:e[a],enumerable:!0})},l=(t,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of g(e))!x.call(t,r)&&r!==a&&i(t,r,{get:()=>e[r],enumerable:!(o=f(e,r))||o.enumerable});return t};var v=(t,e,a)=>(a=t!=null?u(b(t)):{},l(e||!t||!t.__esModule?i(a,\"default\",{value:t,enumerable:!0}):a,t)),w=t=>l(i({},\"__esModule\",{value:!0}),t);var m=H((I,d)=>{d.exports=_jsx_runtime});var S={};y(S,{default:()=>A});var n=v(m());var h=MDXCodeBlock;var s=`export default class NumberStream {\n  // Max heap to store the smaller half of the numbers\n  private maxHeap: number[] = [];\n\n  // Min heap to store the larger half of the numbers\n  private minHeap: number[] = [];\n\n  // Adds a number into the data structure\n  add(num: number): void {\n    // Add the new number to the max heap (lo)\n    this.addNumberToHeap(this.maxHeap, num, (a, b) => b - a);\n\n    // Balance the heaps: move the largest number from maxHeap to minHeap\n    this.addNumberToHeap(\n      this.minHeap,\n      this.removeTopFromHeap(this.maxHeap),\n      (a, b) => a - b,\n    );\n\n    // Ensure that maxHeap has more elements than minHeap if their sizes differ\n    if (this.maxHeap.length < this.minHeap.length) {\n      this.addNumberToHeap(\n        this.maxHeap,\n        this.removeTopFromHeap(this.minHeap),\n        (a, b) => b - a,\n      );\n    }\n  }\n\n  // Returns the median of the current data stream\n  getMedian(): number {\n    // If maxHeap has more elements, the median is its top element\n    if (this.maxHeap.length > this.minHeap.length) {\n      return this.maxHeap[0];\n    }\n    // Otherwise, the median is the average of the tops of maxHeap and minHeap\n    else {\n      return (this.maxHeap[0] + this.minHeap[0]) * 0.5;\n    }\n  }\n\n  // Utility function to add a number to a heap, maintaining the heap property\n  private addNumberToHeap(\n    heap: number[],\n    num: number,\n    comparator: (a: number, b: number) => number,\n  ): void {\n    heap.push(num);\n    let i = heap.length - 1;\n\n    while (i > 0) {\n      let parent = Math.floor((i - 1) / 2);\n      if (comparator(heap[i], heap[parent]) > 0) {\n        [heap[i], heap[parent]] = [heap[parent], heap[i]];\n        i = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Utility function to remove the top element from a heap, maintaining the heap property\n  private removeTopFromHeap(heap: number[]): number {\n    if (heap.length === 0) return NaN;\n    const top = heap[0];\n    const last = heap.pop();\n\n    if (heap.length > 0 && last !== undefined) {\n      heap[0] = last;\n      this.heapify(heap, 0, (a, b) => (heap === this.maxHeap ? b - a : a - b));\n    }\n\n    return top;\n  }\n\n  // Utility function to maintain the heap property from the given index downwards\n  private heapify(\n    heap: number[],\n    i: number,\n    comparator: (a: number, b: number) => number,\n  ): void {\n    const length = heap.length;\n    let largest = i;\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n\n    if (left < length && comparator(heap[left], heap[largest]) > 0) {\n      largest = left;\n    }\n\n    if (right < length && comparator(heap[right], heap[largest]) > 0) {\n      largest = right;\n    }\n\n    if (largest !== i) {\n      [heap[i], heap[largest]] = [heap[largest], heap[i]];\n      this.heapify(heap, largest, comparator);\n    }\n  }\n}\n`;var c=`export default class NumberStream {\n  // Array to store the numbers\n  private store: number[] = [];\n\n  // Adds a number into the data structure\n  add(num: number): void {\n    // Add the number to the array\n    this.store.push(num);\n  }\n\n  // Returns the median of the current number stream\n  getMedian(): number {\n    // Sort the array\n    this.store.sort((a, b) => a - b);\n\n    const n = this.store.length;\n\n    // Compute the median\n    if (n % 2 === 1) {\n      // If the size is odd, return the middle element\n      return this.store[Math.floor(n / 2)];\n    }\n\n    // If the size is even, return the average of the two middle elements\n    const mid1 = this.store[n / 2 - 1];\n    const mid2 = this.store[n / 2];\n    return (mid1 + mid2) * 0.5;\n  }\n}\n`;function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",ol:\"ol\",code:\"code\",h3:\"h3\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute Force Approach Using Sort\"}),`\n`,(0,n.jsx)(e.p,{children:\"The goal of this problem is to calculate the median of a stream of numbers dynamically. The brute force approach maintains a list of all numbers received so far and calculates the median after sorting the list each time a median is requested.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The median is defined as:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The middle element if the total count of numbers is odd.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The average of the two middle elements if the total count of numbers is even.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"This approach works by:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Storing all incoming numbers in an array.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Sorting the array each time the \",(0,n.jsx)(e.code,{children:\"getMedian\"}),\" method is called to ensure the numbers are in ascending order.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Calculating the median based on the sorted array.\"}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Create a \",(0,n.jsx)(e.code,{children:\"NumberStream\"}),\" class with a private array \",(0,n.jsx)(e.code,{children:\"store\"}),\" to hold all incoming numbers.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define an \",(0,n.jsx)(e.code,{children:\"add\"}),\" method to append a number to the \",(0,n.jsx)(e.code,{children:\"store\"}),\" array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a \",(0,n.jsx)(e.code,{children:\"getMedian\"}),\" method to calculate the median:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sort the \",(0,n.jsx)(e.code,{children:\"store\"}),\" array in ascending order.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Determine the size of the array (\",(0,n.jsx)(e.code,{children:\"n\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"n\"}),\" is odd, return the middle element.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"n\"}),\" is even, compute the average of the two middle elements and return the result.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(h,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Sorting the array dominates the runtime of the \",(0,n.jsx)(e.code,{children:\"getMedian\"}),\" method. Adding a number to the \",(0,n.jsx)(e.code,{children:\"store\"}),\" array takes O(1).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"store\"}),\" array grows linearly with the number of elements in the stream.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Two Heaps\"}),`\n`,(0,n.jsx)(e.p,{children:\"This solution optimizes the process of finding the median in a dynamic data stream by utilizing two heaps: a max heap and a min heap. The core idea is to maintain two balanced heaps:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"A max heap (\",(0,n.jsx)(e.code,{children:\"maxHeap\"}),\") that contains the smaller half of the numbers.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"A min heap (\",(0,n.jsx)(e.code,{children:\"minHeap\"}),\") that contains the larger half of the numbers.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The heaps are structured such that the top of the max heap represents the largest number in the smaller half, and the top of the min heap represents the smallest number in the larger half. This structure allows efficient retrieval of the median:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"If the heaps are balanced in size, the median is the average of the tops of both heaps.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the max heap has one more element than the min heap, the median is the top of the max heap.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The approach ensures that the heaps remain balanced after each insertion:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"A new number is first added to the max heap.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The largest number from the max heap is moved to the min heap to maintain order.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the min heap grows larger than the max heap, the smallest number from the min heap is moved back to the max heap.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"By using the heap property, the solution avoids the O(n log n) sorting step of the brute force approach, achieving O(log n) time complexity for insertion and median calculation.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two heaps:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"maxHeap\"}),\" for the smaller half of the numbers.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"minHeap\"}),\" for the larger half of the numbers.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define an \",(0,n.jsx)(e.code,{children:\"add\"}),\" method to insert a new number into the data stream:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Add the number to \",(0,n.jsx)(e.code,{children:\"maxHeap\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Move the largest number from \",(0,n.jsx)(e.code,{children:\"maxHeap\"}),\" to \",(0,n.jsx)(e.code,{children:\"minHeap\"}),\" to maintain order.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"minHeap\"}),\" grows larger than \",(0,n.jsx)(e.code,{children:\"maxHeap\"}),\", move the smallest number from \",(0,n.jsx)(e.code,{children:\"minHeap\"}),\" back to \",(0,n.jsx)(e.code,{children:\"maxHeap\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a \",(0,n.jsx)(e.code,{children:\"getMedian\"}),\" method to calculate the median:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"maxHeap\"}),\" has more elements than \",(0,n.jsx)(e.code,{children:\"minHeap\"}),\", return the top of \",(0,n.jsx)(e.code,{children:\"maxHeap\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Otherwise, return the average of the tops of both heaps.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use utility functions for heap operations:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"addNumberToHeap\"}),\" to insert a number while maintaining the heap property.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"removeTopFromHeap\"}),\" to remove the top element while restoring the heap property.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"heapify\"}),\" to ensure the heap property from a given index downward.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(h,{children:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Each insertion involves O(log n) time complexity to maintain the heap property.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The heaps together store all elements in the data stream.\"]}),`\n`]})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var A=O;return w(S);})();\n;return Component;"
}