{
  "description": "var Component=(()=>{var u=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var L=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},o=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!x.call(t,r)&&r!==i&&s(t,r,{get:()=>e[r],enumerable:!(l=f(e,r))||l.enumerable});return t};var b=(t,e,i)=>(i=t!=null?u(L(t)):{},o(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>o(s({},\"__esModule\",{value:!0}),t);var a=g((C,d)=>{d.exports=_jsx_runtime});var v={};w(v,{default:()=>j,frontmatter:()=>T});var n=b(a());var h=MDXTestExamples;var c=[{input:[[\"list\",[9,9,10,7,10,6,4,2,3,1]]],output:[9,1,9,3,10,2,7,4,10,6],explanation:\"The list is reordered to alternate between the start and end of the list.\"},{input:[[\"list\",[1,2,3,4,5,6]]],output:[1,6,2,5,3,4],explanation:\"The list is reordered to alternate between the start and end of the list.\"}];var T={title:\"Rearrange Linked List\",excerpt:\"Implement a function to rearrange the nodes in a linked list\"};function p(t){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the head of a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Linked_list\",children:\"linked list\"}),\", \",(0,n.jsx)(e.code,{children:\"head\"}),\", reorder the list to alternate between nodes from the start and the end of the list. The reordering should be performed by rearranging the nodes themselves, without modifying the values stored in the nodes.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The original structure is as follows:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"L0 \\u2192 L1 \\u2192 ... \\u2192 Ln-1 \\u2192 Ln\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Reorganize the list into this structure:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"L0 \\u2192 Ln \\u2192 L1 \\u2192 Ln-1 \\u2192 L2 \\u2192 Ln-2 \\u2192 \\u2026\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The linked list is represented by a sequence of \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\"s, where each node points to the next node in the sequence, or \",(0,n.jsx)(e.code,{children:\"null\"}),\" if it is the last node.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"head: ListNode\"}),\": Head of the linked list. Examples display each linked list as an array of values within the list\"]}),`\n`]}),`\n`,(0,n.jsx)(h,{testCases:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 1000\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"ListNode.val\"}),\" <= 1000\"]}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var j=_;return k(v);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to rearrange the nodes in a linked list",
    "title": "Rearrange Linked List"
  },
  "solution": "var Component=(()=>{var p=Object.create;var d=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var i in e)d(t,i,{get:e[i],enumerable:!0})},r=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of u(e))!v.call(t,l)&&l!==i&&d(t,l,{get:()=>e[l],enumerable:!(o=m(e,l))||o.enumerable});return t};var L=(t,e,i)=>(i=t!=null?p(g(t)):{},r(e||!t||!t.__esModule?d(i,\"default\",{value:t,enumerable:!0}):i,t)),T=t=>r(d({},\"__esModule\",{value:!0}),t);var h=w((j,c)=>{c.exports=_jsx_runtime});var y={};x(y,{default:()=>N});var n=L(h());var s=MDXCodeBlock;var a=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function rearrangeLinkedList(head: ListNode | null): void {\n  if (head === null) {\n    return;\n  }\n\n  let slow: ListNode | null = head;\n  let fast: ListNode | null = head;\n\n  // Locate the middle node of the linked list\n  // For example, in the list 1->2->3->4->5->6, the middle is 4\n  while (fast !== null && fast.next !== null) {\n    slow = slow!.next;\n    fast = fast.next.next;\n  }\n\n  // Reverse the second half of the list\n  // Transform 1->2->3->4->5->6 into 1->2->3->4 and 6->5->4 (reversed in-place)\n  let prev: ListNode | null = null;\n  let curr: ListNode | null = slow;\n  while (curr !== null) {\n    const tmp: ListNode | null = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = tmp;\n  }\n\n  // Merge the two halves of the list\n  // Combine 1->2->3->4 and 6->5->4 into 1->6->2->5->3->4\n  let first: ListNode | null = head;\n  let second: ListNode | null = prev;\n  while (second !== null && second.next !== null) {\n    const tmp1: ListNode | null = first!.next;\n    first!.next = second;\n    first = tmp1;\n\n    const tmp2: ListNode | null = second.next;\n    second.next = first;\n    second = tmp2;\n  }\n}\n`;function f(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Merge List with Reversed Sublist\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem involves rearranging a linked list such that nodes alternate between the first and second halves of the list. This approach uses a combination of three key steps: locating the middle of the list, reversing the second half of the list, and merging the two halves.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The middle of the linked list is determined using the two-pointer technique. The \",(0,n.jsx)(e.code,{children:\"slow\"}),\" pointer moves one step at a time, while the \",(0,n.jsx)(e.code,{children:\"fast\"}),\" pointer moves two steps. When the \",(0,n.jsx)(e.code,{children:\"fast\"}),\" pointer reaches the end, the \",(0,n.jsx)(e.code,{children:\"slow\"}),\" pointer is at the middle. This splits the list into two halves.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The second half of the list is reversed in place. This transforms the linked list into two parts: the first half in the original order and the second half in reversed order. Reversing is done to facilitate the alternating merge.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The two halves are merged by alternately selecting nodes from the first and reversed second halves. This rearranges the list in the desired alternating pattern.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach efficiently solves the problem in linear time and uses constant space for reordering nodes.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the \",(0,n.jsx)(e.code,{children:\"head\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\". If true, return immediately as there is nothing to rearrange.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two pointers, \",(0,n.jsx)(e.code,{children:\"slow\"}),\" and \",(0,n.jsx)(e.code,{children:\"fast\"}),\", both set to the \",(0,n.jsx)(e.code,{children:\"head\"}),\" of the linked list.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Locate the middle of the list:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Move \",(0,n.jsx)(e.code,{children:\"slow\"}),\" one step and \",(0,n.jsx)(e.code,{children:\"fast\"}),\" two steps at a time.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Stop when \",(0,n.jsx)(e.code,{children:\"fast\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\" or \",(0,n.jsx)(e.code,{children:\"fast.next\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\". The \",(0,n.jsx)(e.code,{children:\"slow\"}),\" pointer will now point to the middle node.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Reverse the second half of the list:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"prev\"}),\" to \",(0,n.jsx)(e.code,{children:\"null\"}),\" and \",(0,n.jsx)(e.code,{children:\"curr\"}),\" to \",(0,n.jsx)(e.code,{children:\"slow\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Traverse the list from \",(0,n.jsx)(e.code,{children:\"slow\"}),\" to the end:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Store the next node in a temporary variable \",(0,n.jsx)(e.code,{children:\"tmp\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"curr.next\"}),\" to point to \",(0,n.jsx)(e.code,{children:\"prev\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Move \",(0,n.jsx)(e.code,{children:\"prev\"}),\" to \",(0,n.jsx)(e.code,{children:\"curr\"}),\" and \",(0,n.jsx)(e.code,{children:\"curr\"}),\" to \",(0,n.jsx)(e.code,{children:\"tmp\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Merge the two halves of the list:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"first\"}),\" to the \",(0,n.jsx)(e.code,{children:\"head\"}),\" of the list and \",(0,n.jsx)(e.code,{children:\"second\"}),\" to \",(0,n.jsx)(e.code,{children:\"prev\"}),\" (head of the reversed second half).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Alternately link nodes from \",(0,n.jsx)(e.code,{children:\"first\"}),\" and \",(0,n.jsx)(e.code,{children:\"second\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Store the next node of \",(0,n.jsx)(e.code,{children:\"first\"}),\" in \",(0,n.jsx)(e.code,{children:\"tmp1\"}),\" and \",(0,n.jsx)(e.code,{children:\"second\"}),\" in \",(0,n.jsx)(e.code,{children:\"tmp2\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"first.next\"}),\" to point to \",(0,n.jsx)(e.code,{children:\"second\"}),\" and \",(0,n.jsx)(e.code,{children:\"second.next\"}),\" to point to \",(0,n.jsx)(e.code,{children:\"tmp1\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Move \",(0,n.jsx)(e.code,{children:\"first\"}),\" to \",(0,n.jsx)(e.code,{children:\"tmp1\"}),\" and \",(0,n.jsx)(e.code,{children:\"second\"}),\" to \",(0,n.jsx)(e.code,{children:\"tmp2\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(s,{children:a}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node is visited once during the three steps: finding the middle, reversing the second half, and merging.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of additional space.\"]}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var N=k;return T(y);})();\n;return Component;"
}