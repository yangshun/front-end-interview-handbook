{
  "description": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var L=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),N=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},d=(t,e,i,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!g.call(t,l)&&l!==i&&o(t,l,{get:()=>e[l],enumerable:!(s=f(e,l))||s.enumerable});return t};var k=(t,e,i)=>(i=t!=null?p(x(t)):{},d(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),D=t=>d(o({},\"__esModule\",{value:!0}),t);var h=L((C,r)=>{r.exports=_jsx_runtime});var b={};N(b,{default:()=>T,frontmatter:()=>j});var n=k(h());var a=MDXTestExamples;var c=[{input:[[\"list\",[1,2,3,4,5,6]],[\"n\",3]],output:[1,2,3,5,6],explanation:\"The 3rd node from the end is 4. Deleting it results in the list [1, 2, 3, 5, 6].\"},{input:[[\"list\",[8]],[\"n\",1]],output:[],explanation:\"The list contains only one node, which is the 1st from the end. Deleting it results in an empty list.\"},{input:[[\"list\",[9,7]],[\"n\",1]],output:[9],explanation:\"The 1st node from the end is 7. Deleting it results in the list [9].\"}];var j={title:\"Delete Nth Node from End of Linked List\",excerpt:\"Implement a function to delete the nth node from the end of a linked list\"};function u(t){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the head of a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Linked_list\",children:\"linked list\"}),\", delete the \",(0,n.jsx)(e.code,{children:\"n-th\"}),\" node from the end of the list and return the updated head.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The linked list is represented by a sequence of \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\"s, where each node points to the next node in the sequence, or \",(0,n.jsx)(e.code,{children:\"null\"}),\" if it is the last node.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"head: ListNode\"}),\": Head of the linked list. Examples display each linked list as an array of values within the list\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"n: number\"}),\": An integer indicating the position (from the end) of the node to delete\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{testCases:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 1000\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"ListNode.val\"}),\" <= 1000\"]}),`\n`]})]})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var T=w;return D(b);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to delete the nth node from the end of a linked list",
    "title": "Delete Nth Node from End of Linked List"
  },
  "solution": "var Component=(()=>{var p=Object.create;var d=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var i in e)d(n,i,{get:e[i],enumerable:!0})},s=(n,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!b.call(n,o)&&o!==i&&d(n,o,{get:()=>e[o],enumerable:!(r=u(e,o))||r.enumerable});return n};var w=(n,e,i)=>(i=n!=null?p(x(n)):{},s(e||!n||!n.__esModule?d(i,\"default\",{value:n,enumerable:!0}):i,n)),T=n=>s(d({},\"__esModule\",{value:!0}),n);var c=y((C,l)=>{l.exports=_jsx_runtime});var O={};v(O,{default:()=>k});var t=w(c());var h=MDXCodeBlock;var a=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function deleteNthNodeFromEnd(\n  head: ListNode | null,\n  n: number,\n): ListNode | null {\n  // Create a dummy node that points to the head of the list\n  let dummy: ListNode = { val: 0, next: head };\n\n  // Initialize a variable to keep track of the length of the list\n  let length: number = 0;\n  let first: ListNode | null = head;\n\n  // Traverse the list to calculate its length\n  while (first !== null) {\n    length++;\n    first = first.next;\n  }\n\n  // Calculate the position of the node just before the node to be removed\n  length -= n;\n  first = dummy;\n\n  // Traverse to the node just before the node to be removed\n  while (length > 0) {\n    length--;\n    first = first.next!;\n  }\n\n  // Remove the nth node from the end\n  first.next = first.next!.next;\n\n  // Return the modified list, starting from the node after the dummy\n  return dummy.next;\n}\n`;var m=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function removeNthFromEnd(\n  head: ListNode | null,\n  n: number,\n): ListNode | null {\n  // Create a dummy node that points to the head of the list\n  const dummy: ListNode = { val: 0, next: head };\n\n  // Initialize two pointers, both starting at the dummy node\n  let first: ListNode | null = dummy;\n  let second: ListNode | null = dummy;\n\n  // Advance the first pointer so that there is a gap of n nodes between the first and second pointers\n  for (let i = 0; i <= n; i++) {\n    if (first !== null) {\n      first = first.next;\n    }\n  }\n\n  // Move both pointers until the first pointer reaches the end of the list\n  // This maintains the gap between the two pointers\n  while (first !== null) {\n    first = first.next;\n    second = second!.next;\n  }\n\n  // Remove the nth node from the end by skipping the node after the second pointer\n  if (second !== null && second.next !== null) {\n    second.next = second.next.next;\n  }\n\n  // Return the head of the modified list, which is the node after the dummy node\n  return dummy.next;\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Two-Pass\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The two-pass approach for deleting the \",(0,t.jsx)(e.code,{children:\"n\"}),\"th node from the end of a linked list breaks the problem into two clear steps. The first pass determines the total length of the linked list, and the second pass identifies and removes the target node. The use of a dummy node simplifies edge cases, such as when the head of the list needs to be removed.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"By traversing the list in the first pass, the total length of the linked list is calculated. This step ensures the position of the \",(0,t.jsx)(e.code,{children:\"n\"}),\"th node from the end can be computed as \",(0,t.jsx)(e.code,{children:\"(length - n)\"}),\" from the beginning of the list.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Using the calculated position, the second pass stops at the node just before the target node. This is crucial because removing a node in a linked list requires access to the previous node.\"}),`\n`,(0,t.jsx)(e.p,{children:\"A dummy node is added at the beginning of the list to handle cases where the head node is removed. This ensures the logic remains consistent regardless of the node's position in the list.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Once the node just before the target is located, the target node is bypassed by updating the \",(0,t.jsx)(e.code,{children:\"next\"}),\" pointer of its predecessor. This operation ensures the list remains intact and properly linked after the removal.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This approach is straightforward and ensures the problem is solved efficiently while minimizing complexity.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Create a \",(0,t.jsx)(e.code,{children:\"dummy\"}),\" node with its \",(0,t.jsx)(e.code,{children:\"next\"}),\" pointer set to the head of the list.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize a variable \",(0,t.jsx)(e.code,{children:\"length\"}),\" to 0 and set \",(0,t.jsx)(e.code,{children:\"first\"}),\" to the head of the list.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Traverse the list to compute the total length:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Increment \",(0,t.jsx)(e.code,{children:\"length\"}),\" for each node encountered.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move \",(0,t.jsx)(e.code,{children:\"first\"}),\" to the next node until the end of the list is reached.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Subtract \",(0,t.jsx)(e.code,{children:\"n\"}),\" from \",(0,t.jsx)(e.code,{children:\"length\"}),\" to calculate the position of the node just before the target node.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Reset \",(0,t.jsx)(e.code,{children:\"first\"}),\" to the \",(0,t.jsx)(e.code,{children:\"dummy\"}),\" node.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Traverse the list again until the position of the node just before the target node is reached:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Decrement \",(0,t.jsx)(e.code,{children:\"length\"}),\" at each step.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move \",(0,t.jsx)(e.code,{children:\"first\"}),\" to the next node.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Update the \",(0,t.jsx)(e.code,{children:\"next\"}),\" pointer of \",(0,t.jsx)(e.code,{children:\"first\"}),\" to bypass the target node by pointing to \",(0,t.jsx)(e.code,{children:\"first.next.next\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"dummy.next\"}),\" as the head of the modified list.\"]}),`\n`]}),`\n`,(0,t.jsx)(h,{children:a}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The list is traversed twice, once to compute its length and once to locate the target node's predecessor.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of additional space.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using One-Pass\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The one-pass approach for removing the \",(0,t.jsx)(e.code,{children:\"n\"}),\"th node from the end of a linked list optimizes traversal by using two pointers. Instead of calculating the total length of the list, this method ensures that both pointers traverse the list in a single iteration, maintaining a fixed gap between them.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The algorithm uses two pointers, \",(0,t.jsx)(e.code,{children:\"first\"}),\" and \",(0,t.jsx)(e.code,{children:\"second\"}),\", both starting at the \",(0,t.jsx)(e.code,{children:\"dummy\"}),\" node. By advancing the \",(0,t.jsx)(e.code,{children:\"first\"}),\" pointer by \",(0,t.jsx)(e.code,{children:\"n + 1\"}),\" steps, a gap of \",(0,t.jsx)(e.code,{children:\"n\"}),\" nodes is created between \",(0,t.jsx)(e.code,{children:\"first\"}),\" and \",(0,t.jsx)(e.code,{children:\"second\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Once the gap is established, both pointers are moved simultaneously until \",(0,t.jsx)(e.code,{children:\"first\"}),\" reaches the end of the list. At this point, the \",(0,t.jsx)(e.code,{children:\"second\"}),\" pointer is positioned just before the node to be removed.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Using the \",(0,t.jsx)(e.code,{children:\"second\"}),\" pointer, the target node is skipped by updating \",(0,t.jsx)(e.code,{children:\"second.next\"}),\" to \",(0,t.jsx)(e.code,{children:\"second.next.next\"}),\". This ensures that the list remains intact and properly linked after the removal.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.code,{children:\"dummy\"}),\" node is added at the start of the list to handle cases where the head node is removed. This eliminates the need for special handling of edge cases and simplifies the logic.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This one-pass approach is efficient because it minimizes the number of iterations and maintains linear time complexity.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Create a \",(0,t.jsx)(e.code,{children:\"dummy\"}),\" node with its \",(0,t.jsx)(e.code,{children:\"next\"}),\" pointer set to the head of the list.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize two pointers, \",(0,t.jsx)(e.code,{children:\"first\"}),\" and \",(0,t.jsx)(e.code,{children:\"second\"}),\", both pointing to the \",(0,t.jsx)(e.code,{children:\"dummy\"}),\" node.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Advance the \",(0,t.jsx)(e.code,{children:\"first\"}),\" pointer by \",(0,t.jsx)(e.code,{children:\"n + 1\"}),\" steps to create a gap of \",(0,t.jsx)(e.code,{children:\"n\"}),\" nodes between \",(0,t.jsx)(e.code,{children:\"first\"}),\" and \",(0,t.jsx)(e.code,{children:\"second\"}),\":\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If \",(0,t.jsx)(e.code,{children:\"first\"}),\" is not \",(0,t.jsx)(e.code,{children:\"null\"}),\", move it to the next node for each step.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move both \",(0,t.jsx)(e.code,{children:\"first\"}),\" and \",(0,t.jsx)(e.code,{children:\"second\"}),\" pointers one step at a time until \",(0,t.jsx)(e.code,{children:\"first\"}),\" reaches the end of the list:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Move \",(0,t.jsx)(e.code,{children:\"first\"}),\" to \",(0,t.jsx)(e.code,{children:\"first.next\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Move \",(0,t.jsx)(e.code,{children:\"second\"}),\" to \",(0,t.jsx)(e.code,{children:\"second.next\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Remove the \",(0,t.jsx)(e.code,{children:\"n\"}),\"th node from the end by updating \",(0,t.jsx)(e.code,{children:\"second.next\"}),\" to \",(0,t.jsx)(e.code,{children:\"second.next.next\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"dummy.next\"}),\", which points to the head of the modified list.\"]}),`\n`]}),`\n`,(0,t.jsx)(h,{children:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The list is traversed once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of additional space.\"]}),`\n`]})]})}function j(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var k=j;return T(O);})();\n;return Component;"
}