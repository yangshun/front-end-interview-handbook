{
  "description": "var Component=(()=>{var l=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var u=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),F=(t,e)=>{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},h=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of g(e))!m.call(t,r)&&r!==i&&a(t,r,{get:()=>e[r],enumerable:!(o=p(e,r))||o.enumerable});return t};var D=(t,e,i)=>(i=t!=null?l(f(t)):{},h(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),v=t=>h(a({},\"__esModule\",{value:!0}),t);var c=u((E,s)=>{s.exports=_jsx_runtime});var w={};F(w,{default:()=>k,frontmatter:()=>y});var n=D(c()),y={title:\"Depth-first Search\",excerpt:\"Implement a depth-first search algorithm that traverses a directed graph in a depth-first manner\"};function d(t){let e=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",ol:\"ol\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Write a function that implements the depth-first search algorithm on a directed graph (in adjacency list format), given a starting node.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const graph1 = {\n  A: ['B', 'C', 'D'],\n  B: ['E', 'F'],\n  C: ['G', 'H'],\n  D: ['I', 'J'],\n  E: ['D'],\n  F: [],\n  G: [],\n  H: [],\n  I: [],\n  J: [],\n};\ndepthFirstSearch(graph1, 'A'); // ['A', 'B', 'E', 'D', 'I', 'J', 'F', 'C', 'G', 'H']\ndepthFirstSearch(graph1, 'B'); // ['B', 'E', 'D', 'I', 'J', 'F']\n\nconst graph2 = {\n  A: ['B', 'C'],\n  B: ['D', 'E'],\n  C: ['F', 'G'],\n  D: [],\n  E: [],\n  F: [],\n  G: [],\n};\ndepthFirstSearch(graph2, 'A'); // ['A', 'B', 'D', 'E', 'C', 'F', 'G']\ndepthFirstSearch(graph2, 'E'); // ['E']\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Recap (Hint)\"}),`\n`,(0,n.jsx)(e.p,{children:\"Depth-first search (DFS) is an algorithm used for traversing a graph or a tree. The output from DFS is an array of the graph's nodes in the order they were traversed. This output is useful for a variety of different use cases and purposes, which makes DFS a useful algorithm to know. Some use cases:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Find a specific node or group of nodes. This is common in front end to find specific DOM node(s) within the DOM tree.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Checking if a graph is connected.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Finding a path between two nodes in a graph.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Generating a topological sort of a directed acyclic graph (DAG).\"}),`\n`,(0,n.jsx)(e.li,{children:\"Identifying cycles in a graph.\"}),`\n`,(0,n.jsx)(e.li,{children:\"As a building block for other algorithms.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Here is an overview of how DFS works to traverse a graph, using the standard implementation that takes in an adjacency list (we use an array instead) and the root node:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Initialize an array or a stack to store nodes to be visited. Push root node.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Initialize a set to track visited nodes.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Enter a loop that continues until the stack is empty. In each iteration of the loop:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Pop the top node from the array / stack.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Retrieve the neighbors of the node from the input graph.\"}),`\n`,(0,n.jsx)(e.li,{children:\"For each neighbor, check if it has been visited. If it has not been visited, add it to the set of nodes to be visited.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the set of visited nodes.\"}),`\n`]})]})}function b(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var k=b;return v(w);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a depth-first search algorithm that traverses a directed graph in a depth-first manner",
    "title": "Depth-first Search"
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},d=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of m(e))!y.call(t,n)&&n!==i&&o(t,n,{get:()=>e[n],enumerable:!(a=v(e,n))||a.enumerable});return t};var S=(t,e,i)=>(i=t!=null?f(b(t)):{},d(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>d(o({},\"__esModule\",{value:!0}),t);var c=w((C,h)=>{h.exports=_jsx_runtime});var A={};j(A,{default:()=>V});var r=S(c());var s=MDXCodeBlock;var l=`/**\n * @param {Record<string, Array<string>} graph The adjacency list representing the graph.\n * @param {string} source The source node to start traversal from. Has to be a valid node if graph is non-empty.\n * @return {string[]} A DFS-traversed order of nodes.\n */\nexport default function depthFirstSearch(graph, source) {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Create an stack to store the nodes to be visited. We can simulate\n  // stacks using arrays in JavaScript.\n  // Add the root node since we're doing a pre-order DFS.\n  const toBeVisited = [];\n  toBeVisited.push(source);\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set();\n\n  // Loop as long as array is empty (i.e. there are still nodes to be visited).\n  while (toBeVisited.length !== 0) {\n    // Pop top node from array (toBeVisited) and add it to the set (visited).\n    const node = toBeVisited.pop();\n    visited.add(node);\n\n    // Retrieve neighbors (values of the adjacency list input Object)\n    const neighbors = graph[node];\n    // Push neighbors, in reverse order, onto array to be visited\n    // to preserve original order of neighbors when visiting (popping off the array).\n    for (let i = neighbors.length - 1; i >= 0; i--) {\n      const neighbor = neighbors[i];\n      // First check if the neighbor has already been visited before adding it.\n      if (!visited.has(neighbor)) {\n        toBeVisited.push(neighbor);\n      }\n    }\n  }\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n`;var p=`export default function depthFirstSearch(\n  graph: Record<string, Array<string>>,\n  source: string,\n): Array<string> {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Create an stack to store the nodes to be visited. We can simulate\n  // stacks using arrays in JavaScript.\n  // Add the root node since we're doing a pre-order DFS.\n  const toBeVisited: Array<string> = [];\n  toBeVisited.push(source);\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set<string>();\n\n  // Loop as long as array is empty (i.e. there are still nodes to be visited).\n  while (toBeVisited.length !== 0) {\n    // Pop top node from array (toBeVisited) and add it to the set (visited).\n    const node = toBeVisited.pop()!;\n    visited.add(node);\n\n    // Retrieve neighbors (values of the adjacency list input Object)\n    const neighbors = graph[node];\n    // Push neighbors, in reverse order, onto array to be visited\n    // to preserve original order of neighbors when visiting (popping off the array).\n    for (let i = neighbors.length - 1; i >= 0; i--) {\n      const neighbor = neighbors[i];\n      // First check if the neighbor has already been visited before adding it.\n      if (!visited.has(neighbor)) {\n        toBeVisited.push(neighbor);\n      }\n    }\n  }\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n`;var g=`/**\n * @param {Object} graph Node to array of neighboring nodes.\n * @param {string} source Source node to start traversal from. Has to be a valid node if graph is non-empty.\n * @return {string[]} A DFS-traversed order of nodes.\n */\nexport default function depthFirstSearch(graph, source) {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set();\n\n  function traverse(node) {\n    // Visited before, we can ignore.\n    if (visited.has(node)) {\n      return;\n    }\n\n    visited.add(node);\n    // Recursively visit each neighbor.\n    graph[node].forEach((neighbor) => {\n      traverse(neighbor);\n    });\n  }\n\n  // Start traversing from the source.\n  traverse(source);\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n`;function u(t){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,r.jsx)(e.p,{children:\"If unspecified:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Order of traversal: Should we use a standard pre-order traversal or other orders of traversal?\"}),`\n`,(0,r.jsx)(e.li,{children:\"Input format: What is the format of the input data? Can we assume the input will be an adjacency list in the form of a JavaScript Object where keys are nodes and values are child nodes?\"}),`\n`,(0,r.jsx)(e.li,{children:\"Output format: How should the output be formatted? Are there specific requirements or can we return an array with elements in the order of traversal?\"}),`\n`,(0,r.jsx)(e.li,{children:\"Disconnected graphs: Do we have to consider or handle the case for disconnected graphs where there are multiple subgraphs that are not connected to each other?\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsx)(e.p,{children:\"The solution implements the algorithm outlined in the description.\"}),`\n`,(0,r.jsx)(s,{languages:{jsx:l,tsx:p}}),`\n`,(0,r.jsx)(e.p,{children:\"We can also perform DFS recursively, which is can be more intuitive in certain cases. The recursion call stack is an implicit stack to track which nodes to visit next.\"}),`\n`,(0,r.jsx)(s,{children:g}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Empty graphs: Return an empty array without crashing.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Graphs with only one-two nodes: Traverse without crashing.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Cyclic graphs: Make sure not to traverse visited nodes again.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Disjoint graphs: Doesn't require special handling but good to be aware of.\"}),`\n`]})]})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(u,t)})):u(t)}var V=D;return k(A);})();\n;return Component;"
}