{
  "description": "var Component=(()=>{var l=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var u=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),F=(t,e)=>{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},h=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of g(e))!m.call(t,r)&&r!==i&&a(t,r,{get:()=>e[r],enumerable:!(o=p(e,r))||o.enumerable});return t};var D=(t,e,i)=>(i=t!=null?l(f(t)):{},h(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),v=t=>h(a({},\"__esModule\",{value:!0}),t);var c=u((E,s)=>{s.exports=_jsx_runtime});var w={};F(w,{default:()=>k,frontmatter:()=>y});var n=D(c()),y={title:\"Depth-first Search\",excerpt:\"Implement a depth-first search algorithm that traverses a directed graph in a depth-first manner\"};function d(t){let e=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",ol:\"ol\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Write a function that implements the depth-first search algorithm on a directed graph (in adjacency list format), given a starting node.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const graph1 = {\n  A: ['B', 'C', 'D'],\n  B: ['E', 'F'],\n  C: ['G', 'H'],\n  D: ['I', 'J'],\n  E: ['D'],\n  F: [],\n  G: [],\n  H: [],\n  I: [],\n  J: [],\n};\ndepthFirstSearch(graph1, 'A'); // ['A', 'B', 'E', 'D', 'I', 'J', 'F', 'C', 'G', 'H']\ndepthFirstSearch(graph1, 'B'); // ['B', 'E', 'D', 'I', 'J', 'F']\n\nconst graph2 = {\n  A: ['B', 'C'],\n  B: ['D', 'E'],\n  C: ['F', 'G'],\n  D: [],\n  E: [],\n  F: [],\n  G: [],\n};\ndepthFirstSearch(graph2, 'A'); // ['A', 'B', 'D', 'E', 'C', 'F', 'G']\ndepthFirstSearch(graph2, 'E'); // ['E']\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Recap (Hint)\"}),`\n`,(0,n.jsx)(e.p,{children:\"Depth-first search (DFS) is an algorithm used for traversing a graph or a tree. The output from DFS is an array of the graph's nodes in the order they were traversed. This output is useful for a variety of different use cases and purposes, which makes DFS a useful algorithm to know. Some use cases:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Find a specific node or group of nodes. This is common in front end to find specific DOM node(s) within the DOM tree.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Checking if a graph is connected.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Finding a path between two nodes in a graph.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Generating a topological sort of a directed acyclic graph (DAG).\"}),`\n`,(0,n.jsx)(e.li,{children:\"Identifying cycles in a graph.\"}),`\n`,(0,n.jsx)(e.li,{children:\"As a building block for other algorithms.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Here is an overview of how DFS works to traverse a graph, using the standard implementation that takes in an adjacency list (we use an array instead) and the root node:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Initialize an array or a stack to store nodes to be visited. Push root node.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Initialize a set to track visited nodes.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Enter a loop that continues until the stack is empty. In each iteration of the loop:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Pop the top node from the array / stack.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Retrieve the neighbors of the node from the input graph.\"}),`\n`,(0,n.jsx)(e.li,{children:\"For each neighbor, check if it has been visited. If it has not been visited, add it to the set of nodes to be visited.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the set of visited nodes.\"}),`\n`]})]})}function b(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var k=b;return v(w);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/depth-first-search\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/depth-first-search.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/depth-first-search.run.test.ts": "import depthFirstSearch from './depth-first-search';\n\ndescribe('depthFirstSearch', () => {\n  test('empty graph', () => {\n    expect(depthFirstSearch({}, 'A')).toEqual([]);\n  });\n\n  test('graphs with one node', () => {\n    expect(depthFirstSearch({ A: [] }, 'A')).toEqual(['A']);\n  });\n\n  test('graphs with two nodes', () => {\n    expect(depthFirstSearch({ A: ['B'], B: [] }, 'A')).toEqual(['A', 'B']);\n  });\n});\n",
    "/src/depth-first-search.submit.test.ts": "import depthFirstSearch from './depth-first-search';\n\ndescribe('depthFirstSearch', () => {\n  test('empty graph', () => {\n    expect(depthFirstSearch({}, 'A')).toEqual([]);\n  });\n\n  test('graphs with one node', () => {\n    expect(depthFirstSearch({ A: [] }, 'A')).toEqual(['A']);\n  });\n\n  test('graphs with two nodes', () => {\n    expect(depthFirstSearch({ A: ['B'], B: [] }, 'A')).toEqual(['A', 'B']);\n    expect(depthFirstSearch({ A: ['A', 'B'], B: [] }, 'A')).toEqual(['A', 'B']);\n    expect(depthFirstSearch({ A: ['A', 'B'], B: [] }, 'B')).toEqual(['B']);\n    expect(depthFirstSearch({ A: ['A', 'B'], B: ['A'] }, 'B')).toEqual([\n      'B',\n      'A',\n    ]);\n  });\n\n  test('graphs with multiple nodes', () => {\n    expect(depthFirstSearch({ A: ['B'], B: ['C'], C: [] }, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(depthFirstSearch({ A: ['B', 'C'], B: [], C: [] }, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(\n      depthFirstSearch(\n        { A: ['B', 'C'], B: [], C: [], D: ['B'], E: ['C'] },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'C']);\n    expect(\n      depthFirstSearch(\n        { A: ['D', 'E'], B: [], C: [], D: ['B'], E: ['C'] },\n        'A',\n      ),\n    ).toEqual(['A', 'D', 'B', 'E', 'C']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['D', 'E'],\n          B: ['A', 'B', 'C', 'D', 'E'],\n          C: [],\n          D: ['B'],\n          E: ['C'],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'D', 'B', 'C', 'E']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['A', 'B', 'C', 'D', 'E'],\n          B: [],\n          C: [],\n          D: ['B'],\n          E: ['C'],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'C', 'D', 'E']);\n    // Graph taken from https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/\n    const graph = {\n      A: ['B', 'C'],\n      B: ['A', 'D', 'E'],\n      C: ['A', 'E'],\n      D: ['B', 'E', 'F'],\n      E: ['B', 'C', 'D', 'F'],\n      F: ['D', 'E'],\n    };\n    expect(depthFirstSearch(graph, 'A')).toEqual([\n      'A',\n      'B',\n      'D',\n      'E',\n      'C',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'B')).toEqual([\n      'B',\n      'A',\n      'C',\n      'E',\n      'D',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'C')).toEqual([\n      'C',\n      'A',\n      'B',\n      'D',\n      'E',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'D')).toEqual([\n      'D',\n      'B',\n      'A',\n      'C',\n      'E',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'E')).toEqual([\n      'E',\n      'B',\n      'A',\n      'C',\n      'D',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'F')).toEqual([\n      'F',\n      'D',\n      'B',\n      'A',\n      'C',\n      'E',\n    ]);\n  });\n\n  test('disjoint graphs', () => {\n    expect(depthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'A')).toEqual(\n      ['A', 'B'],\n    );\n    expect(depthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'C')).toEqual(\n      ['C'],\n    );\n    expect(depthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'D')).toEqual(\n      ['D', 'C'],\n    );\n  });\n\n  test('cyclic graphs', () => {\n    expect(depthFirstSearch({ A: ['A'] }, 'A')).toEqual(['A']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['B', 'C', 'D'],\n          B: ['E', 'F'],\n          C: ['G', 'H'],\n          D: ['I', 'J'],\n          E: ['D'],\n          F: [],\n          G: [],\n          H: [],\n          I: [],\n          J: [],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'E', 'D', 'I', 'J', 'F', 'C', 'G', 'H']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['B', 'C', 'D'],\n          B: ['E', 'F'],\n          C: ['G', 'H'],\n          D: ['I', 'J'],\n          E: ['D'],\n          F: [],\n          G: [],\n          H: [],\n          I: [],\n          J: [],\n        },\n        'B',\n      ),\n    ).toEqual(['B', 'E', 'D', 'I', 'J', 'F']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['B', 'C'],\n          B: ['D', 'E'],\n          C: ['F', 'G'],\n          D: [],\n          E: [],\n          F: [],\n          G: [],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'D', 'E', 'C', 'F', 'G']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['B', 'C'],\n          B: ['D', 'E'],\n          C: ['F', 'G'],\n          D: [],\n          E: [],\n          F: [],\n          G: [],\n        },\n        'E',\n      ),\n    ).toEqual(['E']);\n  });\n});\n",
    "/src/depth-first-search.ts": "export default function depthFirstSearch(\n  graph: Record<string, Array<string>>,\n  source: string,\n): Array<string> {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Create an stack to store the nodes to be visited. We can simulate\n  // stacks using arrays in JavaScript.\n  // Add the root node since we're doing a pre-order DFS.\n  const toBeVisited: Array<string> = [];\n  toBeVisited.push(source);\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set<string>();\n\n  // Loop as long as array is empty (i.e. there are still nodes to be visited).\n  while (toBeVisited.length !== 0) {\n    // Pop top node from array (toBeVisited) and add it to the set (visited).\n    const node = toBeVisited.pop()!;\n    visited.add(node);\n\n    // Retrieve neighbors (values of the adjacency list input Object)\n    const neighbors = graph[node];\n    // Push neighbors, in reverse order, onto array to be visited\n    // to preserve original order of neighbors when visiting (popping off the array).\n    for (let i = neighbors.length - 1; i >= 0; i--) {\n      const neighbor = neighbors[i];\n      // First check if the neighbor has already been visited before adding it.\n      if (!visited.has(neighbor)) {\n        toBeVisited.push(neighbor);\n      }\n    }\n  }\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n"
  },
  "format": "algo",
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1671667200,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a depth-first search algorithm that traverses a directed graph in a depth-first manner",
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/depth-first-search",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "breadth-first-search"
    ],
    "slug": "depth-first-search",
    "subtitle": null,
    "title": "Depth-first Search",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {Record<string, Array<string>} graph The adjacency list representing the graph.\n * @param {string} source The source node to start traversal from. It has to exist as a node in the graph.\n * @return {Array<string>} A DFS-traversed order of nodes.\n */\nexport default function depthFirstSearch(graph, source) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function depthFirstSearch(\n  graph: Record<string, Array<string>>,\n  source: string,\n): Array<string> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},d=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of m(e))!y.call(t,n)&&n!==i&&o(t,n,{get:()=>e[n],enumerable:!(a=v(e,n))||a.enumerable});return t};var S=(t,e,i)=>(i=t!=null?f(b(t)):{},d(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),k=t=>d(o({},\"__esModule\",{value:!0}),t);var c=w((C,h)=>{h.exports=_jsx_runtime});var A={};j(A,{default:()=>V});var r=S(c());var s=MDXCodeBlock;var l=`/**\n * @param {Record<string, Array<string>} graph The adjacency list representing the graph.\n * @param {string} source The source node to start traversal from. Has to be a valid node if graph is non-empty.\n * @return {string[]} A DFS-traversed order of nodes.\n */\nexport default function depthFirstSearch(graph, source) {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Create an stack to store the nodes to be visited. We can simulate\n  // stacks using arrays in JavaScript.\n  // Add the root node since we're doing a pre-order DFS.\n  const toBeVisited = [];\n  toBeVisited.push(source);\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set();\n\n  // Loop as long as array is empty (i.e. there are still nodes to be visited).\n  while (toBeVisited.length !== 0) {\n    // Pop top node from array (toBeVisited) and add it to the set (visited).\n    const node = toBeVisited.pop();\n    visited.add(node);\n\n    // Retrieve neighbors (values of the adjacency list input Object)\n    const neighbors = graph[node];\n    // Push neighbors, in reverse order, onto array to be visited\n    // to preserve original order of neighbors when visiting (popping off the array).\n    for (let i = neighbors.length - 1; i >= 0; i--) {\n      const neighbor = neighbors[i];\n      // First check if the neighbor has already been visited before adding it.\n      if (!visited.has(neighbor)) {\n        toBeVisited.push(neighbor);\n      }\n    }\n  }\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n`;var p=`export default function depthFirstSearch(\n  graph: Record<string, Array<string>>,\n  source: string,\n): Array<string> {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Create an stack to store the nodes to be visited. We can simulate\n  // stacks using arrays in JavaScript.\n  // Add the root node since we're doing a pre-order DFS.\n  const toBeVisited: Array<string> = [];\n  toBeVisited.push(source);\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set<string>();\n\n  // Loop as long as array is empty (i.e. there are still nodes to be visited).\n  while (toBeVisited.length !== 0) {\n    // Pop top node from array (toBeVisited) and add it to the set (visited).\n    const node = toBeVisited.pop()!;\n    visited.add(node);\n\n    // Retrieve neighbors (values of the adjacency list input Object)\n    const neighbors = graph[node];\n    // Push neighbors, in reverse order, onto array to be visited\n    // to preserve original order of neighbors when visiting (popping off the array).\n    for (let i = neighbors.length - 1; i >= 0; i--) {\n      const neighbor = neighbors[i];\n      // First check if the neighbor has already been visited before adding it.\n      if (!visited.has(neighbor)) {\n        toBeVisited.push(neighbor);\n      }\n    }\n  }\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n`;var g=`/**\n * @param {Object} graph Node to array of neighboring nodes.\n * @param {string} source Source node to start traversal from. Has to be a valid node if graph is non-empty.\n * @return {string[]} A DFS-traversed order of nodes.\n */\nexport default function depthFirstSearch(graph, source) {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set();\n\n  function traverse(node) {\n    // Visited before, we can ignore.\n    if (visited.has(node)) {\n      return;\n    }\n\n    visited.add(node);\n    // Recursively visit each neighbor.\n    graph[node].forEach((neighbor) => {\n      traverse(neighbor);\n    });\n  }\n\n  // Start traversing from the source.\n  traverse(source);\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n`;function u(t){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"Clarification Questions\"}),`\n`,(0,r.jsx)(e.p,{children:\"If unspecified:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Order of traversal: Should we use a standard pre-order traversal or other orders of traversal?\"}),`\n`,(0,r.jsx)(e.li,{children:\"Input format: What is the format of the input data? Can we assume the input will be an adjacency list in the form of a JavaScript Object where keys are nodes and values are child nodes?\"}),`\n`,(0,r.jsx)(e.li,{children:\"Output format: How should the output be formatted? Are there specific requirements or can we return an array with elements in the order of traversal?\"}),`\n`,(0,r.jsx)(e.li,{children:\"Disconnected graphs: Do we have to consider or handle the case for disconnected graphs where there are multiple subgraphs that are not connected to each other?\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsx)(e.p,{children:\"The solution implements the algorithm outlined in the description.\"}),`\n`,(0,r.jsx)(s,{languages:{jsx:l,tsx:p}}),`\n`,(0,r.jsx)(e.p,{children:\"We can also perform DFS recursively, which is can be more intuitive in certain cases. The recursion call stack is an implicit stack to track which nodes to visit next.\"}),`\n`,(0,r.jsx)(s,{children:g}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Empty graphs: Return an empty array without crashing.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Graphs with only one-two nodes: Traverse without crashing.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Cyclic graphs: Make sure not to traverse visited nodes again.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Disjoint graphs: Doesn't require special handling but good to be aware of.\"}),`\n`]})]})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(u,t)})):u(t)}var V=D;return k(A);})();\n;return Component;",
  "workspace": {
    "main": "/src/depth-first-search.ts",
    "run": "/src/depth-first-search.run.test.ts",
    "submit": "/src/depth-first-search.submit.test.ts"
  }
}