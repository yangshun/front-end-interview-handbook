{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/depth-first-search\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/depth-first-search.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/depth-first-search.run.test.ts": "import depthFirstSearch from './depth-first-search';\n\ndescribe('depthFirstSearch', () => {\n  test('empty graph', () => {\n    expect(depthFirstSearch({}, 'A')).toEqual([]);\n  });\n\n  test('graphs with one node', () => {\n    expect(depthFirstSearch({ A: [] }, 'A')).toEqual(['A']);\n  });\n\n  test('graphs with two nodes', () => {\n    expect(depthFirstSearch({ A: ['B'], B: [] }, 'A')).toEqual(['A', 'B']);\n  });\n});\n",
    "/src/depth-first-search.submit.test.ts": "import depthFirstSearch from './depth-first-search';\n\ndescribe('depthFirstSearch', () => {\n  test('empty graph', () => {\n    expect(depthFirstSearch({}, 'A')).toEqual([]);\n  });\n\n  test('graphs with one node', () => {\n    expect(depthFirstSearch({ A: [] }, 'A')).toEqual(['A']);\n  });\n\n  test('graphs with two nodes', () => {\n    expect(depthFirstSearch({ A: ['B'], B: [] }, 'A')).toEqual(['A', 'B']);\n    expect(depthFirstSearch({ A: ['A', 'B'], B: [] }, 'A')).toEqual(['A', 'B']);\n    expect(depthFirstSearch({ A: ['A', 'B'], B: [] }, 'B')).toEqual(['B']);\n    expect(depthFirstSearch({ A: ['A', 'B'], B: ['A'] }, 'B')).toEqual([\n      'B',\n      'A',\n    ]);\n  });\n\n  test('graphs with multiple nodes', () => {\n    expect(depthFirstSearch({ A: ['B'], B: ['C'], C: [] }, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(depthFirstSearch({ A: ['B', 'C'], B: [], C: [] }, 'A')).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(\n      depthFirstSearch(\n        { A: ['B', 'C'], B: [], C: [], D: ['B'], E: ['C'] },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'C']);\n    expect(\n      depthFirstSearch(\n        { A: ['D', 'E'], B: [], C: [], D: ['B'], E: ['C'] },\n        'A',\n      ),\n    ).toEqual(['A', 'D', 'B', 'E', 'C']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['D', 'E'],\n          B: ['A', 'B', 'C', 'D', 'E'],\n          C: [],\n          D: ['B'],\n          E: ['C'],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'D', 'B', 'C', 'E']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['A', 'B', 'C', 'D', 'E'],\n          B: [],\n          C: [],\n          D: ['B'],\n          E: ['C'],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'C', 'D', 'E']);\n    // Graph taken from https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/\n    const graph = {\n      A: ['B', 'C'],\n      B: ['A', 'D', 'E'],\n      C: ['A', 'E'],\n      D: ['B', 'E', 'F'],\n      E: ['B', 'C', 'D', 'F'],\n      F: ['D', 'E'],\n    };\n    expect(depthFirstSearch(graph, 'A')).toEqual([\n      'A',\n      'B',\n      'D',\n      'E',\n      'C',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'B')).toEqual([\n      'B',\n      'A',\n      'C',\n      'E',\n      'D',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'C')).toEqual([\n      'C',\n      'A',\n      'B',\n      'D',\n      'E',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'D')).toEqual([\n      'D',\n      'B',\n      'A',\n      'C',\n      'E',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'E')).toEqual([\n      'E',\n      'B',\n      'A',\n      'C',\n      'D',\n      'F',\n    ]);\n    expect(depthFirstSearch(graph, 'F')).toEqual([\n      'F',\n      'D',\n      'B',\n      'A',\n      'C',\n      'E',\n    ]);\n  });\n\n  test('disjoint graphs', () => {\n    expect(depthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'A')).toEqual(\n      ['A', 'B'],\n    );\n    expect(depthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'C')).toEqual(\n      ['C'],\n    );\n    expect(depthFirstSearch({ A: ['B'], B: [], C: [], D: ['C'] }, 'D')).toEqual(\n      ['D', 'C'],\n    );\n  });\n\n  test('cyclic graphs', () => {\n    expect(depthFirstSearch({ A: ['A'] }, 'A')).toEqual(['A']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['B', 'C', 'D'],\n          B: ['E', 'F'],\n          C: ['G', 'H'],\n          D: ['I', 'J'],\n          E: ['D'],\n          F: [],\n          G: [],\n          H: [],\n          I: [],\n          J: [],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'E', 'D', 'I', 'J', 'F', 'C', 'G', 'H']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['B', 'C', 'D'],\n          B: ['E', 'F'],\n          C: ['G', 'H'],\n          D: ['I', 'J'],\n          E: ['D'],\n          F: [],\n          G: [],\n          H: [],\n          I: [],\n          J: [],\n        },\n        'B',\n      ),\n    ).toEqual(['B', 'E', 'D', 'I', 'J', 'F']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['B', 'C'],\n          B: ['D', 'E'],\n          C: ['F', 'G'],\n          D: [],\n          E: [],\n          F: [],\n          G: [],\n        },\n        'A',\n      ),\n    ).toEqual(['A', 'B', 'D', 'E', 'C', 'F', 'G']);\n    expect(\n      depthFirstSearch(\n        {\n          A: ['B', 'C'],\n          B: ['D', 'E'],\n          C: ['F', 'G'],\n          D: [],\n          E: [],\n          F: [],\n          G: [],\n        },\n        'E',\n      ),\n    ).toEqual(['E']);\n  });\n});\n",
    "/src/depth-first-search.ts": "export default function depthFirstSearch(\n  graph: Record<string, Array<string>>,\n  source: string,\n): Array<string> {\n  // If there are no nodes in the graph, just return an empty array\n  if (Object.keys(graph).length === 0) {\n    return [];\n  }\n\n  // Create an stack to store the nodes to be visited. We can simulate\n  // stacks using arrays in JavaScript.\n  // Add the root node since we're doing a pre-order DFS.\n  const toBeVisited: Array<string> = [];\n  toBeVisited.push(source);\n\n  // Initialize a set that tracks visited nodes.\n  const visited = new Set<string>();\n\n  // Loop as long as array is empty (i.e. there are still nodes to be visited).\n  while (toBeVisited.length !== 0) {\n    // Pop top node from array (toBeVisited) and add it to the set (visited).\n    const node = toBeVisited.pop()!;\n    visited.add(node);\n\n    // Retrieve neighbors (values of the adjacency list input Object)\n    const neighbors = graph[node];\n    // Push neighbors, in reverse order, onto array to be visited\n    // to preserve original order of neighbors when visiting (popping off the array).\n    for (let i = neighbors.length - 1; i >= 0; i--) {\n      const neighbor = neighbors[i];\n      // First check if the neighbor has already been visited before adding it.\n      if (!visited.has(neighbor)) {\n        toBeVisited.push(neighbor);\n      }\n    }\n  }\n\n  // The visited nodes is the traversal order.\n  return Array.from(visited);\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Record<string, Array<string>} graph The adjacency list representing the graph.\n * @param {string} source The source node to start traversal from. It has to exist as a node in the graph.\n * @return {Array<string>} A DFS-traversed order of nodes.\n */\nexport default function depthFirstSearch(graph, source) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function depthFirstSearch(\n  graph: Record<string, Array<string>>,\n  source: string,\n): Array<string> {\n  throw 'Not implemented!';\n}"
  },
  "workspace": {
    "main": "/src/depth-first-search.ts",
    "run": "/src/depth-first-search.run.test.ts",
    "submit": "/src/depth-first-search.submit.test.ts"
  }
}