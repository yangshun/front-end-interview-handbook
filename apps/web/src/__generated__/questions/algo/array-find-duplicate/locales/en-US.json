{
  "description": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var r in e)i(n,r,{get:e[r],enumerable:!0})},o=(n,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of x(e))!b.call(n,a)&&a!==r&&i(n,a,{get:()=>e[a],enumerable:!(s=h(e,a))||s.enumerable});return n};var j=(n,e,r)=>(r=n!=null?d(f(n)):{},o(e||!n||!n.__esModule?i(r,\"default\",{value:n,enumerable:!0}):r,n)),_=n=>o(i({},\"__esModule\",{value:!0}),n);var u=y((T,c)=>{c.exports=_jsx_runtime});var X={};g(X,{default:()=>A,frontmatter:()=>D});var t=j(u());var l=MDXTestExamples;var p=[{input:[[\"numbers\",[5,7,1,3]]],output:!1,explanation:\"All elements in the array are unique.\"},{input:[[\"numbers\",[10,7,0,0,9]]],output:!0,explanation:\"0 appears more than once.\"},{input:[[\"numbers\",[3,2,6,5,0,3,10,3,10,5]]],output:!0,explanation:\"3,5, and 10 appears more than once.\"}];var D={title:\"Find Duplicates in Array\",excerpt:\"Implement a function to check if there are any duplicate numbers in the array\"};function m(n){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given an array of integers \",(0,t.jsx)(e.code,{children:\"numbers\"}),\", determine whether the array contains any duplicate values. A duplicate is defined as any number that appears more than once in the array.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,t.jsx)(l,{testCases:p}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"1 <= \",(0,t.jsx)(e.code,{children:\"numbers.length\"}),\" <= 10,000\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"-1,000,000 <= \",(0,t.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 1,000,000\"]}),`\n`]})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var A=M;return _(X);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to check if there are any duplicate numbers in the array",
    "title": "Find Duplicates in Array"
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),T=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!x.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(a=g(e,r))||a.enumerable});return t};var O=(t,e,i)=>(i=t!=null?f(b(t)):{},c(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),S=t=>c(o({},\"__esModule\",{value:!0}),t);var h=w((B,s)=>{s.exports=_jsx_runtime});var D={};T(D,{default:()=>q});var n=O(h());var l=MDXCodeBlock;var d=`export default function findDuplicates(numbers: number[]): boolean {\n  // Create a set to store unique elements seen so far\n  const seen: Set<number> = new Set();\n\n  // Get the size of the input array for loop iteration\n  const n: number = numbers.length;\n\n  // Iterate through each element in the nums array\n  for (let i = 0; i < n; i++) {\n    // Try inserting the current element into the set\n    // If insertion fails, it means the element already exists (duplicate)\n    if (seen.has(numbers[i])) {\n      return true; // Duplicate found, return true\n    }\n    seen.add(numbers[i]);\n  }\n\n  // If we reach here, no duplicates were found, return false\n  return false;\n}\n`;var u=`export default function findDuplicates(numbers: number[]): boolean {\n  // Sort the array in ascending order\n  numbers.sort((a, b) => a - b);\n\n  // Iterate through the sorted array\n  for (let i = 0; i < numbers.length - 1; i++) {\n    // Check if the current element is equal to the next element\n    if (numbers[i] === numbers[i + 1]) {\n      return true; // If a duplicate is found, return true\n    }\n  }\n\n  // If no duplicates are found, return false\n  return false;\n}\n`;var m=`export default function findDuplicates(numbers: number[]): boolean {\n  // Get the size of the input array for loop iteration\n  const n: number = numbers.length;\n\n  // Iterate through each pair of elements in the array\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      // Check if the elements at index i and j are the same\n      if (numbers[i] === numbers[j]) {\n        return true; // Duplicate found, return true\n      }\n    }\n  }\n\n  //No duplicates were found, return false\n  return false;\n}\n`;function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute Force\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The problem involves finding if there are duplicate elements in an array. The brute-force approach checks every possible pair of elements in the array to determine if they are equal. This is achieved through two nested loops, where each pair is compared. While this method is simple, it is inefficient for arrays with large size due to its O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\") time complexity.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Determine the length of the input array \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" and store it in a variable \",(0,n.jsx)(e.code,{children:\"n\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use a loop with index \",(0,n.jsx)(e.code,{children:\"i\"}),\" to iterate through each element in the array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For each \",(0,n.jsx)(e.code,{children:\"i\"}),\", use another loop with index \",(0,n.jsx)(e.code,{children:\"j\"}),\" starting from \",(0,n.jsx)(e.code,{children:\"i + 1\"}),\" to check every subsequent element in the array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compare the elements at indices \",(0,n.jsx)(e.code,{children:\"i\"}),\" and \",(0,n.jsx)(e.code,{children:\"j\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If they are equal, return \",(0,n.jsx)(e.code,{children:\"true\"}),\" to indicate a duplicate is found.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If no duplicate is found after checking all pairs, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The outer loop iterates \",(0,n.jsx)(e.code,{children:\"n\"}),\" times, and the inner loop iterates up to \",(0,n.jsx)(e.code,{children:\"n - i - 1\"}),\" times, resulting in a quadratic time complexity.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of additional space as it does not rely on any auxiliary data structures.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Sorting\"}),`\n`,(0,n.jsx)(e.p,{children:\"The previous brute force solution has unnecessary work of checking all pairs. To eliminate the redundant comparisons, this optimized solution sorts the array in ascending order, which ensures that duplicate elements appear consecutively. Once the array is sorted, a single traversal is sufficient to check if any two consecutive elements are equal.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sort the input array \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" in ascending order using the built-in \",(0,n.jsx)(e.code,{children:\"sort\"}),\" function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the sorted array using a loop from index \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"numbers.length - 1\"}),\".\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"For each element, compare it with the next element in the array.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the two elements are equal, return \",(0,n.jsx)(e.code,{children:\"true\"}),\" to indicate a duplicate has been found.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If no duplicates are found after the loop completes, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". The sorting operation dominates the runtime with O(n log n). The subsequent linear traversal of the sorted array has a complexity of O(n), which is insignificant compared to the sorting step.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The sorting is performed in-place, and the algorithm does not use any additional data structures, resulting in constant space usage.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"3. Using Set\"}),`\n`,(0,n.jsx)(e.p,{children:\"The previous solution using sorting had a bottleneck in its time complexity due to the sorting step, which is O(n log n). Sorting ensures duplicates appear consecutively but requires significant time for larger input arrays.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The current solution improves upon this by using a \",(0,n.jsx)(e.code,{children:\"Set\"}),\" to track elements seen so far. A \",(0,n.jsx)(e.code,{children:\"Set\"}),\" allows for constant-time operations for checking existence and adding elements. This eliminates the need for sorting, reducing the time complexity to linear O(n). It also preserves the original array since no in-place changes are made.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Create an empty \",(0,n.jsx)(e.code,{children:\"Set\"}),\" to store unique elements.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through each element in the input array:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the current element exists in the \",(0,n.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the element exists, return \",(0,n.jsx)(e.code,{children:\"true\"}),\", indicating a duplicate has been found.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Otherwise, add the current element to the \",(0,n.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the iteration completes without finding duplicates, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm iterates through the array once, performing constant-time operations for adding and checking elements in the \",(0,n.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"Set\"}),\" requires additional space to store up to \",(0,n.jsx)(e.code,{children:\"n\"}),\" elements in the worst case when all elements are unique.\"]}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var q=j;return S(D);})();\n;return Component;"
}