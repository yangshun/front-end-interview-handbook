{
  "description": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),b=(t,n)=>{for(var r in n)i(t,r,{get:n[r],enumerable:!0})},s=(t,n,r,o)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let a of x(n))!f.call(t,a)&&a!==r&&i(t,a,{get:()=>n[a],enumerable:!(o=p(n,a))||o.enumerable});return t};var j=(t,n,r)=>(r=t!=null?h(g(t)):{},s(n||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>s(i({},\"__esModule\",{value:!0}),t);var c=y((O,l)=>{l.exports=_jsx_runtime});var w={};b(w,{default:()=>M,frontmatter:()=>C});var e=j(c());var d=MDXTestExamples;var m=[{input:[[\"numbers\",[1,2,3,4]]],output:1,explanation:\"The original array [1,2,3,4] was rotated 0 times\"},{input:[[\"numbers\",[3,4,1,2]]],output:1,explanation:\"The original array [1,2,3,4] was rotated 2 times\"},{input:[[\"numbers\",[6,7,8,-5,-4,2]]],output:-5,explanation:\"The original array [-5,-4,2,6,7,8] was rotated 3 times.\"}];var C={title:\"Smallest element in rotated sorted array\",excerpt:\"Implement a function to find the smallest element in rotated sorted array\"};function u(t){let n=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"Given a sorted and rotated array \",(0,e.jsx)(n.code,{children:\"numbers\"}),\" containing unique elements, find and return the minimum element in this array.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Rotating an array \",(0,e.jsx)(n.code,{children:\"[a[0], a[1], a[2], ..., a[n-1]]\"}),\" once results in \",(0,e.jsx)(n.code,{children:\"[a[n-1], a[0], a[1], a[2], ..., a[n-2]]\"}),\". Rotating it a second time results in \",(0,e.jsx)(n.code,{children:\"[a[n-2], a[n-1], a[0], a[1], ..., a[n-3]]\"}),\".\"]}),`\n`,(0,e.jsx)(n.p,{children:\"Develop an algorithm that runs in O(log n) time complexity.\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Input\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,e.jsx)(d,{testCases:m}),`\n`,(0,e.jsx)(n.h3,{children:\"Constraints\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"1 <= \",(0,e.jsx)(n.code,{children:\"numbers.length\"}),\" <= 1000\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"-10,000 <= \",(0,e.jsx)(n.code,{children:\"numbers[i]\"}),\" <= 10,000\"]}),`\n`]})]})}function D(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(u,t)})):u(t)}var M=D;return _(w);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the smallest element in rotated sorted array",
    "title": "Smallest element in rotated sorted array"
  },
  "solution": "var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)l(t,i,{get:e[i],enumerable:!0})},a=(t,e,i,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!b.call(t,r)&&r!==i&&l(t,r,{get:()=>e[r],enumerable:!(h=f(e,r))||h.enumerable});return t};var x=(t,e,i)=>(i=t!=null?u(g(t)):{},a(e||!t||!t.__esModule?l(i,\"default\",{value:t,enumerable:!0}):i,t)),I=t=>a(l({},\"__esModule\",{value:!0}),t);var s=y((k,o)=>{o.exports=_jsx_runtime});var T={};w(T,{default:()=>A});var n=x(s());var d=MDXCodeBlock;var c=`export default function smallestInRotatedArray(numbers: number[]): number {\n  // Initialize variables to store starting and ending indices for searching\n  let low = 0;\n  let high = numbers.length - 1;\n\n  // Initialize a variable to store the minimum element found so far\n  let ans = Number.MAX_SAFE_INTEGER;\n\n  // Iterate while the search space (low <= high) exists\n  while (low <= high) {\n    // Calculate the middle index (avoiding potential overflow)\n    const mid = Math.floor((low + high) / 2);\n\n    // Check if the left part of the array is sorted (nums[low] <= nums[mid])\n    if (numbers[low] <= numbers[mid]) {\n      // If left part is sorted, the minimum element could be there\n      ans = Math.min(ans, numbers[low]); // Update minimum if a smaller element is found\n\n      // Since the left part is sorted, eliminate it from the search space\n      low = mid + 1;\n    } else {\n      // If the left part is not sorted, the right part must be sorted\n      // The minimum element must be in the right half of the array\n      ans = Math.min(ans, numbers[mid]); // Update minimum if a smaller element is found\n\n      // Eliminate the right half from the search space\n      high = mid - 1;\n    }\n  }\n\n  // After the loop, the minimum element is stored in 'ans'\n  return ans;\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Modified Binary Search\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem is to find the smallest element in a rotated sorted array using a modified binary search approach. A brute force solution would iterate through the array to find the minimum element in O(n) time. However, the sorted nature of the array can be exploited to reduce the time complexity to O(log n) using binary search.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The key insight is that in a rotated sorted array, one part of the array is always sorted. By checking which part is sorted, the search space can be narrowed efficiently. The algorithm iteratively reduces the search space while keeping track of the smallest element encountered so far.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach eliminates unnecessary iterations by focusing only on the part of the array that could contain the smallest element.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"low\"}),\" to 0 and \",(0,n.jsx)(e.code,{children:\"high\"}),\" to \",(0,n.jsx)(e.code,{children:\"numbers.length - 1\"}),\" to represent the search space.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"ans\"}),\" to \",(0,n.jsx)(e.code,{children:\"Number.MAX_SAFE_INTEGER\"}),\" to store the minimum element found so far.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use a loop while \",(0,n.jsx)(e.code,{children:\"low <= high\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate \",(0,n.jsx)(e.code,{children:\"mid\"}),\" as the floor of \",(0,n.jsx)(e.code,{children:\"(low + high) / 2\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the left half of the array is sorted by comparing \",(0,n.jsx)(e.code,{children:\"numbers[low]\"}),\" and \",(0,n.jsx)(e.code,{children:\"numbers[mid]\"}),\".\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the left half is sorted:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"ans\"}),\" with the smaller of \",(0,n.jsx)(e.code,{children:\"ans\"}),\" and \",(0,n.jsx)(e.code,{children:\"numbers[low]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Eliminate the left half by setting \",(0,n.jsx)(e.code,{children:\"low\"}),\" to \",(0,n.jsx)(e.code,{children:\"mid + 1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Otherwise, the right half must be sorted:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"ans\"}),\" with the smaller of \",(0,n.jsx)(e.code,{children:\"ans\"}),\" and \",(0,n.jsx)(e.code,{children:\"numbers[mid]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Eliminate the right half by setting \",(0,n.jsx)(e.code,{children:\"high\"}),\" to \",(0,n.jsx)(e.code,{children:\"mid - 1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After the loop, return \",(0,n.jsx)(e.code,{children:\"ans\"}),\" as the smallest element in the array.\"]}),`\n`]}),`\n`,(0,n.jsx)(d,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(log n)\"}),\". The binary search reduces the search space by half at each step, resulting in logarithmic time complexity.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of space for variables, as it operates directly on the input array.\"]}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var A=_;return I(T);})();\n;return Component;"
}