{
  "description": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var o in e)a(t,o,{get:e[o],enumerable:!0})},s=(t,e,o,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of x(e))!f.call(t,r)&&r!==o&&a(t,r,{get:()=>e[r],enumerable:!(i=b(e,r))||i.enumerable});return t};var j=(t,e,o)=>(o=t!=null?d(p(t)):{},s(e||!t||!t.__esModule?a(o,\"default\",{value:t,enumerable:!0}):o,t)),v=t=>s(a({},\"__esModule\",{value:!0}),t);var h=g((X,u)=>{u.exports=_jsx_runtime});var M={};y(M,{default:()=>C,frontmatter:()=>w});var n=j(h());var l=MDXTestExamples;var c=[{input:[[\"numbers\",[1,2,3,1]]],output:4,explanation:\"The robber can steal a maximum of 4 by robbing house at index 0 (value 1) and house at index 2 (value 3).\"},{input:[[\"numbers\",[2,7,9,3,1]]],output:12,explanation:\"The robber can steal a maximum of 12 by robbing house at index 0 (value 2), house at index 2 (value 9), and house at index 4 (value 1).\"},{input:[[\"numbers\",[3,6,1,0,6,0,0,9]]],output:21,explanation:\"The robber can steal a maximum of 21 by robbing house at index 1 (value 6), house at index 4 (value 6), house at index 7 (value 9).\"}];var w={title:\"Neighborhood Theft\",excerpt:\"Implement a function to find maximum money to rob without alerting police\"};function m(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"An experienced robber aims to steal the money in the houses on a street. Each house has a certain amount of money hidden, but there is a catch: the security systems in adjacent houses are interconnected. If the robber breaks into two neighboring houses, the police will be alerted.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Given an array of integers \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" where each element represents the amount of money in a house, determine the maximum amount of money the robber can steal without triggering the alarm.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The robber cannot steal from two adjacent houses\"}),`\n`]}),`\n`,(0,n.jsx)(l,{testCases:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 400\"]}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=_;return v(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find maximum money to rob without alerting police",
    "title": "Neighborhood Theft"
  },
  "solution": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var o in e)i(t,o,{get:e[o],enumerable:!0})},s=(t,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of g(e))!y.call(t,r)&&r!==o&&i(t,r,{get:()=>e[r],enumerable:!(a=f(e,r))||a.enumerable});return t};var R=(t,e,o)=>(o=t!=null?p(x(t)):{},s(e||!t||!t.__esModule?i(o,\"default\",{value:t,enumerable:!0}):o,t)),T=t=>s(i({},\"__esModule\",{value:!0}),t);var c=v((F,l)=>{l.exports=_jsx_runtime});var O={};w(O,{default:()=>z});var n=R(c());var h=MDXCodeBlock;var d=`export default function neighborhoodTheft(numbers: number[]): number {\n  const N = numbers.length;\n\n  // Special handling for empty case (no houses to rob).\n  if (N === 0) {\n    return 0;\n  }\n\n  // This array stores the maximum amount of money that can be robbed when considering up to each house.\n  // Note: The calculation starts from the last house and moves backward.\n  const maxRobbedAmount: number[] = new Array(N + 1).fill(0);\n\n  // Base case initializations:\n  // - maxRobbedAmount[N] (robbing the last house + next house is impossible): set to 0.\n  // - maxRobbedAmount[N - 1] (robbing only the last house): set to the value in the last house.\n  maxRobbedAmount[N] = 0;\n  maxRobbedAmount[N - 1] = numbers[N - 1];\n\n  // DP table calculations (iterating backwards from the second-last house):\n  // For each house 'i' (from N-2 to 0):\n  //   - Consider two options:\n  //     1. Rob the current house 'i' and skip the next house (i+1).\n  //     2. Skip the current house 'i' and rob the house after next (i+2).\n  //   - Choose the option that yields the maximum total amount for ending at house 'i'.\n  //   - Store the chosen maximum amount in maxRobbedAmount[i].\n  for (let i = N - 2; i >= 0; i--) {\n    maxRobbedAmount[i] = Math.max(\n      maxRobbedAmount[i + 1],\n      maxRobbedAmount[i + 2] + numbers[i],\n    );\n  }\n\n  // The maximum amount the robber can steal is stored in maxRobbedAmount[0]\n  // (represents the maximum achievable by ending at the first house).\n  return maxRobbedAmount[0];\n}\n`;var u=`// Memoization array to store the results of subproblems\nlet memo: number[] = [];\n\n// Main function to calculate the maximum amount of money that can be robbed\nexport default function neighborhoodTheft(numbers: number[]): number {\n  // Initialize the memo array with -1 to indicate uncomputed values\n  memo = new Array(numbers.length).fill(-1);\n\n  // Start the recursive function from the first house\n  return robFrom(0, numbers);\n}\n\n// Helper function to calculate the maximum amount of money that can be robbed from the ith house onwards\nfunction robFrom(i: number, numbers: number[]): number {\n  // Base case: No more houses left to examine\n  if (i >= numbers.length) {\n    return 0;\n  }\n\n  // If the result for this subproblem is already computed, return the cached value\n  if (memo[i] > -1) {\n    return memo[i];\n  }\n\n  // Calculate the maximum amount by either:\n  // 1. Skipping the current house and moving to the next one\n  // 2. Robbing the current house and moving to the house after the next one\n  const ans = Math.max(\n    robFrom(i + 1, numbers),\n    robFrom(i + 2, numbers) + numbers[i],\n  );\n\n  // Cache the result for future use\n  memo[i] = ans;\n\n  // Return the computed result\n  return ans;\n}\n`;var m=`export default function neighborhoodTheft(numbers: number[]): number {\n  const N = numbers.length;\n\n  // Special handling for empty case (no houses to rob).\n  if (N === 0) {\n    return 0;\n  }\n\n  // If there's only one house, return its value.\n  if (N === 1) {\n    return numbers[0];\n  }\n\n  // Initialize two variables to keep track of the maximum amounts:\n  // prev1: max amount for robbing from house i+1 to the end\n  // prev2: max amount for robbing from house i+2 to the end\n  let prev1 = 0; // Equivalent to maxRobbedAmount[i+1]\n  let prev2 = 0; // Equivalent to maxRobbedAmount[i+2]\n\n  // Iterate backwards from the last house\n  for (let i = N - 1; i >= 0; i--) {\n    // Current maximum is either:\n    // - Skipping the current house (prev1)\n    // - Robbing the current house and adding prev2\n    const current = Math.max(prev1, prev2 + numbers[i]);\n\n    // Update prev2 and prev1 for the next iteration\n    prev2 = prev1;\n    prev1 = current;\n  }\n\n  // The final result is stored in prev1\n  return prev1;\n}\n`;function b(t){let e=Object.assign({h2:\"h2\",p:\"p\",ol:\"ol\",li:\"li\",h3:\"h3\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Top-Down Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:'This solution uses a top-down dynamic programming approach with memoization to solve the \"neighborhood theft\" problem. The problem involves maximizing the amount of money stolen from houses while ensuring that no two adjacent houses are robbed.'}),`\n`,(0,n.jsx)(e.p,{children:\"The algorithm starts from the first house and recursively explores two options:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Skip the current house and move to the next one.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Rob the current house and move to the house after the next one.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Memoization is used to store the results of already-computed subproblems. This avoids redundant computations and significantly reduces the runtime complexity. By caching the results for each house, the solution only calculates each subproblem once, optimizing performance compared to a pure recursive approach.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array with the size of the input array, filled with \",(0,n.jsx)(e.code,{children:\"-1\"}),\", to indicate uncomputed values.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"robFrom\"}),\" that recursively computes the maximum money that can be robbed starting from the \",(0,n.jsx)(e.code,{children:\"i\"}),\"th house.\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check the base case where \",(0,n.jsx)(e.code,{children:\"i\"}),\" exceeds the bounds of the array, returning \",(0,n.jsx)(e.code,{children:\"0\"}),\" since no houses are left to rob.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the result for house \",(0,n.jsx)(e.code,{children:\"i\"}),\" is already computed and stored in \",(0,n.jsx)(e.code,{children:\"memo[i]\"}),\", return the cached value.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compute the maximum value between:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Skipping the current house by calling \",(0,n.jsx)(e.code,{children:\"robFrom(i + 1, numbers)\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Robbing the current house and adding its value to the result of \",(0,n.jsx)(e.code,{children:\"robFrom(i + 2, numbers)\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Store the computed result in \",(0,n.jsx)(e.code,{children:\"memo[i]\"}),\" for future use.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Start the computation by calling \",(0,n.jsx)(e.code,{children:\"robFrom(0, numbers)\"}),\" to process all houses.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the result of the computation, which represents the maximum money that can be robbed without triggering the alarm.\"}),`\n`]}),`\n`,(0,n.jsx)(h,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each house is processed at most once, and the result is stored in the \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array, avoiding redundant recursive calls.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array requires space proportional to the number of houses, and the recursion stack may go up to a depth of \",(0,n.jsx)(e.code,{children:\"n\"}),\" in the worst case.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Bottom-Up Dynamic Programming\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This approach eliminates recursion by iteratively building a \",(0,n.jsx)(e.code,{children:\"dp\"}),\" table (or array) from the last house to the first house, ensuring all subproblems are solved sequentially.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array, \",(0,n.jsx)(e.code,{children:\"maxRobbedAmount\"}),\", stores the maximum money that can be robbed considering houses from the current index up to the last house. For each house, two options are considered:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Skip the current house and take the result stored for the next house (\",(0,n.jsx)(e.code,{children:\"maxRobbedAmount[i + 1]\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Rob the current house and add its value to the result stored for skipping the next house (\",(0,n.jsx)(e.code,{children:\"maxRobbedAmount[i + 2] + numbers[i]\"}),\").\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The decision for each house is made by choosing the option that provides the maximum amount. This avoids redundant calculations and ensures an efficient solution.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Handle the base case where the input array is empty. Return \",(0,n.jsx)(e.code,{children:\"0\"}),\" if there are no houses.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize the \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array \",(0,n.jsx)(e.code,{children:\"maxRobbedAmount\"}),\" with size \",(0,n.jsx)(e.code,{children:\"N + 1\"}),\", filled with \",(0,n.jsx)(e.code,{children:\"0\"}),\". This array will store the maximum money that can be robbed starting from each house.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set the base cases for the last two houses:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"maxRobbedAmount[N]\"}),\" is \",(0,n.jsx)(e.code,{children:\"0\"}),\", representing the case where no houses are left to rob.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"maxRobbedAmount[N - 1]\"}),\" is set to the value of the last house (\",(0,n.jsx)(e.code,{children:\"numbers[N - 1]\"}),\"), as there are no other options for the last house.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate backward through the houses starting from the second-to-last house (\",(0,n.jsx)(e.code,{children:\"N - 2\"}),\") down to the first house (\",(0,n.jsx)(e.code,{children:\"0\"}),\"):\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each house \",(0,n.jsx)(e.code,{children:\"i\"}),\", calculate the maximum money that can be robbed by choosing between:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Skipping the current house: \",(0,n.jsx)(e.code,{children:\"maxRobbedAmount[i + 1]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Robbing the current house and skipping the next house: \",(0,n.jsx)(e.code,{children:\"maxRobbedAmount[i + 2] + numbers[i]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Store the maximum value in \",(0,n.jsx)(e.code,{children:\"maxRobbedAmount[i]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"maxRobbedAmount[0]\"}),\", which represents the maximum money that can be robbed starting from the first house.\"]}),`\n`]}),`\n`,(0,n.jsx)(h,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm processes each house exactly once in a backward iteration.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array \",(0,n.jsx)(e.code,{children:\"maxRobbedAmount\"}),\" requires space proportional to the number of houses.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"3. Bottom-Up Dynamic Programming With Optimized Space\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This solution builds upon the bottom-up dynamic programming approach used in the previous question but optimizes the space complexity from O(n) to O(1). In the earlier solution, a \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array was used to store the maximum amount that could be robbed starting from each house, requiring extra space proportional to the number of houses. However, only the last two values from this array were needed at any given time to compute the current result.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To eliminate unnecessary storage, this solution replaces the \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array with two variables, \",(0,n.jsx)(e.code,{children:\"prev1\"}),\" and \",(0,n.jsx)(e.code,{children:\"prev2\"}),\", which store the maximum amounts for the next house (\",(0,n.jsx)(e.code,{children:\"i + 1\"}),\") and the house after that (\",(0,n.jsx)(e.code,{children:\"i + 2\"}),\"). This ensures that the algorithm still computes the same results but with significantly reduced space usage.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The algorithm iterates backward through the array, updating these two variables at each step. The use of two variables rather than an entire array removes the space overhead while retaining the time efficiency of the earlier approach. This improvement is especially beneficial when dealing with a large number of houses.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Handle special cases:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If there are no houses, return \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"If there is only one house, return its value, as no other options exist.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two variables:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"prev1\"}),\" as \",(0,n.jsx)(e.code,{children:\"0\"}),\", representing the maximum money that can be robbed starting from the next house (\",(0,n.jsx)(e.code,{children:\"i + 1\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"prev2\"}),\" as \",(0,n.jsx)(e.code,{children:\"0\"}),\", representing the maximum money that can be robbed starting from the house after the next (\",(0,n.jsx)(e.code,{children:\"i + 2\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate backward through the houses:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the maximum money that can be robbed from the current house as the maximum of:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Skipping the current house (\",(0,n.jsx)(e.code,{children:\"prev1\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Robbing the current house and adding the value of \",(0,n.jsx)(e.code,{children:\"prev2\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"prev2\"}),\" to the current value of \",(0,n.jsx)(e.code,{children:\"prev1\"}),\", and \",(0,n.jsx)(e.code,{children:\"prev1\"}),\" to the newly calculated maximum.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After the loop ends, \",(0,n.jsx)(e.code,{children:\"prev1\"}),\" contains the maximum amount that can be robbed starting from the first house. Return this value.\"]}),`\n`]}),`\n`,(0,n.jsx)(h,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each house is processed exactly once in a backward iteration.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". Only two variables are used to track intermediate results, eliminating the need for an additional array.\"]}),`\n`]})]})}function S(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(b,t)})):b(t)}var z=S;return T(O);})();\n;return Component;"
}