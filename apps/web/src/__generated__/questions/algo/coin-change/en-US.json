{
  "description": "var Component=(()=>{var d=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),y=(t,n)=>{for(var i in n)r(t,i,{get:n[i],enumerable:!0})},a=(t,n,i,c)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let o of g(n))!x.call(t,o)&&o!==i&&r(t,o,{get:()=>n[o],enumerable:!(c=p(n,o))||c.enumerable});return t};var j=(t,n,i)=>(i=t!=null?d(f(t)):{},a(n||!t||!t.__esModule?r(i,\"default\",{value:t,enumerable:!0}):i,t)),C=t=>a(r({},\"__esModule\",{value:!0}),t);var l=b((X,s)=>{s.exports=_jsx_runtime});var w={};y(w,{default:()=>M,frontmatter:()=>_});var e=j(l());var u=MDXTestExamples;var h=[{input:[[\"coins\",[3,7,4]],[\"target\",14]],output:2,explanation:\"We can form the target amount (14) using the following combination of coins: 7 + 7. This requires a minimum of 2 coins.\"},{input:[[\"coins\",[1]],[\"target\",0]],output:0,explanation:\"The target amount is 0, which requires no coins to reach. Even though there's only a 1 coin available, you can still form 0 using no coins.\"},{input:[[\"coins\",[2]],[\"target\",3]],output:-1,explanation:\"The only available coin denomination is 2. However, it's impossible to form the target amount (3) using just multiples of 2. Therefore, no combination of coins can reach 3, and the output is -1.\"}];var _={title:\"Minimum Coins for Change\",excerpt:\"Implement a function to return minimum coins needed to make the given amount\"};function m(t){let n=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(n.p,{children:[\"Given an integer array \",(0,e.jsx)(n.code,{children:\"coins\"}),\" indicating different coin denominations and an integer \",(0,e.jsx)(n.code,{children:\"target\"}),\" denoting a total sum of money, return the minimum number of coins needed to make up the \",(0,e.jsx)(n.code,{children:\"target\"}),\". If it's not possible to make up the \",(0,e.jsx)(n.code,{children:\"target\"}),\" with any combination of the coins, return \",(0,e.jsx)(n.code,{children:\"-1\"}),\".\"]}),`\n`,(0,e.jsx)(n.p,{children:\"Assume there's an infinite supply of each coin.\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Input\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"coins: number[]\"}),\": An array of integers\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.code,{children:\"target: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,e.jsx)(u,{testCases:h}),`\n`,(0,e.jsx)(n.h3,{children:\"Constraints\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"1 <= \",(0,e.jsx)(n.code,{children:\"coins.length\"}),\" <= 12\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"1 <= \",(0,e.jsx)(n.code,{children:\"coins[i]\"}),\" <= 1,000,000\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"0 <= \",(0,e.jsx)(n.code,{children:\"target\"}),\" <= 10,000\"]}),`\n`]})]})}function v(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(m,t)})):m(t)}var M=v;return C(w);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to return minimum coins needed to make the given amount",
    "title": "Minimum Coins for Change"
  },
  "solution": "var Component=(()=>{var g=Object.create;var r=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var C=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),v=(i,e)=>{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},l=(i,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!y.call(i,o)&&o!==t&&r(i,o,{get:()=>e[o],enumerable:!(a=f(e,o))||a.enumerable});return i};var I=(i,e,t)=>(t=i!=null?g(b(i)):{},l(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),x=i=>l(r({},\"__esModule\",{value:!0}),i);var d=C((_,h)=>{h.exports=_jsx_runtime});var O={};v(O,{default:()=>F});var n=I(d());var c=MDXCodeBlock;var s=`export default function minimumCoinsForChange(\n  coins: number[],\n  target: number,\n): number {\n  // Initialize a dp array with a large value (Infinity)\n  const dp: number[] = new Array(target + 1).fill(Number.MAX_VALUE);\n\n  // Base case: 0 coins are needed to make amount 0\n  dp[0] = 0;\n\n  // Iterate over each amount from 1 to the target amount\n  for (let i = 1; i <= target; i++) {\n    // Check each coin to see if it can contribute to the current amount\n    for (const coin of coins) {\n      if (i - coin >= 0) {\n        dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n      }\n    }\n  }\n\n  // If the value at dp[amount] is still Infinity, return -1 (not possible)\n  // Otherwise, return the minimum number of coins needed for the target amount\n  return dp[target] === Number.MAX_VALUE ? -1 : dp[target];\n}\n`;var m=`function minimumCoinsForChangeHelper(coins: number[], target: number): number {\n  // Base case: If the amount is 0, no coins are needed.\n  if (target === 0) {\n    return 0;\n  }\n\n  let minCoins = Infinity;\n\n  // Try each coin denomination.\n  for (const coin of coins) {\n    // Check if the coin denomination is not greater than the amount.\n    if (coin <= target) {\n      // Recursively calculate the minimum coins needed for the remaining amount.\n      const remainingCoins = minimumCoinsForChangeHelper(coins, target - coin);\n\n      // If a valid solution is found and it requires fewer coins, update minCoins.\n      if (remainingCoins !== -1 && remainingCoins + 1 < minCoins) {\n        minCoins = remainingCoins + 1;\n      }\n    }\n  }\n\n  // If no valid solution was found, return -1. Otherwise, return the minimum coins.\n  return minCoins === Infinity ? -1 : minCoins;\n}\n\nexport default function minimumCoinsForChange(\n  coins: number[],\n  target: number,\n): number {\n  return minimumCoinsForChangeHelper(coins, target);\n}\n`;function u(i){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute Force Approach Using Recursion\"}),`\n`,(0,n.jsx)(e.p,{children:\"The goal is to determine the minimum number of coins needed to make up a given target amount using the available coin denominations. The brute force approach recursively tries every possible combination of coins to find the solution with the fewest coins. The recursion explores all valid ways to reduce the target amount to zero and keeps track of the minimum number of coins required.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"minimumCoinsForChangeHelper\"}),\" that takes the array of coins and the remaining target amount as arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the target amount is \",(0,n.jsx)(e.code,{children:\"0\"}),\", return \",(0,n.jsx)(e.code,{children:\"0\"}),\" as no coins are needed.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a variable \",(0,n.jsx)(e.code,{children:\"minCoins\"}),\" to \",(0,n.jsx)(e.code,{children:\"Infinity\"}),\" to keep track of the minimum coins required.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the array of coins:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Check if the current coin denomination is less than or equal to the remaining target amount.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Recursively call the helper function with the remaining amount (\",(0,n.jsx)(e.code,{children:\"target - coin\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If a valid solution is found and the number of coins used is less than \",(0,n.jsx)(e.code,{children:\"minCoins\"}),\", update \",(0,n.jsx)(e.code,{children:\"minCoins\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After iterating through all coins, return \",(0,n.jsx)(e.code,{children:\"-1\"}),\" if no valid solution is found; otherwise, return the value of \",(0,n.jsx)(e.code,{children:\"minCoins\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The main function \",(0,n.jsx)(e.code,{children:\"minimumCoinsForChange\"}),\" initializes the recursion by calling the helper function with the full target amount.\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(c\",(0,n.jsx)(\"sup\",{children:\"t\"}),\")\"]}),\". The recursion explores all combinations of \",(0,n.jsx)(e.code,{children:\"c\"}),\" coins for the target amount \",(0,n.jsx)(e.code,{children:\"t\"}),\", resulting in exponential time complexity.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(t)\"}),\". The recursive call stack grows proportionally to the target amount \",(0,n.jsx)(e.code,{children:\"t\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Dynamic Programming\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The dynamic programming approach improves upon the brute force solution by avoiding repeated calculations for the same subproblems. Instead of recursively solving for each possible combination of coins, this method uses a \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array to store the minimum number of coins needed to make up amounts from \",(0,n.jsx)(e.code,{children:\"0\"}),\" to the target. Each value is computed iteratively by building upon previously calculated values, ensuring that each subproblem is solved only once. This eliminates redundant work and significantly reduces the time complexity.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array of size \",(0,n.jsx)(e.code,{children:\"target + 1\"}),\" with all values set to \",(0,n.jsx)(e.code,{children:\"Number.MAX_VALUE\"}),\" to represent an unreachable state.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"dp[0]\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" since no coins are needed to make up the amount \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate over amounts from \",(0,n.jsx)(e.code,{children:\"1\"}),\" to \",(0,n.jsx)(e.code,{children:\"target\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"For each amount, iterate through the list of coins.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the current coin can contribute to the amount (\",(0,n.jsx)(e.code,{children:\"i - coin >= 0\"}),\"), update \",(0,n.jsx)(e.code,{children:\"dp[i]\"}),\" with the minimum of its current value or \",(0,n.jsx)(e.code,{children:\"dp[i - coin] + 1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After filling the \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array, check the value at \",(0,n.jsx)(e.code,{children:\"dp[target]\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If it is still \",(0,n.jsx)(e.code,{children:\"Number.MAX_VALUE\"}),\", return \",(0,n.jsx)(e.code,{children:\"-1\"}),\" as the target amount is not achievable.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Otherwise, return \",(0,n.jsx)(e.code,{children:\"dp[target]\"}),\" as the minimum number of coins required.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n.t)\"}),\". Iterating over \",(0,n.jsx)(e.code,{children:\"target\"}),\" amounts and checking each of the \",(0,n.jsx)(e.code,{children:\"n\"}),\" coins results in O(n.t).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(t)\"}),\". The \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array requires space proportional to the target amount \",(0,n.jsx)(e.code,{children:\"t\"}),\".\"]}),`\n`]})]})}function A(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(u,i)})):u(i)}var F=A;return x(O);})();\n;return Component;"
}