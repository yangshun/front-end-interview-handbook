{
  "description": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},l=(t,e,i,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of g(e))!f.call(t,r)&&r!==i&&a(t,r,{get:()=>e[r],enumerable:!(s=u(e,r))||s.enumerable});return t};var j=(t,e,i)=>(i=t!=null?p(x(t)):{},l(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),_=t=>l(a({},\"__esModule\",{value:!0}),t);var c=v((X,o)=>{o.exports=_jsx_runtime});var T={};b(T,{default:()=>M,frontmatter:()=>y});var n=j(c());var d=MDXTestExamples;var h=[{input:[[\"intervals\",[[83,99]]]],output:!0,explanation:\"There is only one meeting, so there is no possibility of overlap.\"},{input:[[\"intervals\",[[1,5],[5,10],[10,15]]]],output:!0,explanation:\"The meetings are back-to-back but do not overlap.\"},{input:[[\"intervals\",[[8,10],[1,3],[2,6],[15,18]]]],output:!1,explanation:\"The meetings [1, 3] and [2, 6] overlap, so it is not possible to attend all meetings.\"}];var y={title:\"Meeting Calendar\",excerpt:\"Implement a function to check if all meetings can be attended\"};function m(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of meeting time \",(0,n.jsx)(e.code,{children:\"intervals\"}),\" where each element represents a meeting time as \",(0,n.jsx)(e.code,{children:\"[start, end]\"}),\", determine whether a person can attend all the meetings without any overlap between meeting times.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"A 2D array of integers \",(0,n.jsx)(e.code,{children:\"intervals\"}),\" of size \",(0,n.jsx)(e.code,{children:\"n x 2\"}),\", where \",(0,n.jsx)(e.code,{children:\"n\"}),\" is the number of meetings and each interval \",(0,n.jsx)(e.code,{children:\"[start, end]\"}),\" represents a meeting starting at time start and ending at time end\"]}),`\n`]}),`\n`,(0,n.jsx)(d,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"intervals.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"intervals[i].length\"}),\" == 2\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"start\"}),\" < \",(0,n.jsx)(e.code,{children:\"end\"}),\" <= 1,000,000\"]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var M=C;return _(T);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to check if all meetings can be attended",
    "title": "Meeting Calendar"
  },
  "solution": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},s=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!y.call(t,i)&&i!==r&&a(t,i,{get:()=>e[i],enumerable:!(o=f(e,i))||o.enumerable});return t};var k=(t,e,r)=>(r=t!=null?p(m(t)):{},s(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),I=t=>s(a({},\"__esModule\",{value:!0}),t);var c=b((F,h)=>{h.exports=_jsx_runtime});var T={};x(T,{default:()=>C});var n=k(c());var l=MDXCodeBlock;var d=`export default function isMeetingCalendarValid(intervals: number[][]): boolean {\n  // Sort the intervals based on the start times\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  // Iterate through the sorted intervals\n  for (let i = 0; i < intervals.length - 1; i++) {\n    // Check if the end time of the current interval is greater than the start time of the next interval\n    if (intervals[i][1] > intervals[i + 1][0]) {\n      return false; // If there is an overlap, return false\n    }\n  }\n\n  // If no overlaps are found, return true\n  return true;\n}\n`;var v=`export default function isMeetingCalendarValid(intervals: number[][]): boolean {\n  const overlap = (interval1: number[], interval2: number[]): boolean => {\n    return (\n      (interval1[0] >= interval2[0] && interval1[0] < interval2[1]) ||\n      (interval2[0] >= interval1[0] && interval2[0] < interval1[1])\n    );\n  };\n\n  // Iterate through each pair of intervals to check for overlaps\n  for (let i = 0; i < intervals.length; i++) {\n    for (let j = i + 1; j < intervals.length; j++) {\n      if (overlap(intervals[i], intervals[j])) {\n        return false; // If any overlap is found, return false\n      }\n    }\n  }\n  return true; // If no overlaps are found, return true\n}\n`;function u(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute Force Approach\"}),`\n`,(0,n.jsx)(e.p,{children:\"The naive approach is to check if a set of intervals can form a valid meeting calendar by verifying that no two intervals overlap. The key idea is to iterate through all pairs of intervals and compare their start and end times. For each pair, the overlap is determined by checking if one interval starts before the other ends and vice versa. If any overlap is detected, the calendar is considered invalid.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"overlap\"}),\" that takes two intervals as input and checks if they overlap by comparing their start and end times.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use nested loops to iterate through all pairs of intervals:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each pair of intervals, call the \",(0,n.jsx)(e.code,{children:\"overlap\"}),\" function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the function returns \",(0,n.jsx)(e.code,{children:\"true\"}),\", immediately return \",(0,n.jsx)(e.code,{children:\"false\"}),\" as the intervals are not valid.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If no overlapping intervals are found after all comparisons, return \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{children:v}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The algorithm iterates through all pairs of intervals, resulting in n(n - 1)/2 comparisons, which is O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses constant space as it does not require any additional data structures.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Sorting\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach relies on sorting intervals by their start times to guarantee that overlapping intervals appear next to each other. Sorting ensures that intervals are ordered chronologically based on when they start. If two intervals overlap, the end time of an earlier interval will extend into the range of the next interval's start time. By arranging the intervals in ascending order of their start times, it becomes sufficient to check each interval against the next one in the sorted list to detect overlaps.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This method removes unnecessary comparisons present in the brute force approach. Instead of comparing every pair of intervals, only adjacent intervals in the sorted order need to be checked, as any overlapping intervals are guaranteed to be consecutive after sorting.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sort the intervals based on their start times in ascending order using the \",(0,n.jsx)(e.code,{children:\"sort\"}),\" method.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the sorted intervals:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"For each interval, check if its end time is greater than the start time of the next interval.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"If an overlap is detected, return \",(0,n.jsx)(e.code,{children:\"false\"}),\" as the calendar is invalid.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the loop completes without detecting any overlaps, return \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Sorting the intervals dominates the runtime, taking O(n log n), while the linear scan through the intervals takes O(n), resulting in O(n log n) overall.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses constant space as it modifies the intervals array in place and does not require additional data structures.\"]}),`\n`]})]})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var C=w;return I(T);})();\n;return Component;"
}