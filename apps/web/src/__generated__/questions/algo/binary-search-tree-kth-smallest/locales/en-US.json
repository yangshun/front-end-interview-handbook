{
  "description": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var T=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),k=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of f(e))!x.call(t,l)&&l!==r&&i(t,l,{get:()=>e[l],enumerable:!(o=m(e,l))||o.enumerable});return t};var v=(t,e,r)=>(r=t!=null?p(T(t)):{},a(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),N=t=>a(i({},\"__esModule\",{value:!0}),t);var s=g((y,d)=>{d.exports=_jsx_runtime});var _={};k(_,{default:()=>S,frontmatter:()=>w});var n=v(s());var c=MDXTestExamples;var h=[{input:[[\"root\",[7,3,10,1,5,8,12]],[\"k\",2]],output:3,explanation:\"In this BST, the second smallest value is 3.\"},{input:[[\"root\",[1,null,2,null,3,null,4,null,5]],[\"k\",4]],output:4,explanation:\"In this right-skewed BST, the fourth smallest value is 4.\"},{input:[[\"root\",[8,6,10,5,7,9,12]],[\"k\",5]],output:9,explanation:\"In this BST, the fifth smallest value is 9.\"}];var w={title:\"Binary Search Tree Kth Smallest Element\",excerpt:\"Implement a function to find the kth smallest node in a BST\"};function u(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the \",(0,n.jsx)(e.code,{children:\"root\"}),\" node of a binary search tree (BST) and an integer \",(0,n.jsx)(e.code,{children:\"k\"}),\", write a function to find and return the \",(0,n.jsx)(e.code,{children:\"k\"}),\"-th smallest value in the BST. The smallest value in the tree is 1.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"root: TreeNode\"}),\": Root node of the tree. Examples display a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"k: number\"}),\": A positive integer\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"k\"}),\" <= Number of nodes <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 1,000,000\"]}),`\n`]})]})}function B(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var S=B;return N(_);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the kth smallest node in a BST",
    "title": "Binary Search Tree Kth Smallest Element"
  },
  "solution": "var Component=(()=>{var v=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),T=(t,e)=>{for(var n in e)i(t,n,{get:e[n],enumerable:!0})},s=(t,e,n,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!k.call(t,o)&&o!==n&&i(t,o,{get:()=>e[o],enumerable:!(h=f(e,o))||h.enumerable});return t};var b=(t,e,n)=>(n=t!=null?v(g(t)):{},s(e||!t||!t.__esModule?i(n,\"default\",{value:t,enumerable:!0}):n,t)),x=t=>s(i({},\"__esModule\",{value:!0}),t);var d=y((A,a)=>{a.exports=_jsx_runtime});var R={};T(R,{default:()=>N});var r=b(d());var l=MDXCodeBlock;var c=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nfunction inorderTraversal(root: TreeNode | null, arr: number[]): number[] {\n  if (root === null) {\n    return arr; // Base case: if the node is null, return the current array\n  }\n\n  inorderTraversal(root.left, arr); // Recursively traverse the left subtree\n  arr.push(root.val); // Add the current node's value to the array\n  inorderTraversal(root.right, arr); // Recursively traverse the right subtree\n\n  return arr; // Return the array with collected values\n}\n\nexport default function kthSmallestElementInABst(\n  root: TreeNode | null,\n  k: number,\n): number {\n  // Perform in-order traversal to get a sorted list of node values\n  const nums = inorderTraversal(root, []);\n\n  // Return the k-th smallest element (k-1 index due to 0-based indexing)\n  return nums[k - 1];\n}\n`;var u=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function kthSmallestElementInABst(\n  root: TreeNode | null,\n  k: number,\n): number {\n  // Stack to hold nodes during the in-order traversal\n  const stack: TreeNode[] = [];\n\n  while (true) {\n    // Traverse to the leftmost node\n    while (root !== null) {\n      stack.push(root); // Push the current node onto the stack\n      root = root.left; // Move to the left child\n    }\n\n    // Process the node at the top of the stack\n    root = stack.pop()!; // Pop the node from the stack\n    if (--k === 0) {\n      return root.val; // If k is 0, return the value of the current node\n    }\n\n    // Move to the right subtree\n    root = root.right;\n  }\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Using Recursion\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The problem of finding the \",(0,r.jsx)(e.code,{children:\"k\"}),\"-th smallest element in a binary search tree (BST) uses the properties of in-order traversal. In-order traversal of a BST visits nodes in ascending order of their values. Using this property, the algorithm collects node values in sorted order and directly retrieves the \",(0,r.jsx)(e.code,{children:\"k\"}),\"-th smallest value.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"The in-order traversal ensures that the values of the BST are visited in ascending order. By traversing the left subtree, then the current node, and finally the right subtree, the algorithm systematically collects sorted values.\"}),`\n`,(0,r.jsx)(e.p,{children:\"The algorithm recursively traverses the BST, appending node values to an array during the process. This array contains all node values in ascending order.\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Since the array is sorted, the \",(0,r.jsx)(e.code,{children:\"k\"}),\"-th smallest element corresponds to the element at index \",(0,r.jsx)(e.code,{children:\"k-1\"}),\" due to zero-based indexing. This makes retrieval efficient.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Define a helper function \",(0,r.jsx)(e.code,{children:\"inorderTraversal\"}),\" that:\",`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Takes a node \",(0,r.jsx)(e.code,{children:\"root\"}),\" and an array \",(0,r.jsx)(e.code,{children:\"arr\"}),\" as inputs.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Checks if the current node is \",(0,r.jsx)(e.code,{children:\"null\"}),\". If true, returns the array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Recursively traverses the left subtree by calling \",(0,r.jsx)(e.code,{children:\"inorderTraversal\"}),\" on \",(0,r.jsx)(e.code,{children:\"root.left\"}),\".\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Appends the current node's value to the array.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"Recursively traverses the right subtree by calling \",(0,r.jsx)(e.code,{children:\"inorderTraversal\"}),\" on \",(0,r.jsx)(e.code,{children:\"root.right\"}),\".\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Returns the array of values collected in sorted order.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Call \",(0,r.jsx)(e.code,{children:\"inorderTraversal\"}),\" on the root of the BST with an empty array to get all node values in sorted order.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Retrieve the \",(0,r.jsx)(e.code,{children:\"k\"}),\"-th smallest element by accessing the \",(0,r.jsx)(e.code,{children:\"(k-1)\"}),\"-th index of the sorted array.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Return this value as the result.\"}),`\n`]}),`\n`,(0,r.jsx)(l,{children:c}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The in-order traversal visits each node exactly once.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The array stores all node values, and the recursion stack may also use up to O(h) space, where \",(0,r.jsx)(e.code,{children:\"h\"}),\" is the height of the BST.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"2. Using Iteration\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The iterative approach for finding the \",(0,r.jsx)(e.code,{children:\"k\"}),\"-th smallest element in a binary search tree (BST) uses in-order traversal, which visits nodes in ascending order. Unlike the recursive approach, this method uses a stack to manage traversal, avoiding recursion and reducing the call stack usage.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"In-order traversal processes nodes in ascending order for a BST. By traversing the left subtree, visiting the root, and then traversing the right subtree, the nodes are visited sequentially in sorted order.\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Instead of traversing the entire tree, the algorithm keeps track of the number of nodes visited (\",(0,r.jsx)(e.code,{children:\"k\"}),\") and stops once the \",(0,r.jsx)(e.code,{children:\"k\"}),\"-th smallest node is found. This optimization ensures efficiency.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"The iterative approach avoids the overhead of recursion and uses the stack to manage traversal, with the stack size proportional to the height of the tree.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Initialize an empty stack to store nodes during traversal.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"While \",(0,r.jsx)(e.code,{children:\"true\"}),\" (infinite loop):\",`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Traverse to the leftmost node:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Push the current \",(0,r.jsx)(e.code,{children:\"root\"}),\" node onto the stack.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Move to the left child (\",(0,r.jsx)(e.code,{children:\"root = root.left\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Pop the node at the top of the stack:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Assign the popped node to \",(0,r.jsx)(e.code,{children:\"root\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Decrement \",(0,r.jsx)(e.code,{children:\"k\"}),\". If \",(0,r.jsx)(e.code,{children:\"k\"}),\" becomes \",(0,r.jsx)(e.code,{children:\"0\"}),\", return the value of the current node (\",(0,r.jsx)(e.code,{children:\"root.val\"}),\").\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Move to the right subtree (\",(0,r.jsx)(e.code,{children:\"root = root.right\"}),\").\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(l,{children:u}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(h + k)\"}),\". The algorithm visits up to \",(0,r.jsx)(e.code,{children:\"k\"}),\" nodes and explores a maximum depth of \",(0,r.jsx)(e.code,{children:\"h\"}),\" (height of the tree) in the leftmost traversal.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The stack stores nodes along the path to the leftmost node, which is proportional to the height of the tree.\"]}),`\n`]})]})}function I(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(m,t)})):m(t)}var N=I;return x(R);})();\n;return Component;"
}