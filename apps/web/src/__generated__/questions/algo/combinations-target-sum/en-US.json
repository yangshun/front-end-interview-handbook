{
  "description": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),T=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},a=(t,e,i,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!g.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(s=p(e,r))||s.enumerable});return t};var j=(t,e,i)=>(i=t!=null?m(f(t)):{},a(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),C=t=>a(o({},\"__esModule\",{value:!0}),t);var c=x((w,l)=>{l.exports=_jsx_runtime});var A={};T(A,{default:()=>X,frontmatter:()=>M});var n=j(c());var u=MDXTestExamples;var d=[{input:[[\"numbers\",[1,2,3]],[\"target\",4]],output:7,explanation:\"The possible combinations are: (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (1, 3), (2, 1, 1), (2, 2), (3, 1)\"},{input:[[\"numbers\",[7]],[\"target\",2]],output:0,explanation:\"There is no combination of elements in [7] that can add up to 2.\"},{input:[[\"numbers\",[2,4]],[\"target\",6]],output:3,explanation:\"The possible combinations are: (2, 2, 2), (2, 4), (4, 2)\"}];var M={title:\"Combinations for Target Sum\",excerpt:\"Implement a function to count combinations that sum to the target\"};function h(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a list of unique integers \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" and an integer \",(0,n.jsx)(e.code,{children:\"target\"}),\", find the number of different combinations of elements from \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" that sum up to target.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"target: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Test cases are chosen to guarantee the output falls within the limits of a 32-bit integer\"}),`\n`,(0,n.jsx)(e.li,{children:\"Combinations that consist of the same elements but differ in order are considered distinct\"}),`\n`]}),`\n`,(0,n.jsx)(u,{testCases:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 200\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"target\"}),\" <= 1000\"]}),`\n`,(0,n.jsx)(e.li,{children:\"All the elements of numbers are unique\"}),`\n`]})]})}function D(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var X=D;return C(A);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to count combinations that sum to the target",
    "title": "Combinations for Target Sum"
  },
  "solution": "var Component=(()=>{var b=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),w=(r,e)=>{for(var t in e)o(r,t,{get:e[t],enumerable:!0})},s=(r,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of f(e))!y.call(r,i)&&i!==t&&o(r,i,{get:()=>e[i],enumerable:!(c=g(e,i))||c.enumerable});return r};var T=(r,e,t)=>(t=r!=null?b(p(r)):{},s(e||!r||!r.__esModule?o(t,\"default\",{value:r,enumerable:!0}):t,r)),S=r=>s(o({},\"__esModule\",{value:!0}),r);var m=v((B,l)=>{l.exports=_jsx_runtime});var D={};w(D,{default:()=>z});var n=T(m());var a=MDXCodeBlock;var h=`export default function combinationTargetSum(\n  numbers: number[],\n  target: number,\n): number {\n  // Initialize a dynamic programming (DP) array to store the number of\n  // combinations for each sum up to the target\n  const dp: number[] = new Array(target + 1).fill(0);\n\n  // Base case: There's one way to reach a sum of 0 (using no elements)\n  dp[0] = 1;\n\n  // Iterate through all possible target sums from 1 to the actual target\n  for (let combSum = 1; combSum <= target; combSum++) {\n    // Iterate through each number in the 'nums' array\n    for (const num of numbers) {\n      // Check if the current number can be subtracted from the current target sum\n      // without going below zero. This ensures we only consider valid combinations\n      if (combSum - num >= 0) {\n        // If valid, add the number of combinations for the remaining sum\n        // (combSum - num) to the current sum's combination count. This leverages\n        // previously calculated subproblems\n        dp[combSum] += dp[combSum - num];\n      }\n    }\n  }\n\n  // The final element in the DP array (dp[target]) holds the number of\n  // combinations that add up to the target sum\n  return dp[target];\n}\n`;var u=`export default function combinationTargetSum(\n  numbers: number[],\n  target: number,\n): number {\n  // Initialize the memoization map\n  const memo = new Map<number, number>();\n\n  // Helper function for recursion with memoization\n  function combs(remain: number): number {\n    // Base case: if remaining target is 0, there is one valid combination\n    if (remain === 0) return 1;\n    // If the result for the current remaining target is already computed, return it\n    if (memo.has(remain)) return memo.get(remain)!;\n\n    let result = 0;\n    // Iterate through the numbers to calculate combinations\n    for (const num of numbers) {\n      // Only proceed if the remaining target after subtracting the current number is non-negative\n      if (remain - num >= 0) {\n        result += combs(remain - num);\n      }\n    }\n    // Store the computed result in the memoization map\n    memo.set(remain, result);\n    return result;\n  }\n\n  // Start the recursive function\n  return combs(target);\n}\n`;function d(r){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Bottom-Up Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:\"The dynamic programming approach to solve the combination target sum problem works by decomposing the problem into smaller subproblems. The key intuition is that the number of ways to achieve a particular sum can be derived from the number of ways to achieve smaller sums. By iteratively building up the solution from the smallest subproblem (sum 0) to the target sum, the algorithm ensures all intermediate results are reused.\"}),`\n`,(0,n.jsx)(e.p,{children:\"For each possible sum from 1 to the target, every number in the input array is considered. If the number can be subtracted from the current sum without resulting in a negative value, the combinations for the remaining sum are added to the current sum's combinations. This ensures that all valid contributions to the current sum are accounted for. The base case, where there is exactly one way to form a sum of 0 (by using no elements), ensures that the process starts correctly.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach avoids the inefficiency of a brute force solution, which would generate and check all possible subsets of the array. Instead, it builds the solution iteratively by using previously computed results, thereby eliminating redundant calculations and significantly reducing the runtime complexity.\"}),`\n`,(0,n.jsx)(a,{children:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array of size \",(0,n.jsx)(e.code,{children:\"target + 1\"}),\", filled with \",(0,n.jsx)(e.code,{children:\"0\"}),\". This array will store the number of combinations for each sum from \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"target\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"dp[0] = 1\"}),\" to represent the base case, where there is exactly one way to achieve a sum of \",(0,n.jsx)(e.code,{children:\"0\"}),\" (using no elements).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through all possible sums (\",(0,n.jsx)(e.code,{children:\"combSum\"}),\") from \",(0,n.jsx)(e.code,{children:\"1\"}),\" to \",(0,n.jsx)(e.code,{children:\"target\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each sum, iterate through the elements of the input array \",(0,n.jsx)(e.code,{children:\"numbers\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the current number can be subtracted from \",(0,n.jsx)(e.code,{children:\"combSum\"}),\" without resulting in a negative value. This ensures only valid combinations are considered.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If valid, update \",(0,n.jsx)(e.code,{children:\"dp[combSum]\"}),\" by adding the value of \",(0,n.jsx)(e.code,{children:\"dp[combSum - num]\"}),\". This adds the number of ways to achieve the remaining sum (\",(0,n.jsx)(e.code,{children:\"combSum - num\"}),\") to the current sum's count.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"dp[target]\"}),\", which holds the number of distinct combinations to achieve the target sum.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n.t)\"}),\". The algorithm iterates over all sums from \",(0,n.jsx)(e.code,{children:\"1\"}),\" to \",(0,n.jsx)(e.code,{children:\"target\"}),\" (outer loop) and processes each element in the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array (inner loop).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(t)\"}),\". The \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array requires space proportional to the target value.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Top-Down Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:\"The top-down dynamic programming approach uses recursion with memoization. The key idea is to break the problem into smaller subproblems by considering the remaining target after subtracting each number in the array. For a given target, the number of combinations is the sum of combinations for smaller targets that can be formed by subtracting each number.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach avoids the inefficiency of recalculating results for overlapping subproblems, a common bottleneck in a brute force recursive solution. Memoization stores the results of previously solved subproblems in a map, allowing constant-time retrieval for subsequent calculations. This reduces redundant computations and improves efficiency compared to a naive recursive method.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"memo\"}),\" map to store the number of combinations for each remaining target.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a recursive helper function \",(0,n.jsx)(e.code,{children:\"combs(remain)\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check if \",(0,n.jsx)(e.code,{children:\"remain\"}),\" equals 0. If so, return 1 as there is one valid combination (using no additional numbers).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the \",(0,n.jsx)(e.code,{children:\"memo\"}),\" map contains the result for \",(0,n.jsx)(e.code,{children:\"remain\"}),\", return the stored value to avoid redundant calculations.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a variable \",(0,n.jsx)(e.code,{children:\"result\"}),\" to 0 to store the number of combinations for the current \",(0,n.jsx)(e.code,{children:\"remain\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through each number in the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"remain - num\"}),\" is non-negative, recursively call \",(0,n.jsx)(e.code,{children:\"combs(remain - num)\"}),\" and add the result to \",(0,n.jsx)(e.code,{children:\"result\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Store the computed \",(0,n.jsx)(e.code,{children:\"result\"}),\" in the \",(0,n.jsx)(e.code,{children:\"memo\"}),\" map for future reference.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the result of calling \",(0,n.jsx)(e.code,{children:\"combs(target)\"}),\" as the total number of combinations for the given target.\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n.t)\"}),\". Each subproblem for a target value is solved once, and solving each involves iterating through \",(0,n.jsx)(e.code,{children:\"numbers\"}),\"..\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(t)\"}),\". The \",(0,n.jsx)(e.code,{children:\"memo\"}),\" map stores results for up to \",(0,n.jsx)(e.code,{children:\"target\"}),\" different values, and the recursion stack can go as deep as \",(0,n.jsx)(e.code,{children:\"target\"}),\" in the worst case.\"]}),`\n`]})]})}function k(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(d,r)})):d(r)}var z=k;return S(D);})();\n;return Component;"
}