{
  "description": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),q=(t,e)=>{for(var s in e)r(t,s,{get:e[s],enumerable:!0})},i=(t,e,s,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!b.call(t,o)&&o!==s&&r(t,o,{get:()=>e[o],enumerable:!(c=p(e,o))||c.enumerable});return t};var z=(t,e,s)=>(s=t!=null?m(x(t)):{},i(e||!t||!t.__esModule?r(s,\"default\",{value:t,enumerable:!0}):s,t)),y=t=>i(r({},\"__esModule\",{value:!0}),t);var d=f((A,l)=>{l.exports=_jsx_runtime});var T={};q(T,{default:()=>C,frontmatter:()=>w});var n=z(d());var h=MDXTestExamples;var a=[{input:[[\"str1\",\"xyz\"],[\"str2\",\"axabz\"]],output:2,explanation:\"The longest common subsequence is 'xz'.\"},{input:[[\"str1\",\"xyz\"],[\"str2\",\"xyz\"]],output:3,explanation:\"The longest common subsequence is 'xyz'.\"},{input:[[\"str1\",\"xyz\"],[\"str2\",\"pqr\"]],output:0,explanation:\"There is no common subsequence.\"}];var w={title:\"Longest Common Subsequence\",excerpt:\"Implement a function to find the longest common subsequence in two strings\"};function u(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given two strings, \",(0,n.jsx)(e.code,{children:\"str1\"}),\" and \",(0,n.jsx)(e.code,{children:\"str2\"}),\", find the length of their longest common subsequence. If no common subsequence exists, return \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, the subsequences of \",(0,n.jsx)(e.code,{children:\"abc\"}),\" are ``, \",(0,n.jsx)(e.code,{children:\"a\"}),\", \",(0,n.jsx)(e.code,{children:\"b\"}),\", \",(0,n.jsx)(e.code,{children:\"c\"}),\", \",(0,n.jsx)(e.code,{children:\"ab\"}),\", \",(0,n.jsx)(e.code,{children:\"ac\"}),\", \",(0,n.jsx)(e.code,{children:\"bc\"}),\", and \",(0,n.jsx)(e.code,{children:\"abc\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A common subsequence between two strings refers to a subsequence that appears in both string sequences in the same relative order. For example, in the strings \",(0,n.jsx)(e.code,{children:\"xyz\"}),\" and \",(0,n.jsx)(e.code,{children:\"axabz\"}),\", the longest common subsequence is \",(0,n.jsx)(e.code,{children:\"xz\"}),\", and therefore, the length of the longest common subsequence is 2.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str1: string\"}),\": A string\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str2: string\"}),\": A string\"]}),`\n`]}),`\n`,(0,n.jsx)(h,{testCases:a}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"str1.length\"}),\", \",(0,n.jsx)(e.code,{children:\"str2.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str1\"}),\" and \",(0,n.jsx)(e.code,{children:\"str2\"}),\" consist of only lowercase English characters\"]}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var C=_;return y(T);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the longest common subsequence in two strings",
    "title": "Longest Common Subsequence"
  },
  "solution": "var Component=(()=>{var f=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var n in e)i(t,n,{get:e[n],enumerable:!0})},s=(t,e,n,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of w(e))!b.call(t,o)&&o!==n&&i(t,o,{get:()=>e[o],enumerable:!(c=p(e,o))||c.enumerable});return t};var R=(t,e,n)=>(n=t!=null?f(x(t)):{},s(e||!t||!t.__esModule?i(n,\"default\",{value:t,enumerable:!0}):n,t)),O=t=>s(i({},\"__esModule\",{value:!0}),t);var h=y((S,d)=>{d.exports=_jsx_runtime});var C={};v(C,{default:()=>q});var r=R(h());var l=MDXCodeBlock;var a=`// Initialize a 2D array for memoization\nconst dp: number[][] = Array.from({ length: 1001 }, () => Array(1001).fill(-1));\n\n// Recursive function to find the length of the longest common subsequence\nfunction lcs(\n  str1: string,\n  str2: string,\n  index1: number,\n  index2: number,\n): number {\n  // Check if the result is already computed\n  if (dp[index1][index2] !== -1) {\n    return dp[index1][index2];\n  }\n\n  // Base case: if any string is exhausted, return 0\n  if (index1 === str1.length || index2 === str2.length) {\n    return 0;\n  }\n\n  // If characters match, move both indices and add 1 to the result\n  if (str1[index1] === str2[index2]) {\n    dp[index1][index2] = 1 + lcs(str1, str2, index1 + 1, index2 + 1);\n  } else {\n    // If characters don't match, find the max between skipping one character in either string\n    dp[index1][index2] = Math.max(\n      lcs(str1, str2, index1 + 1, index2),\n      lcs(str1, str2, index1, index2 + 1),\n    );\n  }\n\n  return dp[index1][index2];\n}\n\nexport default function longestCommonSubsequence(\n  str1: string,\n  str2: string,\n): number {\n  // Initialize the dp array with -1\n  for (let i = 0; i <= 1000; i++) {\n    for (let j = 0; j <= 1000; j++) {\n      dp[i][j] = -1;\n    }\n  }\n  // Start the recursion\n  return lcs(str1, str2, 0, 0);\n}\n`;var u=`export default function longestCommonSubsequence(\n  str1: string,\n  str2: string,\n): number {\n  // Create a 2D array (grid) of zeros with dimensions (str1.length + 1) x (str2.length + 1)\n  const dpGrid: number[][] = Array.from({ length: str1.length + 1 }, () =>\n    Array(str2.length + 1).fill(0),\n  );\n\n  // Iterate through each column starting from the last one\n  for (let col = str2.length - 1; col >= 0; col--) {\n    for (let row = str1.length - 1; row >= 0; row--) {\n      // If the characters at the current positions in both strings are the same\n      if (str1[row] === str2[col]) {\n        // Set the current cell to 1 plus the value from the diagonally next cell\n        dpGrid[row][col] = 1 + dpGrid[row + 1][col + 1];\n      } else {\n        // Otherwise, take the maximum value from the cell directly below or the cell to the right\n        dpGrid[row][col] = Math.max(dpGrid[row + 1][col], dpGrid[row][col + 1]);\n      }\n    }\n  }\n\n  // The answer to the problem is in the top-left cell of the grid\n  return dpGrid[0][0];\n}\n`;var m=`export default function longestCommonSubsequence(\n  str1: string,\n  str2: string,\n): number {\n  // Create two rows for DP, initialized with zeros\n  let currentRow: number[] = Array(str2.length + 1).fill(0);\n  let nextRow: number[] = Array(str2.length + 1).fill(0);\n\n  // Iterate through str1 from bottom to top\n  for (let row = str1.length - 1; row >= 0; row--) {\n    // Swap rows: \\`currentRow\\` becomes \\`nextRow\\`, and vice versa\n    [currentRow, nextRow] = [nextRow, currentRow];\n\n    // Iterate through str2 from right to left\n    for (let col = str2.length - 1; col >= 0; col--) {\n      if (str1[row] === str2[col]) {\n        // If characters match, take 1 + diagonal value from \\`nextRow\\`\n        currentRow[col] = 1 + nextRow[col + 1];\n      } else {\n        // Otherwise, take max of right or below values\n        currentRow[col] = Math.max(nextRow[col], currentRow[col + 1]);\n      }\n    }\n  }\n\n  // The result is stored in \\`currentRow[0]\\` after the final iteration\n  return currentRow[0];\n}\n`;function g(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Using Dynamic Programming\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The dynamic programming approach for the longest common subsequence problem builds a 2D grid (\",(0,r.jsx)(e.code,{children:\"dpGrid\"}),\") where each cell represents the length of the longest common subsequence for the corresponding substrings of the two input strings. The solution iteratively fills the grid from the bottom-right corner to the top-left, leveraging the results of smaller subproblems to calculate larger ones. This approach avoids redundant calculations and ensures an optimal solution by systematically considering all possibilities.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize a 2D array \",(0,r.jsx)(e.code,{children:\"dpGrid\"}),\" with dimensions \",(0,r.jsx)(e.code,{children:\"(str1.length + 1) x (str2.length + 1)\"}),\" filled with zeros.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate through the grid starting from the bottom-right corner:\",`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"For each character in \",(0,r.jsx)(e.code,{children:\"str2\"}),\" (columns, right to left):\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"For each character in \",(0,r.jsx)(e.code,{children:\"str1\"}),\" (rows, bottom to top):\",`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If the characters at the current positions in both strings are equal, set the current cell in \",(0,r.jsx)(e.code,{children:\"dpGrid\"}),\" to \",(0,r.jsx)(e.code,{children:\"1 + dpGrid[row + 1][col + 1]\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Otherwise, set the current cell to the maximum value between \",(0,r.jsx)(e.code,{children:\"dpGrid[row + 1][col]\"}),\" (below) and \",(0,r.jsx)(e.code,{children:\"dpGrid[row][col + 1]\"}),\" (right).\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The top-left cell of \",(0,r.jsx)(e.code,{children:\"dpGrid\"}),\" contains the length of the longest common subsequence for \",(0,r.jsx)(e.code,{children:\"str1\"}),\" and \",(0,r.jsx)(e.code,{children:\"str2\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Return the value in \",(0,r.jsx)(e.code,{children:\"dpGrid[0][0]\"}),\".\"]}),`\n`]}),`\n`,(0,r.jsx)(l,{children:u}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". The solution involves filling a grid of size \",(0,r.jsx)(e.code,{children:\"m x n\"}),\", where \",(0,r.jsx)(e.code,{children:\"m\"}),\" is the length of \",(0,r.jsx)(e.code,{children:\"str1\"}),\" and \",(0,r.jsx)(e.code,{children:\"n\"}),\" is the length of \",(0,r.jsx)(e.code,{children:\"str2\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(m.n)\"}),\". The \",(0,r.jsx)(e.code,{children:\"dpGrid\"}),\" requires space proportional to the product of the lengths of the two strings.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"2. Using Dynamic Programming With Optimized Space\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Instead of using a full DP table, only two rows are maintained at a time to store intermediate results. A traditional DP solution uses a 2D table of size \",(0,r.jsx)(e.code,{children:\"(m+1) x (n+1)\"}),\" to store results for all substrings of \",(0,r.jsx)(e.code,{children:\"str1\"}),\" and \",(0,r.jsx)(e.code,{children:\"str2\"}),\", leading to a space complexity of O(m.n). However, at any point, only the current row and the previous row are required to compute the next row's values. This leads to an optimized solution with O(n) space complexity by recycling the rows.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"The optimized approach eliminates unnecessary storage by maintaining two rows: \",(0,r.jsx)(e.code,{children:\"currentRow\"}),\" for storing results of the current state and \",(0,r.jsx)(e.code,{children:\"nextRow\"}),\" for storing results of the previous state. The algorithm iterates over the strings in reverse order, updating the rows efficiently. By leveraging the relationship between \",(0,r.jsx)(e.code,{children:\"currentRow\"}),\" and \",(0,r.jsx)(e.code,{children:\"nextRow\"}),\", the solution calculates the LCS without constructing the entire DP table.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize two arrays, \",(0,r.jsx)(e.code,{children:\"currentRow\"}),\" and \",(0,r.jsx)(e.code,{children:\"nextRow\"}),\", with zeros, each having a size of \",(0,r.jsx)(e.code,{children:\"str2.length + 1\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate through \",(0,r.jsx)(e.code,{children:\"str1\"}),\" from bottom to top (index \",(0,r.jsx)(e.code,{children:\"row\"}),\" starts from \",(0,r.jsx)(e.code,{children:\"str1.length - 1\"}),\" and decreases to \",(0,r.jsx)(e.code,{children:\"0\"}),\").\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Swap the roles of \",(0,r.jsx)(e.code,{children:\"currentRow\"}),\" and \",(0,r.jsx)(e.code,{children:\"nextRow\"}),\". This ensures \",(0,r.jsx)(e.code,{children:\"currentRow\"}),\" holds results for the current iteration and \",(0,r.jsx)(e.code,{children:\"nextRow\"}),\" holds results for the previous iteration.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"For each character of \",(0,r.jsx)(e.code,{children:\"str2\"}),\", iterate from right to left (index \",(0,r.jsx)(e.code,{children:\"col\"}),\" starts from \",(0,r.jsx)(e.code,{children:\"str2.length - 1\"}),\" and decreases to \",(0,r.jsx)(e.code,{children:\"0\"}),\"):\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If \",(0,r.jsx)(e.code,{children:\"str1[row] === str2[col]\"}),\", set \",(0,r.jsx)(e.code,{children:\"currentRow[col]\"}),\" to \",(0,r.jsx)(e.code,{children:\"1 + nextRow[col + 1]\"}),\", representing the diagonal value plus one.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Otherwise, set \",(0,r.jsx)(e.code,{children:\"currentRow[col]\"}),\" to the maximum of \",(0,r.jsx)(e.code,{children:\"nextRow[col]\"}),\" and \",(0,r.jsx)(e.code,{children:\"currentRow[col + 1]\"}),\", representing the maximum value between skipping the current character of either \",(0,r.jsx)(e.code,{children:\"str1\"}),\" or \",(0,r.jsx)(e.code,{children:\"str2\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"After completing the iterations, the result is stored in \",(0,r.jsx)(e.code,{children:\"currentRow[0]\"}),\".\"]}),`\n`]}),`\n`,(0,r.jsx)(l,{children:m}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Two nested loops are used: one iterating over the length of \",(0,r.jsx)(e.code,{children:\"str1\"}),\" (m) and the other iterating over the length of \",(0,r.jsx)(e.code,{children:\"str2\"}),\" (n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". Only two rows, each of size \",(0,r.jsx)(e.code,{children:\"n+1\"}),\", are used for computation, reducing space usage from O(m.n) to O(n).\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"3. Using Memoization\"}),`\n`,(0,r.jsx)(e.p,{children:\"The key intuition behind the memoization approach for solving the longest common subsequence problem is to avoid redundant calculations by storing the results of previously solved subproblems. This ensures that each unique pair of indices from the two strings is processed only once. By dividing the problem into smaller overlapping subproblems and storing their results, the solution efficiently combines these results to find the overall longest common subsequence.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Create a 2D \",(0,r.jsx)(e.code,{children:\"dp\"}),\" array initialized with \",(0,r.jsx)(e.code,{children:\"-1\"}),\" to store results of subproblems.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Define a recursive function \",(0,r.jsx)(e.code,{children:\"lcs\"}),\" that takes the two strings, \",(0,r.jsx)(e.code,{children:\"str1\"}),\" and \",(0,r.jsx)(e.code,{children:\"str2\"}),\", along with indices \",(0,r.jsx)(e.code,{children:\"index1\"}),\" and \",(0,r.jsx)(e.code,{children:\"index2\"}),\" as arguments:\",`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Check if the result for the current indices is already computed in the \",(0,r.jsx)(e.code,{children:\"dp\"}),\" array. If it is, return the stored value.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If either index reaches the end of its respective string, return \",(0,r.jsx)(e.code,{children:\"0\"}),\" as there is no common subsequence beyond that point.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the characters at the current indices match, compute the result as \",(0,r.jsx)(e.code,{children:\"1 + lcs(str1, str2, index1 + 1, index2 + 1)\"}),\" and store it in the \",(0,r.jsx)(e.code,{children:\"dp\"}),\" array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the characters do not match, compute the maximum of skipping one character in either string and store it in the \",(0,r.jsx)(e.code,{children:\"dp\"}),\" array.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Call the \",(0,r.jsx)(e.code,{children:\"lcs\"}),\" function starting from indices \",(0,r.jsx)(e.code,{children:\"0\"}),\" and \",(0,r.jsx)(e.code,{children:\"0\"}),\" for \",(0,r.jsx)(e.code,{children:\"str1\"}),\" and \",(0,r.jsx)(e.code,{children:\"str2\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Return the value computed by \",(0,r.jsx)(e.code,{children:\"lcs\"}),\" for the full strings.\"]}),`\n`]}),`\n`,(0,r.jsx)(l,{children:a}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Each subproblem is solved at most once, where \",(0,r.jsx)(e.code,{children:\"m\"}),\" is the length of \",(0,r.jsx)(e.code,{children:\"str1\"}),\" and \",(0,r.jsx)(e.code,{children:\"n\"}),\" is the length of \",(0,r.jsx)(e.code,{children:\"str2\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(m.n)\"}),\". The \",(0,r.jsx)(e.code,{children:\"dp\"}),\" array requires space proportional to the product of the lengths of the two strings.\"]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(g,t)})):g(t)}var q=T;return O(C);})();\n;return Component;"
}