{
  "description": "var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var o in e)l(n,o,{get:e[o],enumerable:!0})},c=(n,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!w.call(n,r)&&r!==o&&l(n,r,{get:()=>e[r],enumerable:!(a=p(e,r))||a.enumerable});return n};var j=(n,e,o)=>(o=n!=null?u(x(n)):{},c(e||!n||!n.__esModule?l(o,\"default\",{value:n,enumerable:!0}):o,n)),_=n=>c(l({},\"__esModule\",{value:!0}),n);var h=g((F,i)=>{i.exports=_jsx_runtime});var M={};b(M,{default:()=>C,frontmatter:()=>D});var t=j(h());var s=MDXTestExamples;var d=[{input:[[\"matrix\",[[1,2,3,1],[4,3,3,4],[5,2,4,3],[5,2,1,5],[1,5,1,3]]]],output:[[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,2],[3,0],[4,0],[4,1]],explanation:\"The listed cells are capable of reaching both oceans. For instance, the cell at (row 0, column 2) can flow directly to the top left ocean, and then from (row 0, column 2) it can reach the bottom right ocean through (row 0, column 3).\"},{input:[[\"matrix\",[[1]]]],output:[[0,0]],explanation:\"The only cell can flow to both oceans.\"},{input:[[\"matrix\",[[1,2,3],[4,5,6],[7,8,9]]]],output:[[0,2],[1,2],[2,0],[2,1],[2,2]],explanation:\"The listed cells are capable of reaching both oceans\"}];var D={title:\"Ocean Flow\",excerpt:\"Implement a function returning cells with water flow to both oceans\"};function m(n){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given an \",(0,t.jsx)(e.code,{children:\"m\"}),\" x \",(0,t.jsx)(e.code,{children:\"n\"}),\" 2D \",(0,t.jsx)(e.code,{children:\"matrix\"}),\" representing an island bordered by the two different oceans, one on the left and top edges and another on the right and bottom edges, determine which cells can allow rainwater to flow to both oceans. Each cell contains an integer representing its height above sea level.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Water can flow from one cell to another if the adjacent cell\\u2019s height is less than or equal to the current cell's height. Adjacent cells refers to cells directly north, south, west, and east of the a cell.\"}),`\n`,(0,t.jsx)(e.p,{children:\"Return a list of all cells from which water can flow to both oceans in sorted order, based on their position when traversing the matrix from the top-left to the bottom-right\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"matrix: number[][]\"}),\": A 2D array of integers\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,t.jsx)(s,{testCases:d}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"1 <= \",(0,t.jsx)(e.code,{children:\"m\"}),\", \",(0,t.jsx)(e.code,{children:\"n\"}),\" <= 100\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"0 <= \",(0,t.jsx)(e.code,{children:\"matrix[row][col]\"}),\" <= 100,000\"]}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var C=T;return _(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function returning cells with water flow to both oceans",
    "title": "Ocean Flow"
  },
  "solution": "var Component=(()=>{var f=Object.create;var r=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var R=(l,e)=>()=>(e||l((e={exports:{}}).exports,e),e.exports),C=(l,e)=>{for(var t in e)r(l,t,{get:e[t],enumerable:!0})},a=(l,e,t,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of b(e))!p.call(l,o)&&o!==t&&r(l,o,{get:()=>e[o],enumerable:!(i=w(e,o))||i.enumerable});return l};var x=(l,e,t)=>(t=l!=null?f(g(l)):{},a(e||!l||!l.__esModule?r(t,\"default\",{value:l,enumerable:!0}):t,l)),y=l=>a(r({},\"__esModule\",{value:!0}),l);var s=R((O,h)=>{h.exports=_jsx_runtime});var A={};C(A,{default:()=>B});var n=x(s());var c=MDXCodeBlock;var d=`const DIRECTIONS: number[][] = [\n  [0, 1],\n  [1, 0],\n  [-1, 0],\n  [0, -1],\n];\n\nexport default function oceanFlow(matrix: number[][]): number[][] {\n  // Check if input is empty\n  if (matrix.length === 0 || matrix[0].length === 0) {\n    return [];\n  }\n\n  const numRows = matrix.length;\n  const numCols = matrix[0].length;\n\n  function dfs(row: number, col: number, reachable: boolean[][]): void {\n    // This cell is reachable, so mark it\n    reachable[row][col] = true;\n    for (const dir of DIRECTIONS) {\n      // Check all 4 directions\n      const newRow = row + dir[0];\n      const newCol = col + dir[1];\n      // Check if new cell is within bounds\n      if (newRow < 0 || newRow >= numRows || newCol < 0 || newCol >= numCols) {\n        continue;\n      }\n      // Check that the new cell hasn't already been visited\n      if (reachable[newRow][newCol]) {\n        continue;\n      }\n      // Check that the new cell has a higher or equal height,\n      // So that water can flow from the new cell to the old cell\n      if (matrix[newRow][newCol] < matrix[row][col]) {\n        continue;\n      }\n      // If we've gotten this far, that means the new cell is reachable\n      dfs(newRow, newCol, reachable);\n    }\n  }\n\n  const oceanTopLeftReachable: boolean[][] = Array.from(Array(numRows), () =>\n    Array(numCols).fill(false),\n  );\n  const oceanBottomRightReachable: boolean[][] = Array.from(\n    Array(numRows),\n    () => Array(numCols).fill(false),\n  );\n\n  // Explore each cell adjacent to the oceans and start a DFS\n  for (let row = 0; row < numRows; row++) {\n    dfs(row, 0, oceanTopLeftReachable); // Left edge\n    dfs(row, numCols - 1, oceanBottomRightReachable); // Right edge\n  }\n\n  for (let col = 0; col < numCols; col++) {\n    dfs(0, col, oceanTopLeftReachable); // Top edge\n    dfs(numRows - 1, col, oceanBottomRightReachable); // Bottom edge\n  }\n\n  // Find all cells that can reach both oceans\n  const commonCells: number[][] = [];\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      if (\n        oceanTopLeftReachable[row][col] &&\n        oceanBottomRightReachable[row][col]\n      ) {\n        commonCells.push([row, col]);\n      }\n    }\n  }\n\n  return commonCells;\n}\n`;var u=`const DIRECTIONS: number[][] = [\n  [0, 1],\n  [1, 0],\n  [-1, 0],\n  [0, -1],\n];\n\nexport default function oceanFlow(matrix: number[][]): number[][] {\n  // Check if input is empty\n  if (matrix.length === 0 || matrix[0].length === 0) {\n    return [];\n  }\n\n  const numRows = matrix.length;\n  const numCols = matrix[0].length;\n\n  function bfs(queue: number[][]): boolean[][] {\n    const reachable: boolean[][] = Array.from({ length: numRows }, () =>\n      Array(numCols).fill(false),\n    );\n    while (queue.length > 0) {\n      const cell = queue.shift() as number[];\n      // This cell is reachable, so mark it\n      reachable[cell[0]][cell[1]] = true;\n      for (const dir of DIRECTIONS) {\n        // Check all 4 directions\n        const newRow = cell[0] + dir[0];\n        const newCol = cell[1] + dir[1];\n        // Check if new cell is within bounds\n        if (\n          newRow < 0 ||\n          newRow >= numRows ||\n          newCol < 0 ||\n          newCol >= numCols\n        ) {\n          continue;\n        }\n        // Check that the new cell hasn't already been visited\n        if (reachable[newRow][newCol]) {\n          continue;\n        }\n        // Check that the new cell has a higher or equal height,\n        // So that water can flow from the new cell to the old cell\n        if (matrix[newRow][newCol] < matrix[cell[0]][cell[1]]) {\n          continue;\n        }\n        // If we've gotten this far, that means the new cell is reachable\n        queue.push([newRow, newCol]);\n      }\n    }\n    return reachable;\n  }\n\n  // Setup each queue with cells adjacent to their respective ocean\n  const oceanTopLeftQueue: number[][] = [];\n  const oceanBottomRightQueue: number[][] = [];\n\n  for (let row = 0; row < numRows; row++) {\n    oceanTopLeftQueue.push([row, 0]); // Left edge\n    oceanBottomRightQueue.push([row, numCols - 1]); // Right edge\n  }\n\n  for (let col = 0; col < numCols; col++) {\n    oceanTopLeftQueue.push([0, col]); // Top edge\n    oceanBottomRightQueue.push([numRows - 1, col]); // Bottom edge\n  }\n\n  // Perform a BFS for each ocean to find all cells accessible by each ocean\n  const oceanTopLeftReachable = bfs(oceanTopLeftQueue);\n  const oceanBottomRightReachable = bfs(oceanBottomRightQueue);\n\n  // Find all cells that can reach both oceans\n  const commonCells: number[][] = [];\n\n  for (let row = 0; row < numRows; row++) {\n    for (let col = 0; col < numCols; col++) {\n      if (\n        oceanTopLeftReachable[row][col] &&\n        oceanBottomRightReachable[row][col]\n      ) {\n        commonCells.push([row, col]);\n      }\n    }\n  }\n\n  return commonCells;\n}\n`;function m(l){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",h3:\"h3\",ol:\"ol\",code:\"code\",strong:\"strong\"},l.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using depth-first search\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem involves finding cells in a matrix from which water can flow to both the Pacific Ocean (top and left edges) and the Atlantic Ocean (bottom and right edges). The solution uses a depth-first search (DFS) to explore reachable cells starting from each ocean's boundary.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The intuition behind the approach is to treat the problem as a connectivity graph:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:'A cell is \"connected\" to an ocean if water can flow to that ocean.'}),`\n`,(0,n.jsx)(e.li,{children:\"A cell is considered reachable if all neighboring cells it flows to are at a height greater than or equal to its own.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"The algorithm uses two boolean matrices to track reachability for the Pacific and Atlantic Oceans. Starting DFS from the respective ocean boundaries ensures that only valid paths are explored. After processing, the intersection of the two reachability matrices gives the desired cells.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define the \",(0,n.jsx)(e.code,{children:\"DIRECTIONS\"}),\" array to represent the four possible movements (up, down, left, right).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two 2D boolean matrices: \",(0,n.jsx)(e.code,{children:\"oceanTopLeftReachable\"}),\" and \",(0,n.jsx)(e.code,{children:\"oceanBottomRightReachable\"}),\", to mark cells reachable from the Pacific and Atlantic Oceans respectively.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define the \",(0,n.jsx)(e.code,{children:\"dfs\"}),\" function:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Mark the current cell as reachable in the given boolean matrix.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Explore all valid neighboring cells that:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Are within bounds.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Are not already visited.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Have a height greater than or equal to the current cell.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Start DFS from the boundaries of the Pacific Ocean:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Traverse the top row and left column of the matrix.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Start DFS from the boundaries of the Atlantic Ocean:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Traverse the bottom row and right column of the matrix.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through all cells in the matrix:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Add a cell to the result if it is marked as reachable in both \",(0,n.jsx)(e.code,{children:\"oceanTopLeftReachable\"}),\" and \",(0,n.jsx)(e.code,{children:\"oceanBottomRightReachable\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the list of cells that can flow to both oceans.\"}),`\n`]}),`\n`,(0,n.jsx)(c,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Each cell is visited at most once during DFS, and the matrix has \",(0,n.jsx)(e.code,{children:\"m.n\"}),\" cells.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(m.n)\"}),\". Two boolean matrices of size \",(0,n.jsx)(e.code,{children:\"m.n\"}),\" are used to track reachability, and the call stack for DFS can reach \",(0,n.jsx)(e.code,{children:\"m.n\"}),\" in the worst case.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using breadth-first search\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem involves identifying cells in a matrix from which water can flow to both the Pacific Ocean (top and left edges) and the Atlantic Ocean (bottom and right edges). Using a breadth-first search (BFS) ensures that the flow constraints are met while exploring all valid cells. Each cell must have a height greater than or equal to its adjacent cells for water to flow in reverse.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This solution uses two BFS traversals:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"One starting from the Pacific Ocean's boundary.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Another starting from the Atlantic Ocean's boundary.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Cells reachable from both BFS traversals are the desired result.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define the \",(0,n.jsx)(e.code,{children:\"DIRECTIONS\"}),\" array to represent the four possible movements (up, down, left, right).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Implement the \",(0,n.jsx)(e.code,{children:\"bfs\"}),\" function:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"reachable\"}),\" boolean matrix to track cells accessible during the traversal.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Use a queue to process cells iteratively.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"For each cell:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Mark it as reachable.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Enqueue all valid neighboring cells:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Ensure the neighbor is within bounds.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Ensure the neighbor hasn't been visited yet.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Ensure the neighbor has a height greater than or equal to the current cell.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the \",(0,n.jsx)(e.code,{children:\"reachable\"}),\" matrix.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Prepare queues for BFS:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The Pacific queue starts from the top row and left column.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The Atlantic queue starts from the bottom row and right column.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform BFS for both oceans using the \",(0,n.jsx)(e.code,{children:\"bfs\"}),\" function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through all cells in the matrix:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Add cells to the result if they are reachable from both the Pacific and Atlantic oceans.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the list of common cells.\"}),`\n`]}),`\n`,(0,n.jsx)(c,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Each cell is processed at most once during BFS.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(m.n)\"}),\". Two boolean matrices are used for tracking reachability, and BFS uses a queue that may grow to the size of the matrix.\"]}),`\n`]})]})}function S(l={}){let{wrapper:e}=l.components||{};return e?(0,n.jsx)(e,Object.assign({},l,{children:(0,n.jsx)(m,l)})):m(l)}var B=S;return y(A);})();\n;return Component;"
}