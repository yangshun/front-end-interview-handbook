{
  "description": "var Component=(()=>{var p=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)l(t,r,{get:e[r],enumerable:!0})},s=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of f(e))!b.call(t,i)&&i!==r&&l(t,i,{get:()=>e[i],enumerable:!(o=m(e,i))||o.enumerable});return t};var j=(t,e,r)=>(r=t!=null?p(x(t)):{},s(e||!t||!t.__esModule?l(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>s(l({},\"__esModule\",{value:!0}),t);var u=g((X,c)=>{c.exports=_jsx_runtime});var D={};y(D,{default:()=>w,frontmatter:()=>M});var n=j(u());var a=MDXTestExamples;var d=[{input:[[\"numbers\",[1,2,3]]],output:[6,3,2],explanation:\"Output is multiplication of all other elements except self, i.e 2*3, 1*3, 1*2\"},{input:[[\"numbers\",[2,0,3]]],output:[0,6,0],explanation:\"Output is multiplication of all other elements except self, i.e 0*3, 2*3, 2*0\"},{input:[[\"numbers\",[0,0,-1,1]]],output:[0,0,0,0],explanation:\"Output is multiplication of all other elements except self, i.e 0*-1*1, 0*-1*1, 0*0*1, 0*0*-1\"}];var M={title:\"Array Product Excluding Current\",excerpt:\"Implement a function to find the product of elements in an array excluding the current element\"};function h(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of integers \",(0,n.jsx)(e.code,{children:\"numbers\"}),\", return a new array \",(0,n.jsx)(e.code,{children:\"result\"}),\" where each element \",(0,n.jsx)(e.code,{children:\"result[i]\"}),\" represents the product of all the elements in \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" except for \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The product of any prefix or suffix of the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array is ensured to fit within a 32-bit integer\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Use of the division operator is prohibited\"}),`\n`]}),`\n`,(0,n.jsx)(a,{testCases:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"2 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 10\"]}),`\n`]})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var w=O;return _(D);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the product of elements in an array excluding the current element",
    "title": "Array Product Excluding Current"
  },
  "solution": "var Component=(()=>{var p=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)l(t,i,{get:e[i],enumerable:!0})},h=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of x(e))!y.call(t,n)&&n!==i&&l(t,n,{get:()=>e[n],enumerable:!(o=m(e,n))||o.enumerable});return t};var v=(t,e,i)=>(i=t!=null?p(g(t)):{},h(e||!t||!t.__esModule?l(i,\"default\",{value:t,enumerable:!0}):i,t)),C=t=>h(l({},\"__esModule\",{value:!0}),t);var d=b((I,a)=>{a.exports=_jsx_runtime});var O={};w(O,{default:()=>z});var r=v(d());var c=MDXCodeBlock;var s=`export default function arrayProductExcludingCurrent(\n  numbers: number[],\n): number[] {\n  const n = numbers.length;\n\n  // Create prefix and suffix arrays\n  const prefix: number[] = new Array(n).fill(1);\n  const suffix: number[] = new Array(n).fill(1);\n  const result: number[] = new Array(n).fill(1);\n\n  // Step 1: Fill prefix array\n  prefix[0] = 1; // First element has no elements to its left\n  for (let i = 1; i < n; i++) {\n    prefix[i] = prefix[i - 1] * numbers[i - 1];\n  }\n\n  // Step 2: Fill suffix array\n  suffix[n - 1] = 1; // Last element has no elements to its right\n  for (let i = n - 2; i >= 0; i--) {\n    suffix[i] = suffix[i + 1] * numbers[i + 1];\n  }\n\n  // Step 3: Calculate result array by combining prefix and suffix\n  for (let i = 0; i < n; i++) {\n    result[i] = prefix[i] * suffix[i];\n  }\n\n  // Step 4: Convert -0 to 0 if needed\n  for (let i = 0; i < n; i++) {\n    if (result[i] === -0) {\n      result[i] = 0;\n    }\n  }\n\n  return result;\n}\n`;var u=`export default function arrayProductExcludingCurrent(\n  numbers: number[],\n): number[] {\n  // Get the length of the input array\n  const length = numbers.length;\n\n  // Initialize the result array\n  const result: number[] = new Array(length).fill(1);\n\n  // Calculate products of all elements to the left of each index\n  for (let i = 1; i < length; i++) {\n    // result[i] contains the product of all elements to the left of index 'i'\n    result[i] = numbers[i - 1] * result[i - 1];\n  }\n\n  // Variable to hold the product of all elements to the right\n  let rightProduct = 1;\n  for (let i = length - 1; i >= 0; i--) {\n    // Multiply the right product with the current result\n    result[i] *= rightProduct;\n    // Update rightProduct with the current element\n    rightProduct *= numbers[i];\n  }\n\n  // Convert -0 or +0 to normal 0\n  for (let i = 0; i < length; i++) {\n    if (result[i] === -0) {\n      result[i] = 0;\n    }\n  }\n\n  return result;\n}\n`;function f(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Using Prefix and Suffix\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The task is to compute an array where each element at index \",(0,r.jsx)(e.code,{children:\"i\"}),\" is the product of all elements in the input array except the one at \",(0,r.jsx)(e.code,{children:\"i\"}),\". This solution uses separate prefix and suffix arrays to store intermediate calculations, enabling an efficient computation of the result.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"A brute force approach would involve iterating through the array and calculating the product of all elements except the current one for each index. This results in a time complexity of O(n\",(0,r.jsx)(\"sup\",{children:\"2\"}),\") due to repeated multiplication for each index. The optimized prefix-suffix approach eliminates this redundancy by precomputing the products to the left and right of each element.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"The prefix array stores the cumulative product of elements from the start up to the index \",(0,r.jsx)(e.code,{children:\"i - 1\"}),\", and the suffix array stores the cumulative product of elements from the end down to the index \",(0,r.jsx)(e.code,{children:\"i + 1\"}),\". These arrays are combined to compute the final result array, with each element being the product of the corresponding prefix and suffix values. The handling of negative zero ensures consistent output formatting.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Create three arrays: \",(0,r.jsx)(e.code,{children:\"prefix\"}),\", \",(0,r.jsx)(e.code,{children:\"suffix\"}),\", and \",(0,r.jsx)(e.code,{children:\"result\"}),\", each of size \",(0,r.jsx)(e.code,{children:\"n\"}),\" and initialized with \",(0,r.jsx)(e.code,{children:\"1\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Calculate the prefix array:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Set \",(0,r.jsx)(e.code,{children:\"prefix[0] = 1\"}),\" because there are no elements to the left of the first element.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate from index \",(0,r.jsx)(e.code,{children:\"1\"}),\" to \",(0,r.jsx)(e.code,{children:\"n - 1\"}),\", setting \",(0,r.jsx)(e.code,{children:\"prefix[i]\"}),\" as \",(0,r.jsx)(e.code,{children:\"prefix[i - 1] * numbers[i - 1]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Calculate the suffix array:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Set \",(0,r.jsx)(e.code,{children:\"suffix[n - 1] = 1\"}),\" because there are no elements to the right of the last element.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate from index \",(0,r.jsx)(e.code,{children:\"n - 2\"}),\" to \",(0,r.jsx)(e.code,{children:\"0\"}),\", setting \",(0,r.jsx)(e.code,{children:\"suffix[i]\"}),\" as \",(0,r.jsx)(e.code,{children:\"suffix[i + 1] * numbers[i + 1]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Calculate the result array:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate through the array and set \",(0,r.jsx)(e.code,{children:\"result[i]\"}),\" as \",(0,r.jsx)(e.code,{children:\"prefix[i] * suffix[i]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Handle special cases:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate through the \",(0,r.jsx)(e.code,{children:\"result\"}),\" array and replace any occurrences of \",(0,r.jsx)(e.code,{children:\"-0\"}),\" with \",(0,r.jsx)(e.code,{children:\"0\"}),\" for consistent output.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Return the \",(0,r.jsx)(e.code,{children:\"result\"}),\" array.\"]}),`\n`]}),`\n`,(0,r.jsx)(c,{children:s}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm involves three linear passes: one to compute the prefix array, one to compute the suffix array, and one to compute the result array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". Two auxiliary arrays (\",(0,r.jsx)(e.code,{children:\"prefix\"}),\" and \",(0,r.jsx)(e.code,{children:\"suffix\"}),\") of size \",(0,r.jsx)(e.code,{children:\"n\"}),\" are used in addition to the \",(0,r.jsx)(e.code,{children:\"result\"}),\" array.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"2. Space Optimized Version of Above Approach\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"This solution improves the space usage further by calculating the product of all elements to the left of each index during the first pass and storing these values in the \",(0,r.jsx)(e.code,{children:\"result\"}),\" array. During the second pass, it calculates the product of all elements to the right of each index and multiplies these values with the corresponding values already stored in the \",(0,r.jsx)(e.code,{children:\"result\"}),\" array.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize a \",(0,r.jsx)(e.code,{children:\"result\"}),\" array of the same length as the input array with all elements set to \",(0,r.jsx)(e.code,{children:\"1\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Calculate the left products:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate through the array from left to right starting at index \",(0,r.jsx)(e.code,{children:\"1\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"For each index \",(0,r.jsx)(e.code,{children:\"i\"}),\", compute the product of all elements to the left by multiplying \",(0,r.jsx)(e.code,{children:\"numbers[i - 1]\"}),\" with \",(0,r.jsx)(e.code,{children:\"result[i - 1]\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Store the result in \",(0,r.jsx)(e.code,{children:\"result[i]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Calculate the right products and combine with the left products:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize a variable \",(0,r.jsx)(e.code,{children:\"rightProduct\"}),\" to \",(0,r.jsx)(e.code,{children:\"1\"}),\".\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Iterate through the array from right to left.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"For each index \",(0,r.jsx)(e.code,{children:\"i\"}),\", multiply the value in \",(0,r.jsx)(e.code,{children:\"result[i]\"}),\" with \",(0,r.jsx)(e.code,{children:\"rightProduct\"}),\" to include the product of all elements to the right.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Update \",(0,r.jsx)(e.code,{children:\"rightProduct\"}),\" by multiplying it with \",(0,r.jsx)(e.code,{children:\"numbers[i]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Handle special cases:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Replace any occurrences of \",(0,r.jsx)(e.code,{children:\"-0\"}),\" in \",(0,r.jsx)(e.code,{children:\"result\"}),\" with \",(0,r.jsx)(e.code,{children:\"0\"}),\" for consistent output.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Return the \",(0,r.jsx)(e.code,{children:\"result\"}),\" array.\"]}),`\n`]}),`\n`,(0,r.jsx)(c,{children:u}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm involves two linear passes over the array for calculating left and right products and one additional pass for normalization.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The solution uses constant extra space, as calculations are performed directly in the \",(0,r.jsx)(e.code,{children:\"result\"}),\" array.\"]}),`\n`]})]})}function S(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(f,t)})):f(t)}var z=S;return C(O);})();\n;return Component;"
}