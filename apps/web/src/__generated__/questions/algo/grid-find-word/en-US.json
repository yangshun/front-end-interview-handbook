{
  "description": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var w=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var r in e)o(n,r,{get:e[r],enumerable:!0})},d=(n,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of f(e))!x.call(n,i)&&i!==r&&o(n,i,{get:()=>e[i],enumerable:!(c=u(e,i))||c.enumerable});return n};var y=(n,e,r)=>(r=n!=null?m(p(n)):{},d(e||!n||!n.__esModule?o(r,\"default\",{value:n,enumerable:!0}):r,n)),j=n=>d(o({},\"__esModule\",{value:!0}),n);var a=w((v,l)=>{l.exports=_jsx_runtime});var E={};b(E,{default:()=>D,frontmatter:()=>_});var t=y(a());var h=MDXTestExamples;var s=[{input:[[\"grid\",[[\"a\",\"b\",\"c\",\"e\"],[\"s\",\"f\",\"c\",\"t\"],[\"a\",\"d\",\"e\",\"e\"]]],[\"target\",\"tee\"]],output:!0,explanation:\"The word 'tee' can be formed starting from the cell (1, 3).\"},{input:[[\"grid\",[[\"a\",\"b\"],[\"c\",\"d\"]]],[\"target\",\"abcd\"]],output:!1,explanation:\"The word 'abcd' cannot be formed. There's no way to move from 'b' to 'c' as required by the word.\"},{input:[[\"grid\",[[\"h\",\"e\",\"l\",\"l\",\"o\"],[\"w\",\"o\",\"r\",\"l\",\"d\"]]],[\"target\",\"hello\"]],output:!0,explanation:\"The word 'hello' is found in the first row of the grid.\"}];var _={title:\"Find Word in Grid\",excerpt:\"Implement a function to check the existence of a word in a grid\"};function g(n){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given a grid of characters with dimensions \",(0,t.jsx)(e.code,{children:\"m x n\"}),\", determine if a specified word can be formed by connecting adjacent characters in the grid.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The word can be formed by traveling through adjacent cells, where adjacent cells are those directly next to each other either horizontally or vertically. Each cell in the grid can only be used once for forming the word.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"grid: string[][]\"}),\": A 2D array of size \",(0,t.jsx)(e.code,{children:\"m x n\"}),\", where each element is a lowercase English letter\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"target: string\"}),\": A string to be searched for in the grid\"]}),`\n`]}),`\n`,(0,t.jsx)(h,{testCases:s}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"1 <= \",(0,t.jsx)(e.code,{children:\"grid.length\"}),\", \",(0,t.jsx)(e.code,{children:\"grid[i].length\"}),\" <= 6\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"1 <= \",(0,t.jsx)(e.code,{children:\"target.length\"}),\" <= 15\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Both \",(0,t.jsx)(e.code,{children:\"grid\"}),\" and \",(0,t.jsx)(e.code,{children:\"target\"}),\" consist only of lowercase English letters\"]}),`\n`]})]})}function C(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(g,n)})):g(n)}var D=C;return j(E);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to check the existence of a word in a grid",
    "title": "Find Word in Grid"
  },
  "solution": "var Component=(()=>{var f=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var b=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),x=(r,e)=>{for(var n in e)o(r,n,{get:e[n],enumerable:!0})},l=(r,e,n,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!w.call(r,i)&&i!==n&&o(r,i,{get:()=>e[i],enumerable:!(c=g(e,i))||c.enumerable});return r};var k=(r,e,n)=>(n=r!=null?f(m(r)):{},l(e||!r||!r.__esModule?o(n,\"default\",{value:r,enumerable:!0}):n,r)),v=r=>l(o({},\"__esModule\",{value:!0}),r);var s=b((D,h)=>{h.exports=_jsx_runtime});var I={};x(I,{default:()=>M});var t=k(s());var a=MDXCodeBlock;var d=`export default function exist(grid: string[][], target: string): boolean {\n  const rows = grid.length; // Number of rows in the grid\n  const cols = grid[0].length; // Number of columns in the grid\n\n  function backtrack(row: number, col: number, suffix: string): boolean {\n    // Step 1: Check if we've matched the entire target word\n    if (suffix.length === 0) {\n      return true;\n    }\n\n    // Step 2: Check the boundaries and if the current cell matches the first character of the suffix\n    if (\n      row < 0 || // Out of bounds (top)\n      row === rows || // Out of bounds (bottom)\n      col < 0 || // Out of bounds (left)\n      col === cols || // Out of bounds (right)\n      grid[row][col] !== suffix.charAt(0) // Current cell doesn't match the suffix character\n    ) {\n      return false;\n    }\n\n    // Step 3: Explore the neighbors in DFS\n    let ret = false;\n    // Mark the path before the next exploration\n    const temp = grid[row][col];\n    grid[row][col] = '#'; // Mark the current cell as visited\n\n    const directions = [\n      [0, 1], // Move right\n      [1, 0], // Move down\n      [0, -1], // Move left\n      [-1, 0], // Move up\n    ];\n\n    // Explore all possible directions\n    for (let [rowOffset, colOffset] of directions) {\n      ret = backtrack(row + rowOffset, col + colOffset, suffix.slice(1)); // Recursively check the next cell\n      if (ret) break; // If found, break out of the loop\n    }\n\n    // Step 4: Clean up and return the result\n    grid[row][col] = temp; // Restore the current cell's value\n    return ret; // Return whether we found the target word\n  }\n\n  // Iterate through each cell in the grid\n  for (let row = 0; row < rows; row++) {\n    for (let col = 0; col < cols; col++) {\n      if (backtrack(row, col, target)) return true; // Start backtracking from each cell\n    }\n  }\n  return false; // If no match is found, return false\n}\n`;function u(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Backtracking\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The problem requires finding if a given \",(0,t.jsx)(e.code,{children:\"target\"}),\" word exists in a 2D grid of characters. The word can be constructed by sequentially adjacent cells in the grid, moving up, down, left, or right. A cell cannot be reused within the same word construction.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The approach uses backtracking with depth-first search (DFS) to explore all possible paths starting from each cell in the grid. At each step, the algorithm checks if the current cell matches the next character of the \",(0,t.jsx)(e.code,{children:\"target\"}),\". If a mismatch occurs or the cell goes out of bounds, the path is abandoned. To ensure a cell is not revisited, it is temporarily marked as visited during the DFS exploration. After exploring all directions, the cell's value is restored to enable other paths to use it.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"This method systematically explores all possible paths while pruning invalid paths early, optimizing the search process.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Retrieve the number of rows and columns in the grid.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Define a recursive \",(0,t.jsx)(e.code,{children:\"backtrack\"}),\" function:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If the \",(0,t.jsx)(e.code,{children:\"suffix\"}),\" is empty, return \",(0,t.jsx)(e.code,{children:\"true\"}),\" because the entire word has been matched.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Check if the current cell is out of bounds or if it does not match the first character of the \",(0,t.jsx)(e.code,{children:\"suffix\"}),\". If so, return \",(0,t.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Mark the current cell as visited by temporarily changing its value to \",(0,t.jsx)(e.code,{children:\"'#'\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Define the four possible directions to explore: right, down, left, and up.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through the directions and recursively call the \",(0,t.jsx)(e.code,{children:\"backtrack\"}),\" function for the neighboring cells with the remaining \",(0,t.jsx)(e.code,{children:\"suffix\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Restore the cell's original value after exploring all directions.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"true\"}),\" if any direction leads to a successful match; otherwise, return \",(0,t.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through every cell in the grid:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Call the \",(0,t.jsx)(e.code,{children:\"backtrack\"}),\" function starting from the current cell with the full \",(0,t.jsx)(e.code,{children:\"target\"}),\" string.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If the function returns \",(0,t.jsx)(e.code,{children:\"true\"}),\", the word exists in the grid.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If no starting cell leads to a match, return \",(0,t.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(a,{children:d}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[\"Time complexity: O(m.n.3\",(0,t.jsx)(\"sup\",{children:\"l\"}),\")\"]}),\". Each cell in the grid (\",(0,t.jsx)(e.code,{children:\"m.n\"}),\") can initiate a search, and for each character in the word (\",(0,t.jsx)(e.code,{children:\"l\"}),\"), up to 3 directions are explored (since we won't go back to where we come from).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(l)\"}),\". The recursion stack depth is proportional to the length of the word (\",(0,t.jsx)(e.code,{children:\"l\"}),\").\"]}),`\n`]})]})}function O(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(u,r)})):u(r)}var M=O;return v(I);})();\n;return Component;"
}