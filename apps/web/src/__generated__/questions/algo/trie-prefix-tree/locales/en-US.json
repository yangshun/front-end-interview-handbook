{
  "description": "var Component=(()=>{var p=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},d=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!w.call(t,i)&&i!==r&&s(t,i,{get:()=>e[i],enumerable:!(a=f(e,i))||a.enumerable});return t};var W=(t,e,r)=>(r=t!=null?p(g(t)):{},d(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),T=t=>d(s({},\"__esModule\",{value:!0}),t);var o=x((v,c)=>{c.exports=_jsx_runtime});var _={};b(_,{default:()=>C,frontmatter:()=>k});var n=W(o());var l=MDXTestExamples;var h=[{input:[[\"methods\",[\"insert\",\"insert\",\"search\",\"startsWith\",\"insert\",\"search\",\"startsWith\"]],[\"params\",[\"car\",\"care\",\"car\",\"cap\",\"card\",\"cast\",\"car\"]]],output:[null,null,1,0,null,0,1],explanation:\"The words 'car' and 'care' are inserted. 'search' for 'car' finds it, and 'startsWith' for 'cap' returns 0. 'card' is then inserted. 'search' for 'cast' does not find it. 'startsWith' finds 'car'\"},{input:[[\"methods\",[\"insert\",\"insert\",\"search\",\"startsWith\",\"insert\",\"search\",\"startsWith\"]],[\"params\",[\"dog\",\"doge\",\"dog\",\"do\",\"door\",\"doge\",\"doc\"]]],output:[null,null,1,1,null,1,0],explanation:\"Words 'dog' and 'doge' are inserted. 'search' finds 'dog' and 'startsWith' finds 'do'. After 'door' is inserted, 'search' finds 'doge'.'startsWith' do not finds 'doc'\"},{input:[[\"methods\",[\"insert\",\"insert\",\"startsWith\",\"insert\",\"search\",\"search\",\"startsWith\"]],[\"params\",[\"banana\",\"band\",\"ban\",\"bandit\",\"band\",\"banana\",\"ban\"]]],output:[null,null,1,null,1,1,1],explanation:\"'banana' and 'band' are inserted. 'startsWith' finds 'ban'. After 'bandit' is inserted, both 'band' and 'banana' can be found. 'startsWith' finds 'ban'.\"}];var k={title:\"Trie (Prefix Tree)\",excerpt:\"Implement a trie-prefix-tree with insert, search, and starts with functionality\"};function u(t){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",ul:\"ul\",li:\"li\",h3:\"h3\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Trie\",children:\"trie\"}),` (pronounced \"try\"), also known as a prefix tree, is a tree-like data structure designed to efficiently manage and query strings. It's particularly useful for tasks such as autocomplete and spell checking.`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Implement a \",(0,n.jsx)(e.code,{children:\"Trie\"}),\" class with the following methods:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"insert(word: string): void\"}),\": Adds the given word to the \",(0,n.jsx)(e.code,{children:\"Trie\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"search(word: string): boolean\"}),\": Checks if the specified word exists in the trie and returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if it does, otherwise \",(0,n.jsx)(e.code,{children:\"false\"})]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"startsWith(prefix: string): boolean\"}),\": Checks if there is any word in the Trie that starts with the given prefix and returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if such a word exists, otherwise \",(0,n.jsx)(e.code,{children:\"false\"})]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Trie\"}),\" instance will have its methods called with various parameters based on these:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"methods: string[]\"}),\": An array of \",(0,n.jsx)(e.code,{children:\"Trie\"}),\" method names\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"params: string[]\"}),\": An array of strings\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"methods[i]\"}),\" will be called with \",(0,n.jsx)(e.code,{children:\"params[i]\"}),\".\"]}),`\n`,(0,n.jsx)(l,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"word.length\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"prefix.length\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"word\"}),\" and \",(0,n.jsx)(e.code,{children:\"prefix\"}),\" contain only lowercase English letters\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"methods.length\"}),\" <= 1000\"]}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var C=j;return T(_);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a trie-prefix-tree with insert, search, and starts with functionality",
    "title": "Trie (Prefix Tree)"
  },
  "solution": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var T=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),m=(n,e)=>{for(var i in e)o(n,i,{get:e[i],enumerable:!0})},d=(n,e,i,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of g(e))!x.call(n,t)&&t!==i&&o(n,t,{get:()=>e[t],enumerable:!(h=p(e,t))||h.enumerable});return n};var k=(n,e,i)=>(i=n!=null?u(w(n)):{},d(e||!n||!n.__esModule?o(i,\"default\",{value:n,enumerable:!0}):i,n)),b=n=>d(o({},\"__esModule\",{value:!0}),n);var c=T((E,s)=>{s.exports=_jsx_runtime});var C={};m(C,{default:()=>v});var r=k(c());var a=MDXCodeBlock;var l=`class TrieNode {\n  // Array to hold child nodes\n  private links: TrieNode[] = [];\n  private static readonly NUM_ALPHABETS = 26; // Number of possible links (a-z)\n  private isEnd: boolean = false; // Indicates if this node is the end of a word\n\n  constructor() {\n    this.links = new Array(TrieNode.NUM_ALPHABETS); // Initialize the array with 26 slots\n  }\n\n  // Check if a child node for the given character exists\n  public containsKey(ch: string): boolean {\n    return this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)] !== undefined;\n  }\n\n  // Get the child node for the given character\n  public get(ch: string): TrieNode | undefined {\n    return this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)];\n  }\n\n  // Put a child node for the given character\n  public put(ch: string, node: TrieNode): void {\n    this.links[ch.charCodeAt(0) - 'a'.charCodeAt(0)] = node;\n  }\n\n  // Set this node as the end of a word\n  public setEnd(): void {\n    this.isEnd = true;\n  }\n\n  // Check if this node is the end of a word\n  public isEndNode(): boolean {\n    return this.isEnd;\n  }\n}\n\nexport default class Trie {\n  private root: TrieNode = new TrieNode();\n\n  constructor() {\n    this.root = new TrieNode();\n  }\n\n  // Inserts a word into the trie\n  public insert(word: string): void {\n    let node: TrieNode = this.root;\n\n    for (let i = 0; i < word.length; i++) {\n      const currentChar: string = word.charAt(i);\n      if (!node.containsKey(currentChar)) {\n        node.put(currentChar, new TrieNode());\n      }\n      node = node.get(currentChar)!; // Non-null assertion since containsKey checks existence\n    }\n\n    node.setEnd();\n  }\n\n  // Search for the prefix or whole key in the trie\n  private searchPrefix(word: string): TrieNode | null {\n    let node: TrieNode = this.root;\n    for (let i = 0; i < word.length; i++) {\n      const curLetter: string = word.charAt(i);\n      if (node.containsKey(curLetter)) {\n        node = node.get(curLetter)!; // Non-null assertion since containsKey checks existence\n      } else {\n        return null;\n      }\n    }\n    return node;\n  }\n\n  // Returns if the word is in the trie\n  public search(word: string): boolean {\n    const node: TrieNode | null = this.searchPrefix(word);\n    return node !== null && node.isEndNode();\n  }\n\n  // Returns if there is any word in the trie that starts with the given prefix\n  public startsWith(prefix: string): boolean {\n    const node: TrieNode | null = this.searchPrefix(prefix);\n    return node !== null;\n  }\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",strong:\"strong\",ul:\"ul\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Using Trie data structure\"}),`\n`,(0,r.jsx)(e.p,{children:\"A Trie (prefix tree) is a tree-like data structure used for efficient storage and retrieval of strings, particularly when working with prefixes. Each node in a Trie represents a single character and stores references to its child nodes. This structure enables fast operations such as inserting a word, searching for a word, and checking if any word starts with a given prefix.\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The Trie is initialized with a root node that has links to its child nodes. Each link corresponds to a character from 'a' to 'z'. Words are inserted character by character into the Trie, creating new child nodes if a character does not exist. The search operation traverses the Trie to check if all characters of a word or prefix exist, while the \",(0,r.jsx)(e.code,{children:\"isEnd\"}),\" flag at each node indicates whether the node marks the end of a word. The design efficiently handles operations involving prefixes, as shared prefixes are stored only once.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"Insert\"}),\":\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Start from the root node.\"}),`\n`,(0,r.jsx)(e.li,{children:\"For each character in the word, check if the node contains a link for the character.\"}),`\n`,(0,r.jsx)(e.li,{children:\"If not, create a new node and add it as a child.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Move to the child node and repeat for all characters.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"Mark the last node as the end of a word using the \",(0,r.jsx)(e.code,{children:\"isEnd\"}),\" flag.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"Search\"}),\":\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Traverse the Trie using the characters of the word.\"}),`\n`,(0,r.jsx)(e.li,{children:\"If any character is not found, the word does not exist.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Check if the last node represents the end of a word.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"StartsWith\"}),\":\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Traverse the Trie using the characters of the prefix.\"}),`\n`,(0,r.jsx)(e.li,{children:\"If all characters are found, the prefix exists in the Trie.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(a,{children:l}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Insert: O(m), where \",(0,r.jsx)(e.code,{children:\"m\"}),\" is the length of the word being inserted.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Search: O(m), where \",(0,r.jsx)(e.code,{children:\"m\"}),\" is the length of the word being searched.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"StartsWith: O(m), where \",(0,r.jsx)(e.code,{children:\"m\"}),\" is the length of the prefix.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity\"}),\": O(n), where \",(0,r.jsx)(e.code,{children:\"n\"}),\" is the total number of characters across all inserted words. Each character requires a node in the Trie, and shared prefixes reduce redundancy.\"]}),`\n`]})]})}function N(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(f,n)})):f(n)}var v=N;return b(C);})();\n;return Component;"
}