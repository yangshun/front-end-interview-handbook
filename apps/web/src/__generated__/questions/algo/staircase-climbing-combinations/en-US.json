{
  "description": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var s in e)r(t,s,{get:e[s],enumerable:!0})},a=(t,e,s,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of f(e))!b.call(t,o)&&o!==s&&r(t,o,{get:()=>e[o],enumerable:!(i=d(e,o))||i.enumerable});return t};var j=(t,e,s)=>(s=t!=null?m(x(t)):{},a(e||!t||!t.__esModule?r(s,\"default\",{value:t,enumerable:!0}):s,t)),y=t=>a(r({},\"__esModule\",{value:!0}),t);var c=w((X,p)=>{p.exports=_jsx_runtime});var k={};g(k,{default:()=>M,frontmatter:()=>_});var n=j(c());var h=MDXTestExamples;var l=[{input:[[\"steps\",1]],output:1,explanation:\"There is only one way i.e take 1-step\"},{input:[[\"steps\",2]],output:2,explanation:\"There are two ways, either take two 1-step or take one 2-step\"},{input:[[\"steps\",3]],output:3,explanation:\"There are three ways: 1-step three times, 1-step then 2-step, 2-step then 1-step\"}];var _={title:\"Staircase Climbing Combinations\",excerpt:\"Implement a function to find the number of ways to reach at the top of staircase\"};function u(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a staircase with a length of \",(0,n.jsx)(e.code,{children:\"steps\"}),\", where you can take 1 or 2 steps at a time, find the number of distinct combinations to reach the top of the staircase from the bottom of the stairs.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"steps: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,n.jsx)(h,{testCases:l}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"steps\"}),\" <= 45\"]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var M=T;return y(k);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/staircase-climbing-combinations\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/staircase-climbing-combinations.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"resolveJsonModule\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/run.tests.json": "[\n  {\n    \"input\": [[\"steps\", 1]],\n    \"output\": 1,\n    \"explanation\": \"There is only one way i.e take 1-step\"\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2,\n    \"explanation\": \"There are two ways, either take two 1-step or take one 2-step\"\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3,\n    \"explanation\": \"There are three ways: 1-step three times, 1-step then 2-step, 2-step then 1-step\"\n  }\n]\n",
    "/src/staircase-climbing-combinations.run.test.ts": "import fn from './staircase-climbing-combinations';\nimport runTestCases from './run.tests.json';\n\ndescribe('staircaseClimbingCombinations', () => {\n  runTestCases.forEach((example: any) => {\n    test(`${example.input[0][0]} = ${example.input[0][1]}`, () => {\n      expect(fn(example.input[0][1])).toStrictEqual(example.output);\n    });\n  });\n});\n",
    "/src/staircase-climbing-combinations.submit.test.ts": "import staircaseClimbingCombinations from './staircase-climbing-combinations';\nimport submitTestCases from './submit.tests.json';\n\ndescribe('staircaseClimbingCombinations', () => {\n  (submitTestCases as any[]).forEach((example: any) => {\n    test(`steps = ${example.input[0][1]}`, () => {\n      expect(staircaseClimbingCombinations(example.input[0][1])).toStrictEqual(\n        example.output,\n      );\n    });\n  });\n});\n",
    "/src/staircase-climbing-combinations.ts": "export default function staircaseClimbingCombinations(steps: number): number {\n  // Create an array 'dp' of size n+1 initialized with -1\n  // This array will store the number of distinct ways to reach each step\n  const dp: number[] = new Array(steps + 1).fill(-1);\n\n  // Base cases\n  // There is 1 way to reach step 0 (do nothing)\n  dp[0] = 1;\n  // There is 1 way to reach step 1 (a single step)\n  dp[1] = 1;\n\n  // Fill the dp array using the recurrence relation\n  // dp[i] = dp[i-1] + dp[i-2]\n  // This relation comes from the fact that you can reach step i either from step i-1 or step i-2\n  for (let i = 2; i <= steps; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n\n  // The value at dp[n] will be the number of distinct ways to reach the top of the staircase\n  return dp[steps];\n}\n",
    "/src/submit.tests.json": "[\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 6]],\n    \"output\": 13\n  },\n  {\n    \"input\": [[\"steps\", 1]],\n    \"output\": 1\n  },\n  {\n    \"input\": [[\"steps\", 8]],\n    \"output\": 34\n  },\n  {\n    \"input\": [[\"steps\", 8]],\n    \"output\": 34\n  },\n  {\n    \"input\": [[\"steps\", 10]],\n    \"output\": 89\n  },\n  {\n    \"input\": [[\"steps\", 7]],\n    \"output\": 21\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 6]],\n    \"output\": 13\n  },\n  {\n    \"input\": [[\"steps\", 7]],\n    \"output\": 21\n  },\n  {\n    \"input\": [[\"steps\", 28]],\n    \"output\": 514229\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 10]],\n    \"output\": 89\n  },\n  {\n    \"input\": [[\"steps\", 39]],\n    \"output\": 102334155\n  },\n  {\n    \"input\": [[\"steps\", 19]],\n    \"output\": 6765\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3\n  },\n  {\n    \"input\": [[\"steps\", 28]],\n    \"output\": 514229\n  },\n  {\n    \"input\": [[\"steps\", 24]],\n    \"output\": 75025\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 38]],\n    \"output\": 63245986\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 20]],\n    \"output\": 10946\n  },\n  {\n    \"input\": [[\"steps\", 34]],\n    \"output\": 9227465\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 32]],\n    \"output\": 3524578\n  },\n  {\n    \"input\": [[\"steps\", 23]],\n    \"output\": 46368\n  },\n  {\n    \"input\": [[\"steps\", 31]],\n    \"output\": 2178309\n  },\n  {\n    \"input\": [[\"steps\", 40]],\n    \"output\": 165580141\n  },\n  {\n    \"input\": [[\"steps\", 29]],\n    \"output\": 832040\n  },\n  {\n    \"input\": [[\"steps\", 40]],\n    \"output\": 165580141\n  },\n  {\n    \"input\": [[\"steps\", 20]],\n    \"output\": 10946\n  },\n  {\n    \"input\": [[\"steps\", 36]],\n    \"output\": 24157817\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3\n  },\n  {\n    \"input\": [[\"steps\", 20]],\n    \"output\": 10946\n  },\n  {\n    \"input\": [[\"steps\", 38]],\n    \"output\": 63245986\n  },\n  {\n    \"input\": [[\"steps\", 30]],\n    \"output\": 1346269\n  },\n  {\n    \"input\": [[\"steps\", 15]],\n    \"output\": 987\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 44]],\n    \"output\": 1134903170\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 15]],\n    \"output\": 987\n  },\n  {\n    \"input\": [[\"steps\", 21]],\n    \"output\": 17711\n  },\n  {\n    \"input\": [[\"steps\", 24]],\n    \"output\": 75025\n  },\n  {\n    \"input\": [[\"steps\", 27]],\n    \"output\": 317811\n  },\n  {\n    \"input\": [[\"steps\", 18]],\n    \"output\": 4181\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 7]],\n    \"output\": 21\n  },\n  {\n    \"input\": [[\"steps\", 38]],\n    \"output\": 63245986\n  },\n  {\n    \"input\": [[\"steps\", 29]],\n    \"output\": 832040\n  },\n  {\n    \"input\": [[\"steps\", 41]],\n    \"output\": 267914296\n  },\n  {\n    \"input\": [[\"steps\", 38]],\n    \"output\": 63245986\n  },\n  {\n    \"input\": [[\"steps\", 6]],\n    \"output\": 13\n  },\n  {\n    \"input\": [[\"steps\", 26]],\n    \"output\": 196418\n  },\n  {\n    \"input\": [[\"steps\", 44]],\n    \"output\": 1134903170\n  },\n  {\n    \"input\": [[\"steps\", 25]],\n    \"output\": 121393\n  },\n  {\n    \"input\": [[\"steps\", 12]],\n    \"output\": 233\n  },\n  {\n    \"input\": [[\"steps\", 39]],\n    \"output\": 102334155\n  },\n  {\n    \"input\": [[\"steps\", 37]],\n    \"output\": 39088169\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3\n  },\n  {\n    \"input\": [[\"steps\", 35]],\n    \"output\": 14930352\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 21]],\n    \"output\": 17711\n  },\n  {\n    \"input\": [[\"steps\", 9]],\n    \"output\": 55\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3\n  },\n  {\n    \"input\": [[\"steps\", 31]],\n    \"output\": 2178309\n  },\n  {\n    \"input\": [[\"steps\", 28]],\n    \"output\": 514229\n  },\n  {\n    \"input\": [[\"steps\", 30]],\n    \"output\": 1346269\n  },\n  {\n    \"input\": [[\"steps\", 32]],\n    \"output\": 3524578\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 11]],\n    \"output\": 144\n  },\n  {\n    \"input\": [[\"steps\", 9]],\n    \"output\": 55\n  },\n  {\n    \"input\": [[\"steps\", 39]],\n    \"output\": 102334155\n  },\n  {\n    \"input\": [[\"steps\", 36]],\n    \"output\": 24157817\n  },\n  {\n    \"input\": [[\"steps\", 44]],\n    \"output\": 1134903170\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2\n  },\n  {\n    \"input\": [[\"steps\", 23]],\n    \"output\": 46368\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 31]],\n    \"output\": 2178309\n  },\n  {\n    \"input\": [[\"steps\", 17]],\n    \"output\": 2584\n  },\n  {\n    \"input\": [[\"steps\", 23]],\n    \"output\": 46368\n  },\n  {\n    \"input\": [[\"steps\", 32]],\n    \"output\": 3524578\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 17]],\n    \"output\": 2584\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2\n  },\n  {\n    \"input\": [[\"steps\", 8]],\n    \"output\": 34\n  },\n  {\n    \"input\": [[\"steps\", 33]],\n    \"output\": 5702887\n  },\n  {\n    \"input\": [[\"steps\", 9]],\n    \"output\": 55\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 43]],\n    \"output\": 701408733\n  },\n  {\n    \"input\": [[\"steps\", 8]],\n    \"output\": 34\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 40]],\n    \"output\": 165580141\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2\n  }\n]\n"
  },
  "metadata": {
    "access": "standard",
    "author": "hiten",
    "companies": [],
    "created": 1719187200,
    "difficulty": "easy",
    "duration": 20,
    "excerpt": "Implement a function to find the number of ways to reach at the top of staircase",
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/staircase-climbing-combinations",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "staircase-climbing-combinations",
    "subtitle": null,
    "title": "Staircase Climbing Combinations",
    "topics": []
  },
  "skeleton": {
    "js": "/**\n * @param {number} steps\n * @return {number}\n */\nexport default function staircaseClimbingCombinations(steps) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function staircaseClimbingCombinations(steps: number): number {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var S=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of b(e))!g.call(t,i)&&i!==r&&s(t,i,{get:()=>e[i],enumerable:!(a=f(e,i))||a.enumerable});return t};var w=(t,e,r)=>(r=t!=null?d(y(t)):{},c(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),C=t=>c(s({},\"__esModule\",{value:!0}),t);var l=S((M,p)=>{p.exports=_jsx_runtime});var B={};x(B,{default:()=>_});var n=w(l());var o=MDXCodeBlock;var m=`export default function staircaseClimbingCombinations(steps: number): number {\n  // Create an array 'dp' of size n+1 initialized with -1\n  // This array will store the number of distinct ways to reach each step\n  const dp: number[] = new Array(steps + 1).fill(-1);\n\n  // Base cases\n  // There is 1 way to reach step 0 (do nothing)\n  dp[0] = 1;\n  // There is 1 way to reach step 1 (a single step)\n  dp[1] = 1;\n\n  // Fill the dp array using the recurrence relation\n  // dp[i] = dp[i-1] + dp[i-2]\n  // This relation comes from the fact that you can reach step i either from step i-1 or step i-2\n  for (let i = 2; i <= steps; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n\n  // The value at dp[n] will be the number of distinct ways to reach the top of the staircase\n  return dp[steps];\n}\n`;var u=`export default function staircaseClimbingCombinations(steps: number): number {\n  return climbFromStep(0, steps);\n}\n\n// Helper function using recursion to find the number of ways from step i to n\nfunction climbFromStep(currentStep: number, totalSteps: number): number {\n  // If current step exceeds total steps, no valid way\n  if (currentStep > totalSteps) {\n    return 0;\n  }\n  // If current step equals total steps, one valid way found\n  if (currentStep === totalSteps) {\n    return 1;\n  }\n  // Sum of ways by taking 1 step or 2 steps\n  return (\n    climbFromStep(currentStep + 1, totalSteps) +\n    climbFromStep(currentStep + 2, totalSteps)\n  );\n}\n`;function h(t){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute Force Approach\"}),`\n`,(0,n.jsx)(e.p,{children:\"Time complexity: O(2^N)\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"N is the length of the array\"}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:\"Time complexity: O(n)\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"N is the length of the array\"}),`\n`]}),`\n`,(0,n.jsx)(o,{children:m})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var _=T;return C(B);})();\n;return Component;",
  "workspace": {
    "main": "/src/staircase-climbing-combinations.ts",
    "run": "/src/staircase-climbing-combinations.run.test.ts",
    "submit": "/src/staircase-climbing-combinations.submit.test.ts"
  }
}