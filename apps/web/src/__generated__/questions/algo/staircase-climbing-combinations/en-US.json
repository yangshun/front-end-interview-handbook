{
  "description": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var s in e)r(t,s,{get:e[s],enumerable:!0})},a=(t,e,s,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of f(e))!b.call(t,o)&&o!==s&&r(t,o,{get:()=>e[o],enumerable:!(i=d(e,o))||i.enumerable});return t};var j=(t,e,s)=>(s=t!=null?m(x(t)):{},a(e||!t||!t.__esModule?r(s,\"default\",{value:t,enumerable:!0}):s,t)),y=t=>a(r({},\"__esModule\",{value:!0}),t);var c=w((X,p)=>{p.exports=_jsx_runtime});var k={};g(k,{default:()=>M,frontmatter:()=>_});var n=j(c());var h=MDXTestExamples;var l=[{input:[[\"steps\",1]],output:1,explanation:\"There is only one way i.e take 1-step\"},{input:[[\"steps\",2]],output:2,explanation:\"There are two ways, either take two 1-step or take one 2-step\"},{input:[[\"steps\",3]],output:3,explanation:\"There are three ways: 1-step three times, 1-step then 2-step, 2-step then 1-step\"}];var _={title:\"Staircase Climbing Combinations\",excerpt:\"Implement a function to find the number of ways to reach at the top of staircase\"};function u(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a staircase with a length of \",(0,n.jsx)(e.code,{children:\"steps\"}),\", where you can take 1 or 2 steps at a time, find the number of distinct combinations to reach the top of the staircase from the bottom of the stairs.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"steps: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,n.jsx)(h,{testCases:l}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"steps\"}),\" <= 45\"]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var M=T;return y(k);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/staircase-climbing-combinations\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/staircase-climbing-combinations.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"resolveJsonModule\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/run.tests.json": "[\n  {\n    \"input\": [[\"steps\", 1]],\n    \"output\": 1,\n    \"explanation\": \"There is only one way i.e take 1-step\"\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2,\n    \"explanation\": \"There are two ways, either take two 1-step or take one 2-step\"\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3,\n    \"explanation\": \"There are three ways: 1-step three times, 1-step then 2-step, 2-step then 1-step\"\n  }\n]\n",
    "/src/staircase-climbing-combinations.run.test.ts": "import fn from './staircase-climbing-combinations';\nimport runTestCases from './run.tests.json';\n\ndescribe('staircaseClimbingCombinations', () => {\n  runTestCases.forEach((example: any) => {\n    test(`${example.input[0][0]} = ${example.input[0][1]}`, () => {\n      expect(fn(example.input[0][1])).toStrictEqual(example.output);\n    });\n  });\n});\n",
    "/src/staircase-climbing-combinations.submit.test.ts": "import staircaseClimbingCombinations from './staircase-climbing-combinations';\nimport submitTestCases from './submit.tests.json';\n\ndescribe('staircaseClimbingCombinations', () => {\n  (submitTestCases as any[]).forEach((example: any) => {\n    test(`steps = ${example.input[0][1]}`, () => {\n      expect(staircaseClimbingCombinations(example.input[0][1])).toStrictEqual(\n        example.output,\n      );\n    });\n  });\n});\n",
    "/src/staircase-climbing-combinations.ts": "export default function staircaseClimbingCombinations(steps: number): number {\n  // Create an array 'dp' of size n+1 initialized with -1\n  // This array will store the number of distinct ways to reach each step\n  const dp: number[] = new Array(steps + 1).fill(-1);\n\n  // Base cases\n  // There is 1 way to reach step 0 (do nothing)\n  dp[0] = 1;\n  // There is 1 way to reach step 1 (a single step)\n  dp[1] = 1;\n\n  // Fill the dp array using the recurrence relation\n  // dp[i] = dp[i-1] + dp[i-2]\n  // This relation comes from the fact that you can reach step i either from step i-1 or step i-2\n  for (let i = 2; i <= steps; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n\n  // The value at dp[n] will be the number of distinct ways to reach the top of the staircase\n  return dp[steps];\n}\n",
    "/src/submit.tests.json": "[\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 6]],\n    \"output\": 13\n  },\n  {\n    \"input\": [[\"steps\", 1]],\n    \"output\": 1\n  },\n  {\n    \"input\": [[\"steps\", 8]],\n    \"output\": 34\n  },\n  {\n    \"input\": [[\"steps\", 8]],\n    \"output\": 34\n  },\n  {\n    \"input\": [[\"steps\", 10]],\n    \"output\": 89\n  },\n  {\n    \"input\": [[\"steps\", 7]],\n    \"output\": 21\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 6]],\n    \"output\": 13\n  },\n  {\n    \"input\": [[\"steps\", 7]],\n    \"output\": 21\n  },\n  {\n    \"input\": [[\"steps\", 28]],\n    \"output\": 514229\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 10]],\n    \"output\": 89\n  },\n  {\n    \"input\": [[\"steps\", 39]],\n    \"output\": 102334155\n  },\n  {\n    \"input\": [[\"steps\", 19]],\n    \"output\": 6765\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3\n  },\n  {\n    \"input\": [[\"steps\", 28]],\n    \"output\": 514229\n  },\n  {\n    \"input\": [[\"steps\", 24]],\n    \"output\": 75025\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 38]],\n    \"output\": 63245986\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 20]],\n    \"output\": 10946\n  },\n  {\n    \"input\": [[\"steps\", 34]],\n    \"output\": 9227465\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 32]],\n    \"output\": 3524578\n  },\n  {\n    \"input\": [[\"steps\", 23]],\n    \"output\": 46368\n  },\n  {\n    \"input\": [[\"steps\", 31]],\n    \"output\": 2178309\n  },\n  {\n    \"input\": [[\"steps\", 40]],\n    \"output\": 165580141\n  },\n  {\n    \"input\": [[\"steps\", 29]],\n    \"output\": 832040\n  },\n  {\n    \"input\": [[\"steps\", 40]],\n    \"output\": 165580141\n  },\n  {\n    \"input\": [[\"steps\", 20]],\n    \"output\": 10946\n  },\n  {\n    \"input\": [[\"steps\", 36]],\n    \"output\": 24157817\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3\n  },\n  {\n    \"input\": [[\"steps\", 20]],\n    \"output\": 10946\n  },\n  {\n    \"input\": [[\"steps\", 38]],\n    \"output\": 63245986\n  },\n  {\n    \"input\": [[\"steps\", 30]],\n    \"output\": 1346269\n  },\n  {\n    \"input\": [[\"steps\", 15]],\n    \"output\": 987\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 44]],\n    \"output\": 1134903170\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 15]],\n    \"output\": 987\n  },\n  {\n    \"input\": [[\"steps\", 21]],\n    \"output\": 17711\n  },\n  {\n    \"input\": [[\"steps\", 24]],\n    \"output\": 75025\n  },\n  {\n    \"input\": [[\"steps\", 27]],\n    \"output\": 317811\n  },\n  {\n    \"input\": [[\"steps\", 18]],\n    \"output\": 4181\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 7]],\n    \"output\": 21\n  },\n  {\n    \"input\": [[\"steps\", 38]],\n    \"output\": 63245986\n  },\n  {\n    \"input\": [[\"steps\", 29]],\n    \"output\": 832040\n  },\n  {\n    \"input\": [[\"steps\", 41]],\n    \"output\": 267914296\n  },\n  {\n    \"input\": [[\"steps\", 38]],\n    \"output\": 63245986\n  },\n  {\n    \"input\": [[\"steps\", 6]],\n    \"output\": 13\n  },\n  {\n    \"input\": [[\"steps\", 26]],\n    \"output\": 196418\n  },\n  {\n    \"input\": [[\"steps\", 44]],\n    \"output\": 1134903170\n  },\n  {\n    \"input\": [[\"steps\", 25]],\n    \"output\": 121393\n  },\n  {\n    \"input\": [[\"steps\", 12]],\n    \"output\": 233\n  },\n  {\n    \"input\": [[\"steps\", 39]],\n    \"output\": 102334155\n  },\n  {\n    \"input\": [[\"steps\", 37]],\n    \"output\": 39088169\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3\n  },\n  {\n    \"input\": [[\"steps\", 35]],\n    \"output\": 14930352\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 21]],\n    \"output\": 17711\n  },\n  {\n    \"input\": [[\"steps\", 9]],\n    \"output\": 55\n  },\n  {\n    \"input\": [[\"steps\", 3]],\n    \"output\": 3\n  },\n  {\n    \"input\": [[\"steps\", 31]],\n    \"output\": 2178309\n  },\n  {\n    \"input\": [[\"steps\", 28]],\n    \"output\": 514229\n  },\n  {\n    \"input\": [[\"steps\", 30]],\n    \"output\": 1346269\n  },\n  {\n    \"input\": [[\"steps\", 32]],\n    \"output\": 3524578\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 11]],\n    \"output\": 144\n  },\n  {\n    \"input\": [[\"steps\", 9]],\n    \"output\": 55\n  },\n  {\n    \"input\": [[\"steps\", 39]],\n    \"output\": 102334155\n  },\n  {\n    \"input\": [[\"steps\", 36]],\n    \"output\": 24157817\n  },\n  {\n    \"input\": [[\"steps\", 44]],\n    \"output\": 1134903170\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 16]],\n    \"output\": 1597\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2\n  },\n  {\n    \"input\": [[\"steps\", 23]],\n    \"output\": 46368\n  },\n  {\n    \"input\": [[\"steps\", 45]],\n    \"output\": 1836311903\n  },\n  {\n    \"input\": [[\"steps\", 31]],\n    \"output\": 2178309\n  },\n  {\n    \"input\": [[\"steps\", 17]],\n    \"output\": 2584\n  },\n  {\n    \"input\": [[\"steps\", 23]],\n    \"output\": 46368\n  },\n  {\n    \"input\": [[\"steps\", 32]],\n    \"output\": 3524578\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 17]],\n    \"output\": 2584\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2\n  },\n  {\n    \"input\": [[\"steps\", 8]],\n    \"output\": 34\n  },\n  {\n    \"input\": [[\"steps\", 33]],\n    \"output\": 5702887\n  },\n  {\n    \"input\": [[\"steps\", 9]],\n    \"output\": 55\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 5]],\n    \"output\": 8\n  },\n  {\n    \"input\": [[\"steps\", 43]],\n    \"output\": 701408733\n  },\n  {\n    \"input\": [[\"steps\", 8]],\n    \"output\": 34\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 22]],\n    \"output\": 28657\n  },\n  {\n    \"input\": [[\"steps\", 40]],\n    \"output\": 165580141\n  },\n  {\n    \"input\": [[\"steps\", 2]],\n    \"output\": 2\n  }\n]\n"
  },
  "metadata": {
    "access": "standard",
    "author": "hiten",
    "companies": [],
    "created": 1719187200,
    "difficulty": "easy",
    "duration": 20,
    "excerpt": "Implement a function to find the number of ways to reach at the top of staircase",
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/staircase-climbing-combinations",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "staircase-climbing-combinations",
    "subtitle": null,
    "title": "Staircase Climbing Combinations",
    "topics": [
      "dynamic-programming"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {number} steps\n * @return {number}\n */\nexport default function staircaseClimbingCombinations(steps) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function staircaseClimbingCombinations(steps: number): number {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var w=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),S=(n,e)=>{for(var i in e)s(n,i,{get:e[i],enumerable:!0})},c=(n,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!g.call(n,r)&&r!==i&&s(n,r,{get:()=>e[r],enumerable:!(l=f(e,r))||l.enumerable});return n};var T=(n,e,i)=>(i=n!=null?m(y(n)):{},c(e||!n||!n.__esModule?s(i,\"default\",{value:n,enumerable:!0}):i,n)),v=n=>c(s({},\"__esModule\",{value:!0}),n);var h=w((B,a)=>{a.exports=_jsx_runtime});var O={};S(O,{default:()=>k});var t=T(h());var o=MDXCodeBlock;var d=`export default function staircaseClimbingCombinations(steps: number): number {\n  // Create an array 'dp' of size n+1 initialized with -1\n  // This array will store the number of distinct ways to reach each step\n  const dp: number[] = new Array(steps + 1).fill(-1);\n\n  // Base cases\n  // There is 1 way to reach step 0 (do nothing)\n  dp[0] = 1;\n  // There is 1 way to reach step 1 (a single step)\n  dp[1] = 1;\n\n  // Fill the dp array using the recurrence relation\n  // dp[i] = dp[i-1] + dp[i-2]\n  // This relation comes from the fact that you can reach step i either from step i-1 or step i-2\n  for (let i = 2; i <= steps; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n\n  // The value at dp[n] will be the number of distinct ways to reach the top of the staircase\n  return dp[steps];\n}\n`;var p=`export default function staircaseClimbingCombinations(steps: number): number {\n  return climbFromStep(0, steps);\n}\n\n// Helper function using recursion to find the number of ways from step i to n\nfunction climbFromStep(currentStep: number, totalSteps: number): number {\n  // If current step exceeds total steps, no valid way\n  if (currentStep > totalSteps) {\n    return 0;\n  }\n  // If current step equals total steps, one valid way found\n  if (currentStep === totalSteps) {\n    return 1;\n  }\n  // Sum of ways by taking 1 step or 2 steps\n  return (\n    climbFromStep(currentStep + 1, totalSteps) +\n    climbFromStep(currentStep + 2, totalSteps)\n  );\n}\n`;function u(n){let e=Object.assign({h2:\"h2\",p:\"p\",ol:\"ol\",li:\"li\",h3:\"h3\",code:\"code\",ul:\"ul\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Brute Force Approach\"}),`\n`,(0,t.jsx)(e.p,{children:\"This solution calculates the number of distinct ways to climb a staircase with a given number of steps using recursion. At each step, the climber can choose to take either 1 step or 2 steps. The problem is solved by recursively calculating the total number of ways to reach the top from the current step.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The algorithm uses a helper function to explore all possible combinations of steps:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"If the current step exceeds the total number of steps, the path is invalid, so it returns 0.\"}),`\n`,(0,t.jsx)(e.li,{children:\"If the current step equals the total number of steps, it represents a valid path, so it returns 1.\"}),`\n`,(0,t.jsx)(e.li,{children:\"For all other cases, it recursively calculates the number of ways to reach the top by taking either 1 step or 2 steps from the current step.\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"This brute force approach explores all possible paths to find the total number of combinations. However, it does redundant calculations as the same subproblems are solved multiple times, which increases its computational cost.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Define a function \",(0,t.jsx)(e.code,{children:\"staircaseClimbingCombinations\"}),\" that calls the helper function \",(0,t.jsx)(e.code,{children:\"climbFromStep\"}),\" starting from step \",(0,t.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The helper function \",(0,t.jsx)(e.code,{children:\"climbFromStep\"}),\" takes the current step and total steps as input:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"0\"}),\" if the current step exceeds the total number of steps, as it is invalid.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"1\"}),\" if the current step equals the total number of steps, as it represents a valid path.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Recursively calculate the total number of ways by summing:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The result of taking 1 step (\",(0,t.jsx)(e.code,{children:\"climbFromStep(currentStep + 1, totalSteps)\"}),\").\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The result of taking 2 steps (\",(0,t.jsx)(e.code,{children:\"climbFromStep(currentStep + 2, totalSteps)\"}),\").\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Return the result of the helper function.\"}),`\n`]}),`\n`,(0,t.jsx)(o,{children:p}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[\"Time complexity: O(2\",(0,t.jsx)(\"sup\",{children:\"n\"}),\")\"]}),\". Each step branches into two recursive calls, leading to an exponential number of function calls.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The recursion stack can grow up to the depth of \",(0,t.jsx)(e.code,{children:\"n\"}),\", where \",(0,t.jsx)(e.code,{children:\"n\"}),\" is the total number of steps.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Dynamic Programming\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This solution calculates the number of distinct ways to climb a staircase with a given number of steps using dynamic programming (DP). The problem is solved by breaking it down into smaller subproblems and storing the results of these subproblems in a \",(0,t.jsx)(e.code,{children:\"dp\"}),\" array to avoid redundant calculations.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The intuition is that to reach step \",(0,t.jsx)(e.code,{children:\"i\"}),\", there are two possible ways:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"From step \",(0,t.jsx)(e.code,{children:\"i-1\"}),\" by taking one step.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"From step \",(0,t.jsx)(e.code,{children:\"i-2\"}),\" by taking two steps.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This relationship leads to the recurrence formula: \",(0,t.jsx)(e.code,{children:\"dp[i] = dp[i-1] + dp[i-2]\"}),\". Using this formula, the solution builds up the \",(0,t.jsx)(e.code,{children:\"dp\"}),\" array iteratively, starting from the base cases:\"]}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"There is exactly 1 way to stay at step \",(0,t.jsx)(e.code,{children:\"0\"}),\" (do nothing).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"There is exactly 1 way to reach step \",(0,t.jsx)(e.code,{children:\"1\"}),\" (a single step).\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The final value in \",(0,t.jsx)(e.code,{children:\"dp[steps]\"}),\" gives the total number of ways to reach the top of the staircase.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Create a \",(0,t.jsx)(e.code,{children:\"dp\"}),\" array of size \",(0,t.jsx)(e.code,{children:\"steps + 1\"}),\", initialized with \",(0,t.jsx)(e.code,{children:\"-1\"}),\" to store the number of ways to reach each step.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize the base cases:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Set \",(0,t.jsx)(e.code,{children:\"dp[0] = 1\"}),\" since there is one way to stay at step \",(0,t.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Set \",(0,t.jsx)(e.code,{children:\"dp[1] = 1\"}),\" since there is one way to reach step \",(0,t.jsx)(e.code,{children:\"1\"}),\" (a single step).\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Use a loop to fill the \",(0,t.jsx)(e.code,{children:\"dp\"}),\" array from step \",(0,t.jsx)(e.code,{children:\"2\"}),\" to \",(0,t.jsx)(e.code,{children:\"steps\"}),\":\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"For each step \",(0,t.jsx)(e.code,{children:\"i\"}),\", calculate \",(0,t.jsx)(e.code,{children:\"dp[i]\"}),\" as the sum of \",(0,t.jsx)(e.code,{children:\"dp[i-1]\"}),\" (ways to reach from the previous step) and \",(0,t.jsx)(e.code,{children:\"dp[i-2]\"}),\" (ways to reach from two steps before).\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return the value in \",(0,t.jsx)(e.code,{children:\"dp[steps]\"}),\" as the total number of distinct ways to reach the top of the staircase.\"]}),`\n`]}),`\n`,(0,t.jsx)(o,{children:d}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The \",(0,t.jsx)(e.code,{children:\"dp\"}),\" array is filled in a single pass from \",(0,t.jsx)(e.code,{children:\"0\"}),\" to \",(0,t.jsx)(e.code,{children:\"steps\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,t.jsx)(e.code,{children:\"dp\"}),\" array requires additional space proportional to the number of steps.\"]}),`\n`]})]})}function C(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var k=C;return v(O);})();\n;return Component;",
  "workspace": {
    "main": "/src/staircase-climbing-combinations.ts",
    "run": "/src/staircase-climbing-combinations.run.test.ts",
    "submit": "/src/staircase-climbing-combinations.submit.test.ts"
  }
}