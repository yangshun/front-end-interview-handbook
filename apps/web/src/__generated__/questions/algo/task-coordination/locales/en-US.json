{
  "description": "var Component=(()=>{var m=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var w=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),x=(n,e)=>{for(var s in e)a(n,s,{get:e[s],enumerable:!0})},r=(n,e,s,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of f(e))!k.call(n,i)&&i!==s&&a(n,i,{get:()=>e[i],enumerable:!(o=p(e,i))||o.enumerable});return n};var B=(n,e,s)=>(s=n!=null?m(A(n)):{},r(e||!n||!n.__esModule?a(s,\"default\",{value:n,enumerable:!0}):s,n)),b=n=>r(a({},\"__esModule\",{value:!0}),n);var d=w((D,l)=>{l.exports=_jsx_runtime});var j={};x(j,{default:()=>C,frontmatter:()=>v});var t=B(d());var c=MDXTestExamples;var h=[{input:[[\"tasks\",[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]],[\"n\",2]],output:8,explanation:\"Task 'A' appears 3 times and task 'B' appears 3 times. Since there is a cooldown of 2, we need to ensure that after every 'A' there are at least 2 other tasks or idle intervals before we can add another 'A'. The same applies to 'B'. A valid sequence might look like this: 'A' -> 'B' -> idle -> 'A' -> 'B' -> idle -> 'A' -> 'B'. Thus, the total number of intervals required is 8.\"},{input:[[\"tasks\",[\"A\",\"C\",\"A\",\"B\",\"D\",\"B\"]],[\"n\",1]],output:6,explanation:\"The tasks 'A', 'B', and 'C' appear multiple times, but the cooldown is only 1. After completing one 'A', we can immediately complete another 'A' after just one other task. A valid sequence could look like this: 'A' -> 'C' -> 'A' -> 'B' -> 'D' -> 'B'. Thus, the total number of intervals required is 6.\"},{input:[[\"tasks\",[\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"]],[\"n\",3]],output:10,explanation:\"The cooldown is 3, meaning after completing a task, we must wait for 3 intervals before repeating the same task. A valid sequence could be: 'A' -> 'B' -> idle -> idle -> 'A' -> 'B' -> idle -> idle -> 'A' -> 'B'. Thus, the total number of intervals needed is 10.\"}];var v={title:\"Task Coordination\",excerpt:\"Implement a function to find minimum intervals for tasks with cooldown\"};function u(n){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given a list of tasks, each represented by a letter (from A to Z), and a cooldown period \",(0,t.jsx)(e.code,{children:\"k\"}),\". The cooldown period specifies that the same task must be separated by at least \",(0,t.jsx)(e.code,{children:\"k\"}),\" intervals between executions.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"Determine the minimum number of intervals required to complete all tasks, while ensuring that the same task is not executed again before the cooldown period has passed.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"tasks: string[]\"}),\": An array of characters, where each task is represented as a letter (A-Z)\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"k: number\"}),\": An integer representing the cooldown period, the minimum number of intervals between two executions of the same task\"]}),`\n`]}),`\n`,(0,t.jsx)(c,{testCases:h}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"1 <= \",(0,t.jsx)(e.code,{children:\"tasks.length\"}),\" <= 1000\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"tasks[i]\"}),\" is an uppercase English letter\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"0 <= \",(0,t.jsx)(e.code,{children:\"k\"}),\" <= 100\"]}),`\n`]})]})}function T(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(u,n)})):u(n)}var C=T;return b(j);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find minimum intervals for tasks with cooldown",
    "title": "Task Coordination"
  },
  "solution": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),q=(n,e)=>{for(var i in e)a(n,i,{get:e[i],enumerable:!0})},h=(n,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of k(e))!y.call(n,r)&&r!==i&&a(n,r,{get:()=>e[r],enumerable:!(o=f(e,r))||o.enumerable});return n};var b=(n,e,i)=>(i=n!=null?p(x(n)):{},h(e||!n||!n.__esModule?a(i,\"default\",{value:n,enumerable:!0}):i,n)),C=n=>h(a({},\"__esModule\",{value:!0}),n);var l=g((M,c)=>{c.exports=_jsx_runtime});var I={};q(I,{default:()=>A});var t=b(l());var s=MDXCodeBlock;var d=`export default function taskCoordinator(tasks: string[], k: number): number {\n  // Array to store the frequency of each task (26 letters, A-Z)\n  const counter: number[] = new Array(26).fill(0);\n  let maximum = 0; // Maximum frequency of any task\n  let maxCount = 0; // Number of tasks with maximum frequency\n\n  // Traverse through tasks to calculate task frequencies\n  for (const task of tasks) {\n    const index = task.charCodeAt(0) - 'A'.charCodeAt(0);\n    counter[index]++;\n\n    if (maximum === counter[index]) {\n      maxCount++;\n    } else if (maximum < counter[index]) {\n      maximum = counter[index];\n      maxCount = 1;\n    }\n  }\n\n  // Calculate idle slots, available tasks, and idles needed\n  const partCount = maximum - 1;\n  const partLength = k - (maxCount - 1);\n  const emptySlots = partCount * partLength;\n  const availableTasks = tasks.length - maximum * maxCount;\n  const idles = Math.max(0, emptySlots - availableTasks);\n\n  // Return the total time required\n  return tasks.length + idles;\n}\n`;var u=`export default function leastInterval(tasks: string[], n: number): number {\n  // Building frequency map\n  const freq: number[] = new Array(26).fill(0);\n  for (const ch of tasks) {\n    freq[ch.charCodeAt(0) - 'A'.charCodeAt(0)]++;\n  }\n\n  // Max heap to store frequencies\n  const pq: number[] = [];\n\n  // Helper function to maintain the max heap property\n  function heapPush(value: number) {\n    pq.push(value);\n    let index = pq.length - 1;\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1) / 2);\n      if (pq[index] > pq[parentIndex]) {\n        [pq[index], pq[parentIndex]] = [pq[parentIndex], pq[index]];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n  // Populate the max heap with frequencies\n  for (const count of freq) {\n    if (count > 0) {\n      heapPush(count);\n    }\n  }\n\n  let time = 0;\n  // Process tasks until the heap is empty\n  while (pq.length > 0) {\n    let cycle = n + 1;\n    const store: number[] = [];\n    let taskCount = 0;\n\n    // Execute tasks in each cycle\n    while (cycle-- > 0 && pq.length > 0) {\n      const top = pq[0];\n      if (top > 1) {\n        store.push(top - 1);\n      }\n      pq.shift(); // Remove the top element from the heap\n      taskCount++;\n    }\n\n    // Restore updated frequencies to the heap\n    for (const x of store) {\n      heapPush(x);\n    }\n\n    // Add time for the completed cycle\n    time += pq.length === 0 ? taskCount : n + 1;\n  }\n\n  return time;\n}\n`;function m(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Greedy Approach\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"This solution minimizes the time required to execute a series of tasks with a cooldown period \",(0,t.jsx)(e.code,{children:\"k\"}),\", ensuring that no two identical tasks are executed within \",(0,t.jsx)(e.code,{children:\"k\"}),' intervals. The core idea is to focus on tasks with the highest frequency since they dominate the scheduling process. These tasks must be distributed as evenly as possible, creating \"partitions\" in the schedule. The remaining tasks fill the gaps between these partitions, reducing idle time.']}),`\n`,(0,t.jsxs)(e.p,{children:[\"Tasks with the highest frequency define the framework of the schedule because their distribution determines the placement of all other tasks. Each occurrence of these tasks is separated by at least \",(0,t.jsx)(e.code,{children:\"k\"}),\" intervals. If there are other tasks to fill these gaps, idle periods are reduced; otherwise, idle slots remain, increasing the total time.\"]}),`\n`,(0,t.jsx)(e.p,{children:\"The greedy approach ensures that the schedule is compact by filling the gaps created by the most frequent tasks first. This avoids unnecessary idle times and ensures the schedule respects the cooldown constraint while remaining as short as possible.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize an array \",(0,t.jsx)(e.code,{children:\"counter\"}),\" of size 26 to count the frequency of each task.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Traverse the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" array to populate the \",(0,t.jsx)(e.code,{children:\"counter\"}),\" array:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"For each task, increment its frequency count in \",(0,t.jsx)(e.code,{children:\"counter\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Update \",(0,t.jsx)(e.code,{children:\"maximum\"}),\" to track the highest frequency of any task.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Update \",(0,t.jsx)(e.code,{children:\"maxCount\"}),\" to count how many tasks have this maximum frequency.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Compute the number of partitions as \",(0,t.jsx)(e.code,{children:\"maximum - 1\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Compute the length of each partition as \",(0,t.jsx)(e.code,{children:\"k - (maxCount - 1)\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Calculate the total number of empty slots as \",(0,t.jsx)(e.code,{children:\"partCount * partLength\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Compute the number of available tasks as the total number of tasks minus the tasks with maximum frequency.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Calculate the number of idle slots as \",(0,t.jsx)(e.code,{children:\"Math.max(0, emptySlots - availableTasks)\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return the total time required as \",(0,t.jsx)(e.code,{children:\"tasks.length + idles\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(s,{children:d}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Traversing the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" array and updating the \",(0,t.jsx)(e.code,{children:\"counter\"}),\" array each take linear time.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The \",(0,t.jsx)(e.code,{children:\"counter\"}),\" array has a fixed size of 26, regardless of the input size.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Heap\"}),`\n`,(0,t.jsx)(e.p,{children:\"The key idea is to minimize idle time by always executing the most frequent tasks first. A max heap is used to efficiently retrieve the task with the highest remaining frequency. This ensures that tasks with higher frequencies are executed earlier, reducing the likelihood of idle cycles.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Build a frequency map to count the occurrences of each task.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Populate a max heap with the task frequencies. The heap is structured to prioritize the highest frequency tasks.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize the total time counter to \",(0,t.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"While the heap is not empty:\",`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Execute tasks for a single cooldown cycle (\",(0,t.jsx)(e.code,{children:\"n + 1\"}),\" times) or until the heap is empty.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Decrease the frequency of executed tasks and store updated frequencies.\"}),`\n`,(0,t.jsx)(e.li,{children:\"After the cycle, reinsert the updated task frequencies back into the heap.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Update the total time counter. If the heap is empty after a cycle, add only the tasks executed during the cycle; otherwise, add \",(0,t.jsx)(e.code,{children:\"n + 1\"}),\" time units for the full cycle.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Return the total time counter as the result.\"}),`\n`]}),`\n`,(0,t.jsx)(s,{children:u}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n log k)\"}),\". Iterating through the \",(0,t.jsx)(e.code,{children:\"tasks\"}),\" array and building the frequency map is O(n). Operations on the heap (insertion and deletion) are O(log k), where \",(0,t.jsx)(e.code,{children:\"k\"}),\" is the number of unique tasks.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(k)\"}),\". The heap and the frequency map require storage proportional to the number of unique tasks, which is \",(0,t.jsx)(e.code,{children:\"k\"}),\".\"]}),`\n`]})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(m,n)})):m(n)}var A=v;return C(I);})();\n;return Component;"
}