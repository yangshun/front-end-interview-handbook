{
  "description": "var Component=(()=>{var m=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!f.call(t,i)&&i!==r&&s(t,i,{get:()=>e[i],enumerable:!(l=p(e,i))||l.enumerable});return t};var j=(t,e,r)=>(r=t!=null?m(b(t)):{},o(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),y=t=>o(s({},\"__esModule\",{value:!0}),t);var c=x((v,a)=>{a.exports=_jsx_runtime});var D={};w(D,{default:()=>M,frontmatter:()=>T});var n=j(c());var u=MDXTestExamples;var h=[{input:[[\"numbers\",[0,7,1,9]],[\"target\",7]],output:[0,1],explanation:\"numbers[0] plus numbers[1] = 7 which is target\"},{input:[[\"numbers\",[4,9,2,1,7]],[\"target\",5]],output:[0,3],explanation:\"numbers[3] plus numbers[0] = 5 which is target\"},{input:[[\"numbers\",[4,4]],[\"target\",8]],output:[0,1]}];var T={title:\"Pair sum\",excerpt:\"Implement a function to find two numbers within an array of integers that add up to a target integer\"};function d(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of integers \",(0,n.jsx)(e.code,{children:\"numbers\"}),\", write a function that returns the indices of two integers within the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array that sum up to a \",(0,n.jsx)(e.code,{children:\"target\"}),\" integer. The smaller index should appear first.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"target: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"There will always be exactly one solution for the given input\"}),`\n`,(0,n.jsx)(e.li,{children:\"The same element should not be used more than once\"}),`\n`]}),`\n`,(0,n.jsx)(u,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"2 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-1000 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-1000 <= \",(0,n.jsx)(e.code,{children:\"target\"}),\" <= 1000\"]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var M=C;return y(D);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find two numbers within an array of integers that add up to a target integer",
    "title": "Pair sum"
  },
  "solution": "var Component=(()=>{var f=Object.create;var h=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var k=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)h(t,i,{get:e[i],enumerable:!0})},o=(t,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of g(e))!x.call(t,r)&&r!==i&&h(t,r,{get:()=>e[r],enumerable:!(l=b(e,r))||l.enumerable});return t};var O=(t,e,i)=>(i=t!=null?f(y(t)):{},o(e||!t||!t.__esModule?h(i,\"default\",{value:t,enumerable:!0}):i,t)),T=t=>o(h({},\"__esModule\",{value:!0}),t);var c=k((M,s)=>{s.exports=_jsx_runtime});var F={};w(F,{default:()=>S});var n=O(c());var a=MDXCodeBlock;var d=`export default function pairSum(numbers: number[], target: number): number[] {\n  const hash: { [key: number]: number } = {};\n\n  for (let i = 0; i < numbers.length; i++) {\n    const complement = target - numbers[i];\n\n    // Check if the complement exists (excluding the current element)\n    if (hash.hasOwnProperty(complement) && hash[complement] !== i) {\n      return [hash[complement], i];\n    }\n\n    // Store the number and its index in the hash map\n    hash[numbers[i]] = i;\n  }\n\n  // No solution found\n  return [];\n}\n`;var m=`export default function pairSum(numbers: number[], target: number): number[] {\n  // Iterate through each element in the array\n  for (let i = 0; i < numbers.length; i++) {\n    // For each element, iterate through the elements that come after it\n    for (let j = i + 1; j < numbers.length; j++) {\n      // If the sum of the two elements equals the target, return their indices\n      if (numbers[j] === target - numbers[i]) {\n        return [i, j];\n      }\n    }\n  }\n  // Return an empty array if no solution is found\n  return [];\n}\n`;var u=`export default function pairSum(numbers: number[], target: number): number[] {\n  const hash: { [key: number]: number } = {};\n\n  // First pass: Populate the hash table with numbers and their indices\n  for (let i = 0; i < numbers.length; i++) {\n    hash[numbers[i]] = i;\n  }\n\n  // Second pass: Check for the complement\n  for (let i = 0; i < numbers.length; i++) {\n    const complement = target - numbers[i];\n\n    // Ensure complement exists and is not the same index as the current one\n    if (complement in hash && hash[complement] !== i) {\n      return [i, hash[complement]];\n    }\n  }\n\n  // If no solution is found\n  return [];\n}\n`;function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute Force\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The pair sum problem involves identifying two indices in an array such that their values add up to a specified target. The brute-force approach checks all possible pairs of elements in the array. For every element at index \",(0,n.jsx)(e.code,{children:\"i\"}),\", all subsequent elements at index \",(0,n.jsx)(e.code,{children:\"j > i\"}),\" are examined to determine if their sum matches the target. This ensures that all possible pairs are considered, making the solution straightforward but inefficient for large arrays.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Use a loop with index \",(0,n.jsx)(e.code,{children:\"i\"}),\" to iterate through each element of the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"For each element at index \",(0,n.jsx)(e.code,{children:\"i\"}),\", use another loop with index \",(0,n.jsx)(e.code,{children:\"j\"}),\" to iterate through the elements that come after \",(0,n.jsx)(e.code,{children:\"i\"}),\" (\",(0,n.jsx)(e.code,{children:\"j > i\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the sum of \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" and \",(0,n.jsx)(e.code,{children:\"numbers[j]\"}),\" is equal to the \",(0,n.jsx)(e.code,{children:\"target\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the condition is true, return the indices \",(0,n.jsx)(e.code,{children:\"[i, j]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"If no such pair is found after examining all pairs, return an empty array.\"}),`\n`]}),`\n`,(0,n.jsx)(a,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The outer loop runs \",(0,n.jsx)(e.code,{children:\"n\"}),\" times, and for each iteration, the inner loop runs up to \",(0,n.jsx)(e.code,{children:\"n - 1\"}),\" times, leading to quadratic time complexity.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional data structures are used, and the space requirement is constant.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Hash Map With Two Passes\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The previous brute-force solution involves checking all pairs of elements, resulting in O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\") time complexity due to repeated comparisons of element pairs. Thus, this approach removes redundant work by replacing the nested loops with efficient O(1) hash table lookups, reducing the time complexity to O(n).\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This optimized solution uses a \",(0,n.jsx)(e.strong,{children:\"two-pass hash map\"}),\" approach:\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The first pass constructs a hash table to store each element's value as a key and its index as a value.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"In the second pass, the algorithm checks if the complement of the current element (i.e., \",(0,n.jsx)(e.code,{children:\"target - numbers[i]\"}),\") exists in the hash table.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an empty hash table \",(0,n.jsx)(e.code,{children:\"hash\"}),\" to store the numbers and their indices.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform the first pass through the array:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each element \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\", store it in the hash table with its index as the value (\",(0,n.jsx)(e.code,{children:\"hash[numbers[i]] = i\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform the second pass through the array:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the \",(0,n.jsx)(e.code,{children:\"complement\"}),\" as \",(0,n.jsx)(e.code,{children:\"target - numbers[i]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the \",(0,n.jsx)(e.code,{children:\"complement\"}),\" exists in the hash table and ensure that its index is not the same as the current index.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the conditions are met, return the indices \",(0,n.jsx)(e.code,{children:\"[i, hash[complement]]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"If no valid pair is found, return an empty array.\"}),`\n`]}),`\n`,(0,n.jsx)(a,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm iterates through the array twice, and each hash table operation (insertion or lookup) takes O(1).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". In the worst case, all \",(0,n.jsx)(e.code,{children:\"n\"}),\" elements are stored in the hash map.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"3. Using Hash Map With One Pass\"}),`\n`,(0,n.jsx)(e.p,{children:\"The unnecessary work in the two-pass solution is the need for two iterations over the array. The optimized one-pass hash table approach eliminates this drawback by combining both steps into a single iteration:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"During the iteration, the algorithm calculates the complement of the current number.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the complement is already present in the hash table, the pair is found, and the indices are returned.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If not, the current number and its index are added to the hash table for future lookups.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"This removes the need for a second pass, reducing unnecessary work and improving runtime efficiency.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an empty hash table \",(0,n.jsx)(e.code,{children:\"hash\"}),\" to store numbers and their corresponding indices.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the array \",(0,n.jsx)(e.code,{children:\"numbers\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the \",(0,n.jsx)(e.code,{children:\"complement\"}),\" as \",(0,n.jsx)(e.code,{children:\"target - numbers[i]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the \",(0,n.jsx)(e.code,{children:\"complement\"}),\" exists in the hash table:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If it does, return the indices \",(0,n.jsx)(e.code,{children:\"[hash[complement], i]\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Otherwise, add the current number and its index to the hash table.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"If no valid pair is found, return an empty array.\"}),`\n`]}),`\n`,(0,n.jsx)(a,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm processes each element of the array exactly once, and each lookup or insertion in the hash table takes O(1).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". In the worst case, all \",(0,n.jsx)(e.code,{children:\"n\"}),\" elements are stored in the hash map.\"]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var S=C;return T(F);})();\n;return Component;"
}