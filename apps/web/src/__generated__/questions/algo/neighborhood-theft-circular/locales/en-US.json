{
  "description": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},s=(t,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of x(e))!f.call(t,o)&&o!==r&&a(t,o,{get:()=>e[o],enumerable:!(i=b(e,o))||i.enumerable});return t};var v=(t,e,r)=>(r=t!=null?d(p(t)):{},s(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),j=t=>s(a({},\"__esModule\",{value:!0}),t);var l=g((X,u)=>{u.exports=_jsx_runtime});var M={};y(M,{default:()=>C,frontmatter:()=>_});var n=v(l());var h=MDXTestExamples;var c=[{input:[[\"numbers\",[1,2,3,1]]],output:4,explanation:\"The robber can steal a maximum of 4 by robbing house at index 0 (value 1) and house at index 2 (value 3).\"},{input:[[\"numbers\",[2,7,9,3,1]]],output:11,explanation:\"The robber can steal a maximum of 12 by robbing house at index 0 (value 2), house at index 2 (value 9).\"},{input:[[\"numbers\",[3,6,1,0,6,0,0,9]]],output:21,explanation:\"The robber can steal a maximum of 21 by robbing house at index 1 (value 6), house at index 4 (value 6), house at index 7 (value 9).\"}];var _={title:\"Neighborhood Theft (Circular)\",excerpt:\"Implement a function to find maximum money to rob in circular houses without alerting police\"};function m(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"An experienced robber is planning a heist on a circular street. Every house contains a certain amount of money, and all houses are arranged in a circle, meaning the first house is next to the last one. Additionally, adjacent houses have connected security systems that alert the police if two neighboring houses are robbed on the same night.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Given an array of integers \",(0,n.jsx)(e.code,{children:\"numbers\"}),\", where each element represents the amount of money in a house, return the maximum amount of money the robber can steal without triggering the alarm.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The robber cannot steal from two adjacent houses\"}),`\n`]}),`\n`,(0,n.jsx)(h,{testCases:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 400\"]}),`\n`]})]})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=w;return j(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find maximum money to rob in circular houses without alerting police",
    "title": "Neighborhood Theft (Circular)"
  },
  "solution": "var Component=(()=>{var b=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of f(e))!x.call(t,o)&&o!==r&&i(t,o,{get:()=>e[o],enumerable:!(a=p(e,o))||a.enumerable});return t};var w=(t,e,r)=>(r=t!=null?b(g(t)):{},l(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),C=t=>l(i({},\"__esModule\",{value:!0}),t);var u=y((D,s)=>{s.exports=_jsx_runtime});var R={};v(R,{default:()=>k});var n=w(u());var h=MDXCodeBlock;var c=`export default function neighborhoodTheftCircular(numbers: number[]): number {\n  // If there are no houses, return 0\n  if (numbers.length === 0) return 0;\n  // If there is only one house, return the amount in that house\n  if (numbers.length === 1) return numbers[0];\n\n  // Calculate the maximum amount of money that can be robbed by excluding either the first or the last house\n  const max1 = robSimple(numbers, 0, numbers.length - 2);\n  const max2 = robSimple(numbers, 1, numbers.length - 1);\n\n  // Return the maximum amount from the two calculated values\n  return Math.max(max1, max2);\n}\n\n// Helper function to find the maximum amount of money that can be robbed from a range of houses\nfunction robSimple(numbers: number[], start: number, end: number): number {\n  let t1 = 0,\n    t2 = 0;\n\n  // Iterate over the range of houses\n  for (let i = start; i <= end; i++) {\n    // Store the current value of t1 in a temporary variable\n    const temp = t1;\n    // Update t1 to be the maximum of robbing the current house plus the amount from t2, or the current value of t1\n    t1 = Math.max(numbers[i] + t2, t1);\n    // Update t2 to the previous value of t1\n    t2 = temp;\n  }\n\n  // Return the maximum amount of money that can be robbed from the given range of houses\n  return t1;\n}\n`;var m=`export default function neighborhoodTheftCircular(numbers: number[]): number {\n  // If there are no houses, return 0\n  if (numbers.length === 0) return 0;\n  // If there is only one house, return the amount in that house\n  if (numbers.length === 1) return numbers[0];\n\n  // Calculate the maximum amount of money that can be robbed by excluding either the first or the last house\n  const max1 = robWithMemo(numbers, 0, numbers.length - 2);\n  const max2 = robWithMemo(numbers, 1, numbers.length - 1);\n\n  // Return the maximum amount from the two calculated values\n  return Math.max(max1, max2);\n}\n\n// Helper function to find the maximum amount of money that can be robbed from a range of houses using memoization\nfunction robWithMemo(numbers: number[], start: number, end: number): number {\n  // Initialize the memoization array with -1 indicating uncomputed values\n  const memo: number[] = new Array(numbers.length).fill(-1);\n\n  // Recursive function with memoization\n  function dp(i: number): number {\n    // Base case: if i is beyond the end of the range, return 0\n    if (i > end) return 0;\n\n    // Return the cached value if it's already computed\n    if (memo[i] !== -1) return memo[i];\n\n    // Recursively compute the maximum amount by choosing to rob or not rob the current house\n    const robCurrent = numbers[i] + dp(i + 2); // Rob current house and move to the house after next\n    const skipCurrent = dp(i + 1); // Skip current house and move to the next house\n\n    // Store the result in the memo array\n    memo[i] = Math.max(robCurrent, skipCurrent);\n\n    return memo[i];\n  }\n\n  // Start the recursion from the starting index\n  return dp(start);\n}\n`;function d(t){let e=Object.assign({h2:\"h2\",p:\"p\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",h3:\"h3\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Top-Down Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:\"This solution extends the neighborhood theft problem to a circular arrangement of houses. In this scenario, the first and last houses are adjacent, so they cannot both be robbed. The solution uses a divide-and-conquer approach by breaking the circular problem into two linear subproblems:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Exclude the first house and calculate the maximum amount from the rest.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Exclude the last house and calculate the maximum amount from the rest.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"These subproblems are solved using a top-down dynamic programming approach with memoization. The helper function \",(0,n.jsx)(e.code,{children:\"robWithMemo\"}),\" computes the maximum amount that can be robbed from a given range of houses by recursively exploring two options for each house:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Rob the current house and skip the next one.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Skip the current house and move to the next.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Memoization ensures that intermediate results are cached, avoiding redundant calculations and improving efficiency. The final result is the maximum of the two subproblems, representing the optimal solution for the circular arrangement.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Handle special cases:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If there are no houses, return \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"If there is only one house, return its value.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"robWithMemo\"}),\" to calculate the maximum money that can be robbed from a given range of houses:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"memo\"}),\" array to store intermediate results, filled with \",(0,n.jsx)(e.code,{children:\"-1\"}),\" to indicate uncomputed values.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a recursive function \",(0,n.jsx)(e.code,{children:\"dp(i)\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"0\"}),\" if \",(0,n.jsx)(e.code,{children:\"i\"}),\" exceeds the range's end, as no houses are left to rob.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the cached value in \",(0,n.jsx)(e.code,{children:\"memo[i]\"}),\" if already computed.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the maximum money for the current house by choosing between:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Robbing the current house and adding the result of skipping the next house (\",(0,n.jsx)(e.code,{children:\"numbers[i] + dp(i + 2)\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Skipping the current house and moving to the next house (\",(0,n.jsx)(e.code,{children:\"dp(i + 1)\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Cache the result in \",(0,n.jsx)(e.code,{children:\"memo[i]\"}),\" and return it.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Start the recursion from the given range's start index and return the result.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compute two subproblems:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Maximum money excluding the first house (\",(0,n.jsx)(e.code,{children:\"robWithMemo(numbers, 1, numbers.length - 1)\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Maximum money excluding the last house (\",(0,n.jsx)(e.code,{children:\"robWithMemo(numbers, 0, numbers.length - 2)\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the maximum of the two results.\"}),`\n`]}),`\n`,(0,n.jsx)(h,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each subproblem processes all houses in its range once, resulting in linear time complexity.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The memoization array requires space proportional to the number of houses in the range.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Bottom-Up Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:\"The circular neighborhood theft problem requires handling the additional constraint that the first and last houses are neighbors. This creates a conflict when both houses are considered for robbery, as robbing them together violates the problem's constraints. To solve this, the problem is divided into two separate scenarios:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Rob houses from the second to the last, excluding the first house.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Rob houses from the first to the second-to-last, excluding the last house.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"By solving these two linear subproblems independently, the circular constraint is effectively handled. The results of these two cases are then compared to determine the maximum amount that can be robbed.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Each of these subproblems is solved using a space-optimized dynamic programming approach. Instead of maintaining a full \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array to store the maximum amounts for all houses, two variables are used to track the results for the current house and the previous house. This reduces the space complexity while ensuring that the optimal solution for each subproblem is calculated efficiently.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The core idea uses the observation that in a linear house arrangement, the decision to rob or skip each house depends only on the maximum amounts that can be robbed from the previous two houses. This principle is adapted here to handle the circular arrangement by solving two separate linear cases and combining their results.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array is empty. If it is, return \",(0,n.jsx)(e.code,{children:\"0\"}),\" because there are no houses to rob.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array has only one house. If it does, return the value of that house.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Solve two linear subproblems:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Call \",(0,n.jsx)(e.code,{children:\"robSimple\"}),\" with the range from index \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"n - 2\"}),\" (excluding the last house).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Call \",(0,n.jsx)(e.code,{children:\"robSimple\"}),\" with the range from index \",(0,n.jsx)(e.code,{children:\"1\"}),\" to \",(0,n.jsx)(e.code,{children:\"n - 1\"}),\" (excluding the first house).\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the maximum of the two results.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define the helper function \",(0,n.jsx)(e.code,{children:\"robSimple\"}),\" to solve the linear robbery problem:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two variables, \",(0,n.jsx)(e.code,{children:\"t1\"}),\" and \",(0,n.jsx)(e.code,{children:\"t2\"}),\", to \",(0,n.jsx)(e.code,{children:\"0\"}),\". These represent the maximum amounts that can be robbed up to the current and previous houses.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the range of houses from \",(0,n.jsx)(e.code,{children:\"start\"}),\" to \",(0,n.jsx)(e.code,{children:\"end\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the maximum amount that can be robbed at the current house as the maximum of:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Robbing the current house and adding \",(0,n.jsx)(e.code,{children:\"t2\"}),\" (representing the maximum amount robbed up to two houses before).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Skipping the current house and using \",(0,n.jsx)(e.code,{children:\"t1\"}),\" (representing the maximum amount robbed up to the previous house).\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"t2\"}),\" to the value of \",(0,n.jsx)(e.code,{children:\"t1\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"t1\"}),\" to the calculated maximum.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After the loop, return \",(0,n.jsx)(e.code,{children:\"t1\"}),\", which contains the maximum amount that can be robbed in the range.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(h,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each house is processed exactly once in two linear iterations of the helper function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". Only two variables, \",(0,n.jsx)(e.code,{children:\"t1\"}),\" and \",(0,n.jsx)(e.code,{children:\"t2\"}),\", are used to track intermediate results.\"]}),`\n`]})]})}function S(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var k=S;return C(R);})();\n;return Component;"
}