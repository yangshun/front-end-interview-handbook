{
  "description": "var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),q=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of p(e))!f.call(t,s)&&s!==r&&i(t,s,{get:()=>e[s],enumerable:!(o=g(e,s))||o.enumerable});return t};var j=(t,e,r)=>(r=t!=null?m(b(t)):{},c(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>c(i({},\"__esModule\",{value:!0}),t);var l=x((X,h)=>{h.exports=_jsx_runtime});var M={};q(M,{default:()=>C,frontmatter:()=>w});var n=j(l());var a=MDXTestExamples;var u=[{input:[[\"numbers\",[0,1,0,3,2,3]]],output:4,explanation:\"The longest increasing subsequence is [0, 1, 2, 3], which has a length of 4.\"},{input:[[\"numbers\",[3,2]]],output:1,explanation:\"The longest increasing subsequence is either [3] or [2], both of which have a length of 1.\"},{input:[[\"numbers\",[3,3,3,3]]],output:1,explanation:\"The longest increasing subsequence is [3], since all elements are the same.\"}];var w={title:\"Longest Increasing Subsequence\",excerpt:\"Implement a function to find the length of the longest increasing subsequence\"};function d(t){let e=Object.assign({p:\"p\",code:\"code\",strong:\"strong\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of integers \",(0,n.jsx)(e.code,{children:\"numbers\"}),\", determine the length of the longest subsequence in which each number is strictly greater than the one before it.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.strong,{children:\"subsequence\"}),\" is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. For example, the subsequences of \",(0,n.jsx)(e.code,{children:\"[1, 2, 3]\"}),\" are \",(0,n.jsx)(e.code,{children:\"[1]\"}),\", \",(0,n.jsx)(e.code,{children:\"[2]\"}),\", \",(0,n.jsx)(e.code,{children:\"[3]\"}),\", \",(0,n.jsx)(e.code,{children:\"[1, 2]\"}),\", \",(0,n.jsx)(e.code,{children:\"[2, 3]\"}),\", \",(0,n.jsx)(e.code,{children:\"[1, 3]\"}),\", and \",(0,n.jsx)(e.code,{children:\"[1, 2, 3]\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{testCases:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 2500\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10,000 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 10,000\"]}),`\n`]})]})}function y(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var C=y;return _(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the length of the longest increasing subsequence",
    "title": "Longest Increasing Subsequence"
  },
  "solution": "var Component=(()=>{var g=Object.create;var h=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var x=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),I=(r,e)=>{for(var i in e)h(r,i,{get:e[i],enumerable:!0})},o=(r,e,i,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!y.call(r,t)&&t!==i&&h(r,t,{get:()=>e[t],enumerable:!(s=b(e,t))||s.enumerable});return r};var w=(r,e,i)=>(i=r!=null?g(f(r)):{},o(e||!r||!r.__esModule?h(i,\"default\",{value:r,enumerable:!0}):i,r)),q=r=>o(h({},\"__esModule\",{value:!0}),r);var c=x((z,a)=>{a.exports=_jsx_runtime});var L={};I(L,{default:()=>T});var n=w(c());var l=MDXCodeBlock;var d=`function binarySearch(sub: number[], num: number): number {\n  let left = 0;\n  let right = sub.length - 1;\n\n  // Perform binary search\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (sub[mid] === num) {\n      return mid;\n    }\n\n    if (sub[mid] < num) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n\n  return left;\n}\n\nexport default function longestIncreasingSubsequence(\n  numbers: number[],\n): number {\n  // Array to store the current longest increasing subsequence\n  const sub: number[] = [];\n  sub.push(numbers[0]);\n\n  // Iterate over the numbers array\n  for (let i = 1; i < numbers.length; i++) {\n    const num = numbers[i];\n\n    // If the current number is greater than the last element in 'sub'\n    // then add it to 'sub'\n    if (num > sub[sub.length - 1]) {\n      sub.push(num);\n    } else {\n      // Otherwise, find the position to replace in 'sub' using binary search\n      const j = binarySearch(sub, num);\n      sub[j] = num;\n    }\n  }\n\n  // Return the size of 'sub', which represents the length of the LIS\n  return sub.length;\n}\n`;var u=`export default function longestIncreasingSubsequence(\n  numbers: number[],\n): number {\n  // Initialize an array dp where dp[i] will store the length of the longest increasing subsequence ending at index i\n  const dp: number[] = new Array(numbers.length).fill(1);\n\n  // Iterate through each element in numbers array starting from the second element\n  for (let i = 1; i < numbers.length; i++) {\n    // Compare current element numbers[i] with all previous elements numbers[j] where j < i\n    for (let j = 0; j < i; j++) {\n      // If numbers[i] is greater than numbers[j], it means we can extend the subsequence ending at i with j\n      if (numbers[i] > numbers[j]) {\n        // Update dp[i] to be the maximum of its current value or dp[j] + 1\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n\n  // Find the maximum value in dp array, which represents the length of the longest increasing subsequence\n  let longest = 0;\n  for (let c of dp) {\n    longest = Math.max(longest, c);\n  }\n\n  // Return the length of the longest increasing subsequence\n  return longest;\n}\n`;function m(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Dynamic Programming\"}),`\n`,(0,n.jsx)(e.p,{children:\"This solution uses dynamic programming to find the length of the longest increasing subsequence (LIS) in an array. A subsequence is a sequence that can be derived by deleting some or no elements without changing the order of the remaining elements. The dynamic programming approach eliminates redundant calculations by storing intermediate results.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The algorithm maintains a \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array where \",(0,n.jsx)(e.code,{children:\"dp[i]\"}),\" represents the length of the LIS ending at index \",(0,n.jsx)(e.code,{children:\"i\"}),\". For each element in the array, the algorithm checks all previous elements to determine if the current element can extend an increasing subsequence. This ensures that the solution is built incrementally while avoiding recomputation.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array of size \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" with all values set to \",(0,n.jsx)(e.code,{children:\"1\"}),\". Each element is initially its own subsequence.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array starting from the second element:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each element at index \",(0,n.jsx)(e.code,{children:\"i\"}),\", iterate through all previous elements (index \",(0,n.jsx)(e.code,{children:\"j\"}),\" where \",(0,n.jsx)(e.code,{children:\"j < i\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" is greater than \",(0,n.jsx)(e.code,{children:\"numbers[j]\"}),\", update \",(0,n.jsx)(e.code,{children:\"dp[i]\"}),\" to the maximum of \",(0,n.jsx)(e.code,{children:\"dp[i]\"}),\" and \",(0,n.jsx)(e.code,{children:\"dp[j] + 1\"}),\" to include the current element in the subsequence ending at \",(0,n.jsx)(e.code,{children:\"j\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a variable \",(0,n.jsx)(e.code,{children:\"longest\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" and iterate through the \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array to find the maximum value, which represents the LIS.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the value of \",(0,n.jsx)(e.code,{children:\"longest\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". For each element in the array, the algorithm iterates through all previous elements, resulting in a nested loop.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"dp\"}),\" array requires space proportional to the number of elements in the input array.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Greedy and Binary Search\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"This solution combines greedy and binary search techniques to efficiently compute the length of the longest increasing subsequence (LIS). The core idea is to maintain an auxiliary array called \",(0,n.jsx)(e.code,{children:\"sub\"}),\". This array represents the smallest ending values of increasing subsequences of different lengths. For instance, if \",(0,n.jsx)(e.code,{children:\"sub\"}),\" has three elements, it indicates that an increasing subsequence of length 3 has been identified, and its ending value is stored as the last element of \",(0,n.jsx)(e.code,{children:\"sub\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"sub\"}),\" array does not directly represent the LIS itself but helps track the sequence length. At any point, the size of \",(0,n.jsx)(e.code,{children:\"sub\"}),\" corresponds to the length of the LIS found so far. When processing a number:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the number is greater than the largest value in \",(0,n.jsx)(e.code,{children:\"sub\"}),\", it extends the LIS and is appended to \",(0,n.jsx)(e.code,{children:\"sub\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the number is smaller than or equal to an element in \",(0,n.jsx)(e.code,{children:\"sub\"}),\", it replaces the smallest number in \",(0,n.jsx)(e.code,{children:\"sub\"}),\" that is greater than or equal to it. This replacement ensures that \",(0,n.jsx)(e.code,{children:\"sub\"}),\" remains optimal for extending the LIS later.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"To efficiently determine the position for insertion or replacement in \",(0,n.jsx)(e.code,{children:\"sub\"}),\", binary search is used. This ensures that the algorithm runs in O(n log n) time, as binary search allows for quick position determination.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"binarySearch\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two pointers \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" to represent the search space in the \",(0,n.jsx)(e.code,{children:\"sub\"}),\" array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use a loop to perform binary search, updating the \",(0,n.jsx)(e.code,{children:\"left\"}),\" or \",(0,n.jsx)(e.code,{children:\"right\"}),\" pointer based on comparisons.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the index where the number should be inserted or replaced.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an array \",(0,n.jsx)(e.code,{children:\"sub\"}),\" with the first element of \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" to store the current LIS.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" array starting from the second element:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the current number is greater than the last element of \",(0,n.jsx)(e.code,{children:\"sub\"}),\", append it to \",(0,n.jsx)(e.code,{children:\"sub\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Otherwise, use \",(0,n.jsx)(e.code,{children:\"binarySearch\"}),\" to find the index in \",(0,n.jsx)(e.code,{children:\"sub\"}),\" where the number should replace an existing value to maintain the LIS.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the length of the \",(0,n.jsx)(e.code,{children:\"sub\"}),\" array as the length of the LIS.\"]}),`\n`]}),`\n`,(0,n.jsx)(l,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Each number is processed once, and binary search on the \",(0,n.jsx)(e.code,{children:\"sub\"}),\" array takes O(log n) for each number.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"sub\"}),\" array requires space proportional to the number of elements in the input array in the worst case.\"]}),`\n`]})]})}function v(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(m,r)})):m(r)}var T=v;return q(L);})();\n;return Component;"
}