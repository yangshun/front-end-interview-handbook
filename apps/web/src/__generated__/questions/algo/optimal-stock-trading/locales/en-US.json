{
  "description": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},s=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!g.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(c=m(e,r))||c.enumerable});return t};var j=(t,e,i)=>(i=t!=null?h(x(t)):{},s(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),_=t=>s(o({},\"__esModule\",{value:!0}),t);var l=y((I,a)=>{a.exports=_jsx_runtime});var T={};b(T,{default:()=>D,frontmatter:()=>C});var n=j(l());var p=MDXTestExamples;var d=[{input:[[\"prices\",[1,2,3,4]]],output:3,explanation:\"Buy the stock at day 1 (price = 1) and sell it on day 4 (price = 4), profit: 4 - 1 = 3\"},{input:[[\"prices\",[4,3,2,1]]],output:0,explanation:\"Not possible to profit because the prices is only declining\"},{input:[[\"prices\",[6,8,1,2,30,19]]],output:29,explanation:\"Buy at day 3 (price = 1) and sell it on day 5 (price = 30), profit: 30 - 1 = 29\"}];var C={title:\"Optimal Stock Trading\",excerpt:\"Implement a function to find the maximum profit achievable by buying and selling a stock once\"};function u(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a list of \",(0,n.jsx)(e.code,{children:\"prices\"}),\", where each element \",(0,n.jsx)(e.code,{children:\"prices[i]\"}),\" represents the price of a particular stock on day \",(0,n.jsx)(e.code,{children:\"i\"}),\", determine the maximum profit to be made by purchasing the stock and selling it on a future date. If it is not possible to generate a profit, return \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"prices: number[]\"}),\": An array of integers representing the stock price on each day\"]}),`\n`]}),`\n`,(0,n.jsx)(p,{testCases:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"prices.length\"}),\" <= 10,000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"prices[i]\"}),\" <= 10,000\"]}),`\n`]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(u,t)})):u(t)}var D=M;return _(T);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the maximum profit achievable by buying and selling a stock once",
    "title": "Optimal Stock Trading"
  },
  "solution": "var Component=(()=>{var m=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),P=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of g(e))!x.call(t,n)&&n!==r&&a(t,n,{get:()=>e[n],enumerable:!(c=f(e,n))||c.enumerable});return t};var w=(t,e,r)=>(r=t!=null?m(y(t)):{},l(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),T=t=>l(a({},\"__esModule\",{value:!0}),t);var d=b((F,h)=>{h.exports=_jsx_runtime});var _={};P(_,{default:()=>I});var i=w(d());var o=MDXCodeBlock;var s=`export default function optimalStockTrading(prices: number[]): number {\n  // Initialize maximum profit to 0, assuming no profit initially\n  let maxProfit: number = 0;\n\n  // Track the lowest buying price seen so far\n  let lowestPrice: number = Number.MAX_SAFE_INTEGER;\n\n  for (const currentPrice of prices) {\n    // Update the lowest buying price if a lower price is encountered\n    lowestPrice = Math.min(lowestPrice, currentPrice);\n\n    // Calculate potential profit for the current price\n    const potentialProfit: number = currentPrice - lowestPrice;\n\n    // Update the maximum profit if a higher potential profit is found\n    maxProfit = Math.max(maxProfit, potentialProfit);\n  }\n\n  return maxProfit;\n}\n`;var p=`export default function optimalStockTrading(prices: number[]): number {\n  // Initialize the maximum profit to 0\n  let maxProfit = 0;\n\n  // Iterate through each day's price\n  for (let i = 0; i < prices.length - 1; i++) {\n    // For each day, compare it with the prices of the subsequent days\n    for (let j = i + 1; j < prices.length; j++) {\n      // Calculate the profit by subtracting the current day's price from the future day's price\n      const profit = prices[j] - prices[i];\n\n      // If the calculated profit is greater than the current maximum profit, update the maximum profit\n      if (profit > maxProfit) {\n        maxProfit = profit;\n      }\n    }\n  }\n\n  // Return the maximum profit\n  return maxProfit;\n}\n`;function u(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"1. Brute Force Approach\"}),`\n`,(0,i.jsx)(e.p,{children:\"This solution calculates the maximum profit that can be achieved by buying and selling a stock on different days using a brute force approach. The idea is to evaluate all possible pairs of days and calculate the profit for each pair. The maximum profit is determined by comparing all the calculated profits.\"}),`\n`,(0,i.jsx)(e.p,{children:\"For each day, the algorithm assumes it to be the buying day and iterates through all subsequent days to check for possible selling days. The profit for each pair is calculated as the difference between the selling price and the buying price. The maximum profit encountered during these comparisons is stored and returned as the result.\"}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize a variable \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" to \",(0,i.jsx)(e.code,{children:\"0\"}),\" to store the maximum profit encountered.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Use a nested loop to iterate through all possible pairs of days:\",`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"The outer loop represents the buying day (\",(0,i.jsx)(e.code,{children:\"i\"}),\"), iterating from the first day to the second-to-last day.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"The inner loop represents the selling day (\",(0,i.jsx)(e.code,{children:\"j\"}),\"), iterating from the day after \",(0,i.jsx)(e.code,{children:\"i\"}),\" to the last day.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"For each pair of days:\",`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Calculate the profit as the difference between the price on the selling day (\",(0,i.jsx)(e.code,{children:\"prices[j]\"}),\") and the price on the buying day (\",(0,i.jsx)(e.code,{children:\"prices[i]\"}),\").\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"If the calculated profit is greater than \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\", update \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" with the new profit value.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"After all iterations, return \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" as the maximum profit that can be achieved.\"]}),`\n`]}),`\n`,(0,i.jsx)(o,{children:p}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,i.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The nested loops iterate over all pairs of days, resulting in a quadratic time complexity.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional data structures are used; only a few variables are required for calculations.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{children:\"2. Greedy Approach\"}),`\n`,(0,i.jsx)(e.p,{children:\"This solution calculates the maximum profit that can be achieved by buying and selling a stock on different days using a greedy approach. The algorithm focuses on minimizing unnecessary calculations by keeping track of the lowest price encountered so far and calculating the profit dynamically as the iteration progresses.\"}),`\n`,(0,i.jsx)(e.p,{children:\"The key idea is to maintain two variables:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\", which tracks the minimum price encountered so far in the array.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"maxProfit\"}),\", which tracks the maximum profit possible based on the current \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\" and the current price.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"For each price in the array, the algorithm updates \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\" if the current price is lower. It then calculates the potential profit by subtracting \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\" from the current price and updates \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" if the calculated profit is greater. This approach eliminates the need to compare all pairs of prices, reducing the time complexity significantly compared to the brute force approach.\"]}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" to \",(0,i.jsx)(e.code,{children:\"0\"}),\" to store the maximum profit encountered.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\" to a very large value (\",(0,i.jsx)(e.code,{children:\"Number.MAX_SAFE_INTEGER\"}),\") to track the smallest price encountered so far.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Iterate through each price in the \",(0,i.jsx)(e.code,{children:\"prices\"}),\" array:\",`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Update \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\" with the smaller value between \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\" and the current price.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Calculate the potential profit as the difference between the current price and \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Update \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" with the larger value between \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" and the potential profit.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"After completing the iteration, return \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" as the maximum profit that can be achieved.\"]}),`\n`]}),`\n`,(0,i.jsx)(o,{children:s}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The algorithm traverses the list of prices once, updating \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\" and calculating \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\" in constant time for each price.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". Only two variables, \",(0,i.jsx)(e.code,{children:\"lowestPrice\"}),\" and \",(0,i.jsx)(e.code,{children:\"maxProfit\"}),\", are used to track intermediate results.\"]}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(u,t)})):u(t)}var I=j;return T(_);})();\n;return Component;"
}