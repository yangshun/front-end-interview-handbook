{
  "description": "var Component=(()=>{var s=Object.create;var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var t in e)l(n,t,{get:e[t],enumerable:!0})},d=(n,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!f.call(n,i)&&i!==t&&l(n,i,{get:()=>e[i],enumerable:!(o=u(e,i))||o.enumerable});return n};var b=(n,e,t)=>(t=n!=null?s(p(n)):{},d(e||!n||!n.__esModule?l(t,\"default\",{value:n,enumerable:!0}):t,n)),x=n=>d(l({},\"__esModule\",{value:!0}),n);var a=y((T,c)=>{c.exports=_jsx_runtime});var q={};g(q,{default:()=>w,frontmatter:()=>O});var r=b(a()),O={title:\"Binary Tree\",excerpt:\"Implement a binary tree data structure including essential operations\"};function h(n){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",blockquote:\"blockquote\",h2:\"h2\",pre:\"pre\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:\"Implement a binary tree data structure with the following operations:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"new BinaryTree()\"}),\": Create an instance of a \",(0,r.jsx)(e.code,{children:\"BinaryTree\"}),\". The root is initialized to \",(0,r.jsx)(e.code,{children:\"null\"}),\", indicating the tree starts empty.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\": Return the number of nodes in the tree. Required time complexity: O(n), where n is the number of nodes in the tree.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"height()\"}),\": Return the height of the tree, defined as the number of edges on the longest path from the root to a leaf. The height of an empty tree is 0. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"inOrder()\"}),\": Return an array of values from an in-order traversal. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"preOrder()\"}),\": Return an array of values from a pre-order traversal. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"postOrder()\"}),\": Return an array of values from a post-order traversal. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\": Return \",(0,r.jsx)(e.code,{children:\"true\"}),\" if the tree is balanced. A binary tree is balanced if, for every node in the tree, the height difference between its left and right subtrees is at most 1. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isComplete()\"}),\": Return \",(0,r.jsx)(e.code,{children:\"true\"}),\" if the tree is complete. A binary tree is complete if all levels are fully filled, except possibly the last, which must be filled from left to right. Required time complexity: O(n).\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.blockquote,{children:[`\n`,(0,r.jsxs)(e.p,{children:[\"Use the helper class \",(0,r.jsx)(e.code,{children:\"BinaryTreeNode\"}),\" to represent nodes, with \",(0,r.jsx)(e.code,{children:\"value\"}),\", \",(0,r.jsx)(e.code,{children:\"left\"}),\", and \",(0,r.jsx)(e.code,{children:\"right\"}),\" properties.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`const tree = new BinaryTree();\ntree.root = new BinaryTreeNode(10);\ntree.root.left = new BinaryTreeNode(5);\ntree.root.right = new BinaryTreeNode(15);\n\ntree.size(); // 3\ntree.height(); // 1\ntree.inOrder(); // [5, 10, 15]\ntree.preOrder(); // [10, 5, 15]\ntree.postOrder(); // [5, 15, 10]\ntree.isBalanced(); // true\ntree.isComplete(); // true\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Constraints\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"0 <= Number of nodes <= 100\"}),`\n`,(0,r.jsx)(e.li,{children:\"Each node in a binary tree has at most one left child and one right child\"}),`\n`]})]})}function R(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(h,n)})):h(n)}var w=R;return x(q);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a binary tree data structure including essential operations",
    "title": "Binary Tree"
  },
  "solution": "var Component=(()=>{var p=Object.create;var l=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),T=(n,e)=>{for(var t in e)l(n,t,{get:e[t],enumerable:!0})},d=(n,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!y.call(n,i)&&i!==t&&l(n,i,{get:()=>e[i],enumerable:!(o=g(e,i))||o.enumerable});return n};var H=(n,e,t)=>(t=n!=null?p(v(n)):{},d(e||!n||!n.__esModule?l(t,\"default\",{value:n,enumerable:!0}):t,n)),O=n=>d(l({},\"__esModule\",{value:!0}),n);var s=b((q,h)=>{h.exports=_jsx_runtime});var N={};T(N,{default:()=>A});var r=H(s());var a=MDXCodeBlock;var c=`export class BinaryTreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport class BinaryTree {\n  /**\n   * Initialize the Binary Tree.\n   * @param {*} value The value of the root node.\n   */\n  constructor(value) {\n    this.root = value == null ? null : new BinaryTreeNode(value);\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size() {\n    const sizeHelper = (node) => {\n      if (!node) {\n        return 0;\n      }\n      return 1 + sizeHelper(node.left) + sizeHelper(node.right);\n    };\n    return this.root ? sizeHelper(this.root) : 0;\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height() {\n    const heightHelper = (node) => {\n      if (!node) {\n        return -1;\n      }\n      return 1 + Math.max(heightHelper(node.left), heightHelper(node.right));\n    };\n    return this.root ? heightHelper(this.root) : 0;\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<*>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder() {\n    const arr = [];\n    const inOrderHelper = (node) => {\n      if (node == null) {\n        return;\n      }\n\n      inOrderHelper(node.left);\n      arr.push(node.value);\n      inOrderHelper(node.right);\n    };\n    inOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<*>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder() {\n    const arr = [];\n    const preOrderHelper = (node) => {\n      if (!node) {\n        return;\n      }\n\n      arr.push(node.value);\n      preOrderHelper(node.left);\n      preOrderHelper(node.right);\n    };\n    preOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<*>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder() {\n    const arr = [];\n    const postOrderHelper = (node) => {\n      if (!node) {\n        return;\n      }\n\n      postOrderHelper(node.left);\n      postOrderHelper(node.right);\n      arr.push(node.value);\n    };\n    postOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced() {\n    const isBalancedHelper = (node) => {\n      if (!node) {\n        return 0;\n      }\n\n      const leftHeight = isBalancedHelper(node.left);\n      const rightHeight = isBalancedHelper(node.right);\n\n      if (\n        leftHeight === -1 ||\n        rightHeight === -1 ||\n        Math.abs(leftHeight - rightHeight) > 1\n      ) {\n        return -1;\n      }\n\n      return 1 + Math.max(leftHeight, rightHeight);\n    };\n    return isBalancedHelper(this.root) !== -1;\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete() {\n    if (!this.root) return true;\n\n    const queue = [this.root];\n    let foundNull = false;\n\n    while (queue.length > 0) {\n      const node = queue.shift();\n\n      if (node === null) {\n        foundNull = true;\n      } else {\n        if (foundNull) {\n          return false; // Found a non-null node after a null one\n        }\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n\n    return true;\n  }\n}\n`;var u=`export class BinaryTreeNode<T> {\n  public value: T;\n  public left: BinaryTreeNode<T> | null;\n  public right: BinaryTreeNode<T> | null;\n\n  constructor(value: T) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport class BinaryTree<T> {\n  public root: BinaryTreeNode<T> | null;\n\n  /**\n   * Initialize the Binary Tree.\n   * @param {T} value The value of the root node.\n   */\n  constructor(value?: T) {\n    this.root = value == null ? null : new BinaryTreeNode(value);\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size(): number {\n    const sizeHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return 0;\n      }\n      return 1 + sizeHelper(node.left) + sizeHelper(node.right);\n    };\n    return this.root ? sizeHelper(this.root) : 0;\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height(): number {\n    const heightHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return -1;\n      }\n      return 1 + Math.max(heightHelper(node.left), heightHelper(node.right));\n    };\n    return this.root ? heightHelper(this.root) : 0;\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<T>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const inOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (node == null) {\n        return;\n      }\n\n      inOrderHelper(node.left);\n      arr.push(node.value);\n      inOrderHelper(node.right);\n    };\n    inOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<T>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const preOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (!node) {\n        return;\n      }\n\n      arr.push(node.value);\n      preOrderHelper(node.left);\n      preOrderHelper(node.right);\n    };\n    preOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<T>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const postOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (!node) {\n        return;\n      }\n\n      postOrderHelper(node.left);\n      postOrderHelper(node.right);\n      arr.push(node.value);\n    };\n    postOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced(): boolean {\n    const isBalancedHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return 0;\n      }\n\n      const leftHeight = isBalancedHelper(node.left);\n      const rightHeight = isBalancedHelper(node.right);\n\n      if (\n        leftHeight === -1 ||\n        rightHeight === -1 ||\n        Math.abs(leftHeight - rightHeight) > 1\n      ) {\n        return -1;\n      }\n\n      return 1 + Math.max(leftHeight, rightHeight);\n    };\n    return isBalancedHelper(this.root) !== -1;\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete(): boolean {\n    if (!this.root) return true;\n\n    const queue: Array<BinaryTreeNode<T> | null> = [this.root];\n    let foundNull = false;\n\n    while (queue.length > 0) {\n      const node = queue.shift();\n\n      if (node === undefined || node === null) {\n        foundNull = true;\n      } else {\n        if (foundNull) {\n          return false; // A non-null node appeared after a null one\n        }\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n\n    return true;\n  }\n}\n`;function f(n){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",strong:\"strong\",h3:\"h3\",ol:\"ol\",h2:\"h2\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"A Binary Tree is a hierarchical data structure where each node has at most two children: the \",(0,r.jsx)(e.code,{children:\"left\"}),\" child and the \",(0,r.jsx)(e.code,{children:\"right\"}),\" child. The structure consists of nodes that store a \",(0,r.jsx)(e.code,{children:\"value\"}),\" and references to their children. The topmost node is called the \",(0,r.jsx)(e.code,{children:\"root\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"This implementation separates the binary tree structure (\",(0,r.jsx)(e.code,{children:\"BinaryTree\"}),\") from its individual nodes (\",(0,r.jsx)(e.code,{children:\"BinaryTreeNode\"}),\"). Each node contains a \",(0,r.jsx)(e.code,{children:\"value\"}),\", and pointers to its \",(0,r.jsx)(e.code,{children:\"left\"}),\" and \",(0,r.jsx)(e.code,{children:\"right\"}),\" children.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"The core operations can be implemented using a recursive approach, which is natural and efficient for binary trees because each subtree is itself a binary tree:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Traversal methods\"}),\" (\",(0,r.jsx)(e.code,{children:\"inOrder\"}),\", \",(0,r.jsx)(e.code,{children:\"preOrder\"}),\", \",(0,r.jsx)(e.code,{children:\"postOrder\"}),\") use simple depth-first recursion to visit nodes in the correct order and collect their values in an array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\" and \",(0,r.jsx)(e.code,{children:\"height()\"}),\" are calculated recursively by visiting every node once, combining results from left and right children.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\" uses a recursive approach to walk the tree from the bottom up, checking if each subtree is balanced. While doing this, it also calculates the height of each node. If it finds a subtree with height difference > 1, it returns -1 immediately, which bubbles up and stops further checks, keeping the time complexity at O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isComplete()\"}),\" uses a level-order traversal (BFS) to ensure all levels are fully filled, and the last level is filled from left to right without gaps.\"]}),`\n`]}),`\n`,(0,r.jsx)(a,{languages:{jsx:c,tsx:u}}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"new BinaryTree(value)\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initializes a tree. If a \",(0,r.jsx)(e.code,{children:\"value\"}),\" is passed, the root is set to a new \",(0,r.jsx)(e.code,{children:\"BinaryTreeNode\"}),\" with that value. If not, the root is \",(0,r.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Base case: if \",(0,r.jsx)(e.code,{children:\"node\"}),\" is \",(0,r.jsx)(e.code,{children:\"null\"}),\", return 0.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Recursive case: 1 + size of left subtree + size of right subtree.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"height()\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Base case: if \",(0,r.jsx)(e.code,{children:\"node\"}),\" is \",(0,r.jsx)(e.code,{children:\"null\"}),\", return -1.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Recursive case: 1 + max(height of left subtree, height of right subtree).\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"For an empty tree, \",(0,r.jsx)(e.code,{children:\"height()\"}),\" returns 0.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Traversal Methods (\",(0,r.jsx)(e.code,{children:\"inOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"preOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"postOrder()\"}),\"):\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"These methods return arrays of node values based on different traversal orders:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"In-order (left \\u2192 root \\u2192 right)\"}),`\n`,(0,r.jsx)(e.li,{children:\"Pre-order (root \\u2192 left \\u2192 right)\"}),`\n`,(0,r.jsx)(e.li,{children:\"Post-order (left \\u2192 right \\u2192 root)\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.li,{children:\"Each method uses a recursive helper that walks through the tree from the root using DFS, visiting child nodes in the specified order.\"}),`\n`,(0,r.jsx)(e.li,{children:\"A temporary array is built up during the recursive calls to collect values in the correct sequence.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Recursive helper returns height if subtree is balanced, or -1 if not.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Main method checks if the result is not -1.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isComplete()\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Uses BFS (level-order traversal) with a queue.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"As nodes are dequeued, if a \",(0,r.jsx)(e.code,{children:\"null\"}),\" is found, all subsequent nodes must also be \",(0,r.jsx)(e.code,{children:\"null\"}),\" for the tree to be considered complete. If any non-null node appears after a null, the tree is incomplete.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Let \",(0,r.jsx)(e.code,{children:\"n\"}),\" be the number of nodes and \",(0,r.jsx)(e.code,{children:\"h\"}),\" the height of the tree.\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\", \",(0,r.jsx)(e.code,{children:\"height()\"}),\", \",(0,r.jsx)(e.code,{children:\"inOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"preOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"postOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\", \",(0,r.jsx)(e.code,{children:\"isComplete()\"}),\": O(n). Each node is visited once.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Recursive methods (\",(0,r.jsx)(e.code,{children:\"size()\"}),\", \",(0,r.jsx)(e.code,{children:\"height()\"}),\", traversals, \",(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\"): O(h) due to call stack. In the worst case (skewed tree), h = O(n). In a balanced tree, h = O(log n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isComplete()\"}),\": O(n) in the worst case due to the BFS queue holding up to n/2 nodes at the last level of a complete tree.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Empty tree\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\" is 0\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"height()\"}),\" is 0\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Traversals return \",(0,r.jsx)(e.code,{children:\"[]\"})]}),`\n`,(0,r.jsx)(e.li,{children:\"Tree is both balanced and complete\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Single node tree\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\" is 1\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"height()\"}),\" is 0\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Tree is both balanced and complete\"}),`\n`]}),`\n`]}),`\n`]})]})}function x(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(f,n)})):f(n)}var A=x;return O(N);})();\n;return Component;"
}