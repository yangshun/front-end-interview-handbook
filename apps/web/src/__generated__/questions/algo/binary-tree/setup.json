{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/binary-tree\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/binary-tree.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/binary-tree.run.test.ts": "import { BinaryTree, BinaryTreeNode } from './binary-tree';\n\ndescribe('BinaryTree', () => {\n  test('constructor', () => {\n    const tree = new BinaryTree();\n    expect(tree instanceof BinaryTree).toBeTruthy();\n    expect(tree.size()).toBe(0);\n    expect(tree.height()).toBe(0);\n  });\n\n  test('size & height', () => {\n    const tree = new BinaryTree();\n    tree.root = new BinaryTreeNode(10);\n    const root = tree.root!;\n    expect(tree.size()).toBe(1);\n    expect(tree.height()).toBe(0);\n    root.left = new BinaryTreeNode(5);\n    root.right = new BinaryTreeNode(15);\n    expect(tree.height()).toBe(1);\n    expect(tree.size()).toBe(3);\n    root.left.left = new BinaryTreeNode(3);\n    expect(tree.height()).toBe(2);\n  });\n\n  test('Orders', () => {\n    const tree = new BinaryTree();\n    expect(tree.inOrder()).toEqual([]);\n    tree.root = new BinaryTreeNode(10);\n    const root = tree.root!;\n    root.left = new BinaryTreeNode(5);\n    root.right = new BinaryTreeNode(15);\n    root.left.left = new BinaryTreeNode(3);\n    root.left.right = new BinaryTreeNode(7);\n    expect(tree.inOrder()).toEqual([3, 5, 7, 10, 15]);\n    expect(tree.preOrder()).toEqual([10, 5, 3, 7, 15]);\n    expect(tree.postOrder()).toEqual([3, 7, 5, 15, 10]);\n  });\n\n  test('isBalanced', () => {\n    const tree = new BinaryTree();\n    expect(tree.isBalanced()).toBeTruthy();\n    tree.root = new BinaryTreeNode(10);\n    expect(tree.isBalanced()).toBeTruthy();\n    const root = tree.root!;\n    root.left = new BinaryTreeNode(5);\n    expect(tree.isBalanced()).toBeTruthy();\n  });\n\n  test('isComplete', () => {\n    const tree = new BinaryTree();\n    expect(tree.isComplete()).toBeTruthy();\n    tree.root = new BinaryTreeNode(10);\n    expect(tree.isComplete()).toBeTruthy();\n    const root = tree.root!;\n    root.left = new BinaryTreeNode(5);\n    root.right = new BinaryTreeNode(15);\n    expect(tree.isComplete()).toBeTruthy();\n  });\n});\n",
    "/src/binary-tree.submit.test.ts": "import { BinaryTree, BinaryTreeNode } from './binary-tree';\n\nfunction createTree() {\n  const tree = new BinaryTree('F');\n  const root = tree.root!;\n  root.left = new BinaryTreeNode('B');\n  root.left.left = new BinaryTreeNode('A');\n  root.left.right = new BinaryTreeNode('D');\n  root.left.right.left = new BinaryTreeNode('C');\n  root.left.right.right = new BinaryTreeNode('E');\n  root.right = new BinaryTreeNode('G');\n  root.right.right = new BinaryTreeNode('I');\n  root.right.right.left = new BinaryTreeNode('H');\n  return tree;\n}\n\ndescribe('BinaryTree', () => {\n  describe('constructor()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree).toBeTruthy();\n      expect(tree.root).toBe(null);\n    });\n\n    test('one-node tree', () => {\n      const { root } = new BinaryTree(5);\n      expect(root?.value).toBe(5);\n    });\n  });\n\n  describe('root', () => {\n    test('empty tree', () => {\n      const { root } = new BinaryTree();\n      expect(root).toBe(null);\n    });\n\n    test('one-node tree', () => {\n      const { root } = new BinaryTree(5);\n      expect(root?.value).toBe(5);\n    });\n  });\n\n  describe('size()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.size()).toBe(0);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.size()).toBe(1);\n    });\n\n    test('two-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.size()).toBe(2);\n    });\n\n    test('non-empty tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.left.left = new BinaryTreeNode(15);\n      root.right = new BinaryTreeNode(2);\n      expect(tree.size()).toBe(4);\n    });\n  });\n\n  describe('height()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.height()).toBe(0);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.height()).toBe(0);\n    });\n\n    test('two-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.height()).toBe(1);\n    });\n\n    test('non-empty tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.left.left = new BinaryTreeNode(15);\n      root.right = new BinaryTreeNode(2);\n      expect(tree.height()).toBe(2);\n    });\n  });\n\n  describe('inOrder()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.inOrder()).toEqual([]);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.inOrder()).toEqual([10]);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.inOrder()).toEqual([5, 10, 15]);\n    });\n\n    test('non-empty tree', () => {\n      const tree = createTree();\n      expect(tree.inOrder()).toEqual([\n        'A',\n        'B',\n        'C',\n        'D',\n        'E',\n        'F',\n        'G',\n        'H',\n        'I',\n      ]);\n    });\n  });\n\n  describe('preOrder()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.preOrder()).toEqual([]);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.preOrder()).toEqual([10]);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.preOrder()).toEqual([10, 5, 15]);\n    });\n\n    test('non-empty tree', () => {\n      const tree = createTree();\n      expect(tree.preOrder()).toEqual([\n        'F',\n        'B',\n        'A',\n        'D',\n        'C',\n        'E',\n        'G',\n        'I',\n        'H',\n      ]);\n    });\n  });\n\n  describe('postOrder()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.postOrder()).toEqual([]);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.postOrder()).toEqual([10]);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.postOrder()).toEqual([5, 15, 10]);\n    });\n\n    test('non-empty tree', () => {\n      const tree = createTree();\n      expect(tree.postOrder()).toEqual([\n        'A',\n        'C',\n        'E',\n        'D',\n        'B',\n        'H',\n        'I',\n        'G',\n        'F',\n      ]);\n    });\n  });\n\n  describe('isBalanced()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test('linked-list tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(15);\n      root.right.right = new BinaryTreeNode(20);\n      expect(tree.isBalanced()).toBe(false);\n    });\n\n    test('non-empty tree', () => {\n      const tree = createTree();\n      expect(tree.isBalanced()).toBe(false);\n    });\n  });\n\n  describe('isComplete()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test('two-node tree left', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test('two-node tree right', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(5);\n      expect(tree.isComplete()).toBe(false);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test('linked-list tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(15);\n      root.right.right = new BinaryTreeNode(20);\n      expect(tree.isComplete()).toBe(false);\n    });\n  });\n});\n",
    "/src/binary-tree.ts": "export class BinaryTreeNode<T> {\n  public value: T;\n  public left: BinaryTreeNode<T> | null;\n  public right: BinaryTreeNode<T> | null;\n\n  constructor(value: T) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport class BinaryTree<T> {\n  public root: BinaryTreeNode<T> | null;\n\n  /**\n   * Initialize the Binary Tree.\n   * @param {T} value The value of the root node.\n   */\n  constructor(value?: T) {\n    this.root = value == null ? null : new BinaryTreeNode(value);\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size(): number {\n    const sizeHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return 0;\n      }\n      return 1 + sizeHelper(node.left) + sizeHelper(node.right);\n    };\n    return this.root ? sizeHelper(this.root) : 0;\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height(): number {\n    const heightHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return -1;\n      }\n      return 1 + Math.max(heightHelper(node.left), heightHelper(node.right));\n    };\n    return this.root ? heightHelper(this.root) : 0;\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<T>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const inOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (node == null) {\n        return;\n      }\n\n      inOrderHelper(node.left);\n      arr.push(node.value);\n      inOrderHelper(node.right);\n    };\n    inOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<T>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const preOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (!node) {\n        return;\n      }\n\n      arr.push(node.value);\n      preOrderHelper(node.left);\n      preOrderHelper(node.right);\n    };\n    preOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<T>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const postOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (!node) {\n        return;\n      }\n\n      postOrderHelper(node.left);\n      postOrderHelper(node.right);\n      arr.push(node.value);\n    };\n    postOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced(): boolean {\n    const isBalancedHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return 0;\n      }\n\n      const leftHeight = isBalancedHelper(node.left);\n      const rightHeight = isBalancedHelper(node.right);\n\n      if (\n        leftHeight === -1 ||\n        rightHeight === -1 ||\n        Math.abs(leftHeight - rightHeight) > 1\n      ) {\n        return -1;\n      }\n\n      return 1 + Math.max(leftHeight, rightHeight);\n    };\n    return isBalancedHelper(this.root) !== -1;\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete(): boolean {\n    if (!this.root) return true;\n\n    const queue: Array<BinaryTreeNode<T> | null> = [this.root];\n    let foundNull = false;\n\n    while (queue.length > 0) {\n      const node = queue.shift();\n\n      if (node === undefined || node === null) {\n        foundNull = true;\n      } else {\n        if (foundNull) {\n          return false; // A non-null node appeared after a null one\n        }\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n\n    return true;\n  }\n}\n"
  },
  "skeleton": {
    "js": "export class BinaryTreeNode {\n  /**\n   * Initialize a Binary Tree node.\n   * @param {*} value The value of the node.\n   */\n  constructor(value) {\n    throw 'Not implemented!';\n  }\n}\n\nexport class BinaryTree {\n  /**\n   * Initialize the Binary Tree.\n   * @param {*} value The value of the root node.\n   */\n  constructor(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<*>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<*>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<*>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete() {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export class BinaryTreeNode<T> {\n  public value: T;\n  public left: BinaryTreeNode<T> | null;\n  public right: BinaryTreeNode<T> | null;\n\n  /**\n   * Initialize a Binary Tree node.\n   * @param {T} value The value of the node.\n   */\n  constructor(value?: T) {\n    throw 'Not implemented!';\n  }\n}\n\nexport class BinaryTree<T> {\n  /**\n   * Initialize the Binary Tree.\n   * @param {T} value The value of the root node.\n   */\n  constructor(value?: T) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size(): number {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height(): number {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<T>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder(): Array<T> {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<T>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder(): Array<T> {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<T>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder(): Array<T> {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced(): boolean {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete(): boolean {\n    throw 'Not implemented!';\n  }\n}"
  },
  "workspace": {
    "main": "/src/binary-tree.ts",
    "run": "/src/binary-tree.run.test.ts",
    "submit": "/src/binary-tree.submit.test.ts"
  }
}