{
  "description": "var Component=(()=>{var s=Object.create;var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var y=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var t in e)l(n,t,{get:e[t],enumerable:!0})},d=(n,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!f.call(n,i)&&i!==t&&l(n,i,{get:()=>e[i],enumerable:!(o=u(e,i))||o.enumerable});return n};var b=(n,e,t)=>(t=n!=null?s(p(n)):{},d(e||!n||!n.__esModule?l(t,\"default\",{value:n,enumerable:!0}):t,n)),x=n=>d(l({},\"__esModule\",{value:!0}),n);var a=y((T,c)=>{c.exports=_jsx_runtime});var q={};g(q,{default:()=>w,frontmatter:()=>O});var r=b(a()),O={title:\"Binary Tree\",excerpt:\"Implement a binary tree data structure including essential operations\"};function h(n){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",blockquote:\"blockquote\",h2:\"h2\",pre:\"pre\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:\"Implement a binary tree data structure with the following operations:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"new BinaryTree()\"}),\": Create an instance of a \",(0,r.jsx)(e.code,{children:\"BinaryTree\"}),\". The root is initialized to \",(0,r.jsx)(e.code,{children:\"null\"}),\", indicating the tree starts empty.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\": Return the number of nodes in the tree. Required time complexity: O(n), where n is the number of nodes in the tree.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"height()\"}),\": Return the height of the tree, defined as the number of edges on the longest path from the root to a leaf. The height of an empty tree is 0. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"inOrder()\"}),\": Return an array of values from an in-order traversal. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"preOrder()\"}),\": Return an array of values from a pre-order traversal. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"postOrder()\"}),\": Return an array of values from a post-order traversal. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\": Return \",(0,r.jsx)(e.code,{children:\"true\"}),\" if the tree is balanced. A binary tree is balanced if, for every node in the tree, the height difference between its left and right subtrees is at most 1. Required time complexity: O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isComplete()\"}),\": Return \",(0,r.jsx)(e.code,{children:\"true\"}),\" if the tree is complete. A binary tree is complete if all levels are fully filled, except possibly the last, which must be filled from left to right. Required time complexity: O(n).\"]}),`\n`]}),`\n`,(0,r.jsxs)(e.blockquote,{children:[`\n`,(0,r.jsxs)(e.p,{children:[\"Use the helper class \",(0,r.jsx)(e.code,{children:\"BinaryTreeNode\"}),\" to represent nodes, with \",(0,r.jsx)(e.code,{children:\"value\"}),\", \",(0,r.jsx)(e.code,{children:\"left\"}),\", and \",(0,r.jsx)(e.code,{children:\"right\"}),\" properties.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`const tree = new BinaryTree();\ntree.root = new BinaryTreeNode(10);\ntree.root.left = new BinaryTreeNode(5);\ntree.root.right = new BinaryTreeNode(15);\n\ntree.size(); // 3\ntree.height(); // 1\ntree.inOrder(); // [5, 10, 15]\ntree.preOrder(); // [10, 5, 15]\ntree.postOrder(); // [5, 15, 10]\ntree.isBalanced(); // true\ntree.isComplete(); // true\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Constraints\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"0 <= Number of nodes <= 100\"}),`\n`,(0,r.jsx)(e.li,{children:\"Each node in a binary tree has at most one left child and one right child\"}),`\n`]})]})}function R(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(h,n)})):h(n)}var w=R;return x(q);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/binary-tree\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/binary-tree.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/binary-tree.run.test.ts": "import { BinaryTree, BinaryTreeNode } from './binary-tree';\n\ndescribe('BinaryTree', () => {\n  test('constructor', () => {\n    const tree = new BinaryTree();\n    expect(tree instanceof BinaryTree).toBeTruthy();\n    expect(tree.size()).toBe(0);\n    expect(tree.height()).toBe(0);\n  });\n\n  test('size & height', () => {\n    const tree = new BinaryTree();\n    tree.root = new BinaryTreeNode(10);\n    const root = tree.root!;\n    expect(tree.size()).toBe(1);\n    expect(tree.height()).toBe(0);\n    root.left = new BinaryTreeNode(5);\n    root.right = new BinaryTreeNode(15);\n    expect(tree.height()).toBe(1);\n    expect(tree.size()).toBe(3);\n    root.left.left = new BinaryTreeNode(3);\n    expect(tree.height()).toBe(2);\n  });\n\n  test('Orders', () => {\n    const tree = new BinaryTree();\n    expect(tree.inOrder()).toEqual([]);\n    tree.root = new BinaryTreeNode(10);\n    const root = tree.root!;\n    root.left = new BinaryTreeNode(5);\n    root.right = new BinaryTreeNode(15);\n    root.left.left = new BinaryTreeNode(3);\n    root.left.right = new BinaryTreeNode(7);\n    expect(tree.inOrder()).toEqual([3, 5, 7, 10, 15]);\n    expect(tree.preOrder()).toEqual([10, 5, 3, 7, 15]);\n    expect(tree.postOrder()).toEqual([3, 7, 5, 15, 10]);\n  });\n\n  test('isBalanced', () => {\n    const tree = new BinaryTree();\n    expect(tree.isBalanced()).toBeTruthy();\n    tree.root = new BinaryTreeNode(10);\n    expect(tree.isBalanced()).toBeTruthy();\n    const root = tree.root!;\n    root.left = new BinaryTreeNode(5);\n    expect(tree.isBalanced()).toBeTruthy();\n  });\n\n  test('isComplete', () => {\n    const tree = new BinaryTree();\n    expect(tree.isComplete()).toBeTruthy();\n    tree.root = new BinaryTreeNode(10);\n    expect(tree.isComplete()).toBeTruthy();\n    const root = tree.root!;\n    root.left = new BinaryTreeNode(5);\n    root.right = new BinaryTreeNode(15);\n    expect(tree.isComplete()).toBeTruthy();\n  });\n});\n",
    "/src/binary-tree.submit.test.ts": "import { BinaryTree, BinaryTreeNode } from './binary-tree';\n\nfunction createTree() {\n  const tree = new BinaryTree('F');\n  const root = tree.root!;\n  root.left = new BinaryTreeNode('B');\n  root.left.left = new BinaryTreeNode('A');\n  root.left.right = new BinaryTreeNode('D');\n  root.left.right.left = new BinaryTreeNode('C');\n  root.left.right.right = new BinaryTreeNode('E');\n  root.right = new BinaryTreeNode('G');\n  root.right.right = new BinaryTreeNode('I');\n  root.right.right.left = new BinaryTreeNode('H');\n  return tree;\n}\n\ndescribe('BinaryTree', () => {\n  describe('constructor()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree).toBeTruthy();\n      expect(tree.root).toBe(null);\n    });\n\n    test('one-node tree', () => {\n      const { root } = new BinaryTree(5);\n      expect(root?.value).toBe(5);\n    });\n  });\n\n  describe('root', () => {\n    test('empty tree', () => {\n      const { root } = new BinaryTree();\n      expect(root).toBe(null);\n    });\n\n    test('one-node tree', () => {\n      const { root } = new BinaryTree(5);\n      expect(root?.value).toBe(5);\n    });\n  });\n\n  describe('size()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.size()).toBe(0);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.size()).toBe(1);\n    });\n\n    test('two-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.size()).toBe(2);\n    });\n\n    test('non-empty tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.left.left = new BinaryTreeNode(15);\n      root.right = new BinaryTreeNode(2);\n      expect(tree.size()).toBe(4);\n    });\n  });\n\n  describe('height()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.height()).toBe(0);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.height()).toBe(0);\n    });\n\n    test('two-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.height()).toBe(1);\n    });\n\n    test('non-empty tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.left.left = new BinaryTreeNode(15);\n      root.right = new BinaryTreeNode(2);\n      expect(tree.height()).toBe(2);\n    });\n  });\n\n  describe('inOrder()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.inOrder()).toEqual([]);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.inOrder()).toEqual([10]);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.inOrder()).toEqual([5, 10, 15]);\n    });\n\n    test('non-empty tree', () => {\n      const tree = createTree();\n      expect(tree.inOrder()).toEqual([\n        'A',\n        'B',\n        'C',\n        'D',\n        'E',\n        'F',\n        'G',\n        'H',\n        'I',\n      ]);\n    });\n  });\n\n  describe('preOrder()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.preOrder()).toEqual([]);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.preOrder()).toEqual([10]);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.preOrder()).toEqual([10, 5, 15]);\n    });\n\n    test('non-empty tree', () => {\n      const tree = createTree();\n      expect(tree.preOrder()).toEqual([\n        'F',\n        'B',\n        'A',\n        'D',\n        'C',\n        'E',\n        'G',\n        'I',\n        'H',\n      ]);\n    });\n  });\n\n  describe('postOrder()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.postOrder()).toEqual([]);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.postOrder()).toEqual([10]);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.postOrder()).toEqual([5, 15, 10]);\n    });\n\n    test('non-empty tree', () => {\n      const tree = createTree();\n      expect(tree.postOrder()).toEqual([\n        'A',\n        'C',\n        'E',\n        'D',\n        'B',\n        'H',\n        'I',\n        'G',\n        'F',\n      ]);\n    });\n  });\n\n  describe('isBalanced()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.isBalanced()).toBe(true);\n    });\n\n    test('linked-list tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(15);\n      root.right.right = new BinaryTreeNode(20);\n      expect(tree.isBalanced()).toBe(false);\n    });\n\n    test('non-empty tree', () => {\n      const tree = createTree();\n      expect(tree.isBalanced()).toBe(false);\n    });\n  });\n\n  describe('isComplete()', () => {\n    test('empty tree', () => {\n      const tree = new BinaryTree();\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test('one-node tree', () => {\n      const tree = new BinaryTree(10);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test('two-node tree left', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test('two-node tree right', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(5);\n      expect(tree.isComplete()).toBe(false);\n    });\n\n    test('three-node tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.left = new BinaryTreeNode(5);\n      root.right = new BinaryTreeNode(15);\n      expect(tree.isComplete()).toBe(true);\n    });\n\n    test('linked-list tree', () => {\n      const tree = new BinaryTree(10);\n      const root = tree.root!;\n      root.right = new BinaryTreeNode(15);\n      root.right.right = new BinaryTreeNode(20);\n      expect(tree.isComplete()).toBe(false);\n    });\n  });\n});\n",
    "/src/binary-tree.ts": "export class BinaryTreeNode<T> {\n  public value: T;\n  public left: BinaryTreeNode<T> | null;\n  public right: BinaryTreeNode<T> | null;\n\n  constructor(value: T) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport class BinaryTree<T> {\n  public root: BinaryTreeNode<T> | null;\n\n  /**\n   * Initialize the Binary Tree.\n   * @param {T} value The value of the root node.\n   */\n  constructor(value?: T) {\n    this.root = value == null ? null : new BinaryTreeNode(value);\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size(): number {\n    const sizeHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return 0;\n      }\n      return 1 + sizeHelper(node.left) + sizeHelper(node.right);\n    };\n    return this.root ? sizeHelper(this.root) : 0;\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height(): number {\n    const heightHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return -1;\n      }\n      return 1 + Math.max(heightHelper(node.left), heightHelper(node.right));\n    };\n    return this.root ? heightHelper(this.root) : 0;\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<T>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const inOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (node == null) {\n        return;\n      }\n\n      inOrderHelper(node.left);\n      arr.push(node.value);\n      inOrderHelper(node.right);\n    };\n    inOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<T>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const preOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (!node) {\n        return;\n      }\n\n      arr.push(node.value);\n      preOrderHelper(node.left);\n      preOrderHelper(node.right);\n    };\n    preOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<T>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const postOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (!node) {\n        return;\n      }\n\n      postOrderHelper(node.left);\n      postOrderHelper(node.right);\n      arr.push(node.value);\n    };\n    postOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced(): boolean {\n    const isBalancedHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return 0;\n      }\n\n      const leftHeight = isBalancedHelper(node.left);\n      const rightHeight = isBalancedHelper(node.right);\n\n      if (\n        leftHeight === -1 ||\n        rightHeight === -1 ||\n        Math.abs(leftHeight - rightHeight) > 1\n      ) {\n        return -1;\n      }\n\n      return 1 + Math.max(leftHeight, rightHeight);\n    };\n    return isBalancedHelper(this.root) !== -1;\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete(): boolean {\n    if (!this.root) return true;\n\n    const queue: Array<BinaryTreeNode<T> | null> = [this.root];\n    let foundNull = false;\n\n    while (queue.length > 0) {\n      const node = queue.shift();\n\n      if (node === undefined || node === null) {\n        foundNull = true;\n      } else {\n        if (foundNull) {\n          return false; // A non-null node appeared after a null one\n        }\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n\n    return true;\n  }\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": null,
    "companies": [],
    "created": 1716422400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a binary tree data structure including essential operations",
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/binary-tree",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "binary-search-tree",
      "binary-search"
    ],
    "slug": "binary-tree",
    "subtitle": null,
    "title": "Binary Tree",
    "topics": [
      "binary-tree",
      "tree"
    ]
  },
  "skeleton": {
    "js": "export class BinaryTreeNode {\n  /**\n   * Initialize a Binary Tree node.\n   * @param {*} value The value of the node.\n   */\n  constructor(value) {\n    throw 'Not implemented!';\n  }\n}\n\nexport class BinaryTree {\n  /**\n   * Initialize the Binary Tree.\n   * @param {*} value The value of the root node.\n   */\n  constructor(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<*>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<*>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<*>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete() {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export class BinaryTreeNode<T> {\n  public value: T;\n  public left: BinaryTreeNode<T> | null;\n  public right: BinaryTreeNode<T> | null;\n\n  /**\n   * Initialize a Binary Tree node.\n   * @param {T} value The value of the node.\n   */\n  constructor(value?: T) {\n    throw 'Not implemented!';\n  }\n}\n\nexport class BinaryTree<T> {\n  /**\n   * Initialize the Binary Tree.\n   * @param {T} value The value of the root node.\n   */\n  constructor(value?: T) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size(): number {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height(): number {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<T>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder(): Array<T> {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<T>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder(): Array<T> {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<T>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder(): Array<T> {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced(): boolean {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete(): boolean {\n    throw 'Not implemented!';\n  }\n}"
  },
  "solution": "var Component=(()=>{var p=Object.create;var l=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),T=(n,e)=>{for(var t in e)l(n,t,{get:e[t],enumerable:!0})},d=(n,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!y.call(n,i)&&i!==t&&l(n,i,{get:()=>e[i],enumerable:!(o=g(e,i))||o.enumerable});return n};var H=(n,e,t)=>(t=n!=null?p(v(n)):{},d(e||!n||!n.__esModule?l(t,\"default\",{value:n,enumerable:!0}):t,n)),O=n=>d(l({},\"__esModule\",{value:!0}),n);var s=b((q,h)=>{h.exports=_jsx_runtime});var N={};T(N,{default:()=>A});var r=H(s());var a=MDXCodeBlock;var c=`export class BinaryTreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport class BinaryTree {\n  /**\n   * Initialize the Binary Tree.\n   * @param {*} value The value of the root node.\n   */\n  constructor(value) {\n    this.root = value == null ? null : new BinaryTreeNode(value);\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size() {\n    const sizeHelper = (node) => {\n      if (!node) {\n        return 0;\n      }\n      return 1 + sizeHelper(node.left) + sizeHelper(node.right);\n    };\n    return this.root ? sizeHelper(this.root) : 0;\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height() {\n    const heightHelper = (node) => {\n      if (!node) {\n        return -1;\n      }\n      return 1 + Math.max(heightHelper(node.left), heightHelper(node.right));\n    };\n    return this.root ? heightHelper(this.root) : 0;\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<*>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder() {\n    const arr = [];\n    const inOrderHelper = (node) => {\n      if (node == null) {\n        return;\n      }\n\n      inOrderHelper(node.left);\n      arr.push(node.value);\n      inOrderHelper(node.right);\n    };\n    inOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<*>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder() {\n    const arr = [];\n    const preOrderHelper = (node) => {\n      if (!node) {\n        return;\n      }\n\n      arr.push(node.value);\n      preOrderHelper(node.left);\n      preOrderHelper(node.right);\n    };\n    preOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<*>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder() {\n    const arr = [];\n    const postOrderHelper = (node) => {\n      if (!node) {\n        return;\n      }\n\n      postOrderHelper(node.left);\n      postOrderHelper(node.right);\n      arr.push(node.value);\n    };\n    postOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced() {\n    const isBalancedHelper = (node) => {\n      if (!node) {\n        return 0;\n      }\n\n      const leftHeight = isBalancedHelper(node.left);\n      const rightHeight = isBalancedHelper(node.right);\n\n      if (\n        leftHeight === -1 ||\n        rightHeight === -1 ||\n        Math.abs(leftHeight - rightHeight) > 1\n      ) {\n        return -1;\n      }\n\n      return 1 + Math.max(leftHeight, rightHeight);\n    };\n    return isBalancedHelper(this.root) !== -1;\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete() {\n    if (!this.root) return true;\n\n    const queue = [this.root];\n    let foundNull = false;\n\n    while (queue.length > 0) {\n      const node = queue.shift();\n\n      if (node === null) {\n        foundNull = true;\n      } else {\n        if (foundNull) {\n          return false; // Found a non-null node after a null one\n        }\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n\n    return true;\n  }\n}\n`;var u=`export class BinaryTreeNode<T> {\n  public value: T;\n  public left: BinaryTreeNode<T> | null;\n  public right: BinaryTreeNode<T> | null;\n\n  constructor(value: T) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport class BinaryTree<T> {\n  public root: BinaryTreeNode<T> | null;\n\n  /**\n   * Initialize the Binary Tree.\n   * @param {T} value The value of the root node.\n   */\n  constructor(value?: T) {\n    this.root = value == null ? null : new BinaryTreeNode(value);\n  }\n\n  /**\n   * Get the number of nodes in the tree.\n   * @return {number} The number of nodes in the tree.\n   */\n  size(): number {\n    const sizeHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return 0;\n      }\n      return 1 + sizeHelper(node.left) + sizeHelper(node.right);\n    };\n    return this.root ? sizeHelper(this.root) : 0;\n  }\n\n  /**\n   * Get the height of the tree.\n   * @return {number} The height of the tree.\n   */\n  height(): number {\n    const heightHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return -1;\n      }\n      return 1 + Math.max(heightHelper(node.left), heightHelper(node.right));\n    };\n    return this.root ? heightHelper(this.root) : 0;\n  }\n\n  /**\n   * Traverse the tree in an in-order fashion.\n   * @return {Array<T>} An array of values of the nodes in in-order traversal.\n   */\n  inOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const inOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (node == null) {\n        return;\n      }\n\n      inOrderHelper(node.left);\n      arr.push(node.value);\n      inOrderHelper(node.right);\n    };\n    inOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a pre-order fashion.\n   * @return {Array<T>} An array of values of the nodes in pre-order traversal.\n   */\n  preOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const preOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (!node) {\n        return;\n      }\n\n      arr.push(node.value);\n      preOrderHelper(node.left);\n      preOrderHelper(node.right);\n    };\n    preOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Traverse the tree in a post-order fashion.\n   * @return {Array<T>} An array of values of the nodes in post-order traversal.\n   */\n  postOrder(): Array<T> {\n    const arr: Array<T> = [];\n    const postOrderHelper = (node: BinaryTreeNode<T> | null) => {\n      if (!node) {\n        return;\n      }\n\n      postOrderHelper(node.left);\n      postOrderHelper(node.right);\n      arr.push(node.value);\n    };\n    postOrderHelper(this.root);\n    return arr;\n  }\n\n  /**\n   * Checks if the binary tree is balanced, i.e. depth of the two subtrees of\n   * every node never differ by more than 1.\n   * @return {boolean}\n   */\n  isBalanced(): boolean {\n    const isBalancedHelper = (node: BinaryTreeNode<T> | null): number => {\n      if (!node) {\n        return 0;\n      }\n\n      const leftHeight = isBalancedHelper(node.left);\n      const rightHeight = isBalancedHelper(node.right);\n\n      if (\n        leftHeight === -1 ||\n        rightHeight === -1 ||\n        Math.abs(leftHeight - rightHeight) > 1\n      ) {\n        return -1;\n      }\n\n      return 1 + Math.max(leftHeight, rightHeight);\n    };\n    return isBalancedHelper(this.root) !== -1;\n  }\n\n  /**\n   * Checks if the binary tree is complete, i.e., all levels are completely filled except possibly the last level,\n   * which is filled from left to right.\n   * @return {boolean} True if the binary tree is complete, false otherwise.\n   */\n  isComplete(): boolean {\n    if (!this.root) return true;\n\n    const queue: Array<BinaryTreeNode<T> | null> = [this.root];\n    let foundNull = false;\n\n    while (queue.length > 0) {\n      const node = queue.shift();\n\n      if (node === undefined || node === null) {\n        foundNull = true;\n      } else {\n        if (foundNull) {\n          return false; // A non-null node appeared after a null one\n        }\n        queue.push(node.left);\n        queue.push(node.right);\n      }\n    }\n\n    return true;\n  }\n}\n`;function f(n){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",strong:\"strong\",h3:\"h3\",ol:\"ol\",h2:\"h2\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"A Binary Tree is a hierarchical data structure where each node has at most two children: the \",(0,r.jsx)(e.code,{children:\"left\"}),\" child and the \",(0,r.jsx)(e.code,{children:\"right\"}),\" child. The structure consists of nodes that store a \",(0,r.jsx)(e.code,{children:\"value\"}),\" and references to their children. The topmost node is called the \",(0,r.jsx)(e.code,{children:\"root\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"This implementation separates the binary tree structure (\",(0,r.jsx)(e.code,{children:\"BinaryTree\"}),\") from its individual nodes (\",(0,r.jsx)(e.code,{children:\"BinaryTreeNode\"}),\"). Each node contains a \",(0,r.jsx)(e.code,{children:\"value\"}),\", and pointers to its \",(0,r.jsx)(e.code,{children:\"left\"}),\" and \",(0,r.jsx)(e.code,{children:\"right\"}),\" children.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"The core operations can be implemented using a recursive approach, which is natural and efficient for binary trees because each subtree is itself a binary tree:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Traversal methods\"}),\" (\",(0,r.jsx)(e.code,{children:\"inOrder\"}),\", \",(0,r.jsx)(e.code,{children:\"preOrder\"}),\", \",(0,r.jsx)(e.code,{children:\"postOrder\"}),\") use simple depth-first recursion to visit nodes in the correct order and collect their values in an array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\" and \",(0,r.jsx)(e.code,{children:\"height()\"}),\" are calculated recursively by visiting every node once, combining results from left and right children.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\" uses a recursive approach to walk the tree from the bottom up, checking if each subtree is balanced. While doing this, it also calculates the height of each node. If it finds a subtree with height difference > 1, it returns -1 immediately, which bubbles up and stops further checks, keeping the time complexity at O(n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isComplete()\"}),\" uses a level-order traversal (BFS) to ensure all levels are fully filled, and the last level is filled from left to right without gaps.\"]}),`\n`]}),`\n`,(0,r.jsx)(a,{languages:{jsx:c,tsx:u}}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"new BinaryTree(value)\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initializes a tree. If a \",(0,r.jsx)(e.code,{children:\"value\"}),\" is passed, the root is set to a new \",(0,r.jsx)(e.code,{children:\"BinaryTreeNode\"}),\" with that value. If not, the root is \",(0,r.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Base case: if \",(0,r.jsx)(e.code,{children:\"node\"}),\" is \",(0,r.jsx)(e.code,{children:\"null\"}),\", return 0.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Recursive case: 1 + size of left subtree + size of right subtree.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"height()\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Base case: if \",(0,r.jsx)(e.code,{children:\"node\"}),\" is \",(0,r.jsx)(e.code,{children:\"null\"}),\", return -1.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Recursive case: 1 + max(height of left subtree, height of right subtree).\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"For an empty tree, \",(0,r.jsx)(e.code,{children:\"height()\"}),\" returns 0.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Traversal Methods (\",(0,r.jsx)(e.code,{children:\"inOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"preOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"postOrder()\"}),\"):\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"These methods return arrays of node values based on different traversal orders:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"In-order (left \\u2192 root \\u2192 right)\"}),`\n`,(0,r.jsx)(e.li,{children:\"Pre-order (root \\u2192 left \\u2192 right)\"}),`\n`,(0,r.jsx)(e.li,{children:\"Post-order (left \\u2192 right \\u2192 root)\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.li,{children:\"Each method uses a recursive helper that walks through the tree from the root using DFS, visiting child nodes in the specified order.\"}),`\n`,(0,r.jsx)(e.li,{children:\"A temporary array is built up during the recursive calls to collect values in the correct sequence.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Recursive helper returns height if subtree is balanced, or -1 if not.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Main method checks if the result is not -1.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isComplete()\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Uses BFS (level-order traversal) with a queue.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"As nodes are dequeued, if a \",(0,r.jsx)(e.code,{children:\"null\"}),\" is found, all subsequent nodes must also be \",(0,r.jsx)(e.code,{children:\"null\"}),\" for the tree to be considered complete. If any non-null node appears after a null, the tree is incomplete.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"Let \",(0,r.jsx)(e.code,{children:\"n\"}),\" be the number of nodes and \",(0,r.jsx)(e.code,{children:\"h\"}),\" the height of the tree.\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\", \",(0,r.jsx)(e.code,{children:\"height()\"}),\", \",(0,r.jsx)(e.code,{children:\"inOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"preOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"postOrder()\"}),\", \",(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\", \",(0,r.jsx)(e.code,{children:\"isComplete()\"}),\": O(n). Each node is visited once.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Recursive methods (\",(0,r.jsx)(e.code,{children:\"size()\"}),\", \",(0,r.jsx)(e.code,{children:\"height()\"}),\", traversals, \",(0,r.jsx)(e.code,{children:\"isBalanced()\"}),\"): O(h) due to call stack. In the worst case (skewed tree), h = O(n). In a balanced tree, h = O(log n).\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"isComplete()\"}),\": O(n) in the worst case due to the BFS queue holding up to n/2 nodes at the last level of a complete tree.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Empty tree\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\" is 0\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"height()\"}),\" is 0\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Traversals return \",(0,r.jsx)(e.code,{children:\"[]\"})]}),`\n`,(0,r.jsx)(e.li,{children:\"Tree is both balanced and complete\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Single node tree\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"size()\"}),\" is 1\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"height()\"}),\" is 0\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Tree is both balanced and complete\"}),`\n`]}),`\n`]}),`\n`]})]})}function x(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(f,n)})):f(n)}var A=x;return O(N);})();\n;return Component;",
  "workspace": {
    "main": "/src/binary-tree.ts",
    "run": "/src/binary-tree.run.test.ts",
    "submit": "/src/binary-tree.submit.test.ts"
  }
}