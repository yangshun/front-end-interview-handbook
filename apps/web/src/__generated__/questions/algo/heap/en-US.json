{
  "description": "var Component=(()=>{var c=Object.create;var i=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),y=(n,e)=>{for(var a in e)i(n,a,{get:e[a],enumerable:!0})},h=(n,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!x.call(n,r)&&r!==a&&i(n,r,{get:()=>e[r],enumerable:!(s=d(e,r))||s.enumerable});return n};var g=(n,e,a)=>(a=n!=null?c(u(n)):{},h(e||!n||!n.__esModule?i(a,\"default\",{value:n,enumerable:!0}):a,n)),w=n=>h(i({},\"__esModule\",{value:!0}),n);var l=f((_,o)=>{o.exports=_jsx_runtime});var b={};y(b,{default:()=>H,frontmatter:()=>j});var t=g(l()),j={title:\"Heap\",excerpt:\"Implement a heap data structure containing essential heap operations\"};function p(n){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h2:\"h2\",pre:\"pre\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"Implement a heap data structure in JavaScript that supports the following operations:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"new Heap(array)\"}),\": Creates an instance of a Heap class initialized with \",(0,t.jsx)(e.code,{children:\"array\"}),\" and heapifies it to form as the initial Heap structure. It also initializes any internal structure needed to maintain the heap properties.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"heapify(array)\"}),\": Constructs the heap from an unordered array, establishing the max heap property across all elements. This is performed as part of the constructor, or can be a separate method that resets and rebuilds the heap. Required time complexity: O(n), where n is the number of elements in the array.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"insert(value)\"}),\": Adds a new value to the heap, maintaining the max heap property. Required time complexity: O(log n), where n is the number of elements in the heap after insertion.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"delete()\"}),\": Removes and returns the maximum value from the heap, maintaining the max heap property after removal. Required time complexity: O(log n).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"findMax()\"}),\": Returns the maximum value in the heap without removing it. Required time complexity: O(1).\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-js\",children:`const heap = new Heap();\nheap.insert(20);\nheap.insert(15);\nheap.insert(30);\nheap.findMax(); // 30\nheap.insert(10);\nheap.delete(); // 30\nheap.findMax(); // 20\n\nconst array = [5, 3, 17, 10, 84, 19, 6, 22, 9];\nconst newHeap = new Heap(array);\nnewHeap.findMax(); // 84\n`})})]})}function v(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(p,n)})):p(n)}var H=v;return w(b);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/heap\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/heap.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/heap.run.test.ts": "import Heap from './heap';\n\ndescribe('Heap', () => {\n  test('constructor', () => {\n    const heap = new Heap<number>();\n    expect(heap instanceof Heap).toBeTruthy();\n  });\n\n  test('insert and findMax', () => {\n    const heap = new Heap<number>();\n    heap.insert(100);\n    expect(heap.findMax()).toBe(100);\n    heap.insert(200);\n    expect(heap.findMax()).toBe(200);\n    heap.insert(50);\n    expect(heap.findMax()).toBe(200);\n  });\n\n  test('delete', () => {\n    const heap = new Heap<number>();\n    heap.insert(300);\n    heap.insert(100);\n    heap.insert(200);\n    expect(heap.delete()).toBe(300);\n    expect(heap.findMax()).toBe(200);\n    expect(heap.delete()).toBe(200);\n    expect(heap.findMax()).toBe(100);\n    expect(heap.delete()).toBe(100);\n    expect(heap.findMax()).toBeUndefined();\n  });\n\n  test('heapify', () => {\n    const array = [5, 3, 17, 10, 84, 19, 6, 22, 9];\n    const heap = new Heap<number>(array);\n    expect(heap.findMax()).toBe(84);\n  });\n});\n",
    "/src/heap.submit.test.ts": "import Heap from './heap';\n\ndescribe('Heap', () => {\n  test('constructor', () => {\n    const heap = new Heap<number>();\n    expect(heap instanceof Heap).toBeTruthy();\n  });\n\n  test('insert and findMax', () => {\n    const heap = new Heap<number>();\n    heap.insert(100);\n    expect(heap.findMax()).toBe(100);\n    heap.insert(200);\n    expect(heap.findMax()).toBe(200);\n    heap.insert(50);\n    expect(heap.findMax()).toBe(200);\n  });\n\n  test('delete functionality', () => {\n    const heap = new Heap<number>();\n    heap.insert(300);\n    heap.insert(100);\n    heap.insert(200);\n    expect(heap.delete()).toBe(300);\n    expect(heap.findMax()).toBe(200);\n    expect(heap.delete()).toBe(200);\n    expect(heap.findMax()).toBe(100);\n    heap.insert(400);\n    expect(heap.delete()).toBe(400);\n    expect(heap.findMax()).toBe(100);\n  });\n\n  test('heapify from array', () => {\n    const array = [5, 3, 17, 10, 84, 19, 6, 22, 9];\n    const heap = new Heap<number>(array);\n    expect(heap.findMax()).toBe(84);\n    expect(heap.delete()).toBe(84);\n    expect(heap.findMax()).toBe(22);\n  });\n\n  test('complex insert and delete sequence', () => {\n    const heap = new Heap<number>();\n    heap.insert(20);\n    heap.insert(15);\n    heap.insert(30);\n    heap.insert(10);\n    expect(heap.findMax()).toBe(30);\n    expect(heap.delete()).toBe(30);\n    expect(heap.findMax()).toBe(20);\n    heap.insert(35);\n    heap.insert(45);\n    expect(heap.delete()).toBe(45);\n    expect(heap.findMax()).toBe(35);\n  });\n\n  test('delete on empty heap', () => {\n    const heap = new Heap<number>();\n    expect(heap.delete()).toBeUndefined();\n  });\n\n  test('maintaining state after multiple operations', () => {\n    const heap = new Heap<number>();\n    heap.insert(50);\n    heap.insert(30);\n    heap.insert(60);\n    expect(heap.delete()).toBe(60);\n    heap.insert(55);\n    heap.insert(65);\n    expect(heap.findMax()).toBe(65);\n    expect(heap.delete()).toBe(65);\n    expect(heap.findMax()).toBe(55);\n  });\n\n  test('integration test of operations', () => {\n    const heap = new Heap<number>();\n    heap.insert(5);\n    heap.insert(3);\n    heap.insert(17);\n    heap.insert(10);\n    heap.insert(84);\n    heap.insert(19);\n    heap.insert(6);\n    heap.insert(22);\n    heap.insert(9);\n    expect(heap.delete()).toBe(84);\n    expect(heap.findMax()).toBe(22);\n    heap.insert(55);\n    expect(heap.findMax()).toBe(55);\n    expect(heap.delete()).toBe(55);\n    expect(heap.findMax()).toBe(22);\n  });\n});\n",
    "/src/heap.ts": "export default class Heap<T> {\n  values: T[];\n\n  constructor(array: T[] = []) {\n    this.values = [];\n    if (array.length > 0) {\n      this.heapify(array);\n    }\n  }\n\n  /**\n   * Constructs the initial heap structure with a given `array`.\n   * @param array The initial array to be used for the heap.\n   */\n  heapify(array: T[]): void {\n    this.values = [];\n    array.forEach((element) => this.insert(element));\n  }\n\n  /**\n   * Adds an item to the heap.\n   * @param value The item to be added into the heap.\n   */\n  insert(value: T): void {\n    this.values.push(value);\n    let index = this.values.length - 1;\n    let parentIndex = Math.floor((index - 1) / 2);\n\n    // Move up the newly added value until the heap property is restored.\n    while (index > 0 && this.values[parentIndex] < this.values[index]) {\n      [this.values[parentIndex], this.values[index]] = [\n        this.values[index],\n        this.values[parentIndex],\n      ];\n      index = parentIndex;\n      parentIndex = Math.floor((index - 1) / 2);\n    }\n  }\n\n  /**\n   * Removes the top of the heap / maximum element.\n   * @return The element removed, or undefined if the heap is empty.\n   */\n  delete(): T | undefined {\n    if (this.values.length === 0) {\n      return undefined;\n    }\n    const max = this.values[0];\n    const last = this.values.pop();\n    if (this.values.length > 0 && last !== undefined) {\n      this.values[0] = last;\n      let index = 0;\n\n      // Restore heap property by moving down the root value.\n      while (true) {\n        const left = 2 * index + 1;\n        const right = 2 * index + 2;\n        let largest = index;\n\n        // If left child exists and is larger than the current largest, replace largest with value of left child.\n        if (\n          left < this.values.length &&\n          this.values[left] > this.values[largest]\n        ) {\n          largest = left;\n        }\n\n        // If right child exists and is larger than the current largest, replace largest with value of right child.\n        if (\n          right < this.values.length &&\n          this.values[right] > this.values[largest]\n        ) {\n          largest = right;\n        }\n\n        if (largest === index) {\n          break; // The current root is already the largest, heap property is satisfied.\n        }\n\n        // Swap the position such that the largest value is above `index`, following the heap property.\n        [this.values[index], this.values[largest]] = [\n          this.values[largest],\n          this.values[index],\n        ];\n        index = largest;\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Returns the value of the maximum element.\n   * @return The maximum element.\n   */\n  findMax(): T | undefined {\n    return this.values.length > 0 ? this.values[0] : undefined;\n  }\n}\n"
  },
  "info": {
    "excerpt": "Implement a heap data structure containing essential heap operations",
    "title": "Heap"
  },
  "metadata": {
    "access": "standard",
    "author": null,
    "companies": [],
    "created": 1745539200,
    "difficulty": "hard",
    "duration": 15,
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/heap",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "heap-sort"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "binary-search-tree"
    ],
    "slug": "heap",
    "subtitle": null,
    "topics": [
      "heap"
    ]
  },
  "skeleton": {
    "js": "export default class Heap {\n  constructor(array = []) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Constructs the initial heap structure with a given `array`.\n   * @param {Array} array The initial array.\n   */\n  heapify(array) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item into the heap.\n   * @param {*} item The item to be added into the heap.\n   */\n  insert(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Removes the top of the heap / maximum element.\n   * @return {*} The element removed.\n   */\n  delete() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the value of the maximum element.\n   * @return {number} The maximum element.\n   */\n  findMax() {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export default class Heap<T> {\n  constructor(array: T[] = []) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Constructs the initial heap structure with a given `array`.\n   * @param array The initial array to be used for the heap.\n   */\n  heapify(array: T[]): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the heap.\n   * @param value The item to be added into the heap.\n   */\n  insert(value: T): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Removes the top of the heap / maximum element.\n   * @return The element removed, or undefined if the heap is empty.\n   */\n  delete(): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the value of the maximum element.\n   * @return The maximum element.\n   */\n  findMax(): T | undefined {\n    throw 'Not implemented!';\n  }\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var v=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var y=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),w=(i,e)=>{for(var a in e)r(i,a,{get:e[a],enumerable:!0})},h=(i,e,a,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of f(e))!x.call(i,n)&&n!==a&&r(i,n,{get:()=>e[n],enumerable:!(s=g(e,n))||s.enumerable});return i};var b=(i,e,a)=>(a=i!=null?m(v(i)):{},h(e||!i||!i.__esModule?r(a,\"default\",{value:i,enumerable:!0}):a,i)),T=i=>h(r({},\"__esModule\",{value:!0}),i);var o=y((q,l)=>{l.exports=_jsx_runtime});var C={};w(C,{default:()=>k});var t=b(o());var d=MDXCodeBlock;var u=`export default class Heap {\n  constructor(array = []) {\n    this.values = [];\n    if (array.length > 0) {\n      this.heapify(array);\n    }\n  }\n\n  /**\n   * Constructs the initial heap structure with a given \\`array\\`.\n   * @param {Array} array The initial array.\n   */\n  heapify(array) {\n    this.values = [];\n    array.forEach((element) => this.insert(element));\n  }\n\n  /**\n   * Adds an item into the heap.\n   * @param {*} item The item to be added into the heap.\n   */\n  insert(value) {\n    this.values.push(value);\n    let index = this.values.length - 1;\n    let parentIndex = Math.floor((index - 1) / 2);\n\n    // Move up the newly added value until the heap property is restored.\n    while (index > 0 && this.values[parentIndex] < this.values[index]) {\n      [this.values[parentIndex], this.values[index]] = [\n        this.values[index],\n        this.values[parentIndex],\n      ];\n      index = parentIndex;\n      parentIndex = Math.floor((index - 1) / 2);\n    }\n  }\n\n  /**\n   * Removes the top of the heap / maximum element.\n   * @return {*} The element removed.\n   */\n  delete() {\n    if (this.values.length === 0) {\n      return undefined;\n    }\n    const max = this.values[0];\n    const last = this.values.pop();\n    if (this.values.length === 0) {\n      return max;\n    }\n\n    this.values[0] = last;\n    let index = 0;\n\n    // Restore heap property by moving down the root value.\n    while (true) {\n      const left = 2 * index + 1;\n      const right = 2 * index + 2;\n      let largest = index;\n\n      // If left child exists and is larger than the current largest, replace largest with value of left child.\n      if (\n        left < this.values.length &&\n        this.values[left] > this.values[largest]\n      ) {\n        largest = left;\n      }\n\n      // If right child exists and is larger than the current largest, replace largest with value of right child.\n      if (\n        right < this.values.length &&\n        this.values[right] > this.values[largest]\n      ) {\n        largest = right;\n      }\n\n      if (largest === index) {\n        break; // The current root is already the largest, heap property is satisfied.\n      }\n\n      // Swap the position such that the largest value is above \\`index\\`, following the heap property.\n      [this.values[index], this.values[largest]] = [\n        this.values[largest],\n        this.values[index],\n      ];\n      index = largest;\n    }\n\n    return max;\n  }\n\n  /**\n   * Returns the value of the maximum element.\n   * @return {number} The maximum element.\n   */\n  findMax() {\n    return this.values.length > 0 ? this.values[0] : undefined;\n  }\n}\n`;var p=`export default class Heap<T> {\n  values: T[];\n\n  constructor(array: T[] = []) {\n    this.values = [];\n    if (array.length > 0) {\n      this.heapify(array);\n    }\n  }\n\n  /**\n   * Constructs the initial heap structure with a given \\`array\\`.\n   * @param array The initial array to be used for the heap.\n   */\n  heapify(array: T[]): void {\n    this.values = [];\n    array.forEach((element) => this.insert(element));\n  }\n\n  /**\n   * Adds an item to the heap.\n   * @param value The item to be added into the heap.\n   */\n  insert(value: T): void {\n    this.values.push(value);\n    let index = this.values.length - 1;\n    let parentIndex = Math.floor((index - 1) / 2);\n\n    // Move up the newly added value until the heap property is restored.\n    while (index > 0 && this.values[parentIndex] < this.values[index]) {\n      [this.values[parentIndex], this.values[index]] = [\n        this.values[index],\n        this.values[parentIndex],\n      ];\n      index = parentIndex;\n      parentIndex = Math.floor((index - 1) / 2);\n    }\n  }\n\n  /**\n   * Removes the top of the heap / maximum element.\n   * @return The element removed, or undefined if the heap is empty.\n   */\n  delete(): T | undefined {\n    if (this.values.length === 0) {\n      return undefined;\n    }\n    const max = this.values[0];\n    const last = this.values.pop();\n    if (this.values.length > 0 && last !== undefined) {\n      this.values[0] = last;\n      let index = 0;\n\n      // Restore heap property by moving down the root value.\n      while (true) {\n        const left = 2 * index + 1;\n        const right = 2 * index + 2;\n        let largest = index;\n\n        // If left child exists and is larger than the current largest, replace largest with value of left child.\n        if (\n          left < this.values.length &&\n          this.values[left] > this.values[largest]\n        ) {\n          largest = left;\n        }\n\n        // If right child exists and is larger than the current largest, replace largest with value of right child.\n        if (\n          right < this.values.length &&\n          this.values[right] > this.values[largest]\n        ) {\n          largest = right;\n        }\n\n        if (largest === index) {\n          break; // The current root is already the largest, heap property is satisfied.\n        }\n\n        // Swap the position such that the largest value is above \\`index\\`, following the heap property.\n        [this.values[index], this.values[largest]] = [\n          this.values[largest],\n          this.values[index],\n        ];\n        index = largest;\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Returns the value of the maximum element.\n   * @return The maximum element.\n   */\n  findMax(): T | undefined {\n    return this.values.length > 0 ? this.values[0] : undefined;\n  }\n}\n`;function c(i){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\",code:\"code\",img:\"img\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"Heaps are specialized tree-based data structures that satisfy the heap property, where in a max heap, each parent node is greater than or equal to the values of its children. This property makes heaps ideal for implementing priority queues, where the highest (or lowest) priority element needs to be accessed quickly.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Operations\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"heapify(array)\"}),\": Constructs the heap from an unordered array. This is done by performing a series of insert operations from the bottom half of the array to build the heap in place.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"insert(value)\"}),\": Adds a new element to a heap. This involves appending the element at the end of the array (which represents the heap) and then move up the newly added element until the heap property is restored if it's violated.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/heap/insert.png\",alt:\"Insert\"})}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"delete()\"}),\": Removes the root element of the heap, which is the maximum value in a max heap. The last element of the heap replaces the root, and then slowly move it down until the heap property is restored.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/heap/delete.png\",alt:\"Delete\"})}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"findMax()\"}),\": Returns the element at the root of the heap without removing it, providing constant time access to the maximum value.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"Since the operations \",(0,t.jsx)(e.code,{children:\"insert\"}),\" and \",(0,t.jsx)(e.code,{children:\"delete\"}),\" can potentially involve moving elements across the height of the heap, their time complexity is O(log n), where n is the number of elements in the heap. \",(0,t.jsx)(e.code,{children:\"findMax\"}),\" is a constant-time operation, O(1), as it returns the first element. \",(0,t.jsx)(e.code,{children:\"Heapify\"}),\" has a time complexity of O(n log(n)) as it goes through each element and slowly inserting them one by one.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Inserting into an empty heap.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Deleting from an empty heap.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Calling \",(0,t.jsx)(e.code,{children:\"findMax\"}),\" on an empty heap.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Object-oriented programming.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Array manipulation to simulate a binary tree.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Understanding of logarithmic time complexity and how operations can affect it.\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"This heap implementation focuses on efficient data manipulation, taking advantage of the properties of binary trees to ensure that high-priority items are quickly accessible while maintaining the ability to adjust in logarithmic time.\"}),`\n`,(0,t.jsx)(d,{languages:{jsx:u,tsx:p}})]})}function j(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(c,i)})):c(i)}var k=j;return T(C);})();\n;return Component;",
  "workspace": {
    "main": "/src/heap.ts",
    "run": "/src/heap.run.test.ts",
    "submit": "/src/heap.submit.test.ts"
  }
}