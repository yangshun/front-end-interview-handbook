{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/heap\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/heap.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"target\": \"es2020\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/heap.run.test.ts": "import Heap from './heap';\n\ndescribe('Heap', () => {\n  test('constructor', () => {\n    const heap = new Heap<number>();\n    expect(heap instanceof Heap).toBeTruthy();\n  });\n\n  test('insert and findMax', () => {\n    const heap = new Heap<number>();\n    heap.insert(100);\n    expect(heap.findMax()).toBe(100);\n    heap.insert(200);\n    expect(heap.findMax()).toBe(200);\n    heap.insert(50);\n    expect(heap.findMax()).toBe(200);\n  });\n\n  test('delete', () => {\n    const heap = new Heap<number>();\n    heap.insert(300);\n    heap.insert(100);\n    heap.insert(200);\n    expect(heap.delete()).toBe(300);\n    expect(heap.findMax()).toBe(200);\n    expect(heap.delete()).toBe(200);\n    expect(heap.findMax()).toBe(100);\n    expect(heap.delete()).toBe(100);\n    expect(heap.findMax()).toBeUndefined();\n  });\n\n  test('heapify', () => {\n    const array = [5, 3, 17, 10, 84, 19, 6, 22, 9];\n    const heap = new Heap<number>(array);\n    expect(heap.findMax()).toBe(84);\n  });\n});\n",
    "/src/heap.submit.test.ts": "import Heap from './heap';\n\ndescribe('Heap', () => {\n  test('constructor', () => {\n    const heap = new Heap<number>();\n    expect(heap instanceof Heap).toBeTruthy();\n  });\n\n  test('insert and findMax', () => {\n    const heap = new Heap<number>();\n    heap.insert(100);\n    expect(heap.findMax()).toBe(100);\n    heap.insert(200);\n    expect(heap.findMax()).toBe(200);\n    heap.insert(50);\n    expect(heap.findMax()).toBe(200);\n  });\n\n  test('delete functionality', () => {\n    const heap = new Heap<number>();\n    heap.insert(300);\n    heap.insert(100);\n    heap.insert(200);\n    expect(heap.delete()).toBe(300);\n    expect(heap.findMax()).toBe(200);\n    expect(heap.delete()).toBe(200);\n    expect(heap.findMax()).toBe(100);\n    heap.insert(400);\n    expect(heap.delete()).toBe(400);\n    expect(heap.findMax()).toBe(100);\n  });\n\n  test('heapify from array', () => {\n    const array = [5, 3, 17, 10, 84, 19, 6, 22, 9];\n    const heap = new Heap<number>(array);\n    expect(heap.findMax()).toBe(84);\n    expect(heap.delete()).toBe(84);\n    expect(heap.findMax()).toBe(22);\n  });\n\n  test('complex insert and delete sequence', () => {\n    const heap = new Heap<number>();\n    heap.insert(20);\n    heap.insert(15);\n    heap.insert(30);\n    heap.insert(10);\n    expect(heap.findMax()).toBe(30);\n    expect(heap.delete()).toBe(30);\n    expect(heap.findMax()).toBe(20);\n    heap.insert(35);\n    heap.insert(45);\n    expect(heap.delete()).toBe(45);\n    expect(heap.findMax()).toBe(35);\n  });\n\n  test('delete on empty heap', () => {\n    const heap = new Heap<number>();\n    expect(heap.delete()).toBeUndefined();\n  });\n\n  test('maintaining state after multiple operations', () => {\n    const heap = new Heap<number>();\n    heap.insert(50);\n    heap.insert(30);\n    heap.insert(60);\n    expect(heap.delete()).toBe(60);\n    heap.insert(55);\n    heap.insert(65);\n    expect(heap.findMax()).toBe(65);\n    expect(heap.delete()).toBe(65);\n    expect(heap.findMax()).toBe(55);\n  });\n\n  test('integration test of operations', () => {\n    const heap = new Heap<number>();\n    heap.insert(5);\n    heap.insert(3);\n    heap.insert(17);\n    heap.insert(10);\n    heap.insert(84);\n    heap.insert(19);\n    heap.insert(6);\n    heap.insert(22);\n    heap.insert(9);\n    expect(heap.delete()).toBe(84);\n    expect(heap.findMax()).toBe(22);\n    heap.insert(55);\n    expect(heap.findMax()).toBe(55);\n    expect(heap.delete()).toBe(55);\n    expect(heap.findMax()).toBe(22);\n  });\n});\n",
    "/src/heap.ts": "export default class Heap<T> {\n  values: T[];\n\n  constructor(array: T[] = []) {\n    this.values = [];\n    if (array.length > 0) {\n      this.heapify(array);\n    }\n  }\n\n  /**\n   * Constructs the initial heap structure with a given `array`.\n   * @param array The initial array to be used for the heap.\n   */\n  heapify(array: T[]): void {\n    this.values = [];\n    array.forEach((element) => this.insert(element));\n  }\n\n  /**\n   * Adds an item to the heap.\n   * @param value The item to be added into the heap.\n   */\n  insert(value: T): void {\n    this.values.push(value);\n    let index = this.values.length - 1;\n    let parentIndex = Math.floor((index - 1) / 2);\n\n    // Move up the newly added value until the heap property is restored.\n    while (index > 0 && this.values[parentIndex] < this.values[index]) {\n      [this.values[parentIndex], this.values[index]] = [\n        this.values[index],\n        this.values[parentIndex],\n      ];\n      index = parentIndex;\n      parentIndex = Math.floor((index - 1) / 2);\n    }\n  }\n\n  /**\n   * Removes the top of the heap / maximum element.\n   * @return The element removed, or undefined if the heap is empty.\n   */\n  delete(): T | undefined {\n    if (this.values.length === 0) {\n      return undefined;\n    }\n    const max = this.values[0];\n    const last = this.values.pop();\n    if (this.values.length > 0 && last !== undefined) {\n      this.values[0] = last;\n      let index = 0;\n\n      // Restore heap property by moving down the root value.\n      while (true) {\n        const left = 2 * index + 1;\n        const right = 2 * index + 2;\n        let largest = index;\n\n        // If left child exists and is larger than the current largest, replace largest with value of left child.\n        if (\n          left < this.values.length &&\n          this.values[left] > this.values[largest]\n        ) {\n          largest = left;\n        }\n\n        // If right child exists and is larger than the current largest, replace largest with value of right child.\n        if (\n          right < this.values.length &&\n          this.values[right] > this.values[largest]\n        ) {\n          largest = right;\n        }\n\n        if (largest === index) {\n          break; // The current root is already the largest, heap property is satisfied.\n        }\n\n        // Swap the position such that the largest value is above `index`, following the heap property.\n        [this.values[index], this.values[largest]] = [\n          this.values[largest],\n          this.values[index],\n        ];\n        index = largest;\n      }\n    }\n    return max;\n  }\n\n  /**\n   * Returns the value of the maximum element.\n   * @return The maximum element.\n   */\n  findMax(): T | undefined {\n    return this.values.length > 0 ? this.values[0] : undefined;\n  }\n}\n"
  },
  "skeleton": {
    "js": "export default class Heap {\n  constructor(array = []) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Constructs the initial heap structure with a given `array`.\n   * @param {Array} array The initial array.\n   */\n  heapify(array) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item into the heap.\n   * @param {*} item The item to be added into the heap.\n   */\n  insert(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Removes the top of the heap / maximum element.\n   * @return {*} The element removed.\n   */\n  delete() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the value of the maximum element.\n   * @return {number} The maximum element.\n   */\n  findMax() {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export default class Heap<T> {\n  constructor(array: T[] = []) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Constructs the initial heap structure with a given `array`.\n   * @param array The initial array to be used for the heap.\n   */\n  heapify(array: T[]): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the heap.\n   * @param value The item to be added into the heap.\n   */\n  insert(value: T): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Removes the top of the heap / maximum element.\n   * @return The element removed, or undefined if the heap is empty.\n   */\n  delete(): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Returns the value of the maximum element.\n   * @return The maximum element.\n   */\n  findMax(): T | undefined {\n    throw 'Not implemented!';\n  }\n}"
  },
  "workspace": {
    "main": "/src/heap.ts",
    "run": "/src/heap.run.test.ts",
    "submit": "/src/heap.submit.test.ts"
  }
}