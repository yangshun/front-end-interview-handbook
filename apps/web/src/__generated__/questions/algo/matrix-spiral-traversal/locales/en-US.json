{
  "description": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var v=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports),w=(n,t)=>{for(var r in t)i(n,r,{get:t[r],enumerable:!0})},l=(n,t,r,a)=>{if(t&&typeof t==\"object\"||typeof t==\"function\")for(let o of f(t))!g.call(n,o)&&o!==r&&i(n,o,{get:()=>t[o],enumerable:!(a=p(t,o))||a.enumerable});return n};var b=(n,t,r)=>(r=n!=null?u(x(n)):{},l(t||!n||!n.__esModule?i(r,\"default\",{value:n,enumerable:!0}):r,n)),j=n=>l(i({},\"__esModule\",{value:!0}),n);var c=v((X,s)=>{s.exports=_jsx_runtime});var S={};w(S,{default:()=>D,frontmatter:()=>_});var e=b(c());var h=MDXTestExamples;var m=[{input:[[\"matrix\",[[1,2,3],[4,5,6],[7,8,9]]]],output:[1,2,3,6,9,8,7,4,5],explanation:\"Starting from the top-left corner, move right across the first row, then go down across the last column, then move left along the bottom row, and travel up in the first column. Continue this pattern, spiraling inward, until all the elements have been traversed.\"},{input:[[\"matrix\",[[7,7,0,7],[4,3,7,2],[9,8,6,0],[6,1,3,6]]]],output:[7,7,0,7,2,0,6,3,1,6,9,4,3,7,6,8],explanation:\"Starting from the top-left corner, move right across the first row, then go down in the last column, move left along the bottom row, and travel up in the first column. Continue this pattern, spiraling inward, until all the elements have been traversed.\"},{input:[[\"matrix\",[[1,2],[3,4]]]],output:[1,2,4,3],explanation:\"Starting from the top-left corner, move right across the first row, then go down in the last column, and finally move left across the bottom row.\"}];var _={title:\"Matrix Spiral Traversal\",excerpt:\"Implement a function to traverse the matrix in spiral order\"};function d(n){let t=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsxs)(t.p,{children:[\"Given a \",(0,e.jsx)(t.code,{children:\"matrix\"}),\" of size \",(0,e.jsx)(t.code,{children:\"m\"}),\" x \",(0,e.jsx)(t.code,{children:\"n\"}),\", write a function to return the elements of the matrix arranged in a spiral order.\"]}),`\n`,(0,e.jsx)(t.h3,{children:\"Input\"}),`\n`,(0,e.jsxs)(t.ul,{children:[`\n`,(0,e.jsxs)(t.li,{children:[(0,e.jsx)(t.code,{children:\"matrix: number[][]\"}),\": A 2D array \",(0,e.jsx)(t.code,{children:\"matrix\"}),\" of size \",(0,e.jsx)(t.code,{children:\"m\"}),\" x \",(0,e.jsx)(t.code,{children:\"n\"})]}),`\n`]}),`\n`,(0,e.jsx)(h,{testCases:m}),`\n`,(0,e.jsx)(t.h3,{children:\"Constraints\"}),`\n`,(0,e.jsxs)(t.ul,{children:[`\n`,(0,e.jsxs)(t.li,{children:[\"1 <= \",(0,e.jsx)(t.code,{children:\"m\"}),\", \",(0,e.jsx)(t.code,{children:\"n\"}),\" <= 100\"]}),`\n`,(0,e.jsxs)(t.li,{children:[\"-1,000 <= \",(0,e.jsx)(t.code,{children:\"matrix[row][col]\"}),\" <= 1,000\"]}),`\n`]})]})}function M(n={}){let{wrapper:t}=n.components||{};return t?(0,e.jsx)(t,Object.assign({},n,{children:(0,e.jsx)(d,n)})):d(n)}var D=M;return j(S);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to traverse the matrix in spiral order",
    "title": "Matrix Spiral Traversal"
  },
  "solution": "var Component=(()=>{var g=Object.create;var l=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var w=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var x=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),y=(r,e)=>{for(var i in e)l(r,i,{get:e[i],enumerable:!0})},d=(r,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!v.call(r,t)&&t!==i&&l(r,t,{get:()=>e[t],enumerable:!(c=f(e,t))||c.enumerable});return r};var D=(r,e,i)=>(i=r!=null?g(w(r)):{},d(e||!r||!r.__esModule?l(i,\"default\",{value:r,enumerable:!0}):i,r)),b=r=>d(l({},\"__esModule\",{value:!0}),r);var h=x((E,a)=>{a.exports=_jsx_runtime});var S={};y(S,{default:()=>M});var n=D(h());var o=MDXCodeBlock;var s=`export default function matrixSpiralTraversal(matrix: number[][]): number[] {\n  let result = [];\n  const rows = matrix.length;\n  const columns = matrix[0].length;\n  let up = 0;\n  let left = 0;\n  let right = columns - 1;\n  let down = rows - 1;\n\n  // Continue until all elements are added to the result\n  while (result.length < rows * columns) {\n    // Traverse from left to right along the top row\n    for (let col = left; col <= right; col++) {\n      result.push(matrix[up][col]);\n    }\n    // Traverse downwards along the right column\n    for (let row = up + 1; row <= down; row++) {\n      result.push(matrix[row][right]);\n    }\n    // Make sure we are now on a different row to avoid reprocessing\n    if (up !== down) {\n      // Traverse from right to left along the bottom row\n      for (let col = right - 1; col >= left; col--) {\n        result.push(matrix[down][col]);\n      }\n    }\n    // Make sure we are now on a different column to avoid reprocessing\n    if (left !== right) {\n      // Traverse upwards along the left column\n      for (let row = down - 1; row > up; row--) {\n        result.push(matrix[row][left]);\n      }\n    }\n    // Move the boundaries inward\n    left++;\n    right--;\n    up++;\n    down--;\n  }\n  return result;\n}\n`;var u=`export default function matrixSpiralTraversal(matrix: number[][]): number[] {\n  const VISITED = 1001; // Marker for visited cells\n  let rows = matrix.length, // Total number of rows\n    cols = matrix[0].length; // Total number of columns\n  let result: number[] = [matrix[0][0]]; // Result array initialized with the first element\n  matrix[0][0] = VISITED; // Mark the first element as visited\n\n  // Four directions: right, down, left, up.\n  let directions: number[][] = [\n    [0, 1], // Move right\n    [1, 0], // Move down\n    [0, -1], // Move left\n    [-1, 0], // Move up\n  ];\n\n  let currentDirection = 0; // Initial direction: moving right\n  let changeDirection = 0; // Counter for direction changes\n  let row = 0,\n    col = 0; // Starting position\n\n  // Continue until the direction changes twice without adding new elements\n  while (changeDirection < 2) {\n    // Continue moving in the current direction until a boundary or visited cell is encountered\n    while (\n      row + directions[currentDirection][0] >= 0 &&\n      row + directions[currentDirection][0] < rows &&\n      col + directions[currentDirection][1] >= 0 &&\n      col + directions[currentDirection][1] < cols &&\n      matrix[row + directions[currentDirection][0]][\n        col + directions[currentDirection][1]\n      ] !== VISITED\n    ) {\n      changeDirection = 0; // Reset changeDirection as we are still adding elements\n\n      // Move to the next cell in the current direction\n      row += directions[currentDirection][0];\n      col += directions[currentDirection][1];\n\n      result.push(matrix[row][col]); // Add the element to the result\n      matrix[row][col] = VISITED; // Mark the cell as visited\n    }\n\n    // Change direction\n    currentDirection = (currentDirection + 1) % 4; // Cycle through directions\n    changeDirection++; // Increment changeDirection as we changed direction\n  }\n\n  return result;\n}\n`;function m(r){let e=Object.assign({h2:\"h2\",p:\"p\",ol:\"ol\",li:\"li\",h3:\"h3\",code:\"code\",ul:\"ul\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Set Up Boundaries\"}),`\n`,(0,n.jsx)(e.p,{children:\"The task requires traversing a 2D matrix in a spiral order, starting from the top-left corner and proceeding clockwise. The solution uses boundary variables to define the current limits of traversal and iteratively moves inward.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The intuition is to treat the matrix as layers, starting from the outermost layer and moving inward. For each layer:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Traverse from left to right along the top boundary.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Traverse from top to bottom along the right boundary.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Traverse from right to left along the bottom boundary, ensuring it does not overlap with the top row.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Traverse from bottom to top along the left boundary, ensuring it does not overlap with the right column.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"After each traversal, the boundaries are adjusted inward, and the process continues until all elements are traversed.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize the result array \",(0,n.jsx)(e.code,{children:\"result\"}),\" to store the spiral order.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define the boundaries:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"up\"}),\" as the topmost row index, starting at \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"down\"}),\" as the bottommost row index, starting at \",(0,n.jsx)(e.code,{children:\"rows - 1\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"left\"}),\" as the leftmost column index, starting at \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"right\"}),\" as the rightmost column index, starting at \",(0,n.jsx)(e.code,{children:\"columns - 1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"While the size of \",(0,n.jsx)(e.code,{children:\"result\"}),\" is less than the total number of elements in the matrix:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Traverse from \",(0,n.jsx)(e.code,{children:\"left\"}),\" to \",(0,n.jsx)(e.code,{children:\"right\"}),\" along the \",(0,n.jsx)(e.code,{children:\"up\"}),\" row and add elements to \",(0,n.jsx)(e.code,{children:\"result\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Traverse from \",(0,n.jsx)(e.code,{children:\"up + 1\"}),\" to \",(0,n.jsx)(e.code,{children:\"down\"}),\" along the \",(0,n.jsx)(e.code,{children:\"right\"}),\" column and add elements to \",(0,n.jsx)(e.code,{children:\"result\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"up\"}),\" is not equal to \",(0,n.jsx)(e.code,{children:\"down\"}),\", traverse from \",(0,n.jsx)(e.code,{children:\"right - 1\"}),\" to \",(0,n.jsx)(e.code,{children:\"left\"}),\" along the \",(0,n.jsx)(e.code,{children:\"down\"}),\" row and add elements to \",(0,n.jsx)(e.code,{children:\"result\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"left\"}),\" is not equal to \",(0,n.jsx)(e.code,{children:\"right\"}),\", traverse from \",(0,n.jsx)(e.code,{children:\"down - 1\"}),\" to \",(0,n.jsx)(e.code,{children:\"up\"}),\" along the \",(0,n.jsx)(e.code,{children:\"left\"}),\" column and add elements to \",(0,n.jsx)(e.code,{children:\"result\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Move the boundaries inward:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Increment \",(0,n.jsx)(e.code,{children:\"up\"}),\" and \",(0,n.jsx)(e.code,{children:\"left\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Decrement \",(0,n.jsx)(e.code,{children:\"down\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"result\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Each element in the matrix is visited exactly once.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". Ignoring the \",(0,n.jsx)(e.code,{children:\"result\"}),\" array, the additional space required is constant.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Marking The Visited Element\"}),`\n`,(0,n.jsx)(e.p,{children:\"The task involves traversing a 2D matrix in a spiral order, starting from the top-left corner and proceeding clockwise. This solution uses a marker to identify visited cells and ensures the traversal continues until all elements are added to the result.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The matrix is traversed in four possible directions: right, down, left, and up. The algorithm keeps track of the current position and direction. When a boundary or a previously visited cell is encountered, the direction changes. This process continues until the algorithm cycles through two direction changes without adding any new elements, indicating all elements have been visited.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach eliminates the need for explicitly tracking boundaries by dynamically checking the next cell's validity.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize variables:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define \",(0,n.jsx)(e.code,{children:\"VISITED\"}),\" as a marker for visited cells.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Retrieve the number of rows and columns in the matrix.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Create the \",(0,n.jsx)(e.code,{children:\"result\"}),\" array, starting with the top-left element.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Mark the top-left cell as visited by assigning it the \",(0,n.jsx)(e.code,{children:\"VISITED\"}),\" value.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Define the four possible directions for traversal: right, down, left, and up.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"currentDirection\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" (right) and \",(0,n.jsx)(e.code,{children:\"changeDirection\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\" to track consecutive direction changes without adding elements.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Traverse the matrix:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"While \",(0,n.jsx)(e.code,{children:\"changeDirection\"}),\" is less than \",(0,n.jsx)(e.code,{children:\"2\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Move in the current direction until a boundary or a visited cell is encountered.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"For each valid move:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Update the current position.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Add the element at the current position to the \",(0,n.jsx)(e.code,{children:\"result\"}),\" array.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Mark the cell as visited.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Reset \",(0,n.jsx)(e.code,{children:\"changeDirection\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Change direction by updating \",(0,n.jsx)(e.code,{children:\"currentDirection\"}),\" to the next value in the sequence.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Increment \",(0,n.jsx)(e.code,{children:\"changeDirection\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the \",(0,n.jsx)(e.code,{children:\"result\"}),\" array.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". Each element in the matrix is visited exactly once.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". Ignoring the \",(0,n.jsx)(e.code,{children:\"result\"}),\" array, the additional space required is constant.\"]}),`\n`]})]})}function k(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(m,r)})):m(r)}var M=k;return b(S);})();\n;return Component;"
}