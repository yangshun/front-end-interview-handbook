{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/linked-list\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/linked-list.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/linked-list.run.test.ts": "import LinkedList from './linked-list';\n\ndescribe('LinkedList', () => {\n  test('constructor', () => {\n    const list = new LinkedList();\n    expect(list).toBeInstanceOf(LinkedList);\n  });\n\n  test('insert()', () => {\n    const list = new LinkedList();\n    list.insertHead(100);\n    list.insertTail(200);\n    list.insertHead(300);\n\n    expect(list.length()).toEqual(3);\n    expect(list.toArray()).toEqual([300, 100, 200]);\n  });\n\n  test('remove()', () => {\n    const list = new LinkedList();\n    list.insertHead(100);\n    list.insertTail(200);\n    expect(list.remove(1)).toBe(200);\n    expect(list.remove(1)).toBe(undefined);\n    expect(list.length()).toEqual(1);\n  });\n});\n",
    "/src/linked-list.submit.test.ts": "import LinkedList from './linked-list';\n\ndescribe('LinkedList', () => {\n  test('constructor', () => {\n    const list = new LinkedList();\n    expect(list).toBeInstanceOf(LinkedList);\n  });\n\n  describe('insert', () => {\n    test('insertHead()', () => {\n      const list = new LinkedList();\n      list.insertHead(200);\n      list.insertHead(100);\n      expect(list.toArray()).toEqual([100, 200]);\n    });\n  \n    test('insertTail()', () => {\n      const list = new LinkedList();\n      list.insertTail(100);\n      list.insertTail(150);\n      list.insertTail(200);\n      expect(list.toArray()).toEqual([100, 150, 200]);\n    });\n  });\n\n  describe('get()', () => {\n    test('returns correct value at valid index', () => {\n      const list = new LinkedList();\n      list.insertTail(10);\n      list.insertTail(20);\n      expect(list.get(0)).toBe(10);\n      expect(list.get(1)).toBe(20);\n    });\n  \n    test('returns undefined for out-of-bounds indexes', () => {\n      const list = new LinkedList();\n      expect(list.get(0)).toBeUndefined();\n      list.insertTail(5);\n      expect(list.get(1)).toBeUndefined();\n    });\n  });\n\n  test('remove()', () => {\n    const list = new LinkedList();\n    list.insertHead(100);\n    list.insertTail(200);\n    expect(list.remove(1)).toBe(200);\n    expect(list.length()).toEqual(1);\n    expect(list.remove(1)).toBe(undefined);\n    expect(list.length()).toEqual(1);\n  });\n\n  test('remove()', () => {\n    const list = new LinkedList();\n    expect(list.length()).toEqual(0);\n    expect(list.toArray()).toEqual([]);\n    list.insertTail(2);\n    expect(list.length()).toEqual(1);\n    expect(list.toArray()).toEqual([2]);\n    list.remove(0);\n    expect(list.toArray()).toEqual([]);\n    expect(list.length()).toEqual(0);\n  });\n\n  test('mixed', () => {\n    const linked = new LinkedList();\n    expect(linked.toArray()).toEqual([]);\n    linked.insertTail(1);\n    linked.insertHead(2);\n    expect(linked.toArray()).toEqual([2, 1]);\n    linked.insertTail(3);\n    expect(linked.toArray()).toEqual([2, 1, 3]);\n    expect(linked.get(1)).toBe(1);\n    expect(linked.get(2)).toBe(3);\n    expect(linked.remove(1)).toBe(1);\n    expect(linked.toArray()).toEqual([2, 3]);\n    expect(linked.remove(1)).toBe(3);\n    expect(linked.remove(4)).toBe(undefined);\n    expect(linked.remove(0)).toBe(2);\n    expect(linked.remove(0)).toBe(undefined);\n    expect(linked.toArray()).toEqual([]);\n  });\n});\n",
    "/src/linked-list.ts": "class Node<T> {\n  value: any;\n  next: Node<T> | null;\n\n  constructor(value: any, next: Node<T> | null = null) {\n    this.value = value;\n    this.next = next;\n  }\n}\n\nexport default class LinkedList<T> {\n  head: Node<T> | null;\n  tail: Node<T> | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  /**\n   * Adds an item to the head of the linked list.\n   * @param {*} value The item to be added to the head of the list.\n   */\n  insertHead<T>(value: T): void {\n    const node = new Node<T>(value, this.head);\n    if (this.head == null) {\n      this.tail = node;\n    }\n    this.head = node;\n  }\n\n  /**\n   * Adds an item to the tail of the linked list.\n   * @param {*} value The item to be added to the tail of the list.\n   */\n  insertTail<T>(value: T): void {\n    const node = new Node<T>(value);\n    if (this.tail == null) {\n      this.head = node;\n    } else {\n      this.tail.next = node;\n    }\n    this.tail = node;\n  }\n\n  /**\n   * Remove the item in the given index and return its value or `undefined` if index is out of bound.\n   * @param {number} i The index of the item to be removed.\n   * @return {*} The value of the item in index i if it exists, `undefined` otherwise.\n   */\n  remove<T>(i: number): T | undefined {\n    // To remove index 0, we have to replace the value of head, if it exists.\n    if (i === 0 && this.head != null) {\n      let value = this.head.value;\n      this.head = this.head.next;\n      if (this.head == null) {\n        this.tail = null;\n      } // If there is no node left in the linked list, replace tail with null as well.\n      return value;\n    }\n\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n    // Point the pointer to the next node for i-1 times to reach index i-1.\n    for (let j = 1; j < i; j++) {\n      if (curr == null || curr.next == null) {\n        return undefined;\n      } // Return `undefined` if linked list ends before reaching index i.\n\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    if (curr == null || curr.next == null) {\n      return undefined;\n    }\n\n    let value = curr.next.value; // Save the value of the node in index i.\n    curr.next = curr.next.next;\n\n    // If curr.next, which is to be removed, is the last node in the linked list, update tail to the previous node (curr).\n    this.tail = curr.next == null ? curr : this.tail;\n\n    return value; // Return the value of the node in index i.\n  }\n\n  /**\n   * Return the value of the item in the given index or `undefined` if index is out of bound.\n   * @param {number} i The index of the value of the item to be returned.\n   * @return {*} The value of the item in index i if it exists, `undefined` otherwise.\n   */\n  get<T>(i: number): T | undefined {\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n    // Point the pointer to the next node for i times to reach index i.\n    for (let j = 0; j < i; j++) {\n      if (curr == null) {\n        return undefined;\n      } // Return `undefined` if linked list ends before reaching index i.\n\n      curr = curr.next;\n    }\n\n    let value = curr != null ? curr.value : undefined;\n    return value; // Return the value of the node in index i.\n  }\n\n  /**\n   * Return an array containing all the values of the items in the linked list from head to tail.\n   * @return {*} The array of all the values in the linked list from head to tail.\n   */\n  toArray<T>(): Array<T> {\n    const array: Array<T> = [];\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n\n    // Continue to traverse through the linked list until it reaches the tail (null).\n    while (curr != null) {\n      array.push(curr.value);\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    return array;\n  }\n\n  /**\n   * Return the length / number of elements in the linked list.\n   * @return {*} Length of the linked list.\n   */\n  length(): number {\n    let length = 0;\n    let curr = this.head;\n\n    while (curr) {\n      length += 1;\n      curr = curr.next;\n    }\n\n    return length;\n  }\n}\n"
  },
  "skeleton": {
    "js": "export default class LinkedList {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the head of the linked list.\n   * @param {*} value The item to be added to the head of the list.\n   */\n  insertHead(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the tail of the linked list.\n   * @param {*} value The item to be added to the tail of the list.\n   */\n  insertTail(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Remove the item in the given index and return its value or `undefined` if index is out of bound.\n   * @param {int} i The index of the item to be removed.\n   * @return {*} The value of the item in index i if it exists, `undefined` otherwise.\n   */\n  remove(i) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return the value of the item in the given index or `undefined` if index is out of bound.\n   * @param {int} i The index of the value of the item to be returned.\n   * @return {*} The value of the item in index i if it exists, `undefined` otherwise.\n   */\n  get(i) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return an array containing all the values of the items in the linked list from head to tail.\n   * @return {*} The array of all the values in the linked list from head to tail.\n   */\n  toArray() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return the length / number of elements in the linked list.\n   * @return {*} Length of the linked list.\n   */\n  length() {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export default class LinkedList<T> {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the head of the linked list.\n   * @param {T} value The item to be added to the head of the list.\n   */\n  insertHead(value: T): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the tail of the linked list.\n   * @param {T} value The item to be added to the tail of the list.\n   */\n  insertTail(value: T): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Remove the item in the given index and return its value or `undefined` if index is out of bounds.\n   * @param {number} i The index of the item to be removed.\n   * @return {T | undefined} The value at index i if it exists, `undefined` otherwise.\n   */\n  remove(i: number): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return the value of the item at the given index or `undefined` if index is out of bounds.\n   * @param {number} i The index of the value to retrieve.\n   * @return {T | undefined} The value at index i if it exists, `undefined` otherwise.\n   */\n  get(i: number): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return an array containing all the values in the linked list from head to tail.\n   * @return {Array<T>} The array of all values in the linked list from head to tail.\n   */\n  toArray(): Array<T> {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return the number of elements in the linked list.\n   * @return {number} The length of the list.\n   */\n  length(): number {\n    throw 'Not implemented!';\n  }\n}"
  },
  "workspace": {
    "main": "/src/linked-list.ts",
    "run": "/src/linked-list.run.test.ts",
    "submit": "/src/linked-list.submit.test.ts"
  }
}