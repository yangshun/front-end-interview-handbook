{
  "description": "var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var i in e)r(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!k.call(t,l)&&l!==i&&r(t,l,{get:()=>e[l],enumerable:!(d=u(e,l))||d.enumerable});return t};var x=(t,e,i)=>(i=t!=null?h(p(t)):{},c(e||!t||!t.__esModule?r(i,\"default\",{value:t,enumerable:!0}):i,t)),y=t=>c(r({},\"__esModule\",{value:!0}),t);var s=f((b,a)=>{a.exports=_jsx_runtime});var j={};g(j,{default:()=>L,frontmatter:()=>v});var n=x(s()),v={title:\"Linked List\",excerpt:\"Implement a linked list data structure containing the common linked list methods\"};function o(t){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h2:\"h2\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Implement a linked list data structure in JavaScript that contains the following operations:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"new LinkedList()\"}),\": Creates an instance of a \",(0,n.jsx)(e.code,{children:\"LinkedList\"}),\" class that does not contain any items. The constructor does not accept any arguments.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"get()\"}),\": Accepts an integer parameter \",(0,n.jsx)(e.code,{children:\"i\"}),\" to return the value of the \",(0,n.jsx)(e.code,{children:\"i\"}),\"-th node. Return \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" if index is out of bounds.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"insertHead()\"}),\": Accepts a parameter \",(0,n.jsx)(e.code,{children:\"value\"}),\" and inserts \",(0,n.jsx)(e.code,{children:\"value\"}),\" at the head of the list.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"insertTail()\"}),\": Accepts a parameter \",(0,n.jsx)(e.code,{children:\"value\"}),\" and inserts \",(0,n.jsx)(e.code,{children:\"value\"}),\" at the tail of the list.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"remove()\"}),\": Accepts an integer parameter \",(0,n.jsx)(e.code,{children:\"i\"}),\" and removes the item at the \",(0,n.jsx)(e.code,{children:\"i\"}),\"-th index while returning its value. Return \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" if index is out of bounds.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"toArray()\"}),\": Returns an array containing all the items in the linked list from head (first element in the array) to tail (last element in the array).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"length()\"}),\": Returns the number of elements in the linked list.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const linkedlist = new LinkedList();\nlinkedlist.toArray(); // []\nlinkedlist.insertTail(1);\nlinkedlist.insertHead(2);\nlinkedlist.toArray(); // [2, 1]\nlinkedlist.insertTail(3);\nlinkedlist.toArray(); // [2, 1, 3]\nlinkedlist.length(); // 3\nlinkedlist.get(1); // 1\nlinkedlist.get(2); // 3\nlinkedlist.remove(1); // 1\nlinkedlist.toArray(); // [2, 3]\n`})})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(o,t)})):o(t)}var L=A;return y(j);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/linked-list\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/linked-list.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/linked-list.run.test.ts": "import LinkedList from './linked-list';\n\ndescribe('LinkedList', () => {\n  test('constructor', () => {\n    const list = new LinkedList();\n    expect(list).toBeInstanceOf(LinkedList);\n  });\n\n  test('insert()', () => {\n    const list = new LinkedList();\n    list.insertHead(100);\n    list.insertTail(200);\n    list.insertHead(300);\n\n    expect(list.length()).toEqual(3);\n    expect(list.toArray()).toEqual([300, 100, 200]);\n  });\n\n  test('remove()', () => {\n    const list = new LinkedList();\n    list.insertHead(100);\n    list.insertTail(200);\n    expect(list.remove(1)).toBe(200);\n    expect(list.remove(1)).toBe(undefined);\n    expect(list.length()).toEqual(1);\n  });\n});\n",
    "/src/linked-list.submit.test.ts": "import LinkedList from './linked-list';\n\ndescribe('LinkedList', () => {\n  test('constructor', () => {\n    const list = new LinkedList();\n    expect(list).toBeInstanceOf(LinkedList);\n  });\n\n  describe('insert', () => {\n    test('insertHead()', () => {\n      const list = new LinkedList();\n      list.insertHead(200);\n      list.insertHead(100);\n      expect(list.toArray()).toEqual([100, 200]);\n    });\n  \n    test('insertTail()', () => {\n      const list = new LinkedList();\n      list.insertTail(100);\n      list.insertTail(150);\n      list.insertTail(200);\n      expect(list.toArray()).toEqual([100, 150, 200]);\n    });\n  });\n\n  describe('get()', () => {\n    test('returns correct value at valid index', () => {\n      const list = new LinkedList();\n      list.insertTail(10);\n      list.insertTail(20);\n      expect(list.get(0)).toBe(10);\n      expect(list.get(1)).toBe(20);\n    });\n  \n    test('returns undefined for out-of-bounds indexes', () => {\n      const list = new LinkedList();\n      expect(list.get(0)).toBeUndefined();\n      list.insertTail(5);\n      expect(list.get(1)).toBeUndefined();\n    });\n  });\n\n  test('remove()', () => {\n    const list = new LinkedList();\n    list.insertHead(100);\n    list.insertTail(200);\n    expect(list.remove(1)).toBe(200);\n    expect(list.length()).toEqual(1);\n    expect(list.remove(1)).toBe(undefined);\n    expect(list.length()).toEqual(1);\n  });\n\n  test('remove()', () => {\n    const list = new LinkedList();\n    expect(list.length()).toEqual(0);\n    expect(list.toArray()).toEqual([]);\n    list.insertTail(2);\n    expect(list.length()).toEqual(1);\n    expect(list.toArray()).toEqual([2]);\n    list.remove(0);\n    expect(list.toArray()).toEqual([]);\n    expect(list.length()).toEqual(0);\n  });\n\n  test('mixed', () => {\n    const linked = new LinkedList();\n    expect(linked.toArray()).toEqual([]);\n    linked.insertTail(1);\n    linked.insertHead(2);\n    expect(linked.toArray()).toEqual([2, 1]);\n    linked.insertTail(3);\n    expect(linked.toArray()).toEqual([2, 1, 3]);\n    expect(linked.get(1)).toBe(1);\n    expect(linked.get(2)).toBe(3);\n    expect(linked.remove(1)).toBe(1);\n    expect(linked.toArray()).toEqual([2, 3]);\n    expect(linked.remove(1)).toBe(3);\n    expect(linked.remove(4)).toBe(undefined);\n    expect(linked.remove(0)).toBe(2);\n    expect(linked.remove(0)).toBe(undefined);\n    expect(linked.toArray()).toEqual([]);\n  });\n});\n",
    "/src/linked-list.ts": "class Node<T> {\n  value: any;\n  next: Node<T> | null;\n\n  constructor(value: any, next: Node<T> | null = null) {\n    this.value = value;\n    this.next = next;\n  }\n}\n\nexport default class LinkedList<T> {\n  head: Node<T> | null;\n  tail: Node<T> | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  /**\n   * Adds an item to the head of the linked list.\n   * @param {*} value The item to be added to the head of the list.\n   */\n  insertHead<T>(value: T): void {\n    const node = new Node<T>(value, this.head);\n    if (this.head == null) {\n      this.tail = node;\n    }\n    this.head = node;\n  }\n\n  /**\n   * Adds an item to the tail of the linked list.\n   * @param {*} value The item to be added to the tail of the list.\n   */\n  insertTail<T>(value: T): void {\n    const node = new Node<T>(value);\n    if (this.tail == null) {\n      this.head = node;\n    } else {\n      this.tail.next = node;\n    }\n    this.tail = node;\n  }\n\n  /**\n   * Remove the item in the given index and return its value or `undefined` if index is out of bound.\n   * @param {number} i The index of the item to be removed.\n   * @return {*} The value of the item in index i if it exists, `undefined` otherwise.\n   */\n  remove<T>(i: number): T | undefined {\n    // To remove index 0, we have to replace the value of head, if it exists.\n    if (i === 0 && this.head != null) {\n      let value = this.head.value;\n      this.head = this.head.next;\n      if (this.head == null) {\n        this.tail = null;\n      } // If there is no node left in the linked list, replace tail with null as well.\n      return value;\n    }\n\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n    // Point the pointer to the next node for i-1 times to reach index i-1.\n    for (let j = 1; j < i; j++) {\n      if (curr == null || curr.next == null) {\n        return undefined;\n      } // Return `undefined` if linked list ends before reaching index i.\n\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    if (curr == null || curr.next == null) {\n      return undefined;\n    }\n\n    let value = curr.next.value; // Save the value of the node in index i.\n    curr.next = curr.next.next;\n\n    // If curr.next, which is to be removed, is the last node in the linked list, update tail to the previous node (curr).\n    this.tail = curr.next == null ? curr : this.tail;\n\n    return value; // Return the value of the node in index i.\n  }\n\n  /**\n   * Return the value of the item in the given index or `undefined` if index is out of bound.\n   * @param {number} i The index of the value of the item to be returned.\n   * @return {*} The value of the item in index i if it exists, `undefined` otherwise.\n   */\n  get<T>(i: number): T | undefined {\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n    // Point the pointer to the next node for i times to reach index i.\n    for (let j = 0; j < i; j++) {\n      if (curr == null) {\n        return undefined;\n      } // Return `undefined` if linked list ends before reaching index i.\n\n      curr = curr.next;\n    }\n\n    let value = curr != null ? curr.value : undefined;\n    return value; // Return the value of the node in index i.\n  }\n\n  /**\n   * Return an array containing all the values of the items in the linked list from head to tail.\n   * @return {*} The array of all the values in the linked list from head to tail.\n   */\n  toArray<T>(): Array<T> {\n    const array: Array<T> = [];\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n\n    // Continue to traverse through the linked list until it reaches the tail (null).\n    while (curr != null) {\n      array.push(curr.value);\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    return array;\n  }\n\n  /**\n   * Return the length / number of elements in the linked list.\n   * @return {*} Length of the linked list.\n   */\n  length(): number {\n    let length = 0;\n    let curr = this.head;\n\n    while (curr) {\n      length += 1;\n      curr = curr.next;\n    }\n\n    return length;\n  }\n}\n"
  },
  "info": {
    "excerpt": "Implement a linked list data structure containing the common linked list methods",
    "title": "Linked List"
  },
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1745539200,
    "difficulty": "medium",
    "duration": 20,
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/linked-list",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "stack",
      "queue"
    ],
    "slug": "linked-list",
    "subtitle": null,
    "topics": [
      "linked-list"
    ]
  },
  "skeleton": {
    "js": "export default class LinkedList {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the head of the linked list.\n   * @param {*} value The item to be added to the head of the list.\n   */\n  insertHead(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the tail of the linked list.\n   * @param {*} value The item to be added to the tail of the list.\n   */\n  insertTail(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Remove the item in the given index and return its value or `undefined` if index is out of bound.\n   * @param {int} i The index of the item to be removed.\n   * @return {*} The value of the item in index i if it exists, `undefined` otherwise.\n   */\n  remove(i) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return the value of the item in the given index or `undefined` if index is out of bound.\n   * @param {int} i The index of the value of the item to be returned.\n   * @return {*} The value of the item in index i if it exists, `undefined` otherwise.\n   */\n  get(i) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return an array containing all the values of the items in the linked list from head to tail.\n   * @return {*} The array of all the values in the linked list from head to tail.\n   */\n  toArray() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return the length / number of elements in the linked list.\n   * @return {*} Length of the linked list.\n   */\n  length() {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export default class LinkedList<T> {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the head of the linked list.\n   * @param {T} value The item to be added to the head of the list.\n   */\n  insertHead(value: T): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Adds an item to the tail of the linked list.\n   * @param {T} value The item to be added to the tail of the list.\n   */\n  insertTail(value: T): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Remove the item in the given index and return its value or `undefined` if index is out of bounds.\n   * @param {number} i The index of the item to be removed.\n   * @return {T | undefined} The value at index i if it exists, `undefined` otherwise.\n   */\n  remove(i: number): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return the value of the item at the given index or `undefined` if index is out of bounds.\n   * @param {number} i The index of the value to retrieve.\n   * @return {T | undefined} The value at index i if it exists, `undefined` otherwise.\n   */\n  get(i: number): T | undefined {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return an array containing all the values in the linked list from head to tail.\n   * @return {Array<T>} The array of all values in the linked list from head to tail.\n   */\n  toArray(): Array<T> {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Return the number of elements in the linked list.\n   * @return {number} The length of the list.\n   */\n  length(): number {\n    throw 'Not implemented!';\n  }\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var l=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var x=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var T=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),k=(n,e)=>{for(var i in e)l(n,i,{get:e[i],enumerable:!0})},h=(n,e,i,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of x(e))!p.call(n,r)&&r!==i&&l(n,r,{get:()=>e[r],enumerable:!(d=v(e,r))||d.enumerable});return n};var b=(n,e,i)=>(i=n!=null?m(g(n)):{},h(e||!n||!n.__esModule?l(i,\"default\",{value:n,enumerable:!0}):i,n)),y=n=>h(l({},\"__esModule\",{value:!0}),n);var a=T((C,o)=>{o.exports=_jsx_runtime});var L={};k(L,{default:()=>A});var t=b(a());var u=MDXCodeBlock;var s=`class Node {\n  constructor(value, next = null) {\n    this.value = value;\n    this.next = next;\n  }\n}\n\nexport default class LinkedList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  /**\n   * Adds an item to the head of the linked list.\n   * @param {*} value The item to be added to the head of the list.\n   */\n  insertHead(value) {\n    const node = new Node(value, this.head);\n    if (this.head == null) {\n      this.tail = node;\n    }\n    this.head = node;\n  }\n\n  /**\n   * Adds an item to the tail of the linked list.\n   * @param {*} value The item to be added to the tail of the list.\n   */\n  insertTail(value) {\n    const node = new Node(value);\n    if (this.tail == null) {\n      this.head = node;\n    } else {\n      this.tail.next = node;\n    }\n    this.tail = node;\n  }\n\n  /**\n   * Remove the item in the given index and return its value or \\`undefined\\` if index is out of bound.\n   * @param {number} i The index of the item to be removed.\n   * @return {*} The value of the item in index i if it exists, \\`undefined\\` otherwise.\n   */\n  remove(i) {\n    // To remove index 0, we have to replace the value of head, if it exists.\n    if (i === 0 && this.head != null) {\n      let value = this.head.value;\n      this.head = this.head.next;\n      if (this.head == null) {\n        this.tail = null;\n      } // If there is no node left in the linked list, replace tail with null as well.\n      return value;\n    }\n\n    let curr = this.head; // Set a pointer to the first node of the linked list.\n    // Point the pointer to the next node for i-1 times to reach index i-1.\n    for (let j = 1; j < i; j++) {\n      if (curr == null || curr.next == null) {\n        return undefined;\n      } // Return \\`undefined\\` if linked list ends before reaching index i.\n\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    if (curr == null || curr.next == null) {\n      return undefined;\n    }\n\n    let value = curr.next.value; // Save the value of the node in index i.\n    curr.next = curr.next.next;\n\n    // If curr.next, which is to be removed, is the last node in the linked list, update tail to the previous node (curr).\n    this.tail = curr.next == null ? curr : this.tail;\n\n    return value; // Return the value of the node in index i.\n  }\n\n  /**\n   * Return the value of the item in the given index or \\`undefined\\` if index is out of bound.\n   * @param {number} i The index of the value of the item to be returned.\n   * @return {*} The value of the item in index i if it exists, \\`undefined\\` otherwise.\n   */\n  get(i) {\n    let curr = this.head; // Set a pointer to the first node of the linked list.\n    // Point the pointer to the next node for i times to reach index i.\n    for (let j = 0; j < i; j++) {\n      if (curr == null) {\n        return undefined;\n      } // Return \\`undefined\\` if linked list ends before reaching index i.\n\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    let value = curr != null ? curr.value : undefined;\n    return value; // Return the value of the node in index i.\n  }\n\n  /**\n   * Return an array containing all the values of the items in the linked list from head to tail.\n   * @return {*} The array of all the values in the linked list from head to tail.\n   */\n  toArray() {\n    const array = [];\n    let curr = this.head; // Set a pointer to the first node of the linked list.\n\n    // Continue to traverse through the linked list until it reaches the tail (null).\n    while (curr != null) {\n      array.push(curr.value);\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    return array;\n  }\n\n  /**\n   * Return the length / number of elements in the linked list.\n   * @return {*} Length of the linked list.\n   */\n  length() {\n    let length = 0;\n    let curr = this.head;\n\n    while (curr) {\n      length += 1;\n      curr = curr.next;\n    }\n\n    return length;\n  }\n}\n`;var c=`class Node<T> {\n  value: any;\n  next: Node<T> | null;\n\n  constructor(value: any, next: Node<T> | null = null) {\n    this.value = value;\n    this.next = next;\n  }\n}\n\nexport default class LinkedList<T> {\n  head: Node<T> | null;\n  tail: Node<T> | null;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  /**\n   * Adds an item to the head of the linked list.\n   * @param {*} value The item to be added to the head of the list.\n   */\n  insertHead<T>(value: T): void {\n    const node = new Node<T>(value, this.head);\n    if (this.head == null) {\n      this.tail = node;\n    }\n    this.head = node;\n  }\n\n  /**\n   * Adds an item to the tail of the linked list.\n   * @param {*} value The item to be added to the tail of the list.\n   */\n  insertTail<T>(value: T): void {\n    const node = new Node<T>(value);\n    if (this.tail == null) {\n      this.head = node;\n    } else {\n      this.tail.next = node;\n    }\n    this.tail = node;\n  }\n\n  /**\n   * Remove the item in the given index and return its value or \\`undefined\\` if index is out of bound.\n   * @param {number} i The index of the item to be removed.\n   * @return {*} The value of the item in index i if it exists, \\`undefined\\` otherwise.\n   */\n  remove<T>(i: number): T | undefined {\n    // To remove index 0, we have to replace the value of head, if it exists.\n    if (i === 0 && this.head != null) {\n      let value = this.head.value;\n      this.head = this.head.next;\n      if (this.head == null) {\n        this.tail = null;\n      } // If there is no node left in the linked list, replace tail with null as well.\n      return value;\n    }\n\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n    // Point the pointer to the next node for i-1 times to reach index i-1.\n    for (let j = 1; j < i; j++) {\n      if (curr == null || curr.next == null) {\n        return undefined;\n      } // Return \\`undefined\\` if linked list ends before reaching index i.\n\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    if (curr == null || curr.next == null) {\n      return undefined;\n    }\n\n    let value = curr.next.value; // Save the value of the node in index i.\n    curr.next = curr.next.next;\n\n    // If curr.next, which is to be removed, is the last node in the linked list, update tail to the previous node (curr).\n    this.tail = curr.next == null ? curr : this.tail;\n\n    return value; // Return the value of the node in index i.\n  }\n\n  /**\n   * Return the value of the item in the given index or \\`undefined\\` if index is out of bound.\n   * @param {number} i The index of the value of the item to be returned.\n   * @return {*} The value of the item in index i if it exists, \\`undefined\\` otherwise.\n   */\n  get<T>(i: number): T | undefined {\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n    // Point the pointer to the next node for i times to reach index i.\n    for (let j = 0; j < i; j++) {\n      if (curr == null) {\n        return undefined;\n      } // Return \\`undefined\\` if linked list ends before reaching index i.\n\n      curr = curr.next;\n    }\n\n    let value = curr != null ? curr.value : undefined;\n    return value; // Return the value of the node in index i.\n  }\n\n  /**\n   * Return an array containing all the values of the items in the linked list from head to tail.\n   * @return {*} The array of all the values in the linked list from head to tail.\n   */\n  toArray<T>(): Array<T> {\n    const array: Array<T> = [];\n    let curr: Node<T> | null = this.head; // Set a pointer to the first node of the linked list.\n\n    // Continue to traverse through the linked list until it reaches the tail (null).\n    while (curr != null) {\n      array.push(curr.value);\n      curr = curr.next; // Change the current pointer to the next one.\n    }\n\n    return array;\n  }\n\n  /**\n   * Return the length / number of elements in the linked list.\n   * @return {*} Length of the linked list.\n   */\n  length(): number {\n    let length = 0;\n    let curr = this.head;\n\n    while (curr) {\n      length += 1;\n      curr = curr.next;\n    }\n\n    return length;\n  }\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",img:\"img\",ul:\"ul\",li:\"li\",strong:\"strong\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Linked lists are chains of connected nodes, where each node contains a \",(0,t.jsx)(e.code,{children:\"value\"}),\" and a reference to the \",(0,t.jsx)(e.code,{children:\"next\"}),\" node. The \",(0,t.jsx)(e.code,{children:\"next\"}),\" in each node forms the links required to make linked lists.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In the \",(0,t.jsx)(e.code,{children:\"LinkedList\"}),\" class, \",(0,t.jsx)(e.code,{children:\"head\"}),\" and \",(0,t.jsx)(e.code,{children:\"tail\"}),\" are used to indicate the start and end of the list. While using only \",(0,t.jsx)(e.code,{children:\"head\"}),\" is possible, maintaining a \",(0,t.jsx)(e.code,{children:\"tail\"}),\" pointer improves the time complexity of operations like \",(0,t.jsx)(e.code,{children:\"insertTail()\"}),\" and enables efficient use cases such as implementing queues.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Insert\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"insertHead()\"}),\" and \",(0,t.jsx)(e.code,{children:\"insertTail()\"}),\" involve updating the \",(0,t.jsx)(e.code,{children:\"head\"}),\" or \",(0,t.jsx)(e.code,{children:\"tail\"}),\" of the list to point to a new node.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/linked-list/insert-head.png\",alt:\"Insert Head\"})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/linked-list/insert-tail.png\",alt:\"Insert Tail\"})}),`\n`,(0,t.jsx)(e.h3,{children:\"Remove\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"remove()\"}),\" modifies the \",(0,t.jsx)(e.code,{children:\"next\"}),\" reference of node \",(0,t.jsx)(e.code,{children:\"i-1\"}),\" to point to node \",(0,t.jsx)(e.code,{children:\"i+1\"}),\", effectively removing node \",(0,t.jsx)(e.code,{children:\"i\"}),\" from the list. If the removed node is at the head or tail, the \",(0,t.jsx)(e.code,{children:\"head\"}),\" or \",(0,t.jsx)(e.code,{children:\"tail\"}),\" pointers are also updated accordingly.\"]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/linked-list/remove.png\",alt:\"Remove\"})}),`\n`,(0,t.jsx)(e.h3,{children:\"Get and toArray\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"get()\"}),\" and \",(0,t.jsx)(e.code,{children:\"toArray()\"}),\" traverse the list from the \",(0,t.jsx)(e.code,{children:\"head\"}),\" node. \",(0,t.jsx)(e.code,{children:\"get()\"}),\" stops at the specified index, while \",(0,t.jsx)(e.code,{children:\"toArray()\"}),\" continues until the \",(0,t.jsx)(e.code,{children:\"tail\"}),\", collecting all values.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Length\"}),`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:\"length()\"}),\" traverses through the entire linked list to count the number of elements. Alternatively, a length variable can be maintained to track the length of the linked list every time a node is inserted/removed.\"]}),`\n`,(0,t.jsx)(u,{languages:{jsx:s,tsx:c}}),`\n`,(0,t.jsx)(e.h2,{children:\"Big-O analysis\"}),`\n`,(0,t.jsx)(e.p,{children:\"Let's analyze the algorithm's time and space complexity.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Time complexity\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"insertHead()\"}),\" and \",(0,t.jsx)(e.code,{children:\"insertTail()\"}),\": O(1) as we can access \",(0,t.jsx)(e.code,{children:\"head\"}),\" and \",(0,t.jsx)(e.code,{children:\"tail\"}),\" immediately.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"get()\"}),\", \",(0,t.jsx)(e.code,{children:\"remove()\"}),\", \",(0,t.jsx)(e.code,{children:\"toArray()\"}),\": O(n) as the worst case is to traverse through the entire linked list to search for the specific index for \",(0,t.jsx)(e.code,{children:\"get()\"}),\" and \",(0,t.jsx)(e.code,{children:\"remove()\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"length()\"}),\": O(n) if traversing the entire array to calculate length, O(1) if maintaining a length variable.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Space complexity\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"All methods require O(1) space, as no additional data structures are created that grow with input size.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Empty list\"}),\": When operating on an empty list, \",(0,t.jsx)(e.code,{children:\"insertHead()\"}),\" and \",(0,t.jsx)(e.code,{children:\"insertTail()\"}),\" must set both \",(0,t.jsx)(e.code,{children:\"head\"}),\" and \",(0,t.jsx)(e.code,{children:\"tail\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Invalid index\"}),\": In \",(0,t.jsx)(e.code,{children:\"get()\"}),\" and \",(0,t.jsx)(e.code,{children:\"remove()\"}),\", index values less than 0 or greater than or equal to the list length must be handled gracefully. One common approach is to return \",(0,t.jsx)(e.code,{children:\"undefined\"}),\", as used in this problem.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Techniques\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Object-oriented programming.\"}),`\n`]})]})}function R(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(f,n)})):f(n)}var A=R;return y(L);})();\n;return Component;",
  "workspace": {
    "main": "/src/linked-list.ts",
    "run": "/src/linked-list.run.test.ts",
    "submit": "/src/linked-list.submit.test.ts"
  }
}