{
  "description": "var Component=(()=>{var x=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var w=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),j=(n,e)=>{for(var i in e)a(n,i,{get:e[i],enumerable:!0})},c=(n,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!g.call(n,r)&&r!==i&&a(n,r,{get:()=>e[r],enumerable:!(o=u(e,r))||o.enumerable});return n};var T=(n,e,i)=>(i=n!=null?x(f(n)):{},c(e||!n||!n.__esModule?a(i,\"default\",{value:n,enumerable:!0}):i,n)),_=n=>c(a({},\"__esModule\",{value:!0}),n);var d=w((k,l)=>{l.exports=_jsx_runtime});var C={};j(C,{default:()=>b,frontmatter:()=>D});var t=T(d());var s=MDXTestExamples;var m=[{input:[[\"matrix\",[[1,4],[2,6]]]],output:[[2,1],[6,4]],explanation:\"The 2x2 matrix is rotated 90 degrees clockwise.\"},{input:[[\"matrix\",[[1,2,3],[4,5,6],[7,8,9]]]],output:[[7,4,1],[8,5,2],[9,6,3]],explanation:\"The 3x3 matrix is rotated 90 degrees clockwise.\"},{input:[[\"matrix\",[[3]]]],output:[[3]],explanation:\"The 1x1 matrix remains the same after rotation.\"}];var D={title:\"Matrix Rotation\",excerpt:\"Implement a function to rotate the given matrix by 90 degrees\"};function h(n){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given an \",(0,t.jsx)(e.code,{children:\"n\"}),\" x \",(0,t.jsx)(e.code,{children:\"n\"}),\" two-dimensional array \",(0,t.jsx)(e.code,{children:\"matrix\"}),\", rotate the matrix 90 degrees clockwise in-place. This means the input two-dimensional matrix should be modified directly without using any additional 2D matrices.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"matrix: number[][]\"}),\": A 2D array \",(0,t.jsx)(e.code,{children:\"matrix\"}),\" of size \",(0,t.jsx)(e.code,{children:\"n\"}),\" x \",(0,t.jsx)(e.code,{children:\"n\"})]}),`\n`]}),`\n`,(0,t.jsx)(s,{testCases:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.code,{children:\"n = matrix.length = matrix[i].length\"})}),`\n`,(0,t.jsxs)(e.li,{children:[\"1 <= \",(0,t.jsx)(e.code,{children:\"n\"}),\" <= 20\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"-1000 <= \",(0,t.jsx)(e.code,{children:\"matrix[row][col]\"}),\" <= 1000\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Use O(1) extra space\"}),`\n`]})]})}function M(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var b=M;return _(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to rotate the given matrix by 90 degrees",
    "title": "Matrix Rotation"
  },
  "solution": "var Component=(()=>{var f=Object.create;var r=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty;var y=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),v=(i,e)=>{for(var n in e)r(i,n,{get:e[n],enumerable:!0})},a=(i,e,n,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of u(e))!j.call(i,o)&&o!==n&&r(i,o,{get:()=>e[o],enumerable:!(h=g(e,o))||h.enumerable});return i};var w=(i,e,n)=>(n=i!=null?f(x(i)):{},a(e||!i||!i.__esModule?r(n,\"default\",{value:i,enumerable:!0}):n,i)),T=i=>a(r({},\"__esModule\",{value:!0}),i);var s=y((F,c)=>{c.exports=_jsx_runtime});var O={};v(O,{default:()=>k});var t=w(s());var l=MDXCodeBlock;var m=`export default function matrixRotation(matrix: number[][]): void {\n  // Get the number of rows (or columns) of the matrix\n  let n = matrix.length;\n\n  // Loop through each layer of the matrix\n  // The outer loop goes over each \"layer\" from the outside towards the center\n  for (let i = 0; i < Math.floor((n + 1) / 2); i++) {\n    // The inner loop goes over each element in the layer\n    for (let j = 0; j < Math.floor(n / 2); j++) {\n      // Store the value of the top-left element temporarily\n      let temp = matrix[n - 1 - j][i];\n\n      // Move the bottom-left element to the top-left\n      matrix[n - 1 - j][i] = matrix[n - 1 - i][n - j - 1];\n\n      // Move the bottom-right element to the bottom-left\n      matrix[n - 1 - i][n - j - 1] = matrix[j][n - 1 - i];\n\n      // Move the top-right element to the bottom-right\n      matrix[j][n - 1 - i] = matrix[i][j];\n\n      // Move the stored top-left element to the top-right\n      matrix[i][j] = temp;\n    }\n  }\n}\n`;var d=`export default function matrixRotation(matrix: number[][]): void {\n  // Get the number of rows (or columns) of the matrix\n  const n = matrix.length;\n\n  // Step 1: Transpose the matrix\n  // Transposing involves swapping matrix[i][j] with matrix[j][i]\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n\n  // Step 2: Reflect the matrix horizontally\n  // Reflecting involves swapping elements in each row, from the start to the middle\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n / 2; j++) {\n      [matrix[i][j], matrix[i][n - 1 - j]] = [\n        matrix[i][n - 1 - j],\n        matrix[i][j],\n      ];\n    }\n  }\n}\n`;function p(i){let e=Object.assign({h2:\"h2\",p:\"p\",ul:\"ul\",li:\"li\",h3:\"h3\",ol:\"ol\",code:\"code\",strong:\"strong\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Rotating Group of Four Cells\"}),`\n`,(0,t.jsx)(e.p,{children:\"The task involves rotating a square matrix 90 degrees clockwise in place. This means the transformation must not use additional memory for another matrix. The solution uses a group rotation approach to move values within each layer of the matrix.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The intuition is that for a 90-degree clockwise rotation:\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"The element at the top-left corner moves to the top-right.\"}),`\n`,(0,t.jsx)(e.li,{children:\"The top-right element moves to the bottom-right.\"}),`\n`,(0,t.jsx)(e.li,{children:\"The bottom-right element moves to the bottom-left.\"}),`\n`,(0,t.jsx)(e.li,{children:\"The bottom-left element moves to the top-left.\"}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"This transformation can be achieved by iterating through the matrix layer by layer. Each layer represents a set of nested squares, starting from the outermost layer and moving towards the center. For each layer, elements are swapped in groups of four, effectively performing the rotation without additional memory usage.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Get the size of the matrix \",(0,t.jsx)(e.code,{children:\"n\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through the matrix by layers:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"The outer loop processes each layer from the outside to the center. The number of layers is \",(0,t.jsx)(e.code,{children:\"Math.floor((n + 1) / 2)\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"The inner loop processes the elements within a layer. The number of elements in each layer is determined by \",(0,t.jsx)(e.code,{children:\"Math.floor(n / 2)\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"For each group of four cells in the current layer:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Temporarily store the top-left element.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Move the bottom-left element to the top-left position.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Move the bottom-right element to the bottom-left position.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Move the top-right element to the bottom-right position.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Assign the stored top-left value to the top-right position.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Repeat the process for all layers.\"}),`\n`]}),`\n`,(0,t.jsx)(l,{children:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,t.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". Each element in the matrix is visited once during the layer-wise traversal.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The rotation is performed in place without using additional memory.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Transpose of Matrix\"}),`\n`,(0,t.jsx)(e.p,{children:\"The task involves rotating a square matrix 90 degrees clockwise in place. This transformation can be achieved in two steps: transposing the matrix and then reflecting it horizontally.\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Transpose\"}),\": The transpose operation swaps rows and columns by exchanging the element at position \",(0,t.jsx)(e.code,{children:\"(i, j)\"}),\" with the element at \",(0,t.jsx)(e.code,{children:\"(j, i)\"}),\". This step converts the rows of the original matrix into columns of the resulting matrix.\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[`\n`,(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:\"Reflect horizontally\"}),\": After transposing, reflecting the matrix horizontally swaps elements in each row, exchanging the leftmost elements with the rightmost ones. This completes the 90-degree clockwise rotation.\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:\"This approach efficiently manipulates the matrix in place without requiring additional space for another matrix.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Retrieve the size of the matrix \",(0,t.jsx)(e.code,{children:\"n\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Perform the transpose operation:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through each row \",(0,t.jsx)(e.code,{children:\"i\"}),\" of the matrix.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"For each row, iterate through columns \",(0,t.jsx)(e.code,{children:\"j\"}),\" where \",(0,t.jsx)(e.code,{children:\"j > i\"}),\" to avoid redundant swaps.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Swap the elements at \",(0,t.jsx)(e.code,{children:\"(i, j)\"}),\" and \",(0,t.jsx)(e.code,{children:\"(j, i)\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Perform the horizontal reflection:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Iterate through each row \",(0,t.jsx)(e.code,{children:\"i\"}),\" of the matrix.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"For each row, iterate through the first half of the columns \",(0,t.jsx)(e.code,{children:\"j\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Swap the elements at \",(0,t.jsx)(e.code,{children:\"(i, j)\"}),\" and \",(0,t.jsx)(e.code,{children:\"(i, n-1-j)\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"The matrix is now rotated 90 degrees clockwise.\"}),`\n`]}),`\n`,(0,t.jsx)(l,{children:d}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,t.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". Both the transpose and reflection operations involve visiting each element of the matrix once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The rotation is performed in place without using additional memory.\"]}),`\n`]})]})}function R(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(p,i)})):p(i)}var k=R;return T(O);})();\n;return Component;"
}