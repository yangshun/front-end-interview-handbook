{
  "description": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var T=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},d=(t,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of m(e))!g.call(t,o)&&o!==r&&i(t,o,{get:()=>e[o],enumerable:!(l=f(e,o))||l.enumerable});return t};var w=(t,e,r)=>(r=t!=null?u(x(t)):{},d(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),N=t=>d(i({},\"__esModule\",{value:!0}),t);var h=T((D,a)=>{a.exports=_jsx_runtime});var C={};b(C,{default:()=>v,frontmatter:()=>_});var n=w(h());var c=MDXTestExamples;var s=[{input:[[\"root\",[2,1,3]]],output:[2,3,1],explanation:\"The left and right children are swapped.\"},{input:[[\"root\",[43,null,-55]]],output:[43,-55],explanation:\"The right child becomes the left child after inversion.\"},{input:[[\"root\",[12,8,18,6,null,null,20]]],output:[12,18,8,20,null,null,6],explanation:\"The tree is inverted, with left and right children of each node being swapped.\"}];var _={title:\"Flip Binary Tree\",excerpt:\"Implement a function to flip the nodes in a binary tree\"};function p(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the \",(0,n.jsx)(e.code,{children:\"root\"}),\" node of a binary tree, flip the tree by swapping each node's left and right children, then return the root of the flipped tree.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"root: TreeNode\"}),\": Root node of the tree. Examples display a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 100\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"-100 <= \",(0,n.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 100\"]}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var v=j;return N(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to flip the nodes in a binary tree",
    "title": "Flip Binary Tree"
  },
  "solution": "var Component=(()=>{var f=Object.create;var l=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),T=(r,e)=>{for(var n in e)l(r,n,{get:e[n],enumerable:!0})},d=(r,e,n,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!y.call(r,i)&&i!==n&&l(r,i,{get:()=>e[i],enumerable:!(h=g(e,i))||h.enumerable});return r};var q=(r,e,n)=>(n=r!=null?f(b(r)):{},d(e||!r||!r.__esModule?l(n,\"default\",{value:r,enumerable:!0}):n,r)),w=r=>d(l({},\"__esModule\",{value:!0}),r);var s=v((j,c)=>{c.exports=_jsx_runtime});var O={};T(O,{default:()=>I});var t=q(s());var o=MDXCodeBlock;var u=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeFlip(root: TreeNode | null): TreeNode | null {\n  // Base case: if the node is null, return null\n  if (root === null) {\n    return null;\n  }\n\n  // Recursively invert the left and right subtrees\n  const right: TreeNode | null = binaryTreeFlip(root.right);\n  const left: TreeNode | null = binaryTreeFlip(root.left);\n\n  // Swap the left and right children of the current node\n  root.left = right;\n  root.right = left;\n\n  // Return the root of the inverted tree\n  return root;\n}\n`;var a=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeFlip(root: TreeNode | null): TreeNode | null {\n  // Base case: if the root is null, return null\n  if (root === null) {\n    return null;\n  }\n\n  // Initialize a queue and add the root node\n  const queue: (TreeNode | null)[] = [];\n  queue.push(root);\n\n  // Iterate while there are nodes in the queue\n  while (queue.length > 0) {\n    // Dequeue the current node\n    const current = queue.shift();\n\n    if (current !== undefined && current !== null) {\n      // Swap the left and right children\n      const temp = current.left;\n      current.left = current.right;\n      current.right = temp;\n\n      // If the left child exists, add it to the queue\n      if (current.left !== null) {\n        queue.push(current.left);\n      }\n\n      // If the right child exists, add it to the queue\n      if (current.right !== null) {\n        queue.push(current.right);\n      }\n    }\n  }\n\n  // Return the root of the inverted tree\n  return root;\n}\n`;function p(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Recursion\"}),`\n`,(0,t.jsx)(e.p,{children:\"Flipping a binary tree involves swapping the left and right subtrees of every node in the tree. The recursive approach simplifies this by breaking the problem into smaller subproblems for each subtree.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"It begins with a base case: if the current node is \",(0,t.jsx)(e.code,{children:\"null\"}),\", there is nothing to flip, so it returns \",(0,t.jsx)(e.code,{children:\"null\"}),\". For each non-\",(0,t.jsx)(e.code,{children:\"null\"}),\" node, the left and right subtrees are flipped recursively, and their results are stored in temporary variables. After recursion, the left and right children of the current node are swapped. This ensures that all levels of the tree are flipped correctly, and the structure is completely inverted.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Check the base case: if the node is \",(0,t.jsx)(e.code,{children:\"null\"}),\", return \",(0,t.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively call the function on the right subtree and store the result.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively call the function on the left subtree and store the result.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Swap the left and right children of the current node.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Return the current node as the root of the flipped tree.\"}),`\n`]}),`\n`,(0,t.jsx)(o,{children:u}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node is visited exactly once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The recursion stack uses space proportional to the height of the tree, where \",(0,t.jsx)(e.code,{children:\"h\"}),\" is the height of the tree.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Iteration\"}),`\n`,(0,t.jsx)(e.p,{children:\"Flipping a binary tree involves swapping the left and right subtrees for every node. The iterative approach uses a queue to traverse the tree level by level, ensuring that all nodes are processed. This method avoids recursion, making it a good alternative when dealing with deep trees to prevent stack overflow.\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The iterative approach begins with a base case where an empty tree (\",(0,t.jsx)(e.code,{children:\"null\"}),\" root) directly returns \",(0,t.jsx)(e.code,{children:\"null\"}),\". A queue is initialized with the root node, and a breadth-first traversal is performed. At each step, the left and right children of the current node are swapped. If the swapped children are not \",(0,t.jsx)(e.code,{children:\"null\"}),\", they are added to the queue for subsequent processing. The process continues until the queue is empty, ensuring that all nodes in the tree are flipped.\"]}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Handle the base case by returning \",(0,t.jsx)(e.code,{children:\"null\"}),\" if the root is \",(0,t.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Initialize a queue and add the root node.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"While the queue is not empty:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Dequeue a node and swap its left and right children.\"}),`\n`,(0,t.jsx)(e.li,{children:\"If the left child exists, enqueue it.\"}),`\n`,(0,t.jsx)(e.li,{children:\"If the right child exists, enqueue it.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Return the root of the inverted tree.\"}),`\n`]}),`\n`,(0,t.jsx)(o,{children:a}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node in the tree is processed exactly once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The queue may store up to \",(0,t.jsx)(e.code,{children:\"n\"}),\" nodes in the worst case, proportional to the breadth of the tree at its widest level.\"]}),`\n`]})]})}function F(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(p,r)})):p(r)}var I=F;return w(O);})();\n;return Component;"
}