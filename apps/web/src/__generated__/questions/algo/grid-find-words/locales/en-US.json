{
  "description": "var Component=(()=>{var g=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var w=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),x=(r,e)=>{for(var d in e)i(r,d,{get:e[d],enumerable:!0})},o=(r,e,d,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of u(e))!p.call(r,c)&&c!==d&&i(r,c,{get:()=>e[c],enumerable:!(t=m(e,c))||t.enumerable});return r};var y=(r,e,d)=>(d=r!=null?g(b(r)):{},o(e||!r||!r.__esModule?i(d,\"default\",{value:r,enumerable:!0}):d,r)),j=r=>o(i({},\"__esModule\",{value:!0}),r);var a=w((M,l)=>{l.exports=_jsx_runtime});var C={};x(C,{default:()=>E,frontmatter:()=>z});var n=y(a());var s=MDXTestExamples;var h=[{input:[[\"grid\",[[\"e\",\"e\",\"d\",\"f\",\"a\",\"e\"],[\"b\",\"f\",\"f\",\"b\",\"a\",\"a\"],[\"c\",\"e\",\"f\",\"e\",\"e\",\"d\"],[\"d\",\"d\",\"c\",\"f\",\"c\",\"d\"],[\"a\",\"e\",\"f\",\"e\",\"d\",\"d\"],[\"f\",\"f\",\"e\",\"b\",\"d\",\"c\"]]],[\"words\",[\"acd\",\"cbbc\",\"fb\",\"efdc\"]]],output:[\"fb\"],explanation:\"The word 'fb' can be formed from adjacent cells on the grid, while others cannot.\"},{input:[[\"grid\",[[\"a\",\"b\",\"c\"],[\"s\",\"f\",\"c\"],[\"d\",\"a\",\"f\"]]],[\"words\",[\"abc\",\"bcd\",\"cfa\",\"sfa\"]]],output:[\"abc\",\"cfa\",\"sfa\"],explanation:\"The words 'abc' and 'cfa' can be formed from adjacent cells on the grid.\"},{input:[[\"grid\",[[\"x\",\"y\",\"z\"],[\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"]]],[\"words\",[\"xyz\",\"abc\",\"def\",\"xzy\"]]],output:[\"xyz\",\"abc\",\"def\"],explanation:\"The words 'xyz', 'abc', and 'def' can be formed from adjacent cells on the grid.\"}];var z={title:\"Find Words in Grid\",excerpt:\"Implement a function to find all the words present in the grid\"};function f(r){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a grid of characters \",(0,n.jsx)(e.code,{children:\"grid\"}),\" with dimensions \",(0,n.jsx)(e.code,{children:\"m x n\"}),\" and a list of strings, \",(0,n.jsx)(e.code,{children:\"words\"}),\", find all the words present on the grid.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The word can be formed by traveling through adjacent cells, where adjacent cells are those directly next to each other either horizontally or vertically. Each cell in the grid can only be used once for forming the word.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The result can be returned in any order.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"grid: string[][]\"}),\": A 2D array of size \",(0,n.jsx)(e.code,{children:\"m x n\"}),\", where each element is a lowercase English letter\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"words: string[]\"}),\": A list of strings to be searched for in the grid\"]}),`\n`]}),`\n`,(0,n.jsx)(s,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"m == grid.length\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"n = grid[i].length\"})}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"m\"}),\", \",(0,n.jsx)(e.code,{children:\"n\"}),\" <= 12\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"words.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"words[i].length\"}),\" <= 10\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Both \",(0,n.jsx)(e.code,{children:\"grid\"}),\" and \",(0,n.jsx)(e.code,{children:\"words[i]\"}),\" consist only of lowercase English letters\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Each word in the \",(0,n.jsx)(e.code,{children:\"words\"}),\" list is unique\"]}),`\n`]})]})}function _(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(f,r)})):f(r)}var E=_;return j(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find all the words present in the grid",
    "title": "Find Words in Grid"
  },
  "solution": "var Component=(()=>{var g=Object.create;var o=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),k=(t,e)=>{for(var n in e)o(t,n,{get:e[n],enumerable:!0})},c=(t,e,n,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!m.call(t,i)&&i!==n&&o(t,i,{get:()=>e[i],enumerable:!(l=w(e,i))||l.enumerable});return t};var x=(t,e,n)=>(n=t!=null?g(p(t)):{},c(e||!t||!t.__esModule?o(n,\"default\",{value:t,enumerable:!0}):n,t)),v=t=>c(o({},\"__esModule\",{value:!0}),t);var a=b((O,d)=>{d.exports=_jsx_runtime});var N={};k(N,{default:()=>C});var r=x(a());var s=MDXCodeBlock;var h=`class TrieNode {\n  // Map to hold child nodes\n  children: Map<string, TrieNode> = new Map();\n  // To store the word at the end of the Trie path\n  word: string = '';\n\n  constructor() {}\n}\n\n// Helper function to perform backtracking on the grid\nfunction backtracking(\n  row: number,\n  col: number,\n  board: string[][],\n  parent: TrieNode,\n  result: string[],\n) {\n  const letter = board[row][col];\n  const currNode = parent.children.get(letter)!;\n\n  // Check if the current node represents a word\n  if (currNode.word !== '') {\n    result.push(currNode.word);\n    currNode.word = ''; // Prevent duplicate entries\n  }\n\n  // Mark the current cell as visited\n  board[row][col] = '#';\n\n  // Explore neighboring cells: up, right, down, left\n  const rowOffset = [-1, 0, 1, 0];\n  const colOffset = [0, 1, 0, -1];\n  for (let i = 0; i < 4; i++) {\n    const newRow = row + rowOffset[i];\n    const newCol = col + colOffset[i];\n    if (\n      newRow < 0 ||\n      newRow >= board.length ||\n      newCol < 0 ||\n      newCol >= board[0].length\n    ) {\n      continue;\n    }\n    if (currNode.children.has(board[newRow][newCol])) {\n      backtracking(newRow, newCol, board, currNode, result);\n    }\n  }\n\n  // Restore the original letter in the board\n  board[row][col] = letter;\n\n  // Optimization: remove leaf nodes\n  if (currNode.children.size === 0) {\n    parent.children.delete(letter);\n  }\n}\n\n// Main function to find words in the grid\nexport default function findWordsInGrid(\n  grid: string[][],\n  words: string[],\n): string[] {\n  // Step 1: Construct the Trie\n  const root = new TrieNode();\n  for (const word of words) {\n    let node = root;\n    for (const letter of word) {\n      if (!node.children.has(letter)) {\n        node.children.set(letter, new TrieNode());\n      }\n      node = node.children.get(letter)!;\n    }\n    node.word = word; // Store words in Trie\n  }\n\n  const result: string[] = [];\n\n  // Step 2: Backtracking starting from each cell in the grid\n  for (let row = 0; row < grid.length; row++) {\n    for (let col = 0; col < grid[row].length; col++) {\n      if (root.children.has(grid[row][col])) {\n        backtracking(row, col, grid, root, result);\n      }\n    }\n  }\n\n  return result;\n}\n`;function f(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Using Backtracking with tries\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"The task is to find all words from a given list (\",(0,r.jsx)(e.code,{children:\"words\"}),\") that exist in a 2D grid. Words can be formed by sequentially adjacent cells moving up, down, left, or right. Each cell can only be used once per word.\"]}),`\n`,(0,r.jsx)(e.p,{children:\"This solution uses a trie (prefix tree) combined with backtracking for efficient word lookup and validation. The trie allows fast prefix matching, enabling the algorithm to abandon invalid paths early. Each word from the list is stored in the trie, with each path representing a possible word. During backtracking, the algorithm explores all possible paths starting from each grid cell, checking against the trie to verify valid prefixes. Words are recorded when a complete word in the trie is matched.\"}),`\n`,(0,r.jsx)(e.p,{children:\"This approach minimizes redundant checks and efficiently prunes invalid paths, significantly improving performance compared to brute-force methods.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Construct a trie to store the given \",(0,r.jsx)(e.code,{children:\"words\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Initialize the trie with a root node.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"For each word in \",(0,r.jsx)(e.code,{children:\"words\"}),\", traverse the trie, adding a new node for each character if it doesn't already exist.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Mark the end of each word in the trie by storing the word in the corresponding node.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Define a \",(0,r.jsx)(e.code,{children:\"backtracking\"}),\" function to explore paths in the grid:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Check if the current node in the trie represents a complete word. If so, add the word to the result list and mark it as used to avoid duplicates.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Temporarily mark the current grid cell as visited by changing its value.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"Explore all adjacent cells (up, down, left, right) and recursively call the \",(0,r.jsx)(e.code,{children:\"backtracking\"}),\" function if the corresponding character exists in the trie.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Restore the grid cell's value after exploring all neighbors.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Remove leaf nodes from the trie for optimization if no further paths are possible.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate through each cell in the grid:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"If the cell's character exists as a child of the root node in the trie, initiate a backtracking search from that cell.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.li,{children:\"Return the list of matched words.\"}),`\n`]}),`\n`,(0,r.jsx)(s,{children:h}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsxs)(e.strong,{children:[\"Time complexity: O(m.n.4.3\",(0,r.jsx)(\"sup\",{children:\"l-1\"}),\")\"]}),\". The algorithm iterates over all \",(0,r.jsx)(e.code,{children:\"m.n\"}),\" cells, exploring up to 4.3\",(0,r.jsx)(\"sup\",{children:\"l-1\"}),\" paths per cell in the worst case. This occurs when all paths are valid, such as a board filled with the same letter and a dictionary containing a single long word. Optimizations like removing matched nodes from the trie can reduce backtracking costs once all words are found.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(l)\"}),\", where \",(0,r.jsx)(e.code,{children:\"l\"}),\" is the total number of letters in the dictionary. The trie uses \",(0,r.jsx)(e.code,{children:\"l\"}),\" space, or \",(0,r.jsx)(e.code,{children:\"2.l\"}),\" if the words are also stored. In the worst case, each letter has its own node due to no shared prefixes.\"]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(f,t)})):f(t)}var C=T;return v(N);})();\n;return Component;"
}