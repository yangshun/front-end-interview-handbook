{
  "description": "var Component=(()=>{var f=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var g=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),T=(o,e)=>{for(var n in e)i(o,n,{get:e[n],enumerable:!0})},d=(o,e,n,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!x.call(o,r)&&r!==n&&i(o,r,{get:()=>e[r],enumerable:!(s=p(e,r))||s.enumerable});return o};var R=(o,e,n)=>(n=o!=null?f(m(o)):{},d(e||!o||!o.__esModule?i(n,\"default\",{value:o,enumerable:!0}):n,o)),w=o=>d(i({},\"__esModule\",{value:!0}),o);var c=g((k,l)=>{l.exports=_jsx_runtime});var j={};T(j,{default:()=>_,frontmatter:()=>N});var t=R(c());var a=MDXTestExamples;var h=[{input:[[\"root\",[1,2,3]],[\"subRoot\",[1,2]]],output:!1,explanation:\"SubRoot cannot be a subtree since the root node structure differs.\"},{input:[[\"root\",[12,8,6,3,5]],[\"subRoot\",[8,3,5]]],output:!0,explanation:\"The subtree rooted at node 8 matches subRoot.\"},{input:[[\"root\",[5,4,8,11,null,13,4,7,2,null,null,null,null,5,1]],[\"subRoot\",[11,7,2,5,1]]],output:!0,explanation:\"The subtree rooted at node 11 matches subRoot.\"}];var N={title:\"Binary Tree Subtree\",excerpt:\"Implement a function to check if a binary tree is a subtree of another binary tree\"};function u(o){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",ol:\"ol\",li:\"li\",strong:\"strong\",h3:\"h3\",ul:\"ul\",a:\"a\"},o.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given the roots of two binary trees, \",(0,t.jsx)(e.code,{children:\"root\"}),\" and \",(0,t.jsx)(e.code,{children:\"subRoot\"}),\", determine whether \",(0,t.jsx)(e.code,{children:\"subRoot\"}),\" is a subtree of \",(0,t.jsx)(e.code,{children:\"root\"}),\". The function should return \",(0,t.jsx)(e.code,{children:\"true\"}),\" if there exists a subtree within \",(0,t.jsx)(e.code,{children:\"root\"}),\" that has the same structure and node values as \",(0,t.jsx)(e.code,{children:\"subRoot\"}),\". If no such subtree exists, return \",(0,t.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,t.jsx)(e.code,{children:\"left\"}),\" and \",(0,t.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,t.jsx)(e.p,{children:\"A subtree of a binary tree is defined as a portion of the tree that consists of a node and all its descendants. Subtrees have the following properties:\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Matching structure\"}),\": For \",(0,t.jsx)(e.code,{children:\"subRoot\"}),\" to be a subtree of \",(0,t.jsx)(e.code,{children:\"root\"}),\", the nodes in \",(0,t.jsx)(e.code,{children:\"subRoot\"}),\" must match the nodes in the corresponding portion of \",(0,t.jsx)(e.code,{children:\"root\"}),\" both in value and structure.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Self-containment\"}),\": A tree is always considered a subtree of itself.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"root: TreeNode\"}),\": Root node of the tree. Examples display a \",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"subRoot: TreeNode\"}),\": Root node of the subtree. Examples display a \",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`]}),`\n`,(0,t.jsx)(a,{testCases:h}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"1 <= Number of nodes <= 100\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"-10,000 <= \",(0,t.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 10,000\"]}),`\n`]})]})}function v(o={}){let{wrapper:e}=o.components||{};return e?(0,t.jsx)(e,Object.assign({},o,{children:(0,t.jsx)(u,o)})):u(o)}var _=v;return w(j);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to check if a binary tree is a subtree of another binary tree",
    "title": "Binary Tree Subtree"
  },
  "solution": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var y=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),T=(r,e)=>{for(var n in e)o(r,n,{get:e[n],enumerable:!0})},s=(r,e,n,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!v.call(r,i)&&i!==n&&o(r,i,{get:()=>e[i],enumerable:!(h=b(e,i))||h.enumerable});return r};var R=(r,e,n)=>(n=r!=null?m(g(r)):{},s(e||!r||!r.__esModule?o(n,\"default\",{value:r,enumerable:!0}):n,r)),O=r=>s(o({},\"__esModule\",{value:!0}),r);var c=y((C,a)=>{a.exports=_jsx_runtime});var I={};T(I,{default:()=>A});var t=R(c());var l=MDXCodeBlock;var d=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeSubtree(\n  root: TreeNode | null,\n  subRoot: TreeNode | null,\n): boolean {\n  // If 'root' is null, it means there is no tree to check against 'subRoot'\n  // As per the constraints, 'subRoot' will always be non-null\n  if (root === null) {\n    return false;\n  }\n\n  // Check if the tree rooted at 'root' is identical to the tree rooted at 'subRoot'\n  if (isIdentical(root, subRoot)) {\n    return true;\n  }\n\n  // Recursively check the left and right subtrees of 'root'\n  // If either subtree is identical to 'subRoot', return true\n  return (\n    binaryTreeSubtree(root.left, subRoot) ||\n    binaryTreeSubtree(root.right, subRoot)\n  );\n}\n\nfunction isIdentical(node1: TreeNode | null, node2: TreeNode | null): boolean {\n  // If either of the nodes is null, they are identical only if both are null\n  if (node1 === null || node2 === null) {\n    return node1 === null && node2 === null;\n  }\n\n  // If both nodes are non-null, check:\n  // 1. Their values are equal\n  // 2. Their left subtrees are identical\n  // 3. Their right subtrees are identical\n  return (\n    node1.val === node2.val &&\n    isIdentical(node1.left, node2.left) &&\n    isIdentical(node1.right, node2.right)\n  );\n}\n`;var u=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\n// Constants for hashing\nconst MOD_1 = 1000000007;\nconst MOD_2 = 2147483647;\n\n// Vector to store hashed values of each node\nlet memo: Array<[number, number]> = [];\n\nfunction hashSubtreeAtNode(\n  node: TreeNode | null,\n  needToAdd: boolean,\n): [number, number] {\n  if (node === null) {\n    return [3, 7]; // Base case for null nodes\n  }\n\n  // Recursively hash the left and right subtrees\n  const left = hashSubtreeAtNode(node.left, needToAdd);\n  const right = hashSubtreeAtNode(node.right, needToAdd);\n\n  // Compute the hash values for the current node\n  const left1 = (left[0] << 5) % MOD_1;\n  const right1 = (right[0] << 1) % MOD_1;\n  const left2 = (left[1] << 7) % MOD_2;\n  const right2 = (right[1] << 1) % MOD_2;\n\n  const hashpair: [number, number] = [\n    (left1 + right1 + node.val) % MOD_1,\n    (left2 + right2 + node.val) % MOD_2,\n  ];\n\n  // If \\`needToAdd\\` is true, add the hashpair to the memo array\n  if (needToAdd) {\n    memo.push(hashpair);\n  }\n\n  return hashpair;\n}\n\nexport default function binaryTreeSubtree(\n  root: TreeNode | null,\n  subRoot: TreeNode | null,\n): boolean {\n  // Clear the memo array before starting\n  memo = [];\n\n  // Hash the entire tree rooted at \\`root\\` and store the hashes\n  hashSubtreeAtNode(root, true);\n\n  // Hash the tree rooted at \\`subRoot\\` without storing the hash\n  const s = hashSubtreeAtNode(subRoot, false);\n\n  // Check if the hash of \\`subRoot\\` exists in the memo array\n  return memo.some((hash) => hash[0] === s[0] && hash[1] === s[1]);\n}\n`;function f(r){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",h4:\"h4\",strong:\"strong\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Recursion\"}),`\n`,(0,t.jsx)(e.p,{children:\"The problem requires determining if one binary tree is a subtree of another. A subtree must match exactly in structure and node values with a part of the larger tree. The challenge lies in efficiently comparing subtrees while avoiding redundant checks.\"}),`\n`,(0,t.jsx)(e.p,{children:\"A brute force solution involves comparing every possible subtree in the larger tree to the smaller tree, but this approach results in significant unnecessary work. To optimize, the solution uses a recursive approach to directly verify if the current subtree matches the given smaller tree.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The intuition is based on reducing the problem into smaller subproblems: if the current subtree does not match, the solution checks the left and right subtrees of the current node. To determine if two trees are identical, a helper function verifies their root values and recursively compares their left and right subtrees. This eliminates the need for unnecessary duplicate comparisons and ensures efficient subtree matching.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Check if \",(0,t.jsx)(e.code,{children:\"root\"}),\" is \",(0,t.jsx)(e.code,{children:\"null\"}),\". If it is, return \",(0,t.jsx)(e.code,{children:\"false\"}),\" because no subtree can be found.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Use a helper function to verify if the current subtree is identical to \",(0,t.jsx)(e.code,{children:\"subRoot\"}),\".\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If identical, return \",(0,t.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively check the left and right subtrees of the current node.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"true\"}),\" if any of the recursive calls find a match; otherwise, return \",(0,t.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(l,{children:d}),`\n`,(0,t.jsxs)(e.h4,{children:[(0,t.jsx)(e.code,{children:\"isIdentical\"}),\" helper function:\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"If either tree is empty, return \",(0,t.jsx)(e.code,{children:\"true\"}),\" only if both are empty.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"If both trees are non-empty:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Compare the values at the root of each tree.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively check if the left subtrees are identical.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively check if the right subtrees are identical.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Return \",(0,t.jsx)(e.code,{children:\"true\"}),\" only if the values and structures match completely.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(m.n)\"}),\". For each node in the larger tree (O(m)), the subtree is compared to the smaller tree (O(n)).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The space used is proportional to the height of the larger tree due to recursive calls.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Hashing\"}),`\n`,(0,t.jsx)(e.p,{children:\"The problem involves determining if one binary tree is a subtree of another. Instead of directly comparing nodes and structures repeatedly, the approach uses hashing to represent subtrees as compact hash values. This eliminates redundant structural comparisons by using the properties of hash functions to detect subtree matches efficiently.\"}),`\n`,(0,t.jsx)(e.p,{children:\"The intuition is to compute unique hash values for each subtree in the larger tree and compare them with the hash of the smaller tree. The subtree hash depends on the node value and the hash values of its left and right children, ensuring uniqueness for different subtree structures. By storing all subtree hashes in a collection, the presence of the smaller tree as a subtree can be checked in constant time for each hash comparison. This avoids repetitive structural checks and improves efficiency.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"Define a helper function \",(0,t.jsx)(e.code,{children:\"hashSubtreeAtNode\"}),\" to compute hash values for a subtree rooted at a given node:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"For a \",(0,t.jsx)(e.code,{children:\"null\"}),\" node, return a predefined base hash value.\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively compute hash values for the left and right subtrees.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Calculate the current node's hash using its value and the hash values of its children, applying modular arithmetic to prevent overflow.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Optionally store the hash value in a global collection if needed.\"}),`\n`]}),`\n`]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Initialize an empty collection \",(0,t.jsx)(e.code,{children:\"memo\"}),\" to store the hash values of all subtrees in the larger tree.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[\"Compute the hash values for the entire larger tree, storing each subtree's hash in the \",(0,t.jsx)(e.code,{children:\"memo\"}),\".\"]}),`\n`,(0,t.jsx)(e.li,{children:\"Compute the hash value for the smaller tree without adding it to the collection.\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"Check if the computed hash of the smaller tree exists in the \",(0,t.jsx)(e.code,{children:\"memo\"}),\" collection. Return \",(0,t.jsx)(e.code,{children:\"true\"}),\" if found; otherwise, return \",(0,t.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`,(0,t.jsx)(l,{children:u}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n + m)\"}),\". The larger tree with \",(0,t.jsx)(e.code,{children:\"n\"}),\" nodes and the smaller tree with \",(0,t.jsx)(e.code,{children:\"m\"}),\" nodes are each traversed once during hashing, resulting in a combined time complexity of O(n + m).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The hash values for all \",(0,t.jsx)(e.code,{children:\"n\"}),\" nodes in the larger tree are stored in the \",(0,t.jsx)(e.code,{children:\"memo\"}),\" collection.\"]}),`\n`]})]})}function k(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(f,r)})):f(r)}var A=k;return O(I);})();\n;return Component;"
}