{
  "description": "var Component=(()=>{var p=Object.create;var s=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),j=(n,e)=>{for(var i in e)s(n,i,{get:e[i],enumerable:!0})},c=(n,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!x.call(n,r)&&r!==i&&s(n,r,{get:()=>e[r],enumerable:!(o=h(e,r))||o.enumerable});return n};var v=(n,e,i)=>(i=n!=null?p(f(n)):{},c(e||!n||!n.__esModule?s(i,\"default\",{value:n,enumerable:!0}):i,n)),_=n=>c(s({},\"__esModule\",{value:!0}),n);var l=g((X,a)=>{a.exports=_jsx_runtime});var A={};j(A,{default:()=>y,frontmatter:()=>M});var t=v(l());var u=MDXTestExamples;var m=[{input:[[\"n\",8]],output:268435456,explanation:\"8 in binary is 00000000000000000000000000001000. After reversing its bits, it becomes 00010000000000000000000000000000, which is 268435456 in decimal.\"},{input:[[\"n\",3]],output:3221225472,explanation:\"3 in binary is 00000000000000000000000000000011. After reversing its bits, it becomes 11000000000000000000000000000000, which is 3221225472 in decimal.\"},{input:[[\"n\",0]],output:0,explanation:\"0 in binary is 00000000000000000000000000000000. After reversing its bits, it becomes 00000000000000000000000000000000, which is 0 in decimal.\"}];var M={title:\"Bit Reversal\",excerpt:\"Implement a function to flip the order of the bits in a given number\"};function d(n){let e=Object.assign({p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\",code:\"code\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"Implement a function that reverses the bit order of a given 32-bit unsigned integer and returns its corresponding decimal representation.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"n: number\"}),\": An integer\"]}),`\n`]}),`\n`,(0,t.jsx)(u,{testCases:m}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[\"0 <= \",(0,t.jsx)(e.code,{children:\"n\"}),\" <= 1,000,000\"]}),`\n`]})]})}function w(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(d,n)})):d(n)}var y=w;return _(A);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to flip the order of the bits in a given number",
    "title": "Bit Reversal"
  },
  "solution": "var Component=(()=>{var u=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var n in e)s(t,n,{get:e[n],enumerable:!0})},a=(t,e,n,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!v.call(t,r)&&r!==n&&s(t,r,{get:()=>e[r],enumerable:!(h=p(e,r))||h.enumerable});return t};var w=(t,e,n)=>(n=t!=null?u(g(t)):{},a(e||!t||!t.__esModule?s(n,\"default\",{value:t,enumerable:!0}):n,t)),S=t=>a(s({},\"__esModule\",{value:!0}),t);var c=y((C,o)=>{o.exports=_jsx_runtime});var R={};x(R,{default:()=>U});var i=w(c());var l=MDXCodeBlock;var d=`export default function bitReversal(n: number): number {\n  // Initialize result as 0\n  let reversed = 0;\n\n  // Iterate over each bit position\n  for (let i = 0; i < 32; i++) {\n    // Extract the least significant bit (LSB)\n    const leastSignificantBit = n & 1;\n\n    // Shift the LSB to the most significant position of the reversed number\n    reversed = (reversed << 1) | leastSignificantBit;\n\n    // Right shift the original number to process the next bit\n    n >>= 1;\n  }\n\n  return reversed >>> 0; // Ensure the result is an unsigned 32-bit integer\n}\n`;var b=`export default function bitReversal(n: number): number {\n  // Swap the left and right halves\n  n = (n >>> 16) | (n << 16);\n  // Swap consecutive bytes\n  n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8);\n  // Swap consecutive 4-bit groups\n  n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4);\n  // Swap consecutive pairs of bits\n  n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2);\n  // Swap individual bits\n  n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1);\n\n  return n >>> 0; // Ensure unsigned 32-bit result\n}\n`;function f(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{children:\"1. Using Mask and Shift Approach\"}),`\n`,(0,i.jsx)(e.p,{children:\"The mask and shift approach for bit reversal uses bitwise operations to efficiently reverse the bits of a 32-bit unsigned integer. The key intuition is that the reversal can be performed hierarchically by swapping progressively smaller groups of bits. Starting with large groups such as 16-bit halves, the algorithm continues swapping smaller groups (bytes, 4-bit nibbles, pairs of bits, and finally individual bits) until all bits are in their reversed positions.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Using bitwise masks ensures that only the relevant bits are manipulated during each step, and shifts (\",(0,i.jsx)(e.code,{children:\">>>\"}),\" for unsigned right shift and \",(0,i.jsx)(e.code,{children:\"<<\"}),\" for left shift) relocate the swapped bits to their correct places. This approach eliminates the need to process each bit individually, making the algorithm highly efficient.\"]}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Swap the left and right 16-bit halves:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Use \",(0,i.jsx)(e.code,{children:\"n >>> 16\"}),\" to shift the right half to the leftmost position.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Use \",(0,i.jsx)(e.code,{children:\"n << 16\"}),\" to shift the left half to the rightmost position.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Combine the results with a bitwise OR operation (\",(0,i.jsx)(e.code,{children:\"|\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Swap consecutive bytes (8 bits):\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Use the mask \",(0,i.jsx)(e.code,{children:\"0xff00ff00\"}),\" to isolate the leftmost and rightmost bytes, and shift them right by 8 bits.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Use the mask \",(0,i.jsx)(e.code,{children:\"0x00ff00ff\"}),\" to isolate the inner bytes, and shift them left by 8 bits.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Combine the results with a bitwise OR operation.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Swap consecutive 4-bit groups (nibbles):\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Use the mask \",(0,i.jsx)(e.code,{children:\"0xf0f0f0f0\"}),\" to isolate the 4-bit groups, and shift them right by 4 bits.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Use the mask \",(0,i.jsx)(e.code,{children:\"0x0f0f0f0f\"}),\" to isolate the other groups, and shift them left by 4 bits.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Combine the results with a bitwise OR operation.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Swap consecutive pairs of bits:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Use the mask \",(0,i.jsx)(e.code,{children:\"0xcccccccc\"}),\" to isolate pairs of bits, and shift them right by 2 bits.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Use the mask \",(0,i.jsx)(e.code,{children:\"0x33333333\"}),\" to isolate the other pairs, and shift them left by 2 bits.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Combine the results with a bitwise OR operation.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Swap individual bits:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Use the mask \",(0,i.jsx)(e.code,{children:\"0xaaaaaaaa\"}),\" to isolate alternating bits, and shift them right by 1 bit.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Use the mask \",(0,i.jsx)(e.code,{children:\"0x55555555\"}),\" to isolate the other alternating bits, and shift them left by 1 bit.\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Combine the results with a bitwise OR operation.\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Return the final result as an unsigned 32-bit integer using \",(0,i.jsx)(e.code,{children:\">>> 0\"}),\".\"]}),`\n`]}),`\n`,(0,i.jsx)(l,{children:b}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(1)\"}),\". The algorithm performs a constant number of bitwise operations regardless of the input value.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional space is required beyond a few variables to store intermediate results.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{children:\"2. Using bit manipulation\"}),`\n`,(0,i.jsx)(e.p,{children:\"The bit manipulation approach for bit reversal relies on iterating through all 32 bits of the given integer and reconstructing the reversed bit sequence in a new variable. The key idea is to extract the least significant bit (LSB) of the input number, shift it to its new position in the reversed number, and then move on to the next bit by right-shifting the input number. This process continues until all bits have been reversed.\"}),`\n`,(0,i.jsx)(e.p,{children:\"The reversed bits are progressively built by left-shifting the reversed number and appending the extracted bit at each step. The approach ensures correctness and efficiency by manipulating individual bits directly.\"}),`\n`,(0,i.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Initialize a variable \",(0,i.jsx)(e.code,{children:\"reversed\"}),\" to \",(0,i.jsx)(e.code,{children:\"0\"}),\" to store the reversed bit sequence.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Loop 32 times to process each bit of the input number:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Extract the least significant bit (LSB) of the number using \",(0,i.jsx)(e.code,{children:\"n & 1\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Shift \",(0,i.jsx)(e.code,{children:\"reversed\"}),\" left by one position and append the LSB using the bitwise OR operation (\",(0,i.jsx)(e.code,{children:\"|\"}),\").\"]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Right shift the input number (\",(0,i.jsx)(e.code,{children:\"n\"}),\") by one position to process the next bit.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[\"Return the \",(0,i.jsx)(e.code,{children:\"reversed\"}),\" value as an unsigned 32-bit integer using \",(0,i.jsx)(e.code,{children:\">>> 0\"}),\".\"]}),`\n`]}),`\n`,(0,i.jsx)(l,{children:d}),`\n`,(0,i.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Time complexity: O(1)\"}),\". The algorithm processes a fixed number of 32 bits, so the runtime does not depend on the input size.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional space is used beyond a few variables to store intermediate results.\"]}),`\n`]})]})}function B(t={}){let{wrapper:e}=t.components||{};return e?(0,i.jsx)(e,Object.assign({},t,{children:(0,i.jsx)(f,t)})):f(t)}var U=B;return S(R);})();\n;return Component;"
}