{
  "description": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var T=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var n in e)o(r,n,{get:e[n],enumerable:!0})},i=(r,e,n,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of v(e))!x.call(r,l)&&l!==n&&o(r,l,{get:()=>e[l],enumerable:!(a=f(e,l))||a.enumerable});return r};var w=(r,e,n)=>(n=r!=null?u(m(r)):{},i(e||!r||!r.__esModule?o(n,\"default\",{value:r,enumerable:!0}):n,r)),y=r=>i(o({},\"__esModule\",{value:!0}),r);var d=T((D,h)=>{h.exports=_jsx_runtime});var C={};g(C,{default:()=>j,frontmatter:()=>b});var t=w(d());var s=MDXTestExamples;var c=[{input:[[\"root\",[13,null,-55]]],output:[[13],[-55]],explanation:\"The root has two levels: the first level with the value 13, and the second level with the value -55.\"},{input:[[\"root\",[1,2,3,4,5,6,7]]],output:[[1],[2,3],[4,5,6,7]],explanation:\"The tree has three levels: [1] at the first level, [2, 3] at the second level, and [4, 5, 6, 7] at the third level.\"},{input:[[\"root\",[5,3,8,null,4,7,9]]],output:[[5],[3,8],[4,7,9]],explanation:\"The tree has three levels: [5] at the first level, [3, 8] at the second level, and [4, 7, 9] at the third level.\"}];var b={title:\"Binary Tree Level Order Traversal\",excerpt:\"Implement a function to find the level order traversal of a binary tree\"};function p(r){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"Given the \",(0,t.jsx)(e.code,{children:\"root\"}),\" node of a binary tree, return an array of arrays, where each inner array represents the values of nodes at each level of the tree, traversed from left to right.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,t.jsx)(e.code,{children:\"left\"}),\" and \",(0,t.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"A \",(0,t.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"root: TreeNode\"}),\": Root node of the tree. Examples display a \",(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`]}),`\n`,(0,t.jsx)(s,{testCases:c}),`\n`,(0,t.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"1 <= Number of nodes <= 10,000\"}),`\n`,(0,t.jsxs)(e.li,{children:[\"-100 <= \",(0,t.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 100\"]}),`\n`]})]})}function _(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(p,r)})):p(r)}var j=_;return y(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the level order traversal of a binary tree",
    "title": "Binary Tree Level Order Traversal"
  },
  "solution": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),T=(r,e)=>{for(var n in e)i(r,n,{get:e[n],enumerable:!0})},h=(r,e,n,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!y.call(r,l)&&l!==n&&i(r,l,{get:()=>e[l],enumerable:!(a=f(e,l))||a.enumerable});return r};var x=(r,e,n)=>(n=r!=null?p(g(r)):{},h(e||!r||!r.__esModule?i(n,\"default\",{value:r,enumerable:!0}):n,r)),q=r=>h(i({},\"__esModule\",{value:!0}),r);var d=b((C,s)=>{s.exports=_jsx_runtime});var A={};T(A,{default:()=>I});var t=x(d());var o=MDXCodeBlock;var u=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeLevelOrderTraversal(\n  root: TreeNode | null,\n): number[][] {\n  // Initialize an array to hold the values at each level of the tree\n  let levels: number[][] = [];\n\n  // Helper function to traverse the tree\n  function helper(node: TreeNode, level: number) {\n    // If we're visiting a new level for the first time, add an empty array for that level\n    if (levels.length === level) {\n      levels.push([]);\n    }\n\n    // Add the current node's value to the corresponding level array\n    levels[level].push(node.val);\n\n    // Recursively traverse the left subtree, if it exists, and increment the level\n    if (node.left !== null) {\n      helper(node.left, level + 1);\n    }\n\n    // Recursively traverse the right subtree, if it exists, and increment the level\n    if (node.right !== null) {\n      helper(node.right, level + 1);\n    }\n  }\n\n  // Start the traversal from the root node at level 0\n  if (root !== null) {\n    helper(root, 0);\n  }\n\n  // Return the array of levels, each containing the node values at that level\n  return levels;\n}\n`;var c=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeLevelOrderTraversal(\n  root: TreeNode | null,\n): number[][] {\n  // Initialize an array to store levels of the tree\n  let levels: number[][] = [];\n\n  // If the root is null, return the empty levels array\n  if (!root) {\n    return levels;\n  }\n\n  // Initialize a queue with the root node\n  let queue: TreeNode[] = [root];\n\n  // Initialize the level counter\n  let level: number = 0;\n\n  // Iterate while there are nodes in the queue\n  while (queue.length) {\n    // Start the current level by adding an empty array\n    levels.push([]);\n\n    // Number of nodes in the current level\n    let levelCount: number = queue.length;\n\n    // Process all nodes at the current level\n    for (let i = 0; i < levelCount; i++) {\n      // Dequeue the first node in the queue\n      let node: TreeNode | undefined = queue.shift();\n\n      // Add the node's value to the current level\n      if (node) {\n        levels[level].push(node.val);\n      }\n\n      // Add the node's children to the queue for the next level\n      if (node?.left) {\n        queue.push(node.left);\n      }\n      if (node?.right) {\n        queue.push(node.right);\n      }\n    }\n\n    // Move on to the next level\n    level++;\n  }\n\n  // Return the array of levels\n  return levels;\n}\n`;function v(r){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\",code:\"code\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"1. Using Recursion\"}),`\n`,(0,t.jsx)(e.p,{children:\"The recursive approach groups nodes in a binary tree by their depth level. Each level is represented as an array, and all nodes at the same depth are stored together. The traversal starts from the root and proceeds level by level, ensuring that the hierarchical structure of the tree is preserved. Whenever a new level is reached, a new group is initialized to accommodate the nodes at that depth. This ensures that nodes are grouped efficiently, maintaining a clear distinction between levels of the tree.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Traverse the tree starting from the root, keeping track of the current depth level.\"}),`\n`,(0,t.jsx)(e.li,{children:\"For each level encountered for the first time, initialize a new group to store node values.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Add each node's value to the corresponding group based on its depth level.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Recursively process the left and right children, incrementing the level as the traversal moves deeper into the tree.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Continue until all nodes have been processed and grouped by level.\"}),`\n`]}),`\n`,(0,t.jsx)(o,{children:u}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Every node in the tree is visited exactly once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The space used by the recursion stack is proportional to the height of the tree, \",(0,t.jsx)(e.code,{children:\"h\"}),\", and additional space is used to store the level groups.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"2. Using Iteration\"}),`\n`,(0,t.jsx)(e.p,{children:\"The iterative approach groups nodes in a binary tree by their depth level using a queue. The traversal starts from the root and processes each level separately. At each level, all nodes are dequeued, their values are stored in a group corresponding to the current level, and their children are enqueued for the next iteration. This ensures all nodes at the same depth are processed together before moving to the next level. The approach efficiently handles all nodes in a breadth-first manner, maintaining the hierarchical structure of the tree.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Initialize a queue with the root node to process levels iteratively.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Use a loop to process nodes level by level until the queue is empty.\"}),`\n`,(0,t.jsx)(e.li,{children:\"At each level, track the number of nodes to process and initialize a new group for storing their values.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Dequeue each node at the current level, add its value to the group, and enqueue its left and right children (if they exist).\"}),`\n`,(0,t.jsx)(e.li,{children:\"Append the group of values to the result and proceed to the next level.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Continue until all nodes have been processed and grouped by depth.\"}),`\n`]}),`\n`,(0,t.jsx)(o,{children:c}),`\n`,(0,t.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node is visited exactly once.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Space complexity: O(m)\"}),\". The queue holds nodes at the current level, where \",(0,t.jsx)(e.code,{children:\"m\"}),\" is the maximum number of nodes at any level (equal to the width of the tree).\"]}),`\n`]})]})}function O(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(v,r)})):v(r)}var I=O;return q(A);})();\n;return Component;"
}