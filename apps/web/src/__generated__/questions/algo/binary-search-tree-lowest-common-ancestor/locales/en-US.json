{
  "description": "var Component=(()=>{var f=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var T=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var o in e)i(t,o,{get:e[o],enumerable:!0})},l=(t,e,o,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!x.call(t,r)&&r!==o&&i(t,r,{get:()=>e[r],enumerable:!(d=u(e,r))||d.enumerable});return t};var C=(t,e,o)=>(o=t!=null?f(T(t)):{},l(e||!t||!t.__esModule?i(o,\"default\",{value:t,enumerable:!0}):o,t)),N=t=>l(i({},\"__esModule\",{value:!0}),t);var c=b((_,h)=>{h.exports=_jsx_runtime});var v={};w(v,{default:()=>L,frontmatter:()=>A});var n=C(c());var a=MDXTestExamples;var s=[{input:[[\"root\",[3,1,7,null,2,6,10]],[\"a\",7],[\"b\",6]],output:7,explanation:\"The LCA of nodes 7 and 6 is 7 because 7 is the ancestor of 6.\"},{input:[[\"root\",[5,3,8,2,4,7,9]],[\"a\",3],[\"b\",9]],output:5,explanation:\"The LCA of nodes 3 and 9 is 5, which is the root of the tree.\"},{input:[[\"root\",[7,3,10,2,5,8,12]],[\"a\",8],[\"b\",12]],output:10,explanation:\"The LCA of nodes 8 and 12 is 10, which is the parent of both nodes.\"}];var A={title:\"Binary Search Tree Lowest Common Ancestor\",excerpt:\"Implement a function to find the LCA in a binary search tree\"};function p(t){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the \",(0,n.jsx)(e.code,{children:\"root\"}),\" of a Binary Search Tree (BST), identify the lowest common ancestor (LCA) of two specified nodes within the tree.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The LCA is the lowest node in the tree that has both of the given nodes as descendants. A node can be considered a descendant of itself, following the standard definition of LCA.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"root: TreeNode\"}),\": Root node of the tree. Examples display a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"a: TreeNode\"}),\": The first tree node. Examples display the node's value\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"b: TreeNode\"}),\": The second tree node. Examples display the node's value\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Output\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"A \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\" object which is the LCA of \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"})]}),`\n`]}),`\n`,(0,n.jsx)(a,{testCases:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 1000\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 1,000,000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" are guaranteed to exist in the BST\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"All \",(0,n.jsx)(e.code,{children:\"TreeNode.val\"}),\" are unique within the tree\"]}),`\n`]})]})}function y(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var L=y;return N(v);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the LCA in a binary search tree",
    "title": "Binary Search Tree Lowest Common Ancestor"
  },
  "solution": "var Component=(()=>{var p=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var V=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),v=(r,e)=>{for(var t in e)l(r,t,{get:e[t],enumerable:!0})},a=(r,e,t,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of b(e))!T.call(r,o)&&o!==t&&l(r,o,{get:()=>e[o],enumerable:!(h=m(e,o))||h.enumerable});return r};var C=(r,e,t)=>(t=r!=null?p(g(r)):{},a(e||!r||!r.__esModule?l(t,\"default\",{value:r,enumerable:!0}):t,r)),A=r=>a(l({},\"__esModule\",{value:!0}),r);var c=V((x,d)=>{d.exports=_jsx_runtime});var L={};v(L,{default:()=>B});var n=C(c());var i=MDXCodeBlock;var s=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function BSTLowestCommonAncestor(\n  root: TreeNode | null,\n  a: TreeNode | null,\n  b: TreeNode | null,\n): TreeNode | null {\n  if (root === null) {\n    return null; // Base case: if the root is null, there's no ancestor\n  }\n\n  // Value of the current node (parent node)\n  const parentVal = root.val;\n\n  // Value of node a\n  const aVal = a!.val;\n\n  // Value of node b\n  const bVal = b!.val;\n\n  // If both a and b are bigger than parent, explore the right subtree\n  if (aVal > parentVal && bVal > parentVal) {\n    return BSTLowestCommonAncestor(root.right, a, b);\n  }\n\n  // If both a and b are smaller than parent, explore the left subtree\n  if (aVal < parentVal && bVal < parentVal) {\n    return BSTLowestCommonAncestor(root.left, a, b);\n  }\n\n  // If one of a or b is on one side and the other is on the opposite side,\n  // the current node is the lowest common ancestor.\n  return root;\n}\n`;var u=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function BSTLowestCommonAncestor(\n  root: TreeNode | null,\n  a: TreeNode,\n  b: TreeNode,\n): TreeNode | null {\n  // Value of a\n  const aVal = a.val;\n\n  // Value of b\n  const bVal = b.val;\n\n  // Start from the root node of the tree\n  let node = root;\n\n  // Traverse the tree\n  while (node !== null) {\n    // Value of the current ancestor/parent node\n    const parentVal = node.val;\n\n    if (aVal > parentVal && bVal > parentVal) {\n      // If both a and b are greater than the parent, move to the right subtree\n      node = node.right;\n    } else if (aVal < parentVal && bVal < parentVal) {\n      // If both a and b are lesser than the parent, move to the left subtree\n      node = node.left;\n    } else {\n      // We have found the split point, i.e., the lowest common ancestor (LCA)\n      return node;\n    }\n  }\n\n  // If the LCA is not found, return null (this case is generally not expected in a BST)\n  return null;\n}\n`;function f(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h3:\"h3\",ol:\"ol\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Recursion\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The problem of finding the lowest common ancestor (LCA) in a binary search tree (BST) uses the ordered properties of the BST. The LCA is the node where one node (\",(0,n.jsx)(e.code,{children:\"a\"}),\") is on one side of the current node and the other node (\",(0,n.jsx)(e.code,{children:\"b\"}),\") is on the opposite side, or the current node itself is one of the nodes being searched for.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"For any node in a BST, all values in the left subtree are smaller, and all values in the right subtree are larger. This property simplifies the process of finding the LCA.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The algorithm checks the values of \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" relative to the current node (\",(0,n.jsx)(e.code,{children:\"root\"}),\").\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"If both values are greater than the current node's value, the LCA must lie in the right subtree.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If both values are smaller, the LCA must lie in the left subtree.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If one value is on the left and the other is on the right (or one of the nodes matches the current node), the current node is the LCA.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The algorithm recursively traverses the tree based on the relative values of \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" until the LCA is found.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check the base case:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"root\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\", return \",(0,n.jsx)(e.code,{children:\"null\"}),\" as there is no ancestor.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Retrieve the values of the current node (\",(0,n.jsx)(e.code,{children:\"parentVal\"}),\"), \",(0,n.jsx)(e.code,{children:\"a\"}),\" (\",(0,n.jsx)(e.code,{children:\"aVal\"}),\"), and \",(0,n.jsx)(e.code,{children:\"b\"}),\" (\",(0,n.jsx)(e.code,{children:\"bVal\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compare \",(0,n.jsx)(e.code,{children:\"aVal\"}),\" and \",(0,n.jsx)(e.code,{children:\"bVal\"}),\" with \",(0,n.jsx)(e.code,{children:\"parentVal\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If both \",(0,n.jsx)(e.code,{children:\"aVal\"}),\" and \",(0,n.jsx)(e.code,{children:\"bVal\"}),\" are greater than \",(0,n.jsx)(e.code,{children:\"parentVal\"}),\", recursively call the function with the right subtree (\",(0,n.jsx)(e.code,{children:\"root.right\"}),\") as the new root.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If both \",(0,n.jsx)(e.code,{children:\"aVal\"}),\" and \",(0,n.jsx)(e.code,{children:\"bVal\"}),\" are smaller than \",(0,n.jsx)(e.code,{children:\"parentVal\"}),\", recursively call the function with the left subtree (\",(0,n.jsx)(e.code,{children:\"root.left\"}),\") as the new root.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If one value is on the left and the other is on the right, or one matches \",(0,n.jsx)(e.code,{children:\"parentVal\"}),\", return the current node (\",(0,n.jsx)(e.code,{children:\"root\"}),\") as the LCA.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(i,{children:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(h)\"}),\". The algorithm traverses the height of the tree, where \",(0,n.jsx)(e.code,{children:\"h\"}),\" is the height of the BST. In a balanced BST, this is O(log n), and in the worst case (unbalanced tree), this is O(n).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The recursion stack requires space proportional to the height of the tree.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Iteration\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The iterative approach for finding the lowest common ancestor (LCA) in a binary search tree (BST) uses the properties of the BST to navigate from the root to the LCA without recursion. The LCA is identified as the node where the paths to two nodes (\",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\") diverge or one of them matches the current node.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"In a BST, all values in the left subtree are smaller than the root, and all values in the right subtree are larger. This property helps in determining the direction of traversal:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If both \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" are smaller than the current node, the LCA lies in the left subtree.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If both \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" are larger than the current node, the LCA lies in the right subtree.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"If one node is on the left and the other is on the right, or one matches the current node, the current node is the LCA.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The algorithm eliminates recursion by iteratively moving the pointer (\",(0,n.jsx)(e.code,{children:\"node\"}),\") based on comparisons, maintaining efficiency and simplicity.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The traversal stops as soon as the LCA is found, avoiding unnecessary operations.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Retrieve the values of \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" (\",(0,n.jsx)(e.code,{children:\"aVal\"}),\" and \",(0,n.jsx)(e.code,{children:\"bVal\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a pointer \",(0,n.jsx)(e.code,{children:\"node\"}),\" to the root of the BST.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Traverse the BST using a \",(0,n.jsx)(e.code,{children:\"while\"}),\" loop until \",(0,n.jsx)(e.code,{children:\"node\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Retrieve the value of the current node (\",(0,n.jsx)(e.code,{children:\"parentVal\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compare \",(0,n.jsx)(e.code,{children:\"aVal\"}),\" and \",(0,n.jsx)(e.code,{children:\"bVal\"}),\" with \",(0,n.jsx)(e.code,{children:\"parentVal\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If both are greater than \",(0,n.jsx)(e.code,{children:\"parentVal\"}),\", move \",(0,n.jsx)(e.code,{children:\"node\"}),\" to the right child (\",(0,n.jsx)(e.code,{children:\"node = node.right\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If both are smaller than \",(0,n.jsx)(e.code,{children:\"parentVal\"}),\", move \",(0,n.jsx)(e.code,{children:\"node\"}),\" to the left child (\",(0,n.jsx)(e.code,{children:\"node = node.left\"}),\").\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Otherwise, the current node is the LCA; return it.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If no LCA is found (edge case), return \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(i,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(h)\"}),\". The algorithm traverses the height of the tree, where \",(0,n.jsx)(e.code,{children:\"h\"}),\" is the height of the BST. In a balanced BST, this is O(log n), and in the worst case (unbalanced tree), this is O(n).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of space as there is no recursion or auxiliary data structures.\"]}),`\n`]})]})}function y(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(f,r)})):f(r)}var B=y;return A(L);})();\n;return Component;"
}