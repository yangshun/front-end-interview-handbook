{
  "description": "var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var u=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var n in e)i(t,n,{get:e[n],enumerable:!0})},s=(t,e,n,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of b(e))!p.call(t,a)&&a!==n&&i(t,a,{get:()=>e[a],enumerable:!(o=d(e,a))||o.enumerable});return t};var y=(t,e,n)=>(n=t!=null?m(g(t)):{},s(e||!t||!t.__esModule?i(n,\"default\",{value:t,enumerable:!0}):n,t)),j=t=>s(i({},\"__esModule\",{value:!0}),t);var h=u((q,l)=>{l.exports=_jsx_runtime});var v={};f(v,{default:()=>_,frontmatter:()=>x});var r=y(h()),x={title:\"Bubble Sort\",excerpt:\"Implement a function that performs a bubble sort\"};function c(t){let e=Object.assign({p:\"p\",h2:\"h2\",pre:\"pre\",code:\"code\",img:\"img\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:\"Implement a function that performs a bubble sort. The function should take in an array of integers and return an array with the integers sorted in ascending order. The input array is modified.\"}),`\n`,(0,r.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`bubbleSort([9, 3, 6, 2, 1, 11]); // [1, 2, 3, 6, 9, 11]\nbubbleSort([12, 16, 14, 1, 2, 3]); // [1, 2, 3, 12, 14, 16]\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Recap\"}),`\n`,(0,r.jsx)(e.p,{children:\"Bubble sort is a simple sorting algorithm which compares and swaps adjacent elements such that after every iteration over the array, one more element will be ordered/correctly placed, starting from the largest.\"}),`\n`,(0,r.jsx)(e.p,{children:\"The algorithm starts by iterating over the array, comparing each adjacent pair of elements and swapping them if the larger one is on the left. This will ensure that after one whole iteration, the largest element in the array will be at the last index.\"}),`\n`,(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:\"/img/questions/bubble-sort/bubble-sort-first-iteration.jpg\",alt:\"Illustration of first iteration of bubble sort algorithm\"})}),`\n`,(0,r.jsx)(e.p,{children:\"The algorithm then continues to iterate over the array and compares adjacent pairs, such that the 2nd largest element will be at the 2nd last index. The comparison of adjacent pairs can ignore the last element as it is already confirmed to be the largest element in the array through the first iteration.\"}),`\n`,(0,r.jsx)(e.p,{children:\"For e.g., continuing from the algorithm above, the algorithm will move onto the 3rd iteration to compare adjacent pairs while ignoring the last and 2nd last element as they are already in the right order/place.\"}),`\n`,(0,r.jsx)(e.p,{children:(0,r.jsx)(e.img,{src:\"/img/questions/bubble-sort/bubble-sort-subsequent-iteration.png\",alt:\"Illustration of subsequent iteration of bubble sort algorithm\"})})]})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(c,t)})):c(t)}var _=w;return j(v);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/bubble-sort\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/bubble-sort.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/bubble-sort.run.test.ts": "import bubbleSort from './bubble-sort';\n\ndescribe('bubbleSort', () => {\n  test('empty', () => {\n    expect(bubbleSort([])).toEqual([]);\n  });\n\n  test('one element', () => {\n    expect(bubbleSort([1])).toEqual([1]);\n  });\n\n  test('two elements', () => {\n    expect(bubbleSort([2, 1])).toEqual([1, 2]);\n    expect(bubbleSort([1, 2])).toEqual([1, 2]);\n  });\n});\n",
    "/src/bubble-sort.submit.test.ts": "import bubbleSort from './bubble-sort';\n\ndescribe('bubbleSort', () => {\n  test('empty', () => {\n    expect(bubbleSort([])).toEqual([]);\n  });\n\n  test('one element', () => {\n    expect(bubbleSort([1])).toEqual([1]);\n  });\n\n  test('two elements', () => {\n    expect(bubbleSort([2, 1])).toEqual([1, 2]);\n    expect(bubbleSort([1, 2])).toEqual([1, 2]);\n  });\n\n  test('more than two elements', () => {\n    expect(bubbleSort([10, 2, 4])).toEqual([2, 4, 10]);\n    expect(bubbleSort([4, 5, 6, 1, 2, 3])).toEqual([1, 2, 3, 4, 5, 6]);\n    expect(bubbleSort([1, 2, 3, 4, 5, 0])).toEqual([0, 1, 2, 3, 4, 5]);\n    expect(bubbleSort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1])).toEqual([\n      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n    ]);\n    expect(bubbleSort([5, 4, 3, 2, 1, 10, 9, 8, 7, 6])).toEqual([\n      1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n    ]);\n    expect(bubbleSort([98322, 3242, 876, -234, 34, 12331])).toEqual([\n      -234, 34, 876, 3242, 12331, 98322,\n    ]);\n  });\n\n  test('duplicate elements', () => {\n    expect(bubbleSort([1, 1])).toEqual([1, 1]);\n    expect(bubbleSort([2, 2, 2])).toEqual([2, 2, 2]);\n    expect(bubbleSort([2, 1, 2])).toEqual([1, 2, 2]);\n    expect(bubbleSort([1, 1, 1, 1, 1, 1])).toEqual([1, 1, 1, 1, 1, 1]);\n    expect(bubbleSort([7, 2, 4, 3, 1, 2])).toEqual([1, 2, 2, 3, 4, 7]);\n  });\n});\n",
    "/src/bubble-sort.ts": "export default function bubbleSort(arr: Array<number>): Array<number> {\n  // Do multiple iterations over the array.\n  for (let i: number = 0; i < arr.length; i++) {\n    // For each iteration, compare every adjacent pairs while ignoring the last i elements that are already sorted.\n    for (let j: number = 0; j < arr.length - i; j++) {\n      // If the left element in the pair is larger than the right one, swap their positions to ensure that elements are sorted ascendingly.\n      if (arr[j] > arr[j + 1]) {\n        let temp: number = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n\n  // Return the sorted array.\n  return arr;\n}\n"
  },
  "metadata": {
    "access": "standard",
    "author": null,
    "companies": [],
    "created": 1745539200,
    "difficulty": "easy",
    "duration": 15,
    "excerpt": "Implement a function that performs a bubble sort",
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/bubble-sort",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [
      "quick-sort"
    ],
    "published": true,
    "ranking": 100,
    "similarQuestions": [
      "insertion-sort",
      "selection-sort"
    ],
    "slug": "bubble-sort",
    "subtitle": null,
    "title": "Bubble Sort",
    "topics": [
      "sorting"
    ]
  },
  "skeleton": {
    "js": "/**\n * @param {Array<number>} arr The input integer array to be sorted.\n * @return {Array<number>}\n */\nexport default function bubbleSort(arr) {\n  throw 'Not implemented!';\n}",
    "ts": "export default function bubbleSort(arr: Array<number>): Array<number> {\n  throw 'Not implemented!';\n}"
  },
  "solution": "var Component=(()=>{var m=Object.create;var i=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var j=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var n in e)i(t,n,{get:e[n],enumerable:!0})},l=(t,e,n,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of g(e))!y.call(t,a)&&a!==n&&i(t,a,{get:()=>e[a],enumerable:!(o=f(e,a))||o.enumerable});return t};var w=(t,e,n)=>(n=t!=null?m(b(t)):{},l(e||!t||!t.__esModule?i(n,\"default\",{value:t,enumerable:!0}):n,t)),v=t=>l(i({},\"__esModule\",{value:!0}),t);var d=j((q,s)=>{s.exports=_jsx_runtime});var D={};x(D,{default:()=>k});var r=w(d());var h=MDXCodeBlock;var c=`/**\n * @param {Array<number>} arr The input integer array to be sorted.\n * @return {Array<number>}\n */\nexport default function bubbleSort(arr) {\n  // Do multiple iterations over the array.\n  for (let i = 0; i < arr.length; i++) {\n    // For each iteration, compare every adjacent pairs while ignoring the last i elements that are already sorted.\n    for (let j = 0; j < arr.length - i; j++) {\n      // If the left element in the pair is larger than the right one, swap their positions to ensure that elements are sorted ascendingly.\n      if (arr[j] > arr[j + 1]) {\n        let temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n\n  // Return the sorted array.\n  return arr;\n}\n`;var u=`export default function bubbleSort(arr: Array<number>): Array<number> {\n  // Do multiple iterations over the array.\n  for (let i: number = 0; i < arr.length; i++) {\n    // For each iteration, compare every adjacent pairs while ignoring the last i elements that are already sorted.\n    for (let j: number = 0; j < arr.length - i; j++) {\n      // If the left element in the pair is larger than the right one, swap their positions to ensure that elements are sorted ascendingly.\n      if (arr[j] > arr[j + 1]) {\n        let temp: number = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n\n  // Return the sorted array.\n  return arr;\n}\n`;function p(t){let e=Object.assign({p:\"p\",h2:\"h2\",ul:\"ul\",li:\"li\",code:\"code\",pre:\"pre\",h3:\"h3\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:\"Bubble sort is a stable, in-place, comparison-based algorithm that works well for small to medium-sized arrays as well as arrays that are partially sorted.\"}),`\n`,(0,r.jsx)(e.h2,{children:\"Clarification questions\"}),`\n`,(0,r.jsx)(e.p,{children:\"If unspecified:\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Should the data be sorted in an ascending or descending order?\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"What kinds of inputs do we need to handle?\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Will it just be an array of integers or should we handle other data types?\"}),`\n`,(0,r.jsx)(e.li,{children:\"Are there a large number of duplicate elements?\"}),`\n`,(0,r.jsx)(e.li,{children:\"How should negative numbers be handled?\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,r.jsx)(e.p,{children:\"Note: This question tackles in-place sorting for an output in ascending order. Refer to the 'Notes' section below on how to handle other cases.\"}),`\n`,(0,r.jsx)(h,{languages:{jsx:c,tsx:u}}),`\n`,(0,r.jsx)(e.h2,{children:\"Edge cases\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Non-integer element input: If the input array comprises of elements of different data types, you may need to return an error or settle for sorting on a best-effort basis, for e.g., only sorting a subset of the input data, or even define custom comparison functions for non-integers.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Single element / Empty input: Either return the original data structure, raise an error, or clarify required handling.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Invalid input: If the input is not an array, consider throwing an error.\"}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If asked to sort in descending order: Just change the comparison to \",(0,r.jsx)(e.code,{children:\"<\"}),\" instead of \",(0,r.jsx)(e.code,{children:\">\"}),\", as per below:\"]}),`\n`]}),`\n`,(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:\"language-js\",children:`if (arr[j] < arr[j + 1])\n`})}),`\n`,(0,r.jsx)(e.h2,{children:\"Big-O analysis\"}),`\n`,(0,r.jsx)(e.p,{children:\"Let's analyze the algorithm's time and space complexity.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Time complexity\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"In the case of bubble sort, the time complexity is O(n\",(0,r.jsx)(\"sup\",{children:\"2\"}),\") as it requires a nested loop structure. The outer loop does multiple iterations over the array and the inner loop iterates over the array to compare each adjacent pairs and swap elements based on their correct order.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Space complexity\"}),`\n`,(0,r.jsx)(e.p,{children:\"The space complexity for bubble sort is O(1), as it does in-place sorting and does not require additional storage proportional to input size.\"})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(p,t)})):p(t)}var k=_;return v(D);})();\n;return Component;",
  "workspace": {
    "main": "/src/bubble-sort.ts",
    "run": "/src/bubble-sort.run.test.ts",
    "submit": "/src/bubble-sort.submit.test.ts"
  }
}