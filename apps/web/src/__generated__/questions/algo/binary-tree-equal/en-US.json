{
  "description": "var Component=(()=>{var p=Object.create;var a=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var w=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),b=(r,e)=>{for(var t in e)a(r,t,{get:e[t],enumerable:!0})},i=(r,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of m(e))!T.call(r,l)&&l!==t&&a(r,l,{get:()=>e[l],enumerable:!(o=f(e,l))||o.enumerable});return r};var v=(r,e,t)=>(t=r!=null?p(x(r)):{},i(e||!r||!r.__esModule?a(t,\"default\",{value:r,enumerable:!0}):t,r)),g=r=>i(a({},\"__esModule\",{value:!0}),r);var h=w((M,d)=>{d.exports=_jsx_runtime});var C={};b(C,{default:()=>j,frontmatter:()=>y});var n=v(h());var s=MDXTestExamples;var c=[{input:[[\"a\",[1,2]],[\"b\",[1,null,2]]],output:!1,explanation:\"The trees differ in the structure.\"},{input:[[\"a\",[3,null,7]],[\"b\",[3,5,7]]],output:!1,explanation:\"The first tree has a null left child, while the second tree has a left child with value 5.\"},{input:[[\"a\",[65,null,17]],[\"b\",[65,null,17]]],output:!0,explanation:\"Both trees have the same structure and node values.\"}];var y={title:\"Binary Tree Equal\",excerpt:\"Implement a function to determine whether two binary trees are equal\"};function u(r){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the root nodes of two binary trees, \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\", determine whether the two trees are equal.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Two binary trees are considered equal if they have the same structure and the corresponding nodes in both trees have the same values.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The binary tree is represented by a collection of \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s, where each node has optional \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\" child nodes, which are also \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"TreeNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"a: TreeNode\"}),\": Root node of the first tree. Examples display a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"b: TreeNode\"}),\": Root node of the second tree. Examples display a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Breadth-first_search\",children:\"level-order traversal\"}),\" of the tree\"]}),`\n`]}),`\n`,(0,n.jsx)(s,{testCases:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"0 <= Number of nodes <= 100\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10,000 <= \",(0,n.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 10,000\"]}),`\n`]})]})}function _(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(u,r)})):u(r)}var j=_;return g(C);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to determine whether two binary trees are equal",
    "title": "Binary Tree Equal"
  },
  "solution": "var Component=(()=>{var b=Object.create;var l=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,T=Object.prototype.hasOwnProperty;var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),y=(r,e)=>{for(var t in e)l(r,t,{get:e[t],enumerable:!0})},a=(r,e,t,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!T.call(r,i)&&i!==t&&l(r,i,{get:()=>e[i],enumerable:!(h=p(e,i))||h.enumerable});return r};var q=(r,e,t)=>(t=r!=null?b(g(r)):{},a(e||!r||!r.__esModule?l(t,\"default\",{value:r,enumerable:!0}):t,r)),I=r=>a(l({},\"__esModule\",{value:!0}),r);var s=v((O,d)=>{d.exports=_jsx_runtime});var E={};y(E,{default:()=>w});var n=q(s());var o=MDXCodeBlock;var c=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeEqual(\n  a: TreeNode | null,\n  b: TreeNode | null,\n): boolean {\n  // Check if both a and b are null\n  if (a == null && b == null) {\n    return true;\n  }\n\n  // If one of a or b is null (but not both), the trees are not the same\n  if (b == null || a == null) {\n    return false;\n  }\n\n  // If the values of the current nodes are different, the trees are not the same\n  if (a.val != b.val) {\n    return false;\n  }\n\n  // Recursively check if the right subtrees are the same and if the left subtrees are the same\n  return binaryTreeEqual(a.right, b.right) && binaryTreeEqual(a.left, b.left);\n}\n`;var u=`interface TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n}\n\nexport default function binaryTreeEqual(\n  a: TreeNode | null,\n  b: TreeNode | null,\n): boolean {\n  // Helper function to check if two nodes are the same\n  function check(a: TreeNode | null, b: TreeNode | null) {\n    // If both nodes are null, they are the same\n    if (a === null && b === null) {\n      return true;\n    }\n    // If one node is null and the other is not, they are different\n    if (a === null || b === null) {\n      return false;\n    }\n    // If the values of the nodes are different, they are different\n    if (a.val !== b.val) {\n      return false;\n    }\n    // If none of the above conditions are met, the nodes are the same\n    return true;\n  }\n\n  // Initialize a queue with the pair of root nodes\n  const queue: [TreeNode | null, TreeNode | null][] = [[a, b]];\n\n  // Process the queue until it is empty\n  while (queue.length) {\n    // Dequeue the first pair of nodes\n    [a, b] = queue.shift() as [TreeNode | null, TreeNode | null];\n\n    // If the nodes are not the same, return false\n    if (!check(a, b)) {\n      return false;\n    }\n\n    // If the current node in a is not null, enqueue its left and right children along with b's corresponding children\n    if (a) {\n      queue.push([a.left, b?.left] as [TreeNode | null, TreeNode | null]);\n      queue.push([a.right, b?.right] as [TreeNode | null, TreeNode | null]);\n    }\n  }\n\n  // If all nodes are the same, return true\n  return true;\n}\n`;function f(r){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Recursive\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem of checking if two binary trees are identical involves comparing the structure and values of both trees node by node. The recursive approach simplifies this process by breaking it into smaller subproblems for the left and right subtrees.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The approach begins by checking base cases: if both nodes are null, the trees are identical at this point, but if one node is null and the other is not, or if their values differ, the trees are not identical. It then performs recursive checks, comparing the left subtrees of both trees and the right subtrees of both trees. The trees are considered identical only if both the left and right subtrees are identical. The recursion terminates once all corresponding nodes have been compared or a mismatch is found.\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach ensures that every node is checked for both structure and value.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check the base cases:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If both \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" are \",(0,n.jsx)(e.code,{children:\"null\"}),\", return \",(0,n.jsx)(e.code,{children:\"true\"}),\" as the trees are identical at this point.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If one of \",(0,n.jsx)(e.code,{children:\"a\"}),\" or \",(0,n.jsx)(e.code,{children:\"b\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\", return \",(0,n.jsx)(e.code,{children:\"false\"}),\" as the trees differ in structure.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the values of \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\" are not equal, return \",(0,n.jsx)(e.code,{children:\"false\"}),\" as the trees differ in value.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Recursively check the left and right subtrees:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Call \",(0,n.jsx)(e.code,{children:\"binaryTreeEqual\"}),\" for the right subtrees of \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Call \",(0,n.jsx)(e.code,{children:\"binaryTreeEqual\"}),\" for the left subtrees of \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if both the left and right subtree comparisons return \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node in both trees is visited once.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(h)\"}),\". The recursion stack requires space proportional to the height of the trees, where \",(0,n.jsx)(e.code,{children:\"h\"}),\" is the maximum height of the two trees.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Iterative\"}),`\n`,(0,n.jsx)(e.p,{children:\"The iterative approach for determining if two binary trees are identical uses a breadth-first traversal strategy. Instead of relying on recursion, this method uses a queue to manage pairs of nodes from both trees, ensuring both structural and value equivalence.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The algorithm begins by initializing a queue containing the root nodes of both trees as a pair. Each pair of nodes is dequeued, and their equivalence is checked. If both nodes are \",(0,n.jsx)(e.code,{children:\"null\"}),\", the pair is considered identical at this point. If one node is \",(0,n.jsx)(e.code,{children:\"null\"}),\" and the other is not, or their values differ, the trees are not identical. For non-\",(0,n.jsx)(e.code,{children:\"null\"}),\" nodes, the left and right children of both nodes are enqueued as new pairs. The process continues until the queue is empty, indicating that all corresponding nodes in the two trees are identical in structure and value.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"check\"}),\" that:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if both nodes are \",(0,n.jsx)(e.code,{children:\"null\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Returns \",(0,n.jsx)(e.code,{children:\"false\"}),\" if one node is \",(0,n.jsx)(e.code,{children:\"null\"}),\" and the other is not.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compares the values of two non-\",(0,n.jsx)(e.code,{children:\"null\"}),\" nodes and returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if they are equal.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Initialize a queue with the root nodes of both trees as a pair.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"While the queue is not empty:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Dequeue the first pair of nodes and validate them using the \",(0,n.jsx)(e.code,{children:\"check\"}),\" function.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"If the nodes are valid, enqueue their left and right children as new pairs for further comparison.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if no violations are found during the traversal.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node in both trees is processed once.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The queue stores up to \",(0,n.jsx)(e.code,{children:\"n\"}),\" pairs of nodes, depending on the size of the trees.\"]}),`\n`]})]})}function x(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(f,r)})):f(r)}var w=x;return I(E);})();\n;return Component;"
}