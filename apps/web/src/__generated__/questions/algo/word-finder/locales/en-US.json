{
  "description": "var Component=(()=>{var m=Object.create;var t=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var x=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),f=(r,e)=>{for(var a in e)t(r,a,{get:e[a],enumerable:!0})},o=(r,e,a,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of w(e))!b.call(r,n)&&n!==a&&t(r,n,{get:()=>e[n],enumerable:!(l=p(e,n))||l.enumerable});return r};var W=(r,e,a)=>(a=r!=null?m(g(r)):{},o(e||!r||!r.__esModule?t(a,\"default\",{value:r,enumerable:!0}):a,r)),y=r=>o(t({},\"__esModule\",{value:!0}),r);var h=x((M,c)=>{c.exports=_jsx_runtime});var E={};f(E,{default:()=>T,frontmatter:()=>_});var d=W(h());var s=MDXTestExamples;var i=[{input:[[\"methods\",[\"addWord\",\"addWord\",\"search\",\"addWord\",\"search\",\"search\",\"search\"]],[\"params\",[\"car\",\"cat\",\"c.r\",\"dog\",\"d.g\",\"cat\",\"c..\"]]],output:[null,null,!0,null,!0,!0,!0],explanation:\"Words 'car' and 'cat' are added, 'c.r' matches 'car', 'dog' and 'd.g' match, 'c..' matches both 'car' and 'cat'.\"},{input:[[\"methods\",[\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"addWord\",\"search\"]],[\"params\",[\"hello\",\"hollow\",\"hollow\",\"hell\",\"hel.o\",\"hero\",\"h.o.\"]]],output:[null,null,null,!1,!0,null,!1],explanation:\"The words 'hello', 'hollow' are added, 'hell' doesn't exist, 'hel.o' matches 'hello', 'hero' is added, 'h.o.' does not match with any other word.\"},{input:[[\"methods\",[\"addWord\",\"search\",\"addWord\",\"search\",\"addWord\",\"search\",\"search\"]],[\"params\",[\"bat\",\"b.t\",\"ball\",\"ba.l\",\"bat\",\"b.ll\",\"ball\"]]],output:[null,!0,null,!0,null,!0,!0],explanation:\"Words 'bat' and 'ball' are added, 'b.t' matches 'bat', 'ba.l', 'b.ll' and 'ball' match 'ball'.\"}];var _={title:\"Word Finder\",excerpt:\"Implement a data structure where words can be added and support wildcard searching\"};function u(r){let e=Object.assign({p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",h3:\"h3\"},r.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.p,{children:[\"Implement \",(0,d.jsx)(e.code,{children:\"WordFinder\"}),\" class that allows for adding words and searching for them. It has the following methods:\"]}),`\n`,(0,d.jsxs)(e.ul,{children:[`\n`,(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.code,{children:\"addWord(word: string)\"}),\": Adds a word to the data structure\"]}),`\n`,(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.code,{children:\"search(query: string)\"}),\": Checks if any added word matches the given word. The \",(0,d.jsx)(e.code,{children:\"query\"}),\" can include dots \",(0,d.jsx)(e.code,{children:\".\"}),\", which can match any letter\"]}),`\n`]}),`\n`,(0,d.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,d.jsxs)(e.p,{children:[\"The \",(0,d.jsx)(e.code,{children:\"WordFinder\"}),\" instance will have its methods called with various parameters based on these:\"]}),`\n`,(0,d.jsxs)(e.ul,{children:[`\n`,(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.code,{children:\"methods: string[]\"}),\": An array of method names\"]}),`\n`,(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.code,{children:\"params: string[]\"}),\": An array of strings\"]}),`\n`]}),`\n`,(0,d.jsxs)(e.p,{children:[(0,d.jsx)(e.code,{children:\"methods[i]\"}),\" will be called with \",(0,d.jsx)(e.code,{children:\"params[i]\"}),\".\"]}),`\n`,(0,d.jsx)(s,{testCases:i}),`\n`,(0,d.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,d.jsxs)(e.ul,{children:[`\n`,(0,d.jsxs)(e.li,{children:[\"1 <= \",(0,d.jsx)(e.code,{children:\"word.length\"}),\" <= 25\"]}),`\n`,(0,d.jsxs)(e.li,{children:[\"1 <= \",(0,d.jsx)(e.code,{children:\"methods.length\"}),\" <= 1000\"]}),`\n`,(0,d.jsxs)(e.li,{children:[\"Search queries may include \",(0,d.jsx)(e.code,{children:\".\"}),\" and lowercase English letters, with at most 2 dots per query\"]}),`\n`,(0,d.jsx)(e.li,{children:\"Each word contains only lowercase English letters\"}),`\n`]})]})}function C(r={}){let{wrapper:e}=r.components||{};return e?(0,d.jsx)(e,Object.assign({},r,{children:(0,d.jsx)(u,r)})):u(r)}var T=C;return y(E);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a data structure where words can be added and support wildcard searching",
    "title": "Word Finder"
  },
  "solution": "var Component=(()=>{var u=Object.create;var d=Object.defineProperty;var w=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var t in e)d(n,t,{get:e[t],enumerable:!0})},h=(n,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!p.call(n,i)&&i!==t&&d(n,i,{get:()=>e[i],enumerable:!(o=w(e,i))||o.enumerable});return n};var y=(n,e,t)=>(t=n!=null?u(m(n)):{},h(e||!n||!n.__esModule?d(t,\"default\",{value:n,enumerable:!0}):t,n)),T=n=>h(d({},\"__esModule\",{value:!0}),n);var a=x((F,c)=>{c.exports=_jsx_runtime});var N={};v(N,{default:()=>M});var r=y(a());var l=MDXCodeBlock;var s=`class TrieNode {\n  // A map to hold child nodes\n  children: Map<string, TrieNode> = new Map();\n  // Indicates whether this node is the end of a word\n  word: boolean = false;\n}\n\nexport default class WordFinder {\n  private trie: TrieNode;\n\n  constructor() {\n    // Initialize the root of the trie\n    this.trie = new TrieNode();\n  }\n\n  addWord(word: string): void {\n    let node = this.trie;\n\n    for (const ch of word) {\n      // If the character is not already a child node, add it\n      if (!node.children.has(ch)) {\n        node.children.set(ch, new TrieNode());\n      }\n      // Move to the next node in the trie\n      node = node.children.get(ch)!;\n    }\n    // Mark the end of the word\n    node.word = true;\n  }\n\n  private searchInNode(word: string, node: TrieNode): boolean {\n    for (let i = 0; i < word.length; i++) {\n      const ch = word[i];\n      // If the character is not found, check if it's a '.'\n      if (!node.children.has(ch)) {\n        if (ch === '.') {\n          // Iterate over all children nodes using forEach\n          let found = false;\n          node.children.forEach((child) => {\n            // Recursively search for the remaining substring in each child node\n            if (this.searchInNode(word.substring(i + 1), child)) {\n              found = true;\n            }\n          });\n          return found;\n        }\n        // If the character is not a '.' and not found, return false\n        return false;\n      } else {\n        // If the character is found, move down to the next level in the trie\n        node = node.children.get(ch)!;\n      }\n    }\n    // Return true if the current node marks the end of a word\n    return node.word;\n  }\n\n  search(word: string): boolean {\n    return this.searchInNode(word, this.trie);\n  }\n}\n`;function f(n){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",strong:\"strong\",ul:\"ul\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Using tries\"}),`\n`,(0,r.jsxs)(e.p,{children:[\"A \",(0,r.jsx)(e.code,{children:\"WordFinder\"}),\" is built using a Trie (prefix tree) to efficiently store and search words. The TrieNode structure consists of a \",(0,r.jsx)(e.code,{children:\"Map\"}),\" to store child nodes and a boolean flag indicating whether the node represents the end of a word. This design is particularly effective for solving problems that involve word searches with exact matches or wildcard patterns using \",(0,r.jsx)(e.code,{children:\".\"}),\".\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"The main idea is to add words to the Trie node by node, where each character represents a path in the Trie. Searching is done recursively, with special handling for the \",(0,r.jsx)(e.code,{children:\".\"}),\" character, which acts as a wildcard. The \",(0,r.jsx)(e.code,{children:\".\"}),\" can match any character, and all possible child nodes are explored recursively to find a match.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"Add word\"}),\":\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Start at the root node.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"For each character in the word, check if it exists in the current node's \",(0,r.jsx)(e.code,{children:\"children\"}),\" map.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If it does not exist, create a new \",(0,r.jsx)(e.code,{children:\"TrieNode\"}),\" and add it to the map.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Move to the next node and repeat until the word is fully added.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"Mark the final node as the end of the word by setting the \",(0,r.jsx)(e.code,{children:\"word\"}),\" flag to \",(0,r.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:\"Search\"}),\":\"]}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Use the helper function \",(0,r.jsx)(e.code,{children:\"searchInNode\"}),\" to traverse the Trie recursively.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"For each character:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If it exists in the current node's \",(0,r.jsx)(e.code,{children:\"children\"}),\", move to the child node.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the character is \",(0,r.jsx)(e.code,{children:\".\"}),\", iterate over all children nodes and recursively search for the remaining substring.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the character does not exist and is not \",(0,r.jsx)(e.code,{children:\".\"}),\", return \",(0,r.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"At the end of the word, return \",(0,r.jsx)(e.code,{children:\"true\"}),\" if the current node marks the end of a word.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(l,{children:s}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity\"}),\": O(m), for words that are clearly defined without dots, where \",(0,r.jsx)(e.code,{children:\"m\"}),' is the length of the word. For \"undefined\" words, the time complexity is O(n.26',(0,r.jsx)(\"sup\",{children:\"m\"}),\"), where n is the number of keys and m is the length of the undefined word. This represents the worst-case scenario when searching for an undefined word with m recursive calls, as the word is one character longer than all inserted keys.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity\"}),': O(1) for the search of \"well-defined\" words without dots. For \"undefined\" words, the space complexity can go up to O(m) to accommodate the recursion stack.']}),`\n`]})]})}function I(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(f,n)})):f(n)}var M=I;return T(N);})();\n;return Component;"
}