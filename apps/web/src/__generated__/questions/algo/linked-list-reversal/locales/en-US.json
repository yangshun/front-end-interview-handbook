{
  "description": "var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),L=(t,e)=>{for(var i in e)l(t,i,{get:e[i],enumerable:!0})},d=(t,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of f(e))!k.call(t,s)&&s!==i&&l(t,s,{get:()=>e[s],enumerable:!(r=m(e,s))||r.enumerable});return t};var g=(t,e,i)=>(i=t!=null?u(x(t)):{},d(e||!t||!t.__esModule?l(i,\"default\",{value:t,enumerable:!0}):i,t)),w=t=>d(l({},\"__esModule\",{value:!0}),t);var a=v((C,o)=>{o.exports=_jsx_runtime});var T={};L(T,{default:()=>y,frontmatter:()=>_});var n=g(a());var c=MDXTestExamples;var h=[{input:[[\"list\",[1,2,3,4,5]]],output:[5,4,3,2,1],explanation:\"The input list [1, 2, 3, 4, 5] creates a linked list that, when reversed, produces [5, 4, 3, 2, 1].\"},{input:[[\"list\",[]]],output:[],explanation:\"The input list is empty, so the reversed linked list is also empty.\"}];var _={title:\"Linked List Reversal\",excerpt:\"Implement a function to reverse a linked list\"};function p(t){let e=Object.assign({p:\"p\",a:\"a\",code:\"code\",pre:\"pre\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given the head of a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Linked_list\",children:\"linked list\"}),\", reverse the list and return the new head of the reversed list.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The linked list is represented by a sequence of \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\"s, where each node points to the next node in the sequence, or \",(0,n.jsx)(e.code,{children:\"null\"}),\" if it is the last node.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.code,{children:\"ListNode\"}),\" has the following interface:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-ts\",children:`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"head: ListNode\"}),\": Head of the linked list. Examples display each linked list as an array of values within the list\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"1 <= Number of nodes <= 1000\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"-1000 <= \",(0,n.jsx)(e.code,{children:\"ListNode.val\"}),\" <= 1000\"]}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var y=j;return w(T);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to reverse a linked list",
    "title": "Linked List Reversal"
  },
  "solution": "var Component=(()=>{var v=Object.create;var l=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var w=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),y=(r,e)=>{for(var t in e)l(r,t,{get:e[t],enumerable:!0})},h=(r,e,t,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!g.call(r,i)&&i!==t&&l(r,i,{get:()=>e[i],enumerable:!(d=f(e,i))||d.enumerable});return r};var b=(r,e,t)=>(t=r!=null?v(x(r)):{},h(e||!r||!r.__esModule?l(t,\"default\",{value:r,enumerable:!0}):t,r)),L=r=>h(l({},\"__esModule\",{value:!0}),r);var s=w((O,c)=>{c.exports=_jsx_runtime});var M={};y(M,{default:()=>N});var n=b(s());var o=MDXCodeBlock;var a=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function reverseLinkedList(\n  head: ListNode | null,\n): ListNode | null {\n  // Initialize pointers\n  let prev: ListNode | null = null; // Previous node, initially null\n  let curr: ListNode | null = head; // Current node, starts with head\n\n  // Iterate over the linked list\n  while (curr !== null) {\n    // Temporarily store the next node\n    const nextTemp: ListNode | null = curr.next;\n\n    // Reverse the current node's pointer\n    curr.next = prev;\n\n    // Move prev and curr one step forward\n    prev = curr;\n    curr = nextTemp;\n  }\n\n  // Return the new head of the reversed list\n  return prev;\n}\n`;var u=`interface ListNode {\n  val: number;\n  next: ListNode | null;\n}\n\nexport default function reverseLinkedList(\n  head: ListNode | null,\n): ListNode | null {\n  // Base case: if the list is empty or has only one node, return the head\n  if (head === null || head.next === null) {\n    return head;\n  }\n\n  // Recursive case: reverse the rest of the list\n  const p: ListNode | null = reverseLinkedList(head.next);\n\n  // Set the next node's next reference to the current node\n  head.next.next = head;\n\n  // Set the current node's next reference to null\n  head.next = null;\n\n  // Return the new head of the reversed list\n  return p;\n}\n`;function p(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Iterative Method\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Reversing a linked list involves flipping the \",(0,n.jsx)(e.code,{children:\"next\"}),\" pointers of all nodes so that they point to the previous node instead of the next node. The iterative approach uses two pointers, \",(0,n.jsx)(e.code,{children:\"prev\"}),\" and \",(0,n.jsx)(e.code,{children:\"curr\"}),\", to track the previous and current nodes, respectively. This ensures that the list is reversed in-place without requiring additional memory.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Each node's \",(0,n.jsx)(e.code,{children:\"next\"}),\" pointer is reversed to point to the previous node. This operation is performed iteratively for all nodes in the list.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"curr\"}),\" pointer traverses the list from the head to the end, while the \",(0,n.jsx)(e.code,{children:\"prev\"}),\" pointer lags behind, building the reversed portion of the list step by step.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"By using only a few pointers (\",(0,n.jsx)(e.code,{children:\"prev\"}),\", \",(0,n.jsx)(e.code,{children:\"curr\"}),\", and a temporary pointer for the next node), the algorithm achieves the reversal without requiring additional space for a new list.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The process ends when the \",(0,n.jsx)(e.code,{children:\"curr\"}),\" pointer becomes \",(0,n.jsx)(e.code,{children:\"null\"}),\", indicating that all nodes have been reversed. At this point, the \",(0,n.jsx)(e.code,{children:\"prev\"}),\" pointer points to the new head of the reversed list.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This approach efficiently reverses the list in linear time while maintaining constant space complexity.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two pointers:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"prev\"}),\" to \",(0,n.jsx)(e.code,{children:\"null\"}),\", representing the previous node.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"curr\"}),\" to the \",(0,n.jsx)(e.code,{children:\"head\"}),\", representing the current node.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate over the list while \",(0,n.jsx)(e.code,{children:\"curr\"}),\" is not \",(0,n.jsx)(e.code,{children:\"null\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Store the next node in a temporary variable \",(0,n.jsx)(e.code,{children:\"nextTemp\"}),\" (\",(0,n.jsx)(e.code,{children:\"curr.next\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Reverse the \",(0,n.jsx)(e.code,{children:\"next\"}),\" pointer of the current node (\",(0,n.jsx)(e.code,{children:\"curr.next = prev\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Move the \",(0,n.jsx)(e.code,{children:\"prev\"}),\" pointer to the current node (\",(0,n.jsx)(e.code,{children:\"prev = curr\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Move the \",(0,n.jsx)(e.code,{children:\"curr\"}),\" pointer to the next node (\",(0,n.jsx)(e.code,{children:\"curr = nextTemp\"}),\").\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After the loop, the \",(0,n.jsx)(e.code,{children:\"prev\"}),\" pointer will point to the new head of the reversed list.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"prev\"}),\" as the new head.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:a}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node in the list is visited once.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The algorithm uses a constant amount of additional space.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Recursive Method\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Reversing a linked list recursively involves breaking the problem into smaller subproblems by reversing the tail portion of the list first and adjusting the pointers as the recursion is called. The key is to reverse the \",(0,n.jsx)(e.code,{children:\"next\"}),\" pointers of the nodes one step at a time as the recursion propagates back up the call stack.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The problem is divided into reversing the sublist starting from the second node onward (\",(0,n.jsx)(e.code,{children:\"head.next\"}),\"). The base case occurs when the list is empty or has only one node, in which case the reversal is complete.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"During each recursive call, the \",(0,n.jsx)(e.code,{children:\"next\"}),\" pointer of the subsequent node is updated to point back to the current node (\",(0,n.jsx)(e.code,{children:\"head\"}),\"). This reverses the direction of the \",(0,n.jsx)(e.code,{children:\"next\"}),\" pointer for each node.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The recursive call returns the new head of the reversed sublist, which propagates back to the top-level caller. This ensures that the final head of the reversed list is returned.\"}),`\n`,(0,n.jsx)(e.p,{children:\"The algorithm operates directly on the nodes of the list without requiring additional space for a new list or auxiliary data structures.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check the base case:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"head\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\" or \",(0,n.jsx)(e.code,{children:\"head.next\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\", return \",(0,n.jsx)(e.code,{children:\"head\"}),\" as the reversed list.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Recursively call \",(0,n.jsx)(e.code,{children:\"reverseLinkedList\"}),\" with \",(0,n.jsx)(e.code,{children:\"head.next\"}),\" to reverse the remainder of the list.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Store the result in a variable \",(0,n.jsx)(e.code,{children:\"p\"}),\", which represents the new head of the reversed list.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Adjust the pointers:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"head.next.next\"}),\" to \",(0,n.jsx)(e.code,{children:\"head\"}),\", reversing the \",(0,n.jsx)(e.code,{children:\"next\"}),\" pointer for the current node.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"head.next\"}),\" to \",(0,n.jsx)(e.code,{children:\"null\"}),\" to disconnect the current node from the original list structure.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"p\"}),\" as the new head of the reversed list.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node is visited exactly once during the recursion.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The recursion depth is proportional to the size of the list, requiring additional stack space.\"]}),`\n`]})]})}function R(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(p,r)})):p(r)}var N=R;return L(M);})();\n;return Component;"
}