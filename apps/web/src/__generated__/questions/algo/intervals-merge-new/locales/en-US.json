{
  "description": "var Component=(()=>{var u=Object.create;var a=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var w=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),f=(r,e)=>{for(var t in e)a(r,t,{get:e[t],enumerable:!0})},s=(r,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!x.call(r,i)&&i!==t&&a(r,i,{get:()=>e[i],enumerable:!(l=v(e,i))||l.enumerable});return r};var y=(r,e,t)=>(t=r!=null?u(g(r)):{},s(e||!r||!r.__esModule?a(t,\"default\",{value:r,enumerable:!0}):t,r)),b=r=>s(a({},\"__esModule\",{value:!0}),r);var d=w((D,o)=>{o.exports=_jsx_runtime});var _={};f(_,{default:()=>T,frontmatter:()=>I});var n=y(d());var c=MDXTestExamples;var h=[{input:[[\"intervals\",[[1,2],[3,5],[6,10],[11,12],[13,16]]],[\"newInterval\",[8,15]]],output:[[1,2],[3,5],[6,16]],explanation:\"The new interval [8, 15] overlaps with [6, 10], [11, 12], and [13, 16]. These intervals merge to form [6, 16], and the result is [[1, 2], [3, 5], [6, 16]].\"},{input:[[\"intervals\",[[1,2],[3,4],[5,6],[7,8]]],[\"newInterval\",[2,5]]],output:[[1,6],[7,8]],explanation:\"The new interval [2, 5] overlaps with [1, 2], [3, 4], and [5, 6]. Merging them results in [1, 6].\"},{input:[[\"intervals\",[[2,4],[6,8],[10,12]]],[\"newInterval\",[15,17]]],output:[[2,4],[6,8],[10,12],[15,17]],explanation:\"The new interval [15, 17] does not overlap with any existing intervals and is simply added at the end.\"}];var I={title:\"Merge New Interval\",excerpt:\"Implement a function to insert a new interval in the given intervals\"};function p(r){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a sorted array of non-overlapping intervals \",(0,n.jsx)(e.code,{children:\"intervals\"}),\", where each interval is represented as \",(0,n.jsx)(e.code,{children:\"[start, end]\"}),\" and sorted in ascending order by \",(0,n.jsx)(e.code,{children:\"start\"}),\" times, insert a new interval \",(0,n.jsx)(e.code,{children:\"[start, end]\"}),\" into the array. Ensure the resulting array remains sorted and free of overlapping intervals by merging any overlapping intervals as necessary.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"intervals: Array<[number, number]>\"}),\": An array of integer pairs\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"newInterval: [number, number]\"}),\": An integer pair representing \",(0,n.jsx)(e.code,{children:\"[start, end]\"})]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"intervals.length\"}),\" <= 100\"]}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"intervals[i].length == 2\"})}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"start\"}),\" <= \",(0,n.jsx)(e.code,{children:\"end\"}),\" <= 10,000\"]}),`\n`]})]})}function M(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(p,r)})):p(r)}var T=M;return b(_);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to insert a new interval in the given intervals",
    "title": "Merge New Interval"
  },
  "solution": "var Component=(()=>{var g=Object.create;var l=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var y=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),I=(r,e)=>{for(var t in e)l(r,t,{get:e[t],enumerable:!0})},s=(r,e,t,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of u(e))!w.call(r,i)&&i!==t&&l(r,i,{get:()=>e[i],enumerable:!(h=m(e,i))||h.enumerable});return r};var b=(r,e,t)=>(t=r!=null?g(f(r)):{},s(e||!r||!r.__esModule?l(t,\"default\",{value:r,enumerable:!0}):t,r)),x=r=>s(l({},\"__esModule\",{value:!0}),r);var d=y((C,o)=>{o.exports=_jsx_runtime});var T={};I(T,{default:()=>M});var n=b(d());var a=MDXCodeBlock;var c=`export default function mergeNewInterval(\n  intervals: number[][],\n  newInterval: number[],\n): number[][] {\n  let n = intervals.length,\n    i = 0,\n    res = [];\n\n  // Case 1: No overlapping before merging intervals\n  // Add all intervals that come before the new interval (no overlap)\n  while (i < n && intervals[i][1] < newInterval[0]) {\n    res.push(intervals[i]);\n    i++;\n  }\n\n  // Case 2: Overlapping and merging intervals\n  // Merge all intervals that overlap with the new interval\n  while (i < n && newInterval[1] >= intervals[i][0]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0]); // Adjust the start of the new interval\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1]); // Adjust the end of the new interval\n    i++;\n  }\n  res.push(newInterval); // Add the merged interval to the result\n\n  // Case 3: No overlapping after merging newInterval\n  // Add all remaining intervals after the new interval\n  while (i < n) {\n    res.push(intervals[i]);\n    i++;\n  }\n\n  return res;\n}\n`;var v=`export default function mergeNewInterval(\n  intervals: number[][],\n  newInterval: number[],\n): number[][] {\n  // If the intervals array is empty, return a list containing the newInterval\n  if (intervals.length === 0) {\n    return [newInterval];\n  }\n\n  let n = intervals.length;\n  let target = newInterval[0]; // The start value of the new interval\n  let left = 0,\n    right = n - 1;\n\n  // Binary search to find the position to insert newInterval\n  while (left <= right) {\n    let mid = Math.floor((left + right) / 2);\n    if (intervals[mid][0] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n\n  // Insert newInterval at the found position\n  intervals.splice(left, 0, newInterval);\n\n  // Initialize the result array to hold merged intervals\n  let res: number[][] = [];\n  for (let interval of intervals) {\n    // If res is empty or there is no overlap, add the interval to the result\n    if (res.length === 0 || res[res.length - 1][1] < interval[0]) {\n      res.push(interval);\n      // If there is an overlap, merge the intervals by updating the end of the last interval in res\n    } else {\n      res[res.length - 1][1] = Math.max(res[res.length - 1][1], interval[1]);\n    }\n  }\n  return res; // Return the merged intervals\n}\n`;function p(r){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Linear Search\"}),`\n`,(0,n.jsx)(e.p,{children:\"The approach merges a new interval into a list of non-overlapping intervals by performing a single linear scan. The intervals are processed in three distinct phases based on their relationship to the new interval: intervals that come completely before, intervals that overlap, and intervals that come completely after. Sorting is unnecessary because the input intervals are already sorted.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Intervals that do not overlap with the new interval are added to the result as-is. Overlapping intervals with the new interval are merged by updating the start and end of the new interval to cover the combined range. Once all overlapping intervals are merged, the new interval is added to the result, followed by the remaining intervals. This approach ensures that each interval is processed exactly once.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an empty result array \",(0,n.jsx)(e.code,{children:\"res\"}),\" and set a pointer \",(0,n.jsx)(e.code,{children:\"i\"}),\" to \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Process intervals that come before the new interval:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"While the end of the current interval is less than the start of the new interval, add the interval to \",(0,n.jsx)(e.code,{children:\"res\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Increment the pointer \",(0,n.jsx)(e.code,{children:\"i\"}),\" for each added interval.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Process overlapping intervals:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"While the start of the current interval is less than or equal to the end of the new interval, merge the intervals by updating the start and end of the new interval.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Increment the pointer \",(0,n.jsx)(e.code,{children:\"i\"}),\" after merging.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Add the merged interval (new interval) to the result array \",(0,n.jsx)(e.code,{children:\"res\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Process intervals that come after the new interval:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Add all remaining intervals to \",(0,n.jsx)(e.code,{children:\"res\"}),\" starting from the current pointer position \",(0,n.jsx)(e.code,{children:\"i\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Increment the pointer \",(0,n.jsx)(e.code,{children:\"i\"}),\" for each added interval.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the result array \",(0,n.jsx)(e.code,{children:\"res\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each interval is processed exactly once, resulting in a linear runtime.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The result array \",(0,n.jsx)(e.code,{children:\"res\"}),\" stores all intervals, requiring space proportional to the input size.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Binary Search\"}),`\n`,(0,n.jsx)(e.p,{children:\"This approach combines binary search and merging to efficiently insert a new interval into a sorted list of intervals and merge any overlaps. Binary search is used to determine the correct position to insert the new interval based on its start time. Once inserted, a single pass through the intervals is sufficient to merge overlapping intervals. The merging process ensures that overlapping intervals are combined into a single interval by checking adjacent intervals in the result list.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Handle the edge case where the \",(0,n.jsx)(e.code,{children:\"intervals\"}),\" array is empty by returning a list containing only the \",(0,n.jsx)(e.code,{children:\"newInterval\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use binary search to find the appropriate position to insert the \",(0,n.jsx)(e.code,{children:\"newInterval\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two pointers, \",(0,n.jsx)(e.code,{children:\"left\"}),\" and \",(0,n.jsx)(e.code,{children:\"right\"}),\", to represent the search range.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Compare the start value of the \",(0,n.jsx)(e.code,{children:\"newInterval\"}),\" with the middle element of the current range.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Adjust the pointers until the position to insert the \",(0,n.jsx)(e.code,{children:\"newInterval\"}),\" is found.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Insert the \",(0,n.jsx)(e.code,{children:\"newInterval\"}),\" at the determined position using the \",(0,n.jsx)(e.code,{children:\"splice\"}),\" method.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an empty array \",(0,n.jsx)(e.code,{children:\"res\"}),\" to store the merged intervals.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the \",(0,n.jsx)(e.code,{children:\"intervals\"}),\" array:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If \",(0,n.jsx)(e.code,{children:\"res\"}),\" is empty or the current interval does not overlap with the last interval in \",(0,n.jsx)(e.code,{children:\"res\"}),\", add the current interval to \",(0,n.jsx)(e.code,{children:\"res\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If there is an overlap, merge the intervals by updating the end of the last interval in \",(0,n.jsx)(e.code,{children:\"res\"}),\" to the maximum of the two overlapping intervals.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the \",(0,n.jsx)(e.code,{children:\"res\"}),\" array containing the merged intervals.\"]}),`\n`]}),`\n`,(0,n.jsx)(a,{children:v}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Binary search takes O(log n), but this is insignificant compared to the O(n) time required to merge the intervals.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The result array \",(0,n.jsx)(e.code,{children:\"res\"}),\" requires space proportional to the input size.\"]}),`\n`]})]})}function A(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(p,r)})):p(r)}var M=A;return x(T);})();\n;return Component;"
}