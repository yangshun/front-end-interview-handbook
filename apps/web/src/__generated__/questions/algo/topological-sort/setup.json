{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/topological-sort\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/topological-sort.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/topological-sort.run.test.ts": "import topologicalSort from './topological-sort';\n\ndescribe('topologicalSort', () => {\n  test('empty graph', () => {\n    expect(topologicalSort({})).toEqual([]);\n  });\n\n  test('graphs with one node', () => {\n    expect(topologicalSort({ A: [] })).toEqual(['A']);\n  });\n\n  test('graphs with two nodes', () => {\n    expect(topologicalSort({ A: ['B'], B: [] })).toEqual(['A', 'B']);\n    expect(topologicalSort({ A: [], B: ['A'] })).toEqual(['B', 'A']);\n  });\n});\n",
    "/src/topological-sort.submit.test.ts": "import topologicalSort from './topological-sort';\n\ndescribe('topologicalSort', () => {\n  test('empty graph', () => {\n    expect(topologicalSort({})).toEqual([]);\n  });\n\n  test('graphs with one node', () => {\n    expect(topologicalSort({ A: [] })).toEqual(['A']);\n  });\n\n  test('graphs with two nodes', () => {\n    expect(topologicalSort({ A: ['B'], B: [] })).toEqual(['A', 'B']);\n    expect(topologicalSort({ A: [], B: ['A'] })).toEqual(['B', 'A']);\n  });\n\n  test('graphs with multiple nodes', () => {\n    expect(topologicalSort({ A: ['B', 'C'], B: ['C'], C: [] })).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(\n      topologicalSort({\n        A: ['B', 'C', 'E'],\n        B: ['C'],\n        C: [],\n        D: ['B'],\n        E: ['C', 'D'],\n      }),\n    ).toEqual(['A', 'E', 'D', 'B', 'C']);\n    expect(\n      topologicalSort({\n        A: ['B', 'C'],\n        B: ['C', 'D', 'E'],\n        C: ['F'],\n        D: [],\n        E: ['F'],\n        F: [],\n      }),\n    ).toEqual(['A', 'B', 'C', 'D', 'E', 'F']);\n    expect(\n      topologicalSort({\n        A: ['B', 'C'],\n        B: ['C', 'D'],\n        C: ['D'],\n        D: ['E'],\n        E: ['F'],\n        F: [],\n      }),\n    ).toEqual(['A', 'B', 'C', 'D', 'E', 'F']);\n  });\n\n  test('linked list', () => {\n    expect(topologicalSort({ A: ['B'], B: ['C'], C: [] })).toEqual([\n      'A',\n      'B',\n      'C',\n    ]);\n    expect(\n      topologicalSort({\n        A: [],\n        B: ['A'],\n        C: ['B'],\n        D: ['C'],\n        E: ['D'],\n        F: ['E'],\n      }),\n    ).toEqual(['F', 'E', 'D', 'C', 'B', 'A']);\n  });\n\n  test('graph with cycles', () => {\n    expect(topologicalSort({ A: ['A'] })).toEqual([]);\n    expect(topologicalSort({ A: ['A', 'B'], B: [] })).toEqual([]);\n    expect(topologicalSort({ A: ['A', 'B'], B: ['A'] })).toEqual([]);\n    expect(\n      topologicalSort({\n        A: ['D', 'E'],\n        B: ['A', 'B', 'C', 'D', 'E'],\n        C: [],\n        D: ['B'],\n        E: ['C'],\n      }),\n    ).toEqual([]);\n  });\n});\n",
    "/src/topological-sort.ts": "export default function topologicalSort(\n  graph: Record<string, Array<string>>,\n): Array<string> {\n  // Initialize a Map object to store each node's incoming and outgoing edges,\n  // an array to store the output topological sort order,\n  // and a Queue object to store nodes to be processed\n  const nodes = new Map<string, { in: number; out: Set<string> }>();\n  const queue = new Queue<string>();\n  const order = [];\n\n  // Iterating over all the keys in the input graph object\n  // add each key to the \"nodes\" Map object\n  // with properties \"in\" with value 0\n  // and \"out\" with the value of set of neighboring nodes.\n  Object.keys(graph).forEach((node) => {\n    nodes.set(node, { in: 0, out: new Set(graph[node]) });\n  });\n\n  // Set the Map with the correct `in` values.\n  // Iterating over all the keys in the input graph object,\n  // for each node increase the `in` property of its neighbor node by 1.\n  Object.keys(graph).forEach((node) => {\n    graph[node].forEach((neighbor) => {\n      nodes.get(neighbor)!.in += 1;\n    });\n  });\n\n  // Iterate over the nodes and add all the nodes with `in: 0` to the queue.\n  nodes.forEach((value, node) => {\n    if (value.in === 0) {\n      queue.enqueue(node);\n    }\n  });\n\n  // While queue is not empty.\n  while (queue.length()) {\n    // Dequeue a node from the front of the queue.\n    const node = queue.dequeue()!;\n\n    // For each neighbor of this dequeued node decrease its `in` property by 1,\n    // if the `in` becomes 0, enqueue the neighbor node.\n    nodes.get(node)?.out.forEach((neighbor) => {\n      nodes.get(neighbor)!.in -= 1;\n      if (nodes.get(neighbor)!.in === 0) {\n        queue.enqueue(neighbor);\n      }\n    });\n\n    // Add the dequeued node to the output array.\n    order.push(node);\n  }\n\n  // Return topological-ordered array if it has the same length as\n  // the number of keys in the graph, otherwise there is a cycle\n  // and we return an empty array.\n  return order.length === Object.keys(graph).length ? order : [];\n}\n\nclass Node<T> {\n  value: T | undefined;\n  next: Node<T> | null;\n  prev: Node<T> | null;\n\n  constructor(value?: T) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nclass Queue<T> {\n  _dummyHead: Node<T>;\n  _dummyTail: Node<T>;\n  _length: number;\n\n  constructor() {\n    this._dummyHead = new Node<T>();\n    this._dummyTail = new Node<T>();\n    this._dummyHead.prev = this._dummyTail;\n    this._dummyTail.next = this._dummyHead;\n    this._length = 0;\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   */\n  enqueue(item: T) {\n    const node = new Node(item);\n    const prevLast = this._dummyTail.next;\n    prevLast!.prev = node;\n\n    node.next = prevLast;\n    node.prev = this._dummyTail;\n    this._dummyTail.next = node;\n    this._length++;\n    return this._length;\n  }\n\n  /**\n   * Remove an item from the front of the queue.\n   */\n  dequeue(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const node = this._dummyHead.prev;\n    const newFirst = node!.prev;\n    this._dummyHead.prev = newFirst;\n    newFirst!.next = this._dummyHead;\n    // Unlink the node to be dequeued.\n    node!.prev = null;\n    node!.next = null;\n    this._length--;\n    return node!.value;\n  }\n\n  /**\n   * Determines if the queue is empty.\n   */\n  isEmpty(): boolean {\n    return this._length === 0;\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   */\n  front(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyHead.prev!.value;\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue it.\n   */\n  back(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyTail.next!.value;\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length(): number {\n    return this._length;\n  }\n}\n"
  },
  "skeleton": {
    "js": "/**\n * @param {Object} graph Node to array of traversable neighboring nodes.\n * @return {Array<string>} A topological traversal of nodes.\n */\nexport default function topologicalSort(graph) {\n  throw 'Not implemented!';\n}\n\n// `Queue` data structure is provided in case you want to use it.\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nclass Queue {\n  constructor() {\n    this._dummyHead = new Node();\n    this._dummyTail = new Node();\n    this._dummyHead.prev = this._dummyTail;\n    this._dummyTail.next = this._dummyHead;\n    this._length = 0;\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   * @param {*} item The item to be pushed onto the queue.\n   * @return {number} The new length of the queue.\n   */\n  enqueue(item) {\n    const node = new Node(item);\n    const prevLast = this._dummyTail.next;\n    prevLast.prev = node;\n\n    node.next = prevLast;\n    node.prev = this._dummyTail;\n    this._dummyTail.next = node;\n    this._length++;\n    return this._length;\n  }\n\n  /**\n   * Remove an item from the front of the queue.\n   * @return {*} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  dequeue() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const node = this._dummyHead.prev;\n    const newFirst = node.prev;\n    this._dummyHead.prev = newFirst;\n    newFirst.next = this._dummyHead;\n    // Unlink the node to be dequeued.\n    node.prev = null;\n    node.next = null;\n    this._length--;\n    return node.value;\n  }\n\n  /**\n   * Determines if the queue is empty.\n   * @return {boolean} `true` if the queue has no items, `false` otherwise.\n   */\n  isEmpty() {\n    return this._length === 0;\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   * @return {*} The item at the front of the queue if it is not empty, `undefined` otherwise.\n   */\n  front() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyHead.prev.value;\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue it.\n   * @return {*} The item at the back of the queue if it is not empty, `undefined` otherwise.\n   */\n  back() {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyTail.next.value;\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length() {\n    return this._length;\n  }\n}",
    "ts": "export default function topologicalSort(\n  graph: Record<string, Array<string>>,\n): Array<string> {\n  throw 'Not implemented!';\n}\n\n// `Queue` data structure is provided in case you want to use it.\nclass Node<T> {\n  value: T | undefined;\n  next: Node<T> | null;\n  prev: Node<T> | null;\n\n  constructor(value?: T) {\n    this.value = value;\n    this.next = null;\n    this.prev = null;\n  }\n}\n\nclass Queue<T> {\n  _dummyHead: Node<T>;\n  _dummyTail: Node<T>;\n  _length: number;\n\n  constructor() {\n    this._dummyHead = new Node<T>();\n    this._dummyTail = new Node<T>();\n    this._dummyHead.prev = this._dummyTail;\n    this._dummyTail.next = this._dummyHead;\n    this._length = 0;\n  }\n\n  /**\n   * Adds an item to the back of the queue.\n   */\n  enqueue(item: T) {\n    const node = new Node(item);\n    const prevLast = this._dummyTail.next;\n    prevLast!.prev = node;\n\n    node.next = prevLast;\n    node.prev = this._dummyTail;\n    this._dummyTail.next = node;\n    this._length++;\n    return this._length;\n  }\n\n  /**\n   * Remove an item from the front of the queue.\n   */\n  dequeue(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const node = this._dummyHead.prev;\n    const newFirst = node!.prev;\n    this._dummyHead.prev = newFirst;\n    newFirst!.next = this._dummyHead;\n    // Unlink the node to be dequeued.\n    node!.prev = null;\n    node!.next = null;\n    this._length--;\n    return node!.value;\n  }\n\n  /**\n   * Determines if the queue is empty.\n   */\n  isEmpty(): boolean {\n    return this._length === 0;\n  }\n\n  /**\n   * Returns the item at the front of the queue without removing it from the queue.\n   */\n  front(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyHead.prev!.value;\n  }\n\n  /**\n   * Returns the item at the back of the queue without removing it from the queue it.\n   */\n  back(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    return this._dummyTail.next!.value;\n  }\n\n  /**\n   * Returns the number of items in the queue.\n   * @return {number} The number of items in the queue.\n   */\n  length(): number {\n    return this._length;\n  }\n}"
  },
  "workspace": {
    "main": "/src/topological-sort.ts",
    "run": "/src/topological-sort.run.test.ts",
    "submit": "/src/topological-sort.submit.test.ts"
  }
}