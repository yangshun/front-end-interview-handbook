{
  "description": "var Component=(()=>{var u=Object.create;var i=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var x=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),y=(r,e)=>{for(var t in e)i(r,t,{get:e[t],enumerable:!0})},o=(r,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!f.call(r,a)&&a!==t&&i(r,a,{get:()=>e[a],enumerable:!(l=v(e,a))||l.enumerable});return r};var j=(r,e,t)=>(t=r!=null?u(g(r)):{},o(e||!r||!r.__esModule?i(t,\"default\",{value:r,enumerable:!0}):t,r)),M=r=>o(i({},\"__esModule\",{value:!0}),r);var d=x((E,s)=>{s.exports=_jsx_runtime});var D={};y(D,{default:()=>I,frontmatter:()=>b});var n=j(d());var c=MDXTestExamples;var p=[{input:[[\"intervals\",[[1,5],[6,10],[11,15]]]],output:[[1,5],[6,10],[11,15]],explanation:\"None of the intervals overlap, so they remain the same.\"},{input:[[\"intervals\",[[1,3],[3,5]]]],output:[[1,5]],explanation:\"Intervals [1,3] and [3,5] are considered overlapping and are therefore are merged into [1,5].\"},{input:[[\"intervals\",[[1,5],[2,4],[4,6],[7,8]]]],output:[[1,6],[7,8]],explanation:\"Intervals [1,5], [2,4] and [4,6] are considered overlapping and are therefore merged into [1,6].\"}];var b={title:\"Merge Overlapping Intervals\",excerpt:\"Implement a function to merge overlapping intervals\"};function h(r){let e=Object.assign({p:\"p\",code:\"code\",strong:\"strong\",h3:\"h3\",ul:\"ul\",li:\"li\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of \",(0,n.jsx)(e.code,{children:\"intervals\"}),\" where each interval is represented as \",(0,n.jsx)(e.code,{children:\"[start, end]\"}),\". Each pair denotes the start and end of an interval on a number line. For example, \",(0,n.jsx)(e.code,{children:\"[1, 3]\"}),\" represents an interval that starts at 1 and ends at 3.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Merge all overlapping intervals\"}),\" in the array and return an array of \",(0,n.jsx)(e.strong,{children:\"non-overlapping intervals\"}),\" that fully cover the ranges specified by the input intervals.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"intervals: Array<[number, number]>\"}),\": An array of integer pairs\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:p}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"intervals.length\"}),\" <= 100\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"intervals[i].length\"}),\" == 2\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"start\"}),\" <= \",(0,n.jsx)(e.code,{children:\"end\"}),\" <= 10,000\"]}),`\n`]})]})}function C(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var I=C;return M(D);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to merge overlapping intervals",
    "title": "Merge Overlapping Intervals"
  },
  "solution": "var Component=(()=>{var g=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var y=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),I=(r,e)=>{for(var t in e)a(r,t,{get:e[t],enumerable:!0})},s=(r,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!b.call(r,i)&&i!==t&&a(r,i,{get:()=>e[i],enumerable:!(l=u(e,i))||l.enumerable});return r};var x=(r,e,t)=>(t=r!=null?g(f(r)):{},s(e||!r||!r.__esModule?a(t,\"default\",{value:r,enumerable:!0}):t,r)),w=r=>s(a({},\"__esModule\",{value:!0}),r);var h=y((D,d)=>{d.exports=_jsx_runtime});var M={};I(M,{default:()=>j});var n=x(h());var o=MDXCodeBlock;var c=`export default function mergeOverlappingIntervals(\n  intervals: number[][],\n): number[][] {\n  // Sort the intervals by their starting points\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  // Initialize an array to hold the merged intervals\n  let merged: number[][] = [];\n\n  // Iterate through each interval\n  for (let interval of intervals) {\n    // If the merged list is empty or the current interval does not overlap with the previous, append it\n    if (merged.length === 0 || merged[merged.length - 1][1] < interval[0]) {\n      merged.push(interval);\n    }\n    // Otherwise, there is overlap, so merge the current and previous intervals\n    else {\n      merged[merged.length - 1][1] = Math.max(\n        merged[merged.length - 1][1],\n        interval[1],\n      );\n    }\n  }\n\n  // Return the merged intervals\n  return merged;\n}\n`;var m=`const overlap = (a: number[], b: number[]): boolean => {\n  return a[0] <= b[1] && b[0] <= a[1];\n};\n\nconst buildGraph = (intervals: number[][]): Map<number[], number[][]> => {\n  let graph: Map<number[], number[][]> = new Map();\n  // Iterate through each pair of intervals\n  for (let i = 0; i < intervals.length; i++) {\n    for (let j = i + 1; j < intervals.length; j++) {\n      // If intervals overlap, add an edge in the graph\n      if (overlap(intervals[i], intervals[j])) {\n        if (graph.has(intervals[i])) {\n          graph.get(intervals[i])?.push(intervals[j]);\n        } else {\n          graph.set(intervals[i], [intervals[j]]);\n        }\n        if (graph.has(intervals[j])) {\n          graph.get(intervals[j])?.push(intervals[i]);\n        } else {\n          graph.set(intervals[j], [intervals[i]]);\n        }\n      }\n    }\n  }\n  return graph;\n};\n\nconst mergeNodes = (nodes: number[][]): number[] => {\n  let minStart: number = Infinity;\n  let maxEnd: number = -Infinity;\n  // Find the minimum start and maximum end among the nodes\n  for (let node of nodes) {\n    minStart = Math.min(minStart, node[0]);\n    maxEnd = Math.max(maxEnd, node[1]);\n  }\n  return [minStart, maxEnd];\n};\n\nconst markComponentDFS = (\n  start: number[],\n  graph: Map<number[], number[][]>,\n  nodesInComp: Record<number, number[][]>,\n  compNumber: number,\n  visited: Set<number[]>,\n): void => {\n  let stack: number[][] = [start];\n  // Perform DFS\n  while (stack.length) {\n    let node: number[] | undefined = stack.pop();\n    if (node && !visited.has(node)) {\n      visited.add(node);\n      if (nodesInComp[compNumber]) {\n        nodesInComp[compNumber].push(node);\n      } else {\n        nodesInComp[compNumber] = [node];\n      }\n      // Add all unvisited neighbors to the stack\n      if (graph.has(node)) {\n        for (let child of graph.get(node) as number[][]) {\n          stack.push(child);\n        }\n      }\n    }\n  }\n};\n\n// Main function to merge all overlapping intervals\nexport default function mergeOverlappingIntervals(\n  intervals: number[][],\n): number[][] {\n  // Build the graph\n  let graph: Map<number[], number[][]> = buildGraph(intervals);\n  let nodesInComp: Record<number, number[][]> = {};\n  let visited: Set<number[]> = new Set();\n  let compNumber: number = 0;\n  // Perform DFS to find all connected components\n  for (let interval of intervals) {\n    if (!visited.has(interval)) {\n      markComponentDFS(interval, graph, nodesInComp, compNumber, visited);\n      compNumber++;\n    }\n  }\n  let merged: number[][] = [];\n  // Merge each connected component\n  for (let comp = 0; comp < compNumber; comp++) {\n    merged.push(mergeNodes(nodesInComp[comp]));\n  }\n  return merged;\n}\n`;function p(r){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Sorting\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem involves merging overlapping intervals into a single interval for each overlap group. The approach uses sorting to ensure the intervals are processed in ascending order of their start times. By iterating through the sorted intervals, overlaps can be detected and merged efficiently.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Sorting the intervals by their start times ensures that all potential overlaps appear consecutively, reducing unnecessary comparisons. Without sorting, a brute force approach would involve comparing every interval with all others, leading to duplicated work and inefficiency. The bottleneck in the brute force approach lies in these redundant comparisons, which sorting eliminates. After sorting, a single pass through the intervals is sufficient to merge overlaps by comparing the current interval with the last merged interval.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Sort the \",(0,n.jsx)(e.code,{children:\"intervals\"}),\" array by the starting points of each interval in ascending order.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an empty array \",(0,n.jsx)(e.code,{children:\"merged\"}),\" to store the merged intervals.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through each interval in the sorted array:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the \",(0,n.jsx)(e.code,{children:\"merged\"}),\" array is empty or the current interval does not overlap with the last interval in \",(0,n.jsx)(e.code,{children:\"merged\"}),\", append the current interval to \",(0,n.jsx)(e.code,{children:\"merged\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If there is an overlap, update the end time of the last interval in \",(0,n.jsx)(e.code,{children:\"merged\"}),\" to the maximum of its current end time and the end time of the current interval.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the \",(0,n.jsx)(e.code,{children:\"merged\"}),\" array containing all merged intervals.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:c}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Sorting the intervals takes O(n log n), and the subsequent iteration through the intervals takes O(n).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"merged\"}),\" array can hold up to all intervals in the worst case if no intervals overlap.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Connected Components\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem of merging overlapping intervals can be approached using the concept of connected components from graph theory. Each interval is treated as a node in a graph, and an edge is created between two nodes if their corresponding intervals overlap. The goal is to identify all connected components in this graph, where each component represents a group of overlapping intervals. Each component can then be merged into a single interval.\"}),`\n`,(0,n.jsx)(e.p,{children:\"By building a graph of connected intervals and using a depth-first search (DFS) to identify connected components, the process becomes structured and avoids unnecessary comparisons. Once the components are identified, merging them is straightforward as it involves finding the minimum start and maximum end among all intervals in the component.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Define a helper function \",(0,n.jsx)(e.code,{children:\"overlap\"}),\" to check if two intervals overlap by comparing their start and end points.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Build a graph using the \",(0,n.jsx)(e.code,{children:\"buildGraph\"}),\" function:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Iterate through all pairs of intervals.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If two intervals overlap, add an edge between their corresponding nodes in the graph.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a \",(0,n.jsx)(e.code,{children:\"mergeNodes\"}),\" function to merge all intervals within a connected component by finding the minimum start and maximum end points.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Implement the \",(0,n.jsx)(e.code,{children:\"markComponentDFS\"}),\" function to perform DFS:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Start with a node and mark all connected nodes as part of the same component.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Use a stack to explore all neighbors recursively.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"In the main function:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Build the graph of intervals using \",(0,n.jsx)(e.code,{children:\"buildGraph\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Use DFS to identify all connected components and group intervals into components.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Merge each component into a single interval using \",(0,n.jsx)(e.code,{children:\"mergeNodes\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the merged intervals.\"}),`\n`]}),`\n`,(0,n.jsx)(o,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". Building the graph requires comparing every pair of intervals, resulting in O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\") operations.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsxs)(e.strong,{children:[\"Space complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". The graph can have up to O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\") edges in the worst case, and the \",(0,n.jsx)(e.code,{children:\"visited\"}),\" set and \",(0,n.jsx)(e.code,{children:\"nodesInComp\"}),\" storage scale with the number of intervals.\"]}),`\n`]}),`\n`]})]})}function k(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(p,r)})):p(r)}var j=k;return w(M);})();\n;return Component;"
}