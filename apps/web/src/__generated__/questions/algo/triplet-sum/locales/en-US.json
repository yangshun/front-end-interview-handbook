{
  "description": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var j=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},u=(t,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of b(e))!f.call(t,i)&&i!==r&&s(t,i,{get:()=>e[i],enumerable:!(l=p(e,i))||l.enumerable});return t};var T=(t,e,r)=>(r=t!=null?h(x(t)):{},u(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>u(s({},\"__esModule\",{value:!0}),t);var c=j((O,o)=>{o.exports=_jsx_runtime});var X={};g(X,{default:()=>D,frontmatter:()=>C});var n=T(c());var d=MDXTestExamples;var a=[{input:[[\"numbers\",[-1,0,1,2,-1,-4]]],output:[[-1,-1,2],[-1,0,1]],explanation:\"numbers[0] + numbers[1] + numbers[2] = (-1) + 0 + 1 = 0. numbers[1] + numbers[2] + numbers[4] = 0 + 1 + (-1) = 0. numbers[0] + numbers[3] + numbers[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]\"},{input:[[\"numbers\",[0,0,0]]],output:[[0,0,0]],explanation:\"The only possible triplet adds up to 0\"},{input:[[\"numbers\",[1,0,0]]],output:[],explanation:\"The only possible triplet does not add up to 0\"}];var C={title:\"Triplet Sum\",excerpt:\"Implement a function to find all unique triplets with distinct indices that sum to 0\"};function m(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an integer array \",(0,n.jsx)(e.code,{children:\"numbers\"}),\", return all triplets \",(0,n.jsx)(e.code,{children:\"[numbers[i], numbers[j], numbers[k]]\"}),\" such that \",(0,n.jsx)(e.code,{children:\"i\"}),\", \",(0,n.jsx)(e.code,{children:\"j\"}),\", and \",(0,n.jsx)(e.code,{children:\"k\"}),\" are distinct indices and their values sum to 0. Ensure that the solution set contains no duplicate triplets.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Output should be in sorted order\"}),`\n`]}),`\n`,(0,n.jsx)(d,{testCases:a}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"3 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10,000 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 10,000\"]}),`\n`]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var D=M;return _(X);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find all unique triplets with distinct indices that sum to 0",
    "title": "Triplet Sum"
  },
  "solution": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),j=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},h=(t,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of b(e))!k.call(t,i)&&i!==r&&o(t,i,{get:()=>e[i],enumerable:!(l=f(e,i))||l.enumerable});return t};var S=(t,e,r)=>(r=t!=null?p(g(t)):{},h(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>h(o({},\"__esModule\",{value:!0}),t);var a=y((I,c)=>{c.exports=_jsx_runtime});var O={};j(O,{default:()=>q});var n=S(a());var s=MDXCodeBlock;var d=`export default function tripletSum(numbers: number[]): number[][] {\n  const ans: number[][] = [];\n\n  // Sort the input array for efficient two-pointer search\n  numbers.sort((a, b) => a - b);\n\n  for (let i = 0; i < numbers.length - 2; i++) {\n    // Skip duplicates: only consider unique starting elements (i)\n    if (i > 0 && numbers[i] === numbers[i - 1]) continue;\n\n    // Two-pointer approach for remaining elements (j & k)\n    let j = i + 1;\n    let k = numbers.length - 1;\n\n    while (j < k) {\n      const sum = numbers[i] + numbers[j] + numbers[k];\n\n      if (sum === 0) {\n        // Found a triplet, add it to the answer\n        ans.push([numbers[i], numbers[j], numbers[k]]);\n\n        // Move pointers to skip duplicates\n        do {\n          j++;\n        } while (j < k && numbers[j] === numbers[j - 1]);\n        do {\n          k--;\n        } while (j < k && numbers[k] === numbers[k + 1]);\n      } else if (sum < 0) {\n        // Move j forward to search for a larger positive number\n        j++;\n      } else {\n        // Move k backward to search for a smaller negative number\n        k--;\n      }\n    }\n  }\n\n  return ans;\n}\n`;var u=`export default function tripletSum(numbers: number[]): number[][] {\n  // Set to store unique triplets\n  const uniqueTriplets = new Set<string>();\n  const n = numbers.length;\n\n  // Iterate through the array to find triplets\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      for (let k = j + 1; k < n; k++) {\n        // Check if the sum of three numbers is zero\n        if (numbers[i] + numbers[j] + numbers[k] === 0) {\n          // Sort the triplet to maintain order\n          const triplet = [numbers[i], numbers[j], numbers[k]].sort(\n            (a, b) => a - b,\n          );\n          // Convert to string for set storage\n          uniqueTriplets.add(JSON.stringify(triplet));\n        }\n      }\n    }\n  }\n  // result should be in sorted order as mentioned in the description.\n  const result: number[][] = Array.from(uniqueTriplets)\n    .map((triplet) => JSON.parse(triplet))\n    .sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);\n\n  return result;\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute force\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The goal is to find all unique triplets in an array that sum up to zero. The approach is to use three nested loops to explore every combination of three numbers. Each combination is checked to see if it sums to zero. A \",(0,n.jsx)(e.code,{children:\"Set\"}),\" is used to store the unique triplets by converting them into strings, ensuring that duplicates are avoided. Sorting the triplets helps maintain order and ensures that duplicates are detected correctly when added to the \",(0,n.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize a \",(0,n.jsx)(e.code,{children:\"Set\"}),\" to store unique triplets.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the array with three nested loops:\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The outermost loop fixes the first number of the triplet.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The second loop fixes the second number of the triplet.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The innermost loop selects the third number of the triplet.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"For each combination of three numbers, check if their sum is equal to zero.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the sum is zero, sort the triplet to maintain order and convert it into a string to store in the \",(0,n.jsx)(e.code,{children:\"Set\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After completing the iterations, convert the \",(0,n.jsx)(e.code,{children:\"Set\"}),\" back to an array of arrays by parsing the stored strings.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Sort the resulting array of triplets to meet the requirements for ordered results.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Return the sorted array of triplets.\"}),`\n`]}),`\n`,(0,n.jsx)(s,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"3\"}),\")\"]}),\". The three nested loops iterate through all possible combinations of three numbers in the array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(k)\"}),\". The \",(0,n.jsx)(e.code,{children:\"Set\"}),\" used for storing unique triplets and the resulting array require space proportional to the number of unique triplets, which is \",(0,n.jsx)(e.code,{children:\"k\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Two pointers\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The two-pointer approach improves upon the brute force solution by reducing unnecessary computations. Sorting the array enables efficient searching for triplets that sum to zero by using two pointers (\",(0,n.jsx)(e.code,{children:\"j\"}),\" and \",(0,n.jsx)(e.code,{children:\"k\"}),\") that move towards each other based on the current sum. This eliminates the need for a third nested loop and avoids redundant checks through duplicate skipping. By focusing on pairs of numbers that complement a fixed starting element (\",(0,n.jsx)(e.code,{children:\"i\"}),\"), the solution significantly reduces time complexity.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Sort the input array in ascending order to allow efficient two-pointer traversal.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an empty array \",(0,n.jsx)(e.code,{children:\"ans\"}),\" to store the triplets.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the sorted array with index \",(0,n.jsx)(e.code,{children:\"i\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Skip duplicate elements to ensure that each starting element is unique.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set two pointers: \",(0,n.jsx)(e.code,{children:\"j\"}),\" at the index after \",(0,n.jsx)(e.code,{children:\"i\"}),\", and \",(0,n.jsx)(e.code,{children:\"k\"}),\" at the last index of the array.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"While \",(0,n.jsx)(e.code,{children:\"j\"}),\" is less than \",(0,n.jsx)(e.code,{children:\"k\"}),\":\",`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Compute the sum of \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\", \",(0,n.jsx)(e.code,{children:\"numbers[j]\"}),\", and \",(0,n.jsx)(e.code,{children:\"numbers[k]\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the sum equals zero:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Add the triplet \",(0,n.jsx)(e.code,{children:\"[numbers[i], numbers[j], numbers[k]]\"}),\" to \",(0,n.jsx)(e.code,{children:\"ans\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Move \",(0,n.jsx)(e.code,{children:\"j\"}),\" forward and \",(0,n.jsx)(e.code,{children:\"k\"}),\" backward, skipping duplicate elements.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the sum is less than zero, increment \",(0,n.jsx)(e.code,{children:\"j\"}),\" to increase the sum.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the sum is greater than zero, decrement \",(0,n.jsx)(e.code,{children:\"k\"}),\" to decrease the sum.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the \",(0,n.jsx)(e.code,{children:\"ans\"}),\" array containing all unique triplets.\"]}),`\n`]}),`\n`,(0,n.jsx)(s,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". Sorting the array takes O(n log n), and the two-pointer traversal for each element takes O(n), resulting in O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The solution uses a constant amount of extra space apart from the output array.\"]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var q=T;return w(O);})();\n;return Component;"
}