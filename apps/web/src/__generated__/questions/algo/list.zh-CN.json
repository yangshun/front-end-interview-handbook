[
  {
    "info": {
      "excerpt": "实现一个函数来确定一个字符串是否包含平衡的括号",
      "title": "平衡括号"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722729600,
      "difficulty": "easy",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-balanced-brackets",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-balanced-brackets",
      "subtitle": null,
      "topics": [
        "array",
        "stack"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来检查数组中是否有任何重复的数字",
      "title": "查找数组中的重复项"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718409600,
      "difficulty": "easy",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-find-duplicate",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-find-duplicate",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找已排序数组中缺失的元素",
      "title": "查找序列中缺失的数字"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "easy",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-find-missing-number-in-sequence",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-find-missing-number-in-sequence",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找具有最大乘积的子数组",
      "title": "连续数组中的最大乘积"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718236800,
      "difficulty": "medium",
      "duration": 30,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-maximum-product-contiguous",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-maximum-product-contiguous",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找具有最大和的子数组",
      "title": "连续数组中的最大和"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718841600,
      "difficulty": "medium",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-maximum-sum-contiguous",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-maximum-sum-contiguous",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来确定整数数组中最常见的元素",
      "title": "最常见的元素"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724889600,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-most-common-elements",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-most-common-elements",
      "subtitle": null,
      "topics": [
        "array",
        "heap"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，找到数组中除当前元素之外的所有元素的乘积。",
      "title": "数组的乘积，不包含当前元素"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718496000,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-product-excluding-current",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-product-excluding-current",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来确定数组的末端是否可达",
      "title": "数组末端可达"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1720828800,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-reachable-end",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-reachable-end",
      "subtitle": null,
      "topics": [
        "array",
        "dynamic-programming",
        "greedy"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，在旋转排序数组中查找一个整数",
      "title": "在旋转数组中查找元素"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "medium",
      "duration": 30,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-rotated-find",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-rotated-find",
      "subtitle": null,
      "topics": [
        "array",
        "binary-search"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，找到旋转排序数组中的最小元素",
      "title": "旋转排序数组中的最小元素"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "medium",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/array-smallest-in-rotated",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "array-smallest-in-rotated",
      "subtitle": null,
      "topics": [
        "array",
        "binary-search"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个对数字数组执行二分查找的函数",
      "title": "二分查找"
    },
    "metadata": {
      "access": "standard",
      "author": null,
      "companies": [],
      "created": 1671667200,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-search",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [
        "selection-sort",
        "quick-sort",
        "merge-sort",
        "depth-first-search",
        "breadth-first-search"
      ],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-search",
      "subtitle": null,
      "topics": [
        "binary-search",
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个二叉搜索树数据结构，包括基本的 BST 操作",
      "title": "二叉搜索树"
    },
    "metadata": {
      "access": "standard",
      "author": null,
      "companies": [],
      "created": 1745539200,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-search-tree",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "heap",
        "binary-search"
      ],
      "slug": "binary-search-tree",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "binary-search-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于查找 BST 中第 k 个最小的节点",
      "title": "二叉搜索树第 K 小的元素"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724284800,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-search-tree-kth-smallest",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-search-tree-kth-smallest",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "binary-search-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，以找到二叉搜索树中的 LCA",
      "title": "二叉搜索树的最低公共祖先"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724284800,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-search-tree-lowest-common-ancestor",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-search-tree-lowest-common-ancestor",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "binary-search-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来验证二叉树是否为有效的二叉搜索树",
      "title": "验证二叉搜索树"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724284800,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-search-tree-validate",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-search-tree-validate",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "binary-search-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个二叉树数据结构，包括基本操作",
      "title": "二叉树"
    },
    "metadata": {
      "access": "standard",
      "author": null,
      "companies": [],
      "created": 1716422400,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "binary-search-tree",
        "binary-search"
      ],
      "slug": "binary-tree",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来确定两个二叉树是否相等",
      "title": "二叉树相等"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723161600,
      "difficulty": "easy",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree-equal",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-tree-equal",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来翻转二叉树中的节点",
      "title": "翻转二叉树"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723766400,
      "difficulty": "easy",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree-flip",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-tree-flip",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找二叉树的层序遍历",
      "title": "二叉树层序遍历"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723161600,
      "difficulty": "medium",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree-level-order-traversal",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-tree-level-order-traversal",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找二叉树的最大深度",
      "title": "二叉树的最大深度"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723161600,
      "difficulty": "easy",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree-maximum-depth",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-tree-maximum-depth",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，以找到二叉树路径中节点的最大总和",
      "title": "二叉树最大路径和"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724112000,
      "difficulty": "hard",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree-maximum-total-path",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-tree-maximum-total-path",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个从先序和中序遍历构造二叉树的函数",
      "title": "通过先序和中序遍历重建二叉树"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724889600,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree-rebuilding-from-traversals",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-tree-rebuilding-from-traversals",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个序列化和反序列化二叉树的函数",
      "title": "二叉树序列化和反序列化"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724889600,
      "difficulty": "hard",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree-serialization-deserialization",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-tree-serialization-deserialization",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来检查一个二叉树是否是另一个二叉树的子树",
      "title": "二叉树子树"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723852800,
      "difficulty": "easy",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/binary-tree-subtree",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "binary-tree-subtree",
      "subtitle": null,
      "topics": [
        "binary-tree",
        "tree"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于查找从 0 到 n 的设置位数量",
      "title": "位计数"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "easy",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/bit-counting",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "bit-counting",
      "subtitle": null,
      "topics": [
        "binary"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来翻转给定数字中的位顺序",
      "title": "位翻转"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "easy",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/bit-reversal",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "bit-reversal",
      "subtitle": null,
      "topics": [
        "binary"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个广度优先搜索算法，该算法以广度优先的方式遍历有向图",
      "title": "广度优先搜索"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [],
      "created": 1679788800,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/breadth-first-search",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "depth-first-search"
      ],
      "slug": "breadth-first-search",
      "subtitle": null,
      "topics": [
        "bfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个执行冒泡排序的函数",
      "title": "冒泡排序"
    },
    "metadata": {
      "access": "standard",
      "author": null,
      "companies": [],
      "created": 1745539200,
      "difficulty": "easy",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/bubble-sort",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [
        "quick-sort"
      ],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "insertion-sort",
        "selection-sort"
      ],
      "slug": "bubble-sort",
      "subtitle": null,
      "topics": [
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，返回组成给定金额所需的最少硬币数",
      "title": "找零所需的最少硬币数"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1733616000,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/coin-change",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "coin-change",
      "subtitle": null,
      "topics": [
        "dynamic-programming"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来计算总和为目标值的组合",
      "title": "目标和的组合"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1720310400,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/combinations-target-sum",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "combinations-target-sum",
      "subtitle": null,
      "topics": [
        "dynamic-programming"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找给定整数的二进制表示中的设置位",
      "title": "计算二进制数中的设置位"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "easy",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/count-ones-in-binary",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "count-ones-in-binary",
      "subtitle": null,
      "topics": [
        "binary"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于检查在给定先决条件的情况下是否可以完成所有课程",
      "title": "课程依赖"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1721260800,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/course-dependency",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "course-dependency",
      "subtitle": null,
      "topics": [
        "graph",
        "topological-sort",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个深度优先搜索算法，以深度优先的方式遍历有向图",
      "title": "深度优先搜索"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [],
      "created": 1671667200,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/depth-first-search",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "breadth-first-search"
      ],
      "slug": "depth-first-search",
      "subtitle": null,
      "topics": [
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现 Dijkstra 算法，以找到图中从源顶点开始的最短路径，该图表示为邻接表。",
      "title": "Dijkstra 算法"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [],
      "created": 1745539200,
      "difficulty": "medium",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/dijkstra",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "depth-first-search"
      ],
      "slug": "dijkstra",
      "subtitle": null,
      "topics": [
        "dfs",
        "graph"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，以确定需要移除的最小数量，以获得不重叠的区间",
      "title": "不相交的区间"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722384000,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/disjoint-intervals",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "disjoint-intervals",
      "subtitle": null,
      "topics": [
        "intervals",
        "greedy"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来验证并返回外星语言的字母表顺序",
      "title": "外星语言"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722384000,
      "difficulty": "hard",
      "duration": 55,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/extraterrestrial-language",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "extraterrestrial-language",
      "subtitle": null,
      "topics": [
        "graph",
        "topological-sort"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，深度克隆一个连通的无向图",
      "title": "图的克隆"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1721260800,
      "difficulty": "medium",
      "duration": 50,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/graph-clone",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "graph-clone",
      "subtitle": null,
      "topics": [
        "graph",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来计算图中连通分量的数量",
      "title": "图计算连通分量"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1721779200,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/graph-count-connected-components",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "graph-count-connected-components",
      "subtitle": null,
      "topics": [
        "graph",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来确定一个图是否为有效的树",
      "title": "图是否为树"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1721779200,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/graph-is-tree",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "graph-is-tree",
      "subtitle": null,
      "topics": [
        "graph",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来计算二维二进制网格中不同的岛屿数量",
      "title": "计算网格中的岛屿数量"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1721001600,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/grid-count-islands",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "grid-count-islands",
      "subtitle": null,
      "topics": [
        "matrix",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来计算机器人移动在 m x n 网格中的不同路径",
      "title": "网格中的不同路径"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1720742400,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/grid-distinct-paths",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "grid-distinct-paths",
      "subtitle": null,
      "topics": [
        "dynamic-programming"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来检查单词在网格中是否存在",
      "title": "在网格中查找单词"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722729600,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/grid-find-word",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "grid-find-word",
      "subtitle": null,
      "topics": [
        "matrix",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于查找网格中存在的所有单词",
      "title": "在网格中查找单词"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724976000,
      "difficulty": "hard",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/grid-find-words",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "grid-find-words",
      "subtitle": null,
      "topics": [
        "matrix",
        "tree",
        "trie"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个包含基本堆操作的堆数据结构",
      "title": "堆"
    },
    "metadata": {
      "access": "standard",
      "author": null,
      "companies": [],
      "created": 1745539200,
      "difficulty": "hard",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/heap",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [
        "heap-sort"
      ],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "binary-search-tree"
      ],
      "slug": "heap",
      "subtitle": null,
      "topics": [
        "heap"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个执行堆排序的函数",
      "title": "堆排序"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [],
      "created": 1673395200,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/heap-sort",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [
        "quick-sort"
      ],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "selection-sort"
      ],
      "slug": "heap-sort",
      "subtitle": null,
      "topics": [
        "heap",
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个执行插入排序的函数",
      "title": "插入排序"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [],
      "created": 1671667200,
      "difficulty": "easy",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/insertion-sort",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [
        "quick-sort"
      ],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "selection-sort"
      ],
      "slug": "insertion-sort",
      "subtitle": null,
      "topics": [
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个合并重叠区间的函数",
      "title": "合并重叠区间"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722384000,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/intervals-combine-overlapping",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "intervals-combine-overlapping",
      "subtitle": null,
      "topics": [
        "intervals",
        "sorting",
        "dfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来检查是否可以参加所有会议",
      "title": "会议日历"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1721779200,
      "difficulty": "easy",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/intervals-meeting-calendar",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "intervals-meeting-calendar",
      "subtitle": null,
      "topics": [
        "intervals",
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，将一个新区间插入给定的区间中",
      "title": "合并新区间"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722384000,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/intervals-merge-new",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "intervals-merge-new",
      "subtitle": null,
      "topics": [
        "binary-search",
        "intervals",
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找所需的最少会议室数量",
      "title": "所需最少会议室"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722038400,
      "difficulty": "medium",
      "duration": 55,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/intervals-minimum-meeting-rooms",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "intervals-minimum-meeting-rooms",
      "subtitle": null,
      "topics": [
        "heap",
        "intervals"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个包含常见链表方法的链表数据结构",
      "title": "链表"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [],
      "created": 1745539200,
      "difficulty": "medium",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/linked-list",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "stack",
        "queue"
      ],
      "slug": "linked-list",
      "subtitle": null,
      "topics": [
        "linked-list"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个合并 k 个已排序链表的函数",
      "title": "链表合并 K 个已排序列表"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722297600,
      "difficulty": "hard",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/linked-list-combine-k-sorted",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "linked-list-combine-k-sorted",
      "subtitle": null,
      "topics": [
        "linked-list",
        "heap"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来合并两个已排序的链表",
      "title": "链表合并两个已排序的列表"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722038400,
      "difficulty": "easy",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/linked-list-combine-two-sorted",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "linked-list-combine-two-sorted",
      "subtitle": null,
      "topics": [
        "linked-list"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于删除链表倒数第 n 个节点",
      "title": "删除链表倒数第 N 个节点"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722297600,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/linked-list-delete-nth-from-end",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "linked-list-delete-nth-from-end",
      "subtitle": null,
      "topics": [
        "linked-list"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来检测链表中是否有环",
      "title": "链表检测环"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "easy",
      "duration": 30,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/linked-list-detect-cycle",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "linked-list-detect-cycle",
      "subtitle": null,
      "topics": [
        "linked-list"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来重新排列链表中的节点",
      "title": "重排链表"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722297600,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/linked-list-rearrange",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "linked-list-rearrange",
      "subtitle": null,
      "topics": [
        "linked-list"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个反转链表的函数",
      "title": "链表反转"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722038400,
      "difficulty": "easy",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/linked-list-reversal",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "linked-list-reversal",
      "subtitle": null,
      "topics": [
        "linked-list"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找两个字符串中最长的公共子序列",
      "title": "最长公共子序列"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1719705600,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/longest-common-subsequence",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "longest-common-subsequence",
      "subtitle": null,
      "topics": [
        "array",
        "dynamic-programming"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找最长连续数字序列的长度",
      "title": "最长连续数字序列"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1721606400,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/longest-consecutive-number-sequence",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "longest-consecutive-number-sequence",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找最长递增子序列的长度",
      "title": "最长递增子序列"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1733616000,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/longest-increasing-subsequence",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "longest-increasing-subsequence",
      "subtitle": null,
      "topics": [
        "array",
        "binary-search",
        "greedy"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找具有唯一字符的最长子串的长度",
      "title": "最长不重复子串"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723161600,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/longest-non-repeating-substring",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "longest-non-repeating-substring",
      "subtitle": null,
      "topics": [
        "string"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找最长回文子串",
      "title": "查找最长回文子串"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723161600,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/longest-palindromic-substring",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "longest-palindromic-substring",
      "subtitle": null,
      "topics": [
        "string"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，在最多进行 k 次替换后，找到最长的统一子串",
      "title": "替换后最长重复子串"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723161600,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/longest-repeating-substring-after-replacements",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "longest-repeating-substring-after-replacements",
      "subtitle": null,
      "topics": [
        "string",
        "binary-search"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，将给定的矩阵旋转 90 度",
      "title": "矩阵旋转"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722038400,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/matrix-rotation",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "matrix-rotation",
      "subtitle": null,
      "topics": [
        "matrix"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，以螺旋顺序遍历矩阵",
      "title": "矩阵螺旋遍历"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": null,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/matrix-spiral-traversal",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "matrix-spiral-traversal",
      "subtitle": null,
      "topics": [
        "matrix"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个将矩阵的行和列设置为零的函数",
      "title": "矩阵置零"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722038400,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/matrix-zeroing",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "matrix-zeroing",
      "subtitle": null,
      "topics": [
        "matrix"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于查找墙壁数组中两个墙壁之间的最大蓄水体积",
      "title": "墙壁之间的最大蓄水"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718236800,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/maximum-water-between-walls",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "maximum-water-between-walls",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个执行递归归并排序的函数",
      "title": "归并排序"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [],
      "created": 1671667200,
      "difficulty": "medium",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/merge-sort",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "quick-sort"
      ],
      "slug": "merge-sort",
      "subtitle": null,
      "topics": [
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，找到在不惊动警察的情况下抢劫的最大金额",
      "title": "邻里盗窃"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1720828800,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/neighborhood-theft",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "neighborhood-theft",
      "subtitle": null,
      "topics": [
        "array",
        "dynamic-programming"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于在环形房屋中找到在不惊动警察的情况下抢劫的最大金额",
      "title": "邻里盗窃（环形）"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1720828800,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/neighborhood-theft-circular",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "neighborhood-theft-circular",
      "subtitle": null,
      "topics": [
        "array",
        "dynamic-programming"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来查找动态整数流的中位数",
      "title": "数字流的中位数"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724976000,
      "difficulty": "hard",
      "duration": 55,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/number-stream-median",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "number-stream-median",
      "subtitle": null,
      "topics": [
        "heap"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，返回可以流向两个大洋的单元格",
      "title": "海洋流动"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1721088000,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/ocean-flow",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "ocean-flow",
      "subtitle": null,
      "topics": [
        "graph",
        "dfs",
        "bfs"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，通过买入和卖出股票一次来找到可实现的最大利润",
      "title": "最佳股票交易"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718582400,
      "difficulty": "easy",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/optimal-stock-trading",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "optimal-stock-trading",
      "subtitle": null,
      "topics": [
        "array",
        "greedy"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于查找整数数组中两个相加等于目标整数的数字",
      "title": "Pair sum"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718236800,
      "difficulty": "easy",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/pair-sum",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "pair-sum",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个包含常见队列方法的队列数据结构",
      "title": "队列"
    },
    "metadata": {
      "access": "free",
      "author": "yangshun",
      "companies": [],
      "created": 1670457600,
      "difficulty": "medium",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/queue",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "stack"
      ],
      "slug": "queue",
      "subtitle": null,
      "topics": [
        "queue"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个执行递归快速排序的函数",
      "title": "快速排序"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [],
      "created": 1671667200,
      "difficulty": "medium",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/quick-sort",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "merge-sort"
      ],
      "slug": "quick-sort",
      "subtitle": null,
      "topics": [
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个执行选择排序的函数",
      "title": "选择排序"
    },
    "metadata": {
      "access": "standard",
      "author": null,
      "companies": [],
      "created": 1671667200,
      "difficulty": "easy",
      "duration": 10,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/selection-sort",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [
        "quick-sort"
      ],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "insertion-sort"
      ],
      "slug": "selection-sort",
      "subtitle": null,
      "topics": [
        "sorting"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个包含常见栈方法的栈数据结构",
      "title": "栈"
    },
    "metadata": {
      "access": "free",
      "author": "yangshun",
      "companies": [
        "amazon"
      ],
      "created": 1670025600,
      "difficulty": "easy",
      "duration": 10,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/stack",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [
        "queue"
      ],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "queue"
      ],
      "slug": "stack",
      "subtitle": null,
      "topics": [
        "stack"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，找到到达楼梯顶部的不同方式的数量",
      "title": "爬楼梯组合"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1719187200,
      "difficulty": "easy",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/staircase-climbing-combinations",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "staircase-climbing-combinations",
      "subtitle": null,
      "topics": [
        "dynamic-programming"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来确定两个字符串是否互为异位词",
      "title": "字符串异位词"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722729600,
      "difficulty": "easy",
      "duration": 15,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/string-anagram",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "string-anagram",
      "subtitle": null,
      "topics": [
        "string"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，将字符串数组分组为异位词",
      "title": "字符串异位词分组"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [
        "amazon"
      ],
      "created": 1723161600,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/string-anagram-groups",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "string-anagram-groups",
      "subtitle": null,
      "topics": [
        "string"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来计算解码数字字符串的方法",
      "title": "解码消息"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1720742400,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/string-decode-message",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "string-decode-message",
      "subtitle": null,
      "topics": [
        "string",
        "dynamic-programming"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来确定一个字符串是否是回文",
      "title": "字符串回文"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1722729600,
      "difficulty": "easy",
      "duration": 25,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/string-palindrome",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "string-palindrome",
      "subtitle": null,
      "topics": [
        "string"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来计算字符串中所有回文子串的数量",
      "title": "回文子串"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723161600,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/string-palindromic-substrings",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "string-palindromic-substrings",
      "subtitle": null,
      "topics": [
        "string"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数来检查一个字符串是否可以由字典中的单词组成",
      "title": "单词分割"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1720310400,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/string-segment-words",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "string-segment-words",
      "subtitle": null,
      "topics": [
        "string",
        "dynamic-programming",
        "graph"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，返回包含来自另一个字符串的所有字符（包括重复字符）的字符串的最小子字符串",
      "title": "包含字符的最短子字符串"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1723161600,
      "difficulty": "hard",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/string-shortest-substring-containing-characters",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "string-shortest-substring-containing-characters",
      "subtitle": null,
      "topics": [
        "string"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，无需使用 + 和 - 运算符即可找到两个整数的和",
      "title": "无加法求和"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/sum-without-addition",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "sum-without-addition",
      "subtitle": null,
      "topics": [
        "binary"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，用于查找具有冷却时间的任务的最小间隔",
      "title": "任务协调"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1725408000,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/task-coordination",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "task-coordination",
      "subtitle": null,
      "topics": [
        "greedy",
        "heap"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个执行拓扑排序的函数",
      "title": "拓扑排序"
    },
    "metadata": {
      "access": "free",
      "author": null,
      "companies": [
        "snap"
      ],
      "created": 1673395200,
      "difficulty": "medium",
      "duration": 20,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/topological-sort",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [
        "quick-sort"
      ],
      "published": true,
      "ranking": 100,
      "similarQuestions": [
        "selection-sort"
      ],
      "slug": "topological-sort",
      "subtitle": null,
      "topics": [
        "topological-sort",
        "graph"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个具有插入、搜索和以...开头功能的 trie 前缀树",
      "title": "Trie（前缀树）"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724976000,
      "difficulty": "medium",
      "duration": 40,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/trie-prefix-tree",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "trie-prefix-tree",
      "subtitle": null,
      "topics": [
        "tree",
        "trie"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个函数，找到所有和为 0 且索引不同的唯一三元组。",
      "title": "三元组之和"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1718928000,
      "difficulty": "medium",
      "duration": 35,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/triplet-sum",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "triplet-sum",
      "subtitle": null,
      "topics": [
        "array"
      ]
    }
  },
  {
    "info": {
      "excerpt": "实现一个可以添加单词并支持通配符搜索的数据结构",
      "title": "单词查找器"
    },
    "metadata": {
      "access": "standard",
      "author": "hiten",
      "companies": [],
      "created": 1724976000,
      "difficulty": "medium",
      "duration": 45,
      "featured": false,
      "format": "algo",
      "frameworkDefault": null,
      "frameworks": [],
      "href": "/questions/algo/word-finder",
      "importance": "low",
      "languages": [
        "js",
        "ts"
      ],
      "nextQuestions": [],
      "published": true,
      "ranking": 100,
      "similarQuestions": [],
      "slug": "word-finder",
      "subtitle": null,
      "topics": [
        "matrix",
        "graph",
        "trie"
      ]
    }
  }
]