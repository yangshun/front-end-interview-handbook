{
  "description": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var w=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),b=(e,n)=>{for(var r in n)i(e,r,{get:n[r],enumerable:!0})},o=(e,n,r,s)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let a of g(n))!x.call(e,a)&&a!==r&&i(e,a,{get:()=>n[a],enumerable:!(s=u(n,a))||s.enumerable});return e};var j=(e,n,r)=>(r=e!=null?p(f(e)):{},o(n||!e||!e.__esModule?i(r,\"default\",{value:e,enumerable:!0}):r,e)),v=e=>o(i({},\"__esModule\",{value:!0}),e);var l=w((T,c)=>{c.exports=_jsx_runtime});var M={};b(M,{default:()=>I,frontmatter:()=>_});var t=j(l());var d=MDXTestExamples;var h=[{input:[[\"str\",\"No 'x' in Nixon\"]],output:!0,explanation:\"After removing non-alphanumeric characters and converting to lowercase, the string becomes 'noxinnixon', which is a palindrome.\"},{input:[[\"str\",\"Was it a car or a cat I saw?\"]],output:!0,explanation:\"After removing non-alphanumeric characters and converting to lowercase, the string becomes 'wasitacaroracatisaw', which is a palindrome.\"},{input:[[\"str\",\"tab a cat\"]],output:!1,explanation:\"After removing non-alphanumeric characters and converting to lowercase, the string becomes 'tabacat', which is not a palindrome.\"}];var _={title:\"String Palindrome\",excerpt:\"Implement a function to determine if a string is a palindrome\"};function m(e){let n=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:[\"Given a string \",(0,t.jsx)(n.code,{children:\"str\"}),\", determine if it is a palindrome. Return \",(0,t.jsx)(n.code,{children:\"true\"}),\" if it is, and \",(0,t.jsx)(n.code,{children:\"false\"}),\" otherwise.\"]}),`\n`,(0,t.jsx)(n.p,{children:\"A string is a palindrome if, after changing all uppercase letters to lowercase and discarding all non-alphanumeric characters, it remains identical when read forward and backward. Alphanumeric characters consist of both letters and numbers.\"}),`\n`,(0,t.jsx)(n.h3,{children:\"Input\"}),`\n`,(0,t.jsxs)(n.ul,{children:[`\n`,(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:\"str: string\"}),\": A string\"]}),`\n`]}),`\n`,(0,t.jsx)(d,{testCases:h}),`\n`,(0,t.jsx)(n.h3,{children:\"Constraints\"}),`\n`,(0,t.jsxs)(n.ul,{children:[`\n`,(0,t.jsxs)(n.li,{children:[\"1 <= \",(0,t.jsx)(n.code,{children:\"str.length\"}),\" <= 1000\"]}),`\n`,(0,t.jsxs)(n.li,{children:[\"The string \",(0,t.jsx)(n.code,{children:\"str\"}),\" consists only of printable ASCII characters\"]}),`\n`]})]})}function C(e={}){let{wrapper:n}=e.components||{};return n?(0,t.jsx)(n,Object.assign({},e,{children:(0,t.jsx)(m,e)})):m(e)}var I=C;return v(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to determine if a string is a palindrome",
    "title": "String Palindrome"
  },
  "solution": "var Component=(()=>{var f=Object.create;var h=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var C=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var w=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var i in e)h(t,i,{get:e[i],enumerable:!0})},o=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let n of u(e))!v.call(t,n)&&n!==i&&h(t,n,{get:()=>e[n],enumerable:!(c=m(e,n))||c.enumerable});return t};var b=(t,e,i)=>(i=t!=null?f(C(t)):{},o(e||!t||!t.__esModule?h(i,\"default\",{value:t,enumerable:!0}):i,t)),j=t=>o(h({},\"__esModule\",{value:!0}),t);var l=w((z,s)=>{s.exports=_jsx_runtime});var k={};y(k,{default:()=>T});var r=b(l());var a=MDXCodeBlock;var d=`export default function isStringPalindrome(str: string): boolean {\n  // Initialize an empty string to store filtered characters\n  let filteredChars = '';\n\n  // Iterate through each character in the input string\n  for (let ch of str) {\n    // Check if the character is alphanumeric (a-z, A-Z, 0-9)\n    if (ch.match(/[a-z0-9]/i)) {\n      // Convert the character to lowercase and add it to the filteredChars string\n      filteredChars += ch.toLowerCase();\n    }\n  }\n\n  // Reverse the filtered characters string\n  const reversedChars = filteredChars.split('').reverse().join('');\n\n  // Compare the original filtered string with the reversed string\n  // If they are the same, it is a palindrome\n  return filteredChars === reversedChars;\n}\n`;var g=`export default function isStringPalindrome(str: string): boolean {\n  let i = 0; // Initialize the left pointer\n  let j = str.length - 1; // Initialize the right pointer\n\n  // Loop until the left pointer is less than the right pointer\n  while (i < j) {\n    // Move the left pointer to the right if the current character is not alphanumeric\n    while (i < j && !isLetterOrDigit(str.charAt(i))) {\n      i++;\n    }\n\n    // Move the right pointer to the left if the current character is not alphanumeric\n    while (i < j && !isLetterOrDigit(str.charAt(j))) {\n      j--;\n    }\n\n    // Compare the characters at the left and right pointers after converting to lowercase\n    if (str.charAt(i).toLowerCase() !== str.charAt(j).toLowerCase()) {\n      return false; // Return false if characters don't match\n    }\n\n    i++; // Move the left pointer to the right\n    j--; // Move the right pointer to the left\n  }\n\n  return true; // Return true if all characters match\n}\n\nfunction isLetterOrDigit(character: string): boolean {\n  const charCode = character.charCodeAt(0);\n  return (\n    (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) || // Check if character is a lowercase letter\n    (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) || // Check if character is an uppercase letter\n    (charCode >= '0'.charCodeAt(0) && charCode <= '9'.charCodeAt(0)) // Check if character is a digit\n  );\n}\n`;function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Comparing the Reverse Order\"}),`\n`,(0,r.jsx)(e.p,{children:\"The solution identifies whether a string is a palindrome by focusing only on its alphanumeric characters and ignoring case sensitivity. The key intuition is that a palindrome's sequence of characters must be identical when reversed. Therefore, this approach will reverse the input string and compare the reversed string with original string to check whether they are similar. To simplify the comparison, the solution preprocesses the string by filtering out non-alphanumeric characters and converting the remaining ones to lowercase. This creates a normalized version of the string, making the reverse comparison straightforward.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize an empty string \",(0,r.jsx)(e.code,{children:\"filteredChars\"}),\" to store alphanumeric characters in lowercase.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Iterate through each character of the input string:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If the character is alphanumeric, convert it to lowercase and append it to \",(0,r.jsx)(e.code,{children:\"filteredChars\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Reverse the \",(0,r.jsx)(e.code,{children:\"filteredChars\"}),\" string using \",(0,r.jsx)(e.code,{children:\"split\"}),\", \",(0,r.jsx)(e.code,{children:\"reverse\"}),\", and \",(0,r.jsx)(e.code,{children:\"join\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Compare the original \",(0,r.jsx)(e.code,{children:\"filteredChars\"}),\" with the reversed version.\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"If they are the same, return \",(0,r.jsx)(e.code,{children:\"true\"}),\" as the string is a palindrome.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Otherwise, return \",(0,r.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(a,{children:d}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Filtering the characters and reversing the string each takes linear time.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,r.jsx)(e.code,{children:\"filteredChars\"}),\" and \",(0,r.jsx)(e.code,{children:\"reversedChars\"}),\" strings both require O(n) space.\"]}),`\n`]}),`\n`,(0,r.jsx)(e.h2,{children:\"2. Using two pointers\"}),`\n`,(0,r.jsx)(e.p,{children:\"This solution improves on the previous one by avoiding the creation of a reversed string, which requires additional time and space. The two-pointer approach determines whether a string is a palindrome by using two indices, one starting at the beginning of the string and the other at the end, and moving toward the center. This removes the need to reverse the string, as comparisons can be made directly between corresponding characters.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Initialize two pointers:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"One (\",(0,r.jsx)(e.code,{children:\"left\"}),\") at the start of the string.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"The other (\",(0,r.jsx)(e.code,{children:\"right\"}),\") at the end of the string.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"While \",(0,r.jsx)(e.code,{children:\"left\"}),\" is less than \",(0,r.jsx)(e.code,{children:\"right\"}),\":\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[\"Skip non-alphanumeric characters by moving \",(0,r.jsx)(e.code,{children:\"left\"}),\" forward and \",(0,r.jsx)(e.code,{children:\"right\"}),\" backward until valid characters are found.\"]}),`\n`,(0,r.jsx)(e.li,{children:\"Convert both characters to lowercase for case-insensitive comparison.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"If the characters at \",(0,r.jsx)(e.code,{children:\"left\"}),\" and \",(0,r.jsx)(e.code,{children:\"right\"}),\" are not equal, return \",(0,r.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,r.jsxs)(e.li,{children:[\"Otherwise, move \",(0,r.jsx)(e.code,{children:\"left\"}),\" forward and \",(0,r.jsx)(e.code,{children:\"right\"}),\" backward to continue comparisons.\"]}),`\n`]}),`\n`]}),`\n`,(0,r.jsxs)(e.li,{children:[\"If all characters match, return \",(0,r.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`,(0,r.jsx)(a,{children:g}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each character in the string is processed once.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The two-pointer approach uses constant extra space for variables.\"]}),`\n`]})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(p,t)})):p(t)}var T=A;return j(k);})();\n;return Component;"
}