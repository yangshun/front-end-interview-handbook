{
  "description": "var Component=(()=>{var u=Object.create;var s=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var A=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!f.call(t,i)&&i!==r&&s(t,i,{get:()=>e[i],enumerable:!(c=m(e,i))||c.enumerable});return t};var k=(t,e,r)=>(r=t!=null?u(A(t)):{},a(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>a(s({},\"__esModule\",{value:!0}),t);var l=b((M,o)=>{o.exports=_jsx_runtime});var D={};x(D,{default:()=>_,frontmatter:()=>j});var n=k(l());var h=MDXTestExamples;var d=[{input:[[\"str\",\"ABCDE\"],[\"k\",2]],output:3,explanation:\"Modify any two characters to match each other, resulting in a maximum length of 3. For instance, change 'B' and 'C' to 'A', transforming the string into 'AAADE'.\"},{input:[[\"str\",\"AAAA\"],[\"k\",3]],output:4,explanation:\"All characters are already the same, so no changes needed, and the entire string forms the longest substring.\"},{input:[[\"str\",\"AABAA\"],[\"k\",2]],output:5,explanation:\"By replacing 'B' with 'A', the string becomes 'AAAAA', which is the longest substring of identical characters.\"}];var j={title:\"Longest Repeating Substring After Replacements\",excerpt:\"Implement a function to find the longest uniform substring after up to k replacements\"};function g(t){let e=Object.assign({p:\"p\",code:\"code\",strong:\"strong\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given a string \",(0,n.jsx)(e.code,{children:\"str\"}),\" consisting of uppercase English letters and an integer \",(0,n.jsx)(e.code,{children:\"k\"}),\", determine the length of the longest substring that can be formed where all characters are the same. A maximum of \",(0,n.jsx)(e.code,{children:\"k\"}),\" character replacements can be made to achieve this.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"A \",(0,n.jsx)(e.strong,{children:\"substring\"}),\" is any contiguous sequence of characters within a string. For example, the substrings of string \",(0,n.jsx)(e.code,{children:\"abc\"}),\" are \",(0,n.jsx)(e.code,{children:\"a\"}),\", \",(0,n.jsx)(e.code,{children:\"b\"}),\", \",(0,n.jsx)(e.code,{children:\"c\"}),\", \",(0,n.jsx)(e.code,{children:\"ab\"}),\", \",(0,n.jsx)(e.code,{children:\"bc\"}),\", and \",(0,n.jsx)(e.code,{children:\"abc\"}),\". A substring is formed by selecting a starting and ending point without skipping characters in between.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str: string\"}),\": A string\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"k\"}),\": An integer\"]}),`\n`]}),`\n`,(0,n.jsx)(h,{testCases:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"str.length\"}),\" <= 10,000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"str\"}),\" contains only uppercase English letters\"]}),`\n`]})]})}function C(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(g,t)})):g(t)}var _=C;return w(D);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the longest uniform substring after up to k replacements",
    "title": "Longest Repeating Substring After Replacements"
  },
  "solution": "var Component=(()=>{var f=Object.create;var h=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var w=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var r in e)h(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of w(e))!b.call(t,i)&&i!==r&&h(t,i,{get:()=>e[i],enumerable:!(l=m(e,i))||l.enumerable});return t};var q=(t,e,r)=>(r=t!=null?f(p(t)):{},a(e||!t||!t.__esModule?h(r,\"default\",{value:t,enumerable:!0}):r,t)),x=t=>a(h({},\"__esModule\",{value:!0}),t);var o=y((F,d)=>{d.exports=_jsx_runtime});var S={};v(S,{default:()=>A});var n=q(o());var c=MDXCodeBlock;var s=`export default function longestSubstringReplacement(\n  str: string,\n  k: number,\n): number {\n  let start = 0;\n  const frequencyMap: number[] = new Array(26).fill(0);\n  let maxFrequency = 0;\n  let longestSubstringLength = 0;\n\n  for (let end = 0; end < str.length; end++) {\n    // Calculate the relative order of the current character entering the window\n    const currentChar = str.charCodeAt(end) - 'A'.charCodeAt(0);\n\n    // Increment the frequency of the current character\n    frequencyMap[currentChar] += 1;\n\n    // Update the maximum frequency we've seen in any window\n    maxFrequency = Math.max(maxFrequency, frequencyMap[currentChar]);\n\n    // If the window is invalid, move the start pointer to the right\n    const isValid = end + 1 - start - maxFrequency <= k;\n    if (!isValid) {\n      const outgoingChar = str.charCodeAt(start) - 'A'.charCodeAt(0);\n\n      // Decrease the frequency of the outgoing character\n      frequencyMap[outgoingChar] -= 1;\n\n      // Move the start pointer forward\n      start += 1;\n    }\n\n    // The window is valid at this point, update the length of the longest valid substring\n    longestSubstringLength = end + 1 - start;\n  }\n\n  return longestSubstringLength;\n}\n`;var u=`export default function longestSubstringReplacement(\n  str: string,\n  k: number,\n): number {\n  // Binary search over the length of the substring\n  // \\`low\\` holds the valid value, and \\`high\\` holds the invalid value\n  let low = 1;\n  let high = str.length + 1;\n\n  while (low + 1 < high) {\n    const mid = low + Math.floor((high - low) / 2);\n\n    // Check if we can make a valid substring of length \\`mid\\`\n    if (canMakeValidSubstring(str, mid, k)) {\n      // Explore the right half\n      low = mid;\n    } else {\n      // Explore the left half\n      high = mid;\n    }\n  }\n\n  // Return the length of the longest substring that satisfies the condition\n  return low;\n}\n\n// Helper function to check if a valid substring of a given length can be made\nfunction canMakeValidSubstring(\n  str: string,\n  substringLength: number,\n  k: number,\n): boolean {\n  // Frequency map to store the frequency of characters in the current window\n  const freqMap: number[] = new Array(26).fill(0);\n  let maxFrequency = 0;\n  let start = 0;\n\n  for (let end = 0; end < str.length; end++) {\n    // Update the frequency of the current character\n    freqMap[str.charCodeAt(end) - 'A'.charCodeAt(0)] += 1;\n\n    // If the window [start, end] exceeds \\`substringLength\\`, move the start pointer\n    if (end + 1 - start > substringLength) {\n      // Decrease the frequency of the character at the start before moving the pointer\n      freqMap[str.charCodeAt(start) - 'A'.charCodeAt(0)] -= 1;\n      start += 1;\n    }\n\n    // Record the maximum frequency seen so far\n    maxFrequency = Math.max(\n      maxFrequency,\n      freqMap[str.charCodeAt(end) - 'A'.charCodeAt(0)],\n    );\n\n    // Check if the current window can be made valid with at most \\`k\\` replacements\n    if (substringLength - maxFrequency <= k) {\n      return true;\n    }\n  }\n\n  // If no valid substring of the given size was found\n  return false;\n}\n`;function g(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using Sliding Window\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The task is to find the length of the longest substring with the same character after replacing at most \",(0,n.jsx)(e.code,{children:\"k\"}),\" characters in the given string. A sliding window approach is used to dynamically manage a window of valid substrings. The solution focuses on maintaining a balance between the maximum frequency of any character in the current window and the number of replacements allowed (\",(0,n.jsx)(e.code,{children:\"k\"}),\").\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Instead of checking all possible substrings, the sliding window dynamically adjusts the window size to ensure validity. A frequency map keeps track of the occurrence of each character within the current window, and the \",(0,n.jsx)(e.code,{children:\"maxFrequency\"}),\" variable helps determine the minimum replacements required to make all characters in the window the same. If the number of replacements exceeds \",(0,n.jsx)(e.code,{children:\"k\"}),\", the window size is adjusted by moving the \",(0,n.jsx)(e.code,{children:\"start\"}),\" pointer forward.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize the \",(0,n.jsx)(e.code,{children:\"start\"}),\" pointer to \",(0,n.jsx)(e.code,{children:\"0\"}),\", a frequency map \",(0,n.jsx)(e.code,{children:\"frequencyMap\"}),\" of size \",(0,n.jsx)(e.code,{children:\"26\"}),\" (for all uppercase English letters) filled with \",(0,n.jsx)(e.code,{children:\"0\"}),\", \",(0,n.jsx)(e.code,{children:\"maxFrequency\"}),\" to track the highest frequency of any character in the current window, and \",(0,n.jsx)(e.code,{children:\"longestSubstringLength\"}),\" to store the length of the longest valid substring found.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the string using an \",(0,n.jsx)(e.code,{children:\"end\"}),\" pointer:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Calculate the relative index of the current character in the frequency map.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Increment the frequency of the current character in the frequency map.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"maxFrequency\"}),\" to the maximum frequency observed in the current window.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Determine whether the current window is valid by checking if the number of replacements required (\",(0,n.jsx)(e.code,{children:\"end + 1 - start - maxFrequency\"}),\") is less than or equal to \",(0,n.jsx)(e.code,{children:\"k\"}),\".\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If the window is invalid, move the \",(0,n.jsx)(e.code,{children:\"start\"}),\" pointer forward:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Decrement the frequency of the character that is moving out of the window.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Increment the \",(0,n.jsx)(e.code,{children:\"start\"}),\" pointer.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"longestSubstringLength\"}),\" with the size of the current valid window (\",(0,n.jsx)(e.code,{children:\"end + 1 - start\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the value of \",(0,n.jsx)(e.code,{children:\"longestSubstringLength\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"end\"}),\" pointer iterates through the string once, and the \",(0,n.jsx)(e.code,{children:\"start\"}),\" pointer adjusts as needed, resulting in linear time.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The \",(0,n.jsx)(e.code,{children:\"frequencyMap\"}),\" is of constant size (\",(0,n.jsx)(e.code,{children:\"26\"}),\"), independent of the input string length.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Binary Search with Sliding Window\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The solution combines binary search with sliding window optimization to efficiently determine the result. Binary search is used to explore the possible lengths of valid substrings. The range of possible lengths is reduced logarithmically by checking whether a substring of a given length can be made valid with at most \",(0,n.jsx)(e.code,{children:\"k\"}),\" replacements. The sliding window technique verifies the validity of each length by maintaining the frequency of characters in the current window and determining whether the required replacements fall within the allowed \",(0,n.jsx)(e.code,{children:\"k\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The core idea is to maximize the frequency of any character in the window while ensuring the window size does not exceed the allowed replacements. If a window of the desired length can be made valid, larger lengths are explored. Otherwise, smaller lengths are checked. This combination of binary search and sliding window ensures the solution is both efficient and scalable.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize the binary search bounds:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"low\"}),\" to \",(0,n.jsx)(e.code,{children:\"1\"}),\", representing the minimum possible substring length.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set \",(0,n.jsx)(e.code,{children:\"high\"}),\" to \",(0,n.jsx)(e.code,{children:\"str.length + 1\"}),\", representing an invalid substring length beyond the input string's length.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Perform binary search:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the midpoint \",(0,n.jsx)(e.code,{children:\"mid\"}),\" of the current range.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if a valid substring of length \",(0,n.jsx)(e.code,{children:\"mid\"}),\" can be created using the helper function \",(0,n.jsx)(e.code,{children:\"canMakeValidSubstring\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If valid, move \",(0,n.jsx)(e.code,{children:\"low\"}),\" to \",(0,n.jsx)(e.code,{children:\"mid\"}),\" to explore larger substrings.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Otherwise, move \",(0,n.jsx)(e.code,{children:\"high\"}),\" to \",(0,n.jsx)(e.code,{children:\"mid\"}),\" to explore smaller substrings.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"low\"}),\", which represents the largest valid substring length.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use the \",(0,n.jsx)(e.code,{children:\"canMakeValidSubstring\"}),\" function to verify a given length:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Maintain a frequency map \",(0,n.jsx)(e.code,{children:\"freqMap\"}),\" to track character occurrences in the current window.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use a sliding window to traverse the string:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Add the current character to the frequency map.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the window size exceeds the candidate substring length, remove the character at the start of the window.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Update \",(0,n.jsx)(e.code,{children:\"maxFrequency\"}),\" with the highest frequency observed in the current window.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the current window can be made valid with at most \",(0,n.jsx)(e.code,{children:\"k\"}),\" replacements. If valid, return \",(0,n.jsx)(e.code,{children:\"true\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If no valid substring of the given length is found, return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". The binary search performs \",(0,n.jsx)(e.code,{children:\"O(log n)\"}),\" iterations, and each iteration calls \",(0,n.jsx)(e.code,{children:\"canMakeValidSubstring\"}),\", which runs in O(n).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The frequency map is of fixed size (\",(0,n.jsx)(e.code,{children:\"26\"}),\"), independent of the input size.\"]}),`\n`]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(g,t)})):g(t)}var A=M;return x(S);})();\n;return Component;"
}