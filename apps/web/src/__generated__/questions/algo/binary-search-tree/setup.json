{
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/binary-search-tree\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/binary-search-tree.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"jsx\": \"react-jsx\",\n    \"target\": \"es2020\"\n  }\n}\n",
    "/src/binary-search-tree.run.test.ts": "import BST from './binary-search-tree';\n\ndescribe('BST', () => {\n  test('constructor', () => {\n    const bst = new BST();\n    expect(bst instanceof BST).toBeTruthy();\n  });\n\n  test('insert and search', () => {\n    const bst = new BST();\n    bst.insert(100);\n    expect(bst.search(100)).toBeTruthy();\n    bst.insert(200);\n    expect(bst.search(200)).toBeTruthy();\n    bst.insert(50);\n    expect(bst.search(50)).toBeTruthy();\n    expect(bst.search(250)).toBeFalsy();\n  });\n\n  test('delete', () => {\n    const bst = new BST();\n    bst.insert(300);\n    bst.insert(100);\n    bst.insert(200);\n    bst.insert(50);\n    bst.delete(100);\n    expect(bst.search(100)).toBeFalsy();\n    expect(bst.search(300)).toBeTruthy();\n    expect(bst.search(200)).toBeTruthy();\n    bst.delete(300);\n    expect(bst.search(300)).toBeFalsy();\n    expect(bst.search(50)).toBeTruthy();\n  });\n});\n",
    "/src/binary-search-tree.submit.test.ts": "import BST from './binary-search-tree';\n\ndescribe('BST', () => {\n  test('constructor', () => {\n    const bst = new BST();\n    expect(bst instanceof BST).toBeTruthy();\n    expect(bst.root).toBeNull();\n  });\n\n  test('insert and search', () => {\n    const bst = new BST();\n    bst.insert(100);\n    expect(bst.search(100)).toBeTruthy();\n    bst.insert(200);\n    expect(bst.search(200)).toBeTruthy();\n    bst.insert(50);\n    expect(bst.search(50)).toBeTruthy();\n  });\n\n  test('delete leaf node', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.delete(30);\n    expect(bst.search(30)).toBeFalsy();\n    expect(bst.root?.left).toBeNull();\n  });\n\n  test('delete node with one child', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(20);\n    bst.delete(30);\n    expect(bst.search(30)).toBeFalsy();\n    expect(bst.root?.left?.value).toBe(20);\n  });\n\n  test('delete node with two children', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.insert(20);\n    bst.insert(40);\n    bst.delete(30);\n    expect(bst.search(30)).toBeFalsy();\n    expect(bst.root?.left?.value).not.toBe(30);\n  });\n\n  test('delete root node', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.delete(50);\n    expect(bst.search(50)).toBeFalsy();\n    expect(bst.root?.value).not.toBe(50);\n  });\n\n  test('insert many and test structure', () => {\n    const bst = new BST();\n    const values = [50, 30, 70, 20, 40, 60, 80];\n    values.forEach((value) => bst.insert(value));\n    expect(bst.root?.value).toBe(50);\n    expect(bst.root?.left?.value).toBe(30);\n    expect(bst.root?.right?.value).toBe(70);\n    expect(bst.root?.left?.left?.value).toBe(20);\n    expect(bst.root?.left?.right?.value).toBe(40);\n    expect(bst.root?.right?.left?.value).toBe(60);\n    expect(bst.root?.right?.right?.value).toBe(80);\n  });\n\n  test('search non-existent value', () => {\n    const bst = new BST();\n    bst.insert(50);\n    expect(bst.search(100)).toBeFalsy();\n  });\n\n  test('complex insert and delete sequence', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.insert(20);\n    bst.insert(40);\n    bst.insert(60);\n    bst.insert(80);\n    bst.delete(70);\n    expect(bst.search(70)).toBeFalsy();\n    bst.delete(50);\n    expect(bst.search(50)).toBeFalsy();\n    bst.insert(35);\n    bst.insert(45);\n    expect(bst.search(35)).toBeTruthy();\n    expect(bst.search(45)).toBeTruthy();\n  });\n\n  test('delete on empty BST', () => {\n    const bst = new BST();\n    bst.delete(100);\n    expect(bst.root).toBeNull();\n  });\n\n  test('maintaining state after multiple operations', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(60);\n    bst.delete(50);\n    bst.insert(55);\n    bst.insert(65);\n    expect(bst.search(55)).toBeTruthy();\n    expect(bst.search(65)).toBeTruthy();\n    bst.delete(65);\n    expect(bst.search(65)).toBeFalsy();\n  });\n\n  test('integration test of operations', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.insert(20);\n    bst.insert(60);\n    bst.insert(80);\n    bst.insert(40);\n    bst.delete(50);\n    expect(bst.search(50)).toBeFalsy();\n    bst.insert(55);\n    expect(bst.search(55)).toBeTruthy();\n    bst.delete(55);\n    expect(bst.search(55)).toBeFalsy();\n  });\n});\n",
    "/src/binary-search-tree.ts": "class Node<T> {\n  value: number | null;\n  left: Node<T> | null;\n  right: Node<T> | null;\n\n  constructor(value: number | null = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport default class BinarySearchTree<T> {\n  root: Node<T> | null;\n\n  constructor() {\n    this.root = null;\n  }\n\n  /**\n   * Inserts a new value into the BST while maintaining BST properties.\n   * @param value The value to be inserted into the BST.\n   */\n  insert(value: number): void {\n    const newNode = new Node(value);\n    if (this.root === null) {\n      this.root = newNode;\n      return;\n    }\n\n    let currentNode: Node<T> | null = this.root;\n    let parent: Node<T> | null = null;\n    while (currentNode) {\n      parent = currentNode;\n      if (value < currentNode.value!) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (parent && value < parent.value!) {\n      parent.left = newNode;\n    } else if (parent) {\n      parent.right = newNode;\n    }\n  }\n\n  /**\n   * Searches for a value in the BST. Returns true if the value exists, false otherwise.\n   * @param value The value to search for.\n   * @return True if the value is found, false otherwise.\n   */\n  search(value: number): boolean {\n    let currentNode = this.root;\n    while (currentNode) {\n      if (value === currentNode.value) {\n        return true;\n      }\n      currentNode =\n        value < currentNode.value! ? currentNode.left : currentNode.right;\n    }\n    return false;\n  }\n\n  /**\n   * Deletes a value from the BST, if it exists, while maintaining BST properties.\n   * @param value The value to be deleted from the BST.\n   */\n  delete(value: number): void {\n    let currentNode = this.root;\n    let parent: Node<T> | null = null;\n\n    // Find the node and its parent.\n    while (currentNode && currentNode.value !== value) {\n      parent = currentNode;\n      if (value < currentNode.value!) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (!currentNode) {\n      return; // Node not found.\n    }\n\n    // Node has two children.\n    if (currentNode.left && currentNode.right) {\n      let successor = currentNode.right;\n      let successorParent = currentNode;\n\n      // Find the node with the smallest value in the right subtree and take note of its parent.\n      while (successor.left) {\n        successorParent = successor;\n        successor = successor.left;\n      }\n\n      currentNode.value = successor.value; // Replace value.\n      currentNode = successor; // Move pointer to successor, which will be deleted.\n      parent = successorParent;\n    }\n\n    // Node has one or zero children.\n    let child = currentNode.left ? currentNode.left : currentNode.right;\n\n    // If the node to be deleted is the root node.\n    if (!parent) {\n      this.root = child;\n    } else {\n      if (parent.left === currentNode) {\n        parent.left = child;\n      } else {\n        parent.right = child;\n      }\n    }\n  }\n}\n"
  },
  "skeleton": {
    "js": "export default class BinarySearchTree {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Inserts a new value into the BST while maintaining BST properties.\n   * @param {*} value The value to be inserted into the BST.\n   */\n  insert(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Searches for a value in the BST. Returns true if the value exists, false otherwise.\n   * @param {*} value The value to search for.\n   * @return {boolean} True if the value is found, false otherwise.\n   */\n  search(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Deletes a value from the BST, if it exists, while maintaining BST properties.\n   * @param {*} value The value to be deleted from the BST.\n   */\n  delete(value) {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export default class BinarySearchTree<T> {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Inserts a new value into the BST while maintaining BST properties.\n   * @param value The value to be inserted into the BST.\n   */\n  insert(value: number): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Searches for a value in the BST. Returns true if the value exists, false otherwise.\n   * @param value The value to search for.\n   * @return True if the value is found, false otherwise.\n   */\n  search(value: number): boolean {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Deletes a value from the BST, if it exists, while maintaining BST properties.\n   * @param value The value to be deleted from the BST.\n   */\n  delete(value: number): void {\n    throw 'Not implemented!';\n  }\n}"
  },
  "workspace": {
    "main": "/src/binary-search-tree.ts",
    "run": "/src/binary-search-tree.run.test.ts",
    "submit": "/src/binary-search-tree.submit.test.ts"
  }
}