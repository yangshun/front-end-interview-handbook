{
  "description": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!b.call(t,i)&&i!==r&&a(t,i,{get:()=>e[i],enumerable:!(s=u(e,i))||s.enumerable});return t};var x=(t,e,r)=>(r=t!=null?d(p(t)):{},o(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>o(a({},\"__esModule\",{value:!0}),t);var l=f((j,c)=>{c.exports=_jsx_runtime});var S={};g(S,{default:()=>y,frontmatter:()=>T});var n=x(l()),T={title:\"Binary Search Tree\",excerpt:\"Implement a binary search tree data structure including essential BST operations\"};function h(t){let e=Object.assign({p:\"p\",ul:\"ul\",li:\"li\",code:\"code\",h2:\"h2\",pre:\"pre\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Implement a binary search tree (BST) data structure that supports the following operations:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"new BST()\"}),\": Creates an instance of a BST class. It initializes the root to \",(0,n.jsx)(e.code,{children:\"null\"}),\" as there are no nodes in the tree initially.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"insert(value)\"}),\": Adds a new value to the BST. The new value is inserted in the correct position to maintain the binary search tree order. If the tree is empty, the new value becomes the root. Required time complexity: O(log n) on average, but can degrade to O(n) in the worst case where the tree becomes a linear chain.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"search(value)\"}),\": Searches for a value in the BST. Returns \",(0,n.jsx)(e.code,{children:\"true\"}),\" if the value exists in the tree; otherwise, returns \",(0,n.jsx)(e.code,{children:\"false\"}),\". This operation also adheres to the average time complexity of O(log n) but can become O(n) in the worst case.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"delete(value)\"}),\": Removes a value from the BST, if it exists. This method requires handling three cases: deleting a node with no children, one child, or two children. The function maintains the properties of the BST after deletion. Required time complexity: O(log n) on average, but may be O(n) in the worst case.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Examples\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const bst = new BST();\nbst.insert(15);\nbst.insert(10);\nbst.insert(20);\nbst.search(10); // true\nbst.delete(10);\nbst.search(10); // false\n`})})]})}function v(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var y=v;return w(S);})();\n;return Component;",
  "files": {
    "/package.json": "{\n  \"name\": \"@gfe-questions/binary-search-tree\",\n  \"version\": \"0.0.1\",\n  \"main\": \"/src/binary-search-tree.ts\",\n  \"devDependencies\": {\n    \"@types/jest\": \"29.5.0\",\n    \"typescript\": \"5.0.2\"\n  }\n}\n",
    "/tsconfig.json": "{\n  \"include\": [\"./**/*\"],\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"lib\": [\"dom\", \"esnext\"],\n    \"jsx\": \"react-jsx\"\n  }\n}\n",
    "/src/binary-search-tree.run.test.ts": "import BST from './binary-search-tree';\n\ndescribe('BST', () => {\n  test('constructor', () => {\n    const bst = new BST();\n    expect(bst instanceof BST).toBeTruthy();\n  });\n\n  test('insert and search', () => {\n    const bst = new BST();\n    bst.insert(100);\n    expect(bst.search(100)).toBeTruthy();\n    bst.insert(200);\n    expect(bst.search(200)).toBeTruthy();\n    bst.insert(50);\n    expect(bst.search(50)).toBeTruthy();\n    expect(bst.search(250)).toBeFalsy();\n  });\n\n  test('delete', () => {\n    const bst = new BST();\n    bst.insert(300);\n    bst.insert(100);\n    bst.insert(200);\n    bst.insert(50);\n    bst.delete(100);\n    expect(bst.search(100)).toBeFalsy();\n    expect(bst.search(300)).toBeTruthy();\n    expect(bst.search(200)).toBeTruthy();\n    bst.delete(300);\n    expect(bst.search(300)).toBeFalsy();\n    expect(bst.search(50)).toBeTruthy();\n  });\n});\n",
    "/src/binary-search-tree.submit.test.ts": "import BST from './binary-search-tree';\n\ndescribe('BST', () => {\n  test('constructor', () => {\n    const bst = new BST();\n    expect(bst instanceof BST).toBeTruthy();\n    expect(bst.root).toBeNull();\n  });\n\n  test('insert and search', () => {\n    const bst = new BST();\n    bst.insert(100);\n    expect(bst.search(100)).toBeTruthy();\n    bst.insert(200);\n    expect(bst.search(200)).toBeTruthy();\n    bst.insert(50);\n    expect(bst.search(50)).toBeTruthy();\n  });\n\n  test('delete leaf node', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.delete(30);\n    expect(bst.search(30)).toBeFalsy();\n    expect(bst.root?.left).toBeNull();\n  });\n\n  test('delete node with one child', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(20);\n    bst.delete(30);\n    expect(bst.search(30)).toBeFalsy();\n    expect(bst.root?.left?.value).toBe(20);\n  });\n\n  test('delete node with two children', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.insert(20);\n    bst.insert(40);\n    bst.delete(30);\n    expect(bst.search(30)).toBeFalsy();\n    expect(bst.root?.left?.value).not.toBe(30);\n  });\n\n  test('delete root node', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.delete(50);\n    expect(bst.search(50)).toBeFalsy();\n    expect(bst.root?.value).not.toBe(50);\n  });\n\n  test('insert many and test structure', () => {\n    const bst = new BST();\n    const values = [50, 30, 70, 20, 40, 60, 80];\n    values.forEach((value) => bst.insert(value));\n    expect(bst.root?.value).toBe(50);\n    expect(bst.root?.left?.value).toBe(30);\n    expect(bst.root?.right?.value).toBe(70);\n    expect(bst.root?.left?.left?.value).toBe(20);\n    expect(bst.root?.left?.right?.value).toBe(40);\n    expect(bst.root?.right?.left?.value).toBe(60);\n    expect(bst.root?.right?.right?.value).toBe(80);\n  });\n\n  test('search non-existent value', () => {\n    const bst = new BST();\n    bst.insert(50);\n    expect(bst.search(100)).toBeFalsy();\n  });\n\n  test('complex insert and delete sequence', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.insert(20);\n    bst.insert(40);\n    bst.insert(60);\n    bst.insert(80);\n    bst.delete(70);\n    expect(bst.search(70)).toBeFalsy();\n    bst.delete(50);\n    expect(bst.search(50)).toBeFalsy();\n    bst.insert(35);\n    bst.insert(45);\n    expect(bst.search(35)).toBeTruthy();\n    expect(bst.search(45)).toBeTruthy();\n  });\n\n  test('delete on empty BST', () => {\n    const bst = new BST();\n    bst.delete(100);\n    expect(bst.root).toBeNull();\n  });\n\n  test('maintaining state after multiple operations', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(60);\n    bst.delete(50);\n    bst.insert(55);\n    bst.insert(65);\n    expect(bst.search(55)).toBeTruthy();\n    expect(bst.search(65)).toBeTruthy();\n    bst.delete(65);\n    expect(bst.search(65)).toBeFalsy();\n  });\n\n  test('integration test of operations', () => {\n    const bst = new BST();\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(70);\n    bst.insert(20);\n    bst.insert(60);\n    bst.insert(80);\n    bst.insert(40);\n    bst.delete(50);\n    expect(bst.search(50)).toBeFalsy();\n    bst.insert(55);\n    expect(bst.search(55)).toBeTruthy();\n    bst.delete(55);\n    expect(bst.search(55)).toBeFalsy();\n  });\n});\n",
    "/src/binary-search-tree.ts": "class Node<T> {\n  value: number | null;\n  left: Node<T> | null;\n  right: Node<T> | null;\n\n  constructor(value: number | null = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport default class BinarySearchTree<T> {\n  root: Node<T> | null;\n\n  constructor() {\n    this.root = null;\n  }\n\n  /**\n   * Inserts a new value into the BST while maintaining BST properties.\n   * @param value The value to be inserted into the BST.\n   */\n  insert(value: number): void {\n    const newNode = new Node(value);\n    if (this.root === null) {\n      this.root = newNode;\n      return;\n    }\n\n    let currentNode: Node<T> | null = this.root;\n    let parent: Node<T> | null = null;\n    while (currentNode) {\n      parent = currentNode;\n      if (value < currentNode.value!) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (parent && value < parent.value!) {\n      parent.left = newNode;\n    } else if (parent) {\n      parent.right = newNode;\n    }\n  }\n\n  /**\n   * Searches for a value in the BST. Returns true if the value exists, false otherwise.\n   * @param value The value to search for.\n   * @return True if the value is found, false otherwise.\n   */\n  search(value: number): boolean {\n    let currentNode = this.root;\n    while (currentNode) {\n      if (value === currentNode.value) {\n        return true;\n      }\n      currentNode =\n        value < currentNode.value! ? currentNode.left : currentNode.right;\n    }\n    return false;\n  }\n\n  /**\n   * Deletes a value from the BST, if it exists, while maintaining BST properties.\n   * @param value The value to be deleted from the BST.\n   */\n  delete(value: number): void {\n    let currentNode = this.root;\n    let parent: Node<T> | null = null;\n\n    // Find the node and its parent.\n    while (currentNode && currentNode.value !== value) {\n      parent = currentNode;\n      if (value < currentNode.value!) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (!currentNode) {\n      return; // Node not found.\n    }\n\n    // Node has two children.\n    if (currentNode.left && currentNode.right) {\n      let successor = currentNode.right;\n      let successorParent = currentNode;\n\n      // Find the node with the smallest value in the right subtree and take note of its parent.\n      while (successor.left) {\n        successorParent = successor;\n        successor = successor.left;\n      }\n\n      currentNode.value = successor.value; // Replace value.\n      currentNode = successor; // Move pointer to successor, which will be deleted.\n      parent = successorParent;\n    }\n\n    // Node has one or zero children.\n    let child = currentNode.left ? currentNode.left : currentNode.right;\n\n    // If the node to be deleted is the root node.\n    if (!parent) {\n      this.root = child;\n    } else {\n      if (parent.left === currentNode) {\n        parent.left = child;\n      } else {\n        parent.right = child;\n      }\n    }\n  }\n}\n"
  },
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1715126400,
    "difficulty": "medium",
    "duration": 15,
    "excerpt": "Implement a binary search tree data structure including essential BST operations",
    "featured": false,
    "format": "algo",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/algo/binary-search-tree",
    "importance": "low",
    "languages": [
      "js",
      "ts"
    ],
    "nextQuestions": [],
    "published": false,
    "ranking": 100,
    "similarQuestions": [
      "heap",
      "binary-search"
    ],
    "slug": "binary-search-tree",
    "subtitle": null,
    "title": "Binary Search Tree",
    "topics": []
  },
  "skeleton": {
    "js": "export default class BinarySearchTree {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Inserts a new value into the BST while maintaining BST properties.\n   * @param {*} value The value to be inserted into the BST.\n   */\n  insert(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Searches for a value in the BST. Returns true if the value exists, false otherwise.\n   * @param {*} value The value to search for.\n   * @return {boolean} True if the value is found, false otherwise.\n   */\n  search(value) {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Deletes a value from the BST, if it exists, while maintaining BST properties.\n   * @param {*} value The value to be deleted from the BST.\n   */\n  delete(value) {\n    throw 'Not implemented!';\n  }\n}",
    "ts": "export default class BinarySearchTree<T> {\n  constructor() {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Inserts a new value into the BST while maintaining BST properties.\n   * @param value The value to be inserted into the BST.\n   */\n  insert(value: number): void {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Searches for a value in the BST. Returns true if the value exists, false otherwise.\n   * @param value The value to search for.\n   * @return True if the value is found, false otherwise.\n   */\n  search(value: number): boolean {\n    throw 'Not implemented!';\n  }\n\n  /**\n   * Deletes a value from the BST, if it exists, while maintaining BST properties.\n   * @param value The value to be deleted from the BST.\n   */\n  delete(value: number): void {\n    throw 'Not implemented!';\n  }\n}"
  },
  "solution": "var Component=(()=>{var v=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var N=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var T=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),w=(r,e)=>{for(var n in e)i(r,n,{get:e[n],enumerable:!0})},a=(r,e,n,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of N(e))!g.call(r,o)&&o!==n&&i(r,o,{get:()=>e[o],enumerable:!(l=p(e,o))||l.enumerable});return r};var S=(r,e,n)=>(n=r!=null?v(m(r)):{},a(e||!r||!r.__esModule?i(n,\"default\",{value:r,enumerable:!0}):n,r)),b=r=>a(i({},\"__esModule\",{value:!0}),r);var u=T((j,s)=>{s.exports=_jsx_runtime});var D={};w(D,{default:()=>O});var t=S(u());var d=MDXCodeBlock;var c=`class Node {\n  constructor(value = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport default class BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  /**\n   * Inserts a new value into the BST while maintaining BST properties.\n   * @param {*} value The value to be inserted into the BST.\n   */\n  insert(value) {\n    const newNode = new Node(value);\n    if (this.root === null) {\n      this.root = newNode;\n      return;\n    }\n\n    let currentNode = this.root;\n    let parent = null;\n    while (currentNode) {\n      parent = currentNode;\n      if (value < currentNode.value) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (value < parent.value) {\n      parent.left = newNode;\n    } else {\n      parent.right = newNode;\n    }\n  }\n\n  /**\n   * Searches for a value in the BST. Returns true if the value exists, false otherwise.\n   * @param {*} value The value to search for.\n   * @return {boolean} True if the value is found, false otherwise.\n   */\n  search(value) {\n    let currentNode = this.root;\n    while (currentNode) {\n      if (value === currentNode.value) {\n        return true;\n      }\n      currentNode =\n        value < currentNode.value ? currentNode.left : currentNode.right;\n    }\n    return false;\n  }\n\n  /**\n   * Deletes a value from the BST, if it exists, while maintaining BST properties.\n   * @param {*} value The value to be deleted from the BST.\n   */\n  delete(value) {\n    let currentNode = this.root;\n    let parent = null;\n\n    // Find the node and its parent.\n    while (currentNode && currentNode.value !== value) {\n      parent = currentNode;\n      if (value < currentNode.value) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (!currentNode) {\n      return; // Node not found.\n    }\n\n    // Node has two children.\n    if (currentNode.left && currentNode.right) {\n      let successor = currentNode.right;\n      let successorParent = currentNode;\n\n      // Find the node with the smallest value in the right subtree and take note of its parent.\n      while (successor.left) {\n        successorParent = successor;\n        successor = successor.left;\n      }\n\n      currentNode.value = successor.value; // Replace value.\n      currentNode = successor; // Move pointer to successor, which will be deleted.\n      parent = successorParent;\n    }\n\n    // Node has one or zero children.\n    let child = currentNode.left ? currentNode.left : currentNode.right;\n\n    // If the node to be deleted is the root node.\n    if (!parent) {\n      this.root = child;\n    } else {\n      if (parent.left === currentNode) {\n        parent.left = child;\n      } else {\n        parent.right = child;\n      }\n    }\n  }\n}\n`;var h=`class Node<T> {\n  value: number | null;\n  left: Node<T> | null;\n  right: Node<T> | null;\n\n  constructor(value: number | null = null) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nexport default class BinarySearchTree<T> {\n  root: Node<T> | null;\n\n  constructor() {\n    this.root = null;\n  }\n\n  /**\n   * Inserts a new value into the BST while maintaining BST properties.\n   * @param value The value to be inserted into the BST.\n   */\n  insert(value: number): void {\n    const newNode = new Node(value);\n    if (this.root === null) {\n      this.root = newNode;\n      return;\n    }\n\n    let currentNode: Node<T> | null = this.root;\n    let parent: Node<T> | null = null;\n    while (currentNode) {\n      parent = currentNode;\n      if (value < currentNode.value!) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (parent && value < parent.value!) {\n      parent.left = newNode;\n    } else if (parent) {\n      parent.right = newNode;\n    }\n  }\n\n  /**\n   * Searches for a value in the BST. Returns true if the value exists, false otherwise.\n   * @param value The value to search for.\n   * @return True if the value is found, false otherwise.\n   */\n  search(value: number): boolean {\n    let currentNode = this.root;\n    while (currentNode) {\n      if (value === currentNode.value) {\n        return true;\n      }\n      currentNode =\n        value < currentNode.value! ? currentNode.left : currentNode.right;\n    }\n    return false;\n  }\n\n  /**\n   * Deletes a value from the BST, if it exists, while maintaining BST properties.\n   * @param value The value to be deleted from the BST.\n   */\n  delete(value: number): void {\n    let currentNode = this.root;\n    let parent: Node<T> | null = null;\n\n    // Find the node and its parent.\n    while (currentNode && currentNode.value !== value) {\n      parent = currentNode;\n      if (value < currentNode.value!) {\n        currentNode = currentNode.left;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n\n    if (!currentNode) {\n      return; // Node not found.\n    }\n\n    // Node has two children.\n    if (currentNode.left && currentNode.right) {\n      let successor = currentNode.right;\n      let successorParent = currentNode;\n\n      // Find the node with the smallest value in the right subtree and take note of its parent.\n      while (successor.left) {\n        successorParent = successor;\n        successor = successor.left;\n      }\n\n      currentNode.value = successor.value; // Replace value.\n      currentNode = successor; // Move pointer to successor, which will be deleted.\n      parent = successorParent;\n    }\n\n    // Node has one or zero children.\n    let child = currentNode.left ? currentNode.left : currentNode.right;\n\n    // If the node to be deleted is the root node.\n    if (!parent) {\n      this.root = child;\n    } else {\n      if (parent.left === currentNode) {\n        parent.left = child;\n      } else {\n        parent.right = child;\n      }\n    }\n  }\n}\n`;function f(r){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\",code:\"code\",img:\"img\"},r.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"Solution\"}),`\n`,(0,t.jsx)(e.p,{children:\"Binary Search Trees (BSTs) are a fundamental data structure in computer science, primarily used to maintain a dynamically changing dataset in a sorted order. Each node in a BST contains a key and pointers to its left and right children. The tree is structured such that for any given node, all nodes in its left subtree have keys less than the node\\u2019s key, and all nodes in its right subtree have keys greater than the node\\u2019s key. This property enables efficient searching, insertion, and deletion operations.\"}),`\n`,(0,t.jsx)(d,{languages:{jsx:c,tsx:h}}),`\n`,(0,t.jsx)(e.h3,{children:\"Operations\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"new BST()\"}),\": Initializes a new instance of a BST. The constructor sets the root of the tree to null, indicating that the tree is initially empty.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"insert(value)\"}),\": Adds a new node with the given value to the BST. If the tree is empty, the new node becomes the root. If not, the tree is traversed starting from the root to find the correct position for the new node to maintain the BST property. This operation involves comparing the new value with the current node\\u2019s value and deciding to move left or right. The average time complexity is O(log n), but it can degrade to O(n) if values are inserted in an ascending/descending order.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/binary-search-tree/insert.png\",alt:\"Insert\"})}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"search(value)\"}),\": Searches for a node containing the specified value. Starting from the root, the tree is traversed to the left or right depending on how the target value compares to the current node\\u2019s value. The process is repeated until the value is found or until a leaf is reached. Similar to \",(0,t.jsx)(e.code,{children:\"insert(value)\"}),\", the average time complexity is O(log n), with a worst-case of O(n).\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:\"delete(value)\"}),\": Removes a node with the specified value from the BST. This operation is more complex as it needs to handle three cases:\",`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Leaf Node: Directly remove the node.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Node with One Child: Remove the node and replace it with its child.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Node with Two Children: Replace the node's value with the smallest value in the right subtree and then delete the successor node.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/binary-search-tree/delete.png\",alt:\"Delete\"})}),`\n`,(0,t.jsx)(e.p,{children:\"The deletion process ensures that the BST properties are maintained after the node is removed. Similar to insertion, the time complexity averages O(log n) but can become O(n).\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Edge Cases\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"Inserting a value that already exists in the tree.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Deleting a node from an empty tree or a non-existent value.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Searching for a value not present in the tree.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Deleting duplicate values in the binary search tree.\"}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Techniques\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:\"In-Order Traversal: Utilized during the delete operation to find the successor.\"}),`\n`,(0,t.jsx)(e.li,{children:\"Object-Oriented Design: Using a Node class to represent each tree node and a BST class for the tree operations provides a clear structure and encapsulation.\"}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"This binary search tree implementation uses iterative solution, whereas a recursive solution for \",(0,t.jsx)(e.code,{children:\"delete(value)\"}),\" may be easier to implement.\"]})]})}function x(r={}){let{wrapper:e}=r.components||{};return e?(0,t.jsx)(e,Object.assign({},r,{children:(0,t.jsx)(f,r)})):f(r)}var O=x;return b(D);})();\n;return Component;",
  "workspace": {
    "main": "/src/binary-search-tree.ts",
    "run": "/src/binary-search-tree.run.test.ts",
    "submit": "/src/binary-search-tree.submit.test.ts"
  }
}