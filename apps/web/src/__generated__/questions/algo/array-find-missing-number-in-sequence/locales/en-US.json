{
  "description": "var Component=(()=>{var u=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)s(t,r,{get:e[r],enumerable:!0})},o=(t,e,r,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!x.call(t,i)&&i!==r&&s(t,i,{get:()=>e[i],enumerable:!(a=f(e,i))||a.enumerable});return t};var j=(t,e,r)=>(r=t!=null?u(g(t)):{},o(e||!t||!t.__esModule?s(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>o(s({},\"__esModule\",{value:!0}),t);var m=b((F,h)=>{h.exports=_jsx_runtime});var z={};y(z,{default:()=>C,frontmatter:()=>M});var n=j(m());var c=MDXTestExamples;var l=[{input:[[\"numbers\",[1,3,0]]],output:2,explanation:\"The array has a size of 3, and within the range from 0 to 3, the number 2 is missing from the array\"},{input:[[\"numbers\",[1]]],output:0,explanation:\"The array has a size of 1, and within the range from 0 to 1, the number 0 is missing from the array\"},{input:[[\"numbers\",[3,0,4,2,1]]],output:5,explanation:\"The array has a size of 5, and within the range from 0 to 5, the number 5 is missing from the array\"}];var M={title:\"Find Missing Number in Sequence\",excerpt:\"Implement a function to find the missing element in a sorted array\"};function d(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" of size \",(0,n.jsx)(e.code,{children:\"n\"}),\" storing \",(0,n.jsx)(e.code,{children:\"n\"}),\" different integers which fall within the range \",(0,n.jsx)(e.code,{children:\"[0, n]\"}),\", implement a function to identify the missing element in the array. All numbers except one are present in the array. Find the missing number.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:l}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"n\"}),\" <= 10,000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= \",(0,n.jsx)(e.code,{children:\"n\"})]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var C=T;return _(z);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to find the missing element in a sorted array",
    "title": "Find Missing Number in Sequence"
  },
  "solution": "var Component=(()=>{var b=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var S=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),I=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!y.call(t,i)&&i!==r&&o(t,i,{get:()=>e[i],enumerable:!(h=g(e,i))||h.enumerable});return t};var k=(t,e,r)=>(r=t!=null?b(x(t)):{},l(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),O=t=>l(o({},\"__esModule\",{value:!0}),t);var c=S((w,u)=>{u.exports=_jsx_runtime});var M={};I(M,{default:()=>j});var n=k(c());var s=MDXCodeBlock;var a=`export default function findMissingNumberInSequence(numbers: number[]): number {\n  let expectedSum = 0;\n  const n = numbers.length;\n\n  // Calculate the expected sum of all numbers from 0 to n\n  for (let i = 0; i <= n; i++) {\n    expectedSum += i;\n  }\n\n  // Calculate the actual sum of elements in the array\n  let actualSum = 0;\n  for (const num of numbers) {\n    actualSum += num;\n  }\n\n  // Return the missing number (expected sum - actual sum)\n  return expectedSum - actualSum;\n}\n`;var d=`export default function findMissingNumberInSequence(numbers: number[]): number {\n  numbers.sort((a, b) => a - b);\n\n  // Check if the last number is equal to the array length\n  if (numbers[numbers.length - 1] !== numbers.length) {\n    return numbers.length;\n  }\n  // Check if the first number is 0\n  else if (numbers[0] !== 0) {\n    return 0;\n  }\n\n  // Iterate through the sorted array to find the missing number\n  for (let i = 1; i < numbers.length; i++) {\n    const expectedNum = numbers[i - 1] + 1;\n    if (numbers[i] !== expectedNum) {\n      return expectedNum;\n    }\n  }\n\n  // Return -1 if no numbers are missing (should not happen in valid input)\n  return -1;\n}\n`;var m=`export default function findMissingNumberInSequence(numbers: number[]): number {\n  const n: number = numbers.length;\n\n  // Iterate through the expected range of numbers from 0 to n\n  for (let i = 0; i <= n; i++) {\n    // Check if the current number \\`i\\` exists in the array\n    let found = false;\n    for (let j = 0; j < n; j++) {\n      if (numbers[j] === i) {\n        found = true;\n        break; // Stop searching once the number is found\n      }\n    }\n\n    // If the current number \\`i\\` is not found, it's the missing number\n    if (!found) {\n      return i;\n    }\n  }\n\n  // Return -1 if no missing number is found (should not happen in valid input)\n  return -1;\n}\n`;function f(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute Force\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The problem requires identifying the missing number in a sequence from 0 to \",(0,n.jsx)(e.code,{children:\"n\"}),\". The brute force solution iterates through the expected range of numbers and checks if each number exists in the array. For each number, another iteration through the array is performed to check for its presence. This approach involves nested loops, resulting in a time complexity of O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\"). This method is simple but inefficient for larger arrays due to repeated checks.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the expected range number \",(0,n.jsx)(e.code,{children:\"n\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the range of numbers from 0 to \",(0,n.jsx)(e.code,{children:\"n\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"For each number, iterate through the array to check if the current number is present.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the number is found, stop searching for it and move to the next number.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the number is not found, return it as the missing number.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return -1 if no missing number is found.\"}),`\n`]}),`\n`,(0,n.jsx)(s,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". For each number in the range 0 to \",(0,n.jsx)(e.code,{children:\"n\"}),\", a full traversal of the array is performed to check for its presence.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". No additional space is used apart from a few variables to store intermediate results.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Sorting\"}),`\n`,(0,n.jsx)(e.p,{children:\"To eliminate the redundant checks in the brute force solution, this optimized approach sorts the input array, making it easier to identify the missing number in a sequence by ensuring the numbers are in ascending order. Once sorted, the solution checks boundary cases (whether the first or last number in the sequence is missing). If no boundary case is detected, the solution iterates through the sorted array to check whether the expected values exists at each index.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Sort the input array in ascending order.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the last number is equal to the array length:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"If not, return the array length as the missing number.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Check if the first number is 0:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"If not, return 0 as the missing number.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the sorted array:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"For each number, calculate the expected next number as the current number plus one.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If the next number does not match the expected value, return the expected value as the missing number.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Return -1 if no missing number is found, which should not occur with valid input.\"}),`\n`]}),`\n`,(0,n.jsx)(s,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log n)\"}),\". Sorting the array dominates the runtime, requiring O(n log n) time. The subsequent iteration through the array is O(n).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". Sorting is performed in place, and no additional space is used beyond a few variables.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"3. Using mathematical property to calculate sum of numbers from 0 to n\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Sorting is probably unnecessary since the missing number can be determined by using the mathematical property of the sum of integers from 0 to \",(0,n.jsx)(e.code,{children:\"n\"}),\". The mathematical property eliminates the need to iterate through and compare elements. Instead, it calculates the total expected sum and subtracts the actual sum to find the missing number. This optimization removes the bottleneck of sorting and reduces the overall time complexity to O(n).\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"expectedSum\"}),\" to 0. This will hold the sum of all integers from 0 to \",(0,n.jsx)(e.code,{children:\"n\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Calculate the total expected sum of integers from 0 to \",(0,n.jsx)(e.code,{children:\"n\"}),\" using a loop and store the result in \",(0,n.jsx)(e.code,{children:\"expectedSum\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize \",(0,n.jsx)(e.code,{children:\"actualSum\"}),\" to 0. This will hold the sum of the elements in the given array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the array and calculate the sum of all its elements, storing it in \",(0,n.jsx)(e.code,{children:\"actualSum\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Subtract \",(0,n.jsx)(e.code,{children:\"actualSum\"}),\" from \",(0,n.jsx)(e.code,{children:\"expectedSum\"}),\" to determine the missing number.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the result.\"}),`\n`]}),`\n`,(0,n.jsx)(s,{children:a}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Calculating the expected sum and iterating through the array both take O(n) time.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(1)\"}),\". The solution uses a constant amount of space for variables.\"]}),`\n`]})]})}function T(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var j=T;return O(M);})();\n;return Component;"
}