{
  "description": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),C=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},i=(t,e,r,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let d of g(e))!f.call(t,d)&&d!==r&&o(t,d,{get:()=>e[d],enumerable:!(c=m(e,d))||c.enumerable});return t};var w=(t,e,r)=>(r=t!=null?u(b(t)):{},i(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),_=t=>i(o({},\"__esModule\",{value:!0}),t);var l=x((X,a)=>{a.exports=_jsx_runtime});var M={};C(M,{default:()=>D,frontmatter:()=>y});var n=w(l());var h=MDXTestExamples;var s=[{input:[[\"num\",6],[\"edges\",[[0,1],[4,5],[2,4],[1,3],[0,2]]]],output:1,explanation:\"All nodes are connected.\"},{input:[[\"num\",3],[\"edges\",[[0,1],[1,2]]]],output:1,explanation:\"All nodes are connected.\"},{input:[[\"num\",4],[\"edges\",[[0,1],[2,3]]]],output:2,explanation:\"There are two connected components: {0, 1} and {2, 3}.\"}];var y={title:\"Graph Count Connected Components\",excerpt:\"Implement a function to count connected components in a graph\"};function p(t){let e=Object.assign({p:\"p\",code:\"code\",a:\"a\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Consider a graph with \",(0,n.jsx)(e.code,{children:\"num\"}),\" nodes, labeled from \",(0,n.jsx)(e.code,{children:\"0\"}),\" to \",(0,n.jsx)(e.code,{children:\"num - 1\"}),\". Given \",(0,n.jsx)(e.code,{children:\"num\"}),\" and a list of edges where each \",(0,n.jsx)(e.code,{children:\"edges[i] = [a, b]\"}),\" represents an undirected connection between nodes \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"}),\", determine the number of connected components in the graph.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the context of a graph, a \",(0,n.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Component_(graph_theory)\",children:\"component\"}),\" of an undirected graph is a connected subgraph that is not part of any larger connected subgraph.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"num: number\"}),\": An integer, the number of nodes in the graph\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"edges: Array<[number, number]>\"}),\": A 2D array where \",(0,n.jsx)(e.code,{children:\"edges[i] = [a, b]\"}),\" represents an undirected edge between nodes \",(0,n.jsx)(e.code,{children:\"a\"}),\" and \",(0,n.jsx)(e.code,{children:\"b\"})]}),`\n`]}),`\n`,(0,n.jsx)(h,{testCases:s}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"num\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"edges.length\"}),\" <= 2000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"edges[i].length\"}),\" == 2\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"0 <= \",(0,n.jsx)(e.code,{children:\"a\"}),\" < \",(0,n.jsx)(e.code,{children:\"b\"}),\" < \",(0,n.jsx)(e.code,{children:\"num\"})]}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.code,{children:\"a != b\"})}),`\n`,(0,n.jsx)(e.li,{children:\"There are no self-loops or duplicate edges\"}),`\n`]})]})}function A(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var D=A;return _(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to count connected components in a graph",
    "title": "Graph Count Connected Components"
  },
  "solution": "var Component=(()=>{var p=Object.create;var o=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},d=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of v(e))!y.call(t,i)&&i!==r&&o(t,i,{get:()=>e[i],enumerable:!(s=f(e,i))||s.enumerable});return t};var z=(t,e,r)=>(r=t!=null?p(g(t)):{},d(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>d(o({},\"__esModule\",{value:!0}),t);var l=b((F,a)=>{a.exports=_jsx_runtime});var D={};x(D,{default:()=>A});var n=z(l());var c=MDXCodeBlock;var h=`// Depth-First Search (DFS) to explore all nodes in a component\nfunction dfs(adjList: number[][], visited: number[], src: number): void {\n  // Mark the current node as visited\n  visited[src] = 1;\n\n  // Traverse all adjacent nodes\n  for (const neighbor of adjList[src]) {\n    if (visited[neighbor] === 0) {\n      dfs(adjList, visited, neighbor);\n    }\n  }\n}\n\nexport default function graphCountConnectedComponents(\n  num: number,\n  edges: Array<[number, number]>,\n): number {\n  // Edge case: if there are no nodes, return 0\n  if (num === 0) return 0;\n\n  // Initialize the count of connected components\n  let components = 0;\n  // Create an array to track visited nodes\n  const visited = new Array(num).fill(0);\n  // Create an adjacency list to represent the graph\n  const adjList: number[][] = Array.from({ length: num }, () => []);\n\n  // Build the adjacency list from edges\n  for (const [u, v] of edges) {\n    adjList[u].push(v);\n    adjList[v].push(u);\n  }\n\n  // Perform DFS for each unvisited node to count components\n  for (let i = 0; i < num; i++) {\n    if (visited[i] === 0) {\n      components++;\n      dfs(adjList, visited, i);\n    }\n  }\n\n  return components;\n}\n`;var u=`function find(representative: number[], vertex: number): number {\n  if (vertex === representative[vertex]) {\n    return vertex;\n  }\n  // Path compression\n  representative[vertex] = find(representative, representative[vertex]);\n  return representative[vertex];\n}\n\nfunction combine(\n  representative: number[],\n  size: number[],\n  vertex1: number,\n  vertex2: number,\n): number {\n  // Find the root representatives of both vertices\n  vertex1 = find(representative, vertex1);\n  vertex2 = find(representative, vertex2);\n\n  // If both vertices are already in the same set\n  if (vertex1 === vertex2) {\n    return 0; // No union occurred\n  } else {\n    // Union by size\n    if (size[vertex1] > size[vertex2]) {\n      size[vertex1] += size[vertex2];\n      representative[vertex2] = vertex1;\n    } else {\n      size[vertex2] += size[vertex1];\n      representative[vertex1] = vertex2;\n    }\n    return 1; // Union occurred\n  }\n}\n\nexport default function graphCountConnectedComponents(\n  num: number,\n  edges: Array<[number, number]>,\n): number {\n  // Initialize representative and size arrays\n  const representative = new Array(num).fill(0).map((_, index) => index);\n  const size = new Array(num).fill(1);\n\n  // Initialize the number of components\n  let components = num;\n\n  // Process each edge and union the components\n  for (const [u, v] of edges) {\n    components -= combine(representative, size, u, v);\n  }\n\n  return components;\n}\n`;function m(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Using DFS\"}),`\n`,(0,n.jsx)(e.p,{children:\"The problem requires counting the number of connected components in an undirected graph. A connected component is a subgraph where any two nodes are reachable from each other, and no node in the subgraph is connected to any node outside of it.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The approach uses depth-first search (DFS) to explore the graph. The intuition is to treat the graph as a collection of nodes and edges, represented by an adjacency list. By starting at an unvisited node, a DFS traversal will explore all nodes in the same connected component. Each time a new unvisited node is encountered, it indicates the start of a new connected component. This ensures all nodes are processed, and no component is missed. The \",(0,n.jsx)(e.code,{children:\"visited\"}),\" array is used to track nodes that have already been explored, avoiding redundant traversals.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This method eliminates unnecessary traversal of nodes already part of a known connected component, making it efficient and systematic.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Handle the edge case where the number of nodes (\",(0,n.jsx)(e.code,{children:\"num\"}),\") is \",(0,n.jsx)(e.code,{children:\"0\"}),\" by returning \",(0,n.jsx)(e.code,{children:\"0\"}),\" immediately.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"A counter \",(0,n.jsx)(e.code,{children:\"components\"}),\" to keep track of the number of connected components.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"An array \",(0,n.jsx)(e.code,{children:\"visited\"}),\" of size \",(0,n.jsx)(e.code,{children:\"num\"}),\" with all elements set to \",(0,n.jsx)(e.code,{children:\"0\"}),\" to mark unvisited nodes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"An adjacency list \",(0,n.jsx)(e.code,{children:\"adjList\"}),\" to represent the graph, initialized as an array of empty arrays.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Build the adjacency list from the given \",(0,n.jsx)(e.code,{children:\"edges\"}),\" by adding each edge to the list of both connected nodes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through all nodes:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"If a node has not been visited, increment the \",(0,n.jsx)(e.code,{children:\"components\"}),\" counter.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Perform a DFS starting from this node to mark all reachable nodes in the current connected component as visited.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the value of \",(0,n.jsx)(e.code,{children:\"components\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{children:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(v + e)\"}),\". Each node (\",(0,n.jsx)(e.code,{children:\"v\"}),\") and edge (\",(0,n.jsx)(e.code,{children:\"e\"}),\") is processed exactly once during the DFS traversal.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(v + e)\"}),\". The adjacency list requires O(v + e) space to store the graph, and the \",(0,n.jsx)(e.code,{children:\"visited\"}),\" array requires O(v) space.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Disjoint Set Union\"}),`\n`,(0,n.jsxs)(e.p,{children:['The intuition is to treat each node as its own component initially. As edges are processed, nodes are merged into the same component if they are connected. The union-find data structure efficiently tracks the components by maintaining a representative for each set and combining sets using the \"union by size\" strategy to minimize tree height. Path compression further optimizes the ',(0,n.jsx)(e.code,{children:\"find\"}),\" operation by flattening the tree structure during lookups.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"This approach avoids redundant traversal of the graph by directly managing the relationships between components using efficient operations, making it well-suited for counting connected components.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize two arrays:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"representative\"}),\" to track the representative of each node. Initially, each node is its own representative.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"size\"}),\" to store the size of each component. All nodes are initialized with size \",(0,n.jsx)(e.code,{children:\"1\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Set the initial count of connected components to the number of nodes (\",(0,n.jsx)(e.code,{children:\"num\"}),\").\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a \",(0,n.jsx)(e.code,{children:\"find\"}),\" function to determine the representative of a node:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"If a node is its own representative, return the node.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Otherwise, recursively find the representative of its parent, applying path compression to flatten the tree structure.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Define a \",(0,n.jsx)(e.code,{children:\"combine\"}),\" function to merge two sets:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Find the root representatives of the two sets.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"If the representatives are the same, the nodes are already in the same set. Return \",(0,n.jsx)(e.code,{children:\"0\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Otherwise, perform a union by size:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Attach the smaller set to the larger set and update the size.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return \",(0,n.jsx)(e.code,{children:\"1\"}),\" to indicate a union occurred.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the list of edges. For each edge, call the \",(0,n.jsx)(e.code,{children:\"combine\"}),\" function to union the connected nodes and reduce the count of connected components.\"]}),`\n`,(0,n.jsx)(e.li,{children:\"Return the final count of connected components.\"}),`\n`]}),`\n`,(0,n.jsx)(c,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(e.\\u03B1(v))\"}),\". The union-find operations \",(0,n.jsx)(e.code,{children:\"find\"}),\" and \",(0,n.jsx)(e.code,{children:\"union\"}),\" are nearly constant time due to path compression and union by size, where \\u03B1(v) is the inverse Ackermann function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(v)\"}),\". The \",(0,n.jsx)(e.code,{children:\"representative\"}),\" and \",(0,n.jsx)(e.code,{children:\"size\"}),\" arrays require space proportional to the number of nodes (\",(0,n.jsx)(e.code,{children:\"v\"}),\").\"]}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var A=k;return w(D);})();\n;return Component;"
}