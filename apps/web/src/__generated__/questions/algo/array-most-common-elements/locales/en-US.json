{
  "description": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},u=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of f(e))!x.call(t,o)&&o!==r&&i(t,o,{get:()=>e[o],enumerable:!(s=p(e,o))||s.enumerable});return t};var k=(t,e,r)=>(r=t!=null?d(b(t)):{},u(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),q=t=>u(i({},\"__esModule\",{value:!0}),t);var l=g((X,a)=>{a.exports=_jsx_runtime});var M={};y(M,{default:()=>C,frontmatter:()=>T});var n=k(l());var c=MDXTestExamples;var h=[{input:[[\"numbers\",[4,4,4,6,6,5,5,5]],[\"k\",2]],output:[4,5],explanation:\"The two most frequent numbers are 4 and 5, as they appear the most often in the array.\"},{input:[[\"numbers\",[7,7,7,8,8,9,9,9]],[\"k\",3]],output:[7,9,8],explanation:\"The three most frequent numbers are 7, 9, and 8.\"},{input:[[\"numbers\",[10,10,10,10,10]],[\"k\",1]],output:[10],explanation:\"Since there is only one unique number, 10, it is the most frequent.\"}];var T={title:\"Most Common Elements\",excerpt:\"Implement a function to determine the most common elements in an integer array\"};function m(t){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Given an array of integers \",(0,n.jsx)(e.code,{children:\"numbers\"}),\" and a number \",(0,n.jsx)(e.code,{children:\"k\"}),\", find the \",(0,n.jsx)(e.code,{children:\"k\"}),\" most frequent numbers in the array. Here, \",(0,n.jsx)(e.code,{children:\"k\"}),\" represents the number of elements that should be returned, which are the ones that appear the most frequently. The order of the result does not matter.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"numbers: number[]\"}),\": An array of integers\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"k\"}),\": An integer\"]}),`\n`]}),`\n`,(0,n.jsx)(c,{testCases:h}),`\n`,(0,n.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"numbers.length\"}),\" <= 1000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"-10,000 <= \",(0,n.jsx)(e.code,{children:\"numbers[i]\"}),\" <= 10,000\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"1 <= \",(0,n.jsx)(e.code,{children:\"k\"}),\" <= Number of unique elements in \",(0,n.jsx)(e.code,{children:\"numbers\"})]}),`\n`,(0,n.jsx)(e.li,{children:\"The solution is guaranteed to have a unique result\"}),`\n`]})]})}function _(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(m,t)})):m(t)}var C=_;return q(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to determine the most common elements in an integer array",
    "title": "Most Common Elements"
  },
  "solution": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var y=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var q=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var k=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),x=(t,e)=>{for(var r in e)c(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,h)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of b(e))!g.call(t,i)&&i!==r&&c(t,i,{get:()=>e[i],enumerable:!(h=y(e,i))||h.enumerable});return t};var M=(t,e,r)=>(r=t!=null?p(q(t)):{},a(e||!t||!t.__esModule?c(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>a(c({},\"__esModule\",{value:!0}),t);var s=k((z,l)=>{l.exports=_jsx_runtime});var v={};x(v,{default:()=>T});var n=M(s());var o=MDXCodeBlock;var u=`export default function mostCommonElements(\n  numbers: number[],\n  k: number,\n): number[] {\n  // If k equals the size of numbers, return numbers as the result since all elements are required\n  if (k === numbers.length) {\n    return numbers;\n  }\n\n  // Step 1: Create a hash map to count the frequency of each element in numbers\n  const countMap = new Map<number, number>();\n  numbers.forEach((k) => {\n    countMap.set(k, (countMap.get(k) || 0) + 1);\n  });\n\n  // Step 2: Initialize a min-heap with a custom comparator to keep the most frequent elements\n  const heap: number[] = [];\n  const comp = (n1: number, n2: number) =>\n    (countMap.get(n1) || 0) - (countMap.get(n2) || 0);\n\n  // Step 3: Insert elements into the heap and maintain the size of the heap to k\n  countMap.forEach((_, key) => {\n    heap.push(key);\n    heap.sort(comp); // Maintain heap order after insertion\n    if (heap.length > k) heap.shift(); // Remove the least frequent element if heap exceeds size k\n  });\n\n  // Step 4: The heap now contains the k most frequent elements; return them as the result\n  return heap;\n}\n`;var d=`export default function mostCommonElements(\n  numbers: number[],\n  k: number,\n): number[] {\n  const frequencyMap: { [key: number]: number } = {};\n\n  // Count the frequency of each number in the array\n  for (let i = 0; i < numbers.length; i++) {\n    frequencyMap[numbers[i]] = (frequencyMap[numbers[i]] || 0) + 1;\n  }\n\n  // Create an array of buckets where the index represents the frequency\n  const buckets: number[][] = Array(numbers.length + 1)\n    .fill(null)\n    .map(() => []);\n\n  // Place numbers into the corresponding bucket based on their frequency\n  for (const num in frequencyMap) {\n    const frequency = frequencyMap[num];\n    buckets[frequency].push(Number(num));\n  }\n\n  const result: number[] = [];\n\n  // Iterate from the highest frequency bucket to the lowest\n  for (let i = buckets.length - 1; i >= 0 && k > 0; i--) {\n    if (buckets[i].length > 0) {\n      for (const num of buckets[i]) {\n        result.push(num);\n        k--;\n        if (k === 0) break;\n      }\n    }\n  }\n\n  return result;\n}\n`;var m=`export default function mostCommonElements(\n  numbers: number[],\n  k: number,\n): number[] {\n  const frequency: { value: number; count: number }[] = [];\n\n  // Step 1: Calculate frequencies manually using nested loops\n  for (let i = 0; i < numbers.length; i++) {\n    let found = false;\n    for (let j = 0; j < frequency.length; j++) {\n      if (frequency[j].value === numbers[i]) {\n        frequency[j].count++;\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      frequency.push({ value: numbers[i], count: 1 });\n    }\n  }\n\n  // Step 2: Sort the frequencies array by count in descending order\n  frequency.sort((a, b) => b.count - a.count);\n\n  // Step 3: Extract the \\`k\\` most common elements\n  const result: number[] = [];\n  for (let i = 0; i < k && i < frequency.length; i++) {\n    result.push(frequency[i].value);\n  }\n\n  return result;\n}\n`;function f(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",code:\"code\",ul:\"ul\",strong:\"strong\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"1. Brute Force\"}),`\n`,(0,n.jsx)(e.p,{children:\"A naive approach is to calculate the frequency of each element using nested loops. The frequencies are stored in a separate array, and then the array is sorted to find the most common elements.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Initialize an empty array \",(0,n.jsx)(e.code,{children:\"frequency\"}),\" to store objects with \",(0,n.jsx)(e.code,{children:\"value\"}),\" and \",(0,n.jsx)(e.code,{children:\"count\"}),\" properties.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the input array:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"For each number, check if it already exists in the \",(0,n.jsx)(e.code,{children:\"frequency\"}),\" array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If it exists, increment its \",(0,n.jsx)(e.code,{children:\"count\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If it does not exist, add it to the \",(0,n.jsx)(e.code,{children:\"frequency\"}),\" array with an initial \",(0,n.jsx)(e.code,{children:\"count\"}),\" of 1.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Sort the \",(0,n.jsx)(e.code,{children:\"frequency\"}),\" array in descending order of \",(0,n.jsx)(e.code,{children:\"count\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Extract the first \",(0,n.jsx)(e.code,{children:\"k\"}),\" elements from the sorted \",(0,n.jsx)(e.code,{children:\"frequency\"}),\" array.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return an array containing the \",(0,n.jsx)(e.code,{children:\"value\"}),\" of the top \",(0,n.jsx)(e.code,{children:\"k\"}),\" elements.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:m}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Time complexity: O(n\",(0,n.jsx)(\"sup\",{children:\"2\"}),\")\"]}),\". This is due to the nested loop for frequency calculation.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". If all \",(0,n.jsx)(e.code,{children:\"n\"}),\" elements in numbers are unique, the frequency array will have a size of O(n).\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"2. Using Heap\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The brute force solution had a major bottleneck due to its nested loops for calculating frequencies and sorting the entire frequency array. This led to redundant comparisons and high time complexity. The optimized approach uses a hash map for frequency counting, which avoids duplicate computations, and a min-heap to maintain the top \",(0,n.jsx)(e.code,{children:\"k\"}),\" frequent elements efficiently. This significantly reduces unnecessary sorting and comparisons, focusing only on the required elements.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Check if \",(0,n.jsx)(e.code,{children:\"k\"}),\" is equal to the size of the input array. If true, return the array as all elements are required.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Create a hash map to count the frequency of each element in the array:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Iterate through the array, updating the frequency count for each element in the hash map.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.li,{children:\"Initialize a min-heap with a custom comparator to sort elements by their frequency.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through the elements in the hash map:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Insert each element into the heap while maintaining the heap's size to \",(0,n.jsx)(e.code,{children:\"k\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"After each insertion, sort the heap using the comparator and remove the least frequent element if the heap size exceeds \",(0,n.jsx)(e.code,{children:\"k\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Return the elements in the heap, which are the \",(0,n.jsx)(e.code,{children:\"k\"}),\" most frequent elements.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:u}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n log k)\"}),\". Maintaining the heap requires sorting up to \",(0,n.jsx)(e.code,{children:\"k\"}),\" elements for each of the n unique elements, which takes O(n log k) in total.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n + k)\"}),\". The hash map requires O(n) space to store no more than \",(0,n.jsx)(e.code,{children:\"n\"}),\" unique elements, and the heap requires O(k) space to store the top \",(0,n.jsx)(e.code,{children:\"k\"}),\" elements.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"3. Using Map\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another approach uses a frequency map to count occurrences of each number. A \",(0,n.jsx)(e.code,{children:\"buckets\"}),\" array is then built to group elements by their frequencies, where the index corresponds to the frequency. Traversing the \",(0,n.jsx)(e.code,{children:\"buckets\"}),\" array from highest frequency to lowest frequency efficiently collects the top \",(0,n.jsx)(e.code,{children:\"k\"}),\" frequent elements without incurring an O(n log n) sorting step. This approach reduces the overall complexity to O(n).\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Build a frequency map \",(0,n.jsx)(e.code,{children:\"frequencyMap\"}),\" that maps each number to its frequency count .\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Build a \",(0,n.jsx)(e.code,{children:\"buckets\"}),\" array, where each index corresponds to a frequency and stores an array of numbers with that frequency.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Iterate through \",(0,n.jsx)(e.code,{children:\"buckets\"}),\" from the highest frequency bucket to the lowest frequency bucket and select numbers until \",(0,n.jsx)(e.code,{children:\"k\"}),\" is reached.\"]}),`\n`]}),`\n`,(0,n.jsx)(o,{children:d}),`\n`,(0,n.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Counting frequencies and then populating buckets both run in O(n), followed by a final pass that selects at most \",(0,n.jsx)(e.code,{children:\"k\"}),\" elements, still O(n).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". The \",(0,n.jsx)(e.code,{children:\"frequencyMap\"}),\" and \",(0,n.jsx)(e.code,{children:\"buckets\"}),\" array each take up to O(n) space.\"]}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(f,t)})):f(t)}var T=j;return w(v);})();\n;return Component;"
}