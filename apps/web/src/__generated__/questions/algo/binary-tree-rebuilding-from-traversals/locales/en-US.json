{
  "description": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),g=(n,e)=>{for(var t in e)i(n,t,{get:e[t],enumerable:!0})},s=(n,e,t,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of f(e))!b.call(n,o)&&o!==t&&i(n,o,{get:()=>e[o],enumerable:!(d=m(e,o))||d.enumerable});return n};var y=(n,e,t)=>(t=n!=null?p(x(n)):{},s(e||!n||!n.__esModule?i(t,\"default\",{value:n,enumerable:!0}):t,n)),T=n=>s(i({},\"__esModule\",{value:!0}),n);var l=v((X,a)=>{a.exports=_jsx_runtime});var M={};g(M,{default:()=>C,frontmatter:()=>w});var r=y(l());var c=MDXTestExamples;var h=[{input:[[\"preorder\",[3,1,2,6,5,9]],[\"inorder\",[1,2,3,5,6,9]]],output:[3,1,6,null,2,5,9],explanation:\"The root is 3, with left subtree [1, 2] and right subtree [6, 5, 9].\"},{input:[[\"preorder\",[1,2,3]],[\"inorder\",[3,2,1]]],output:[1,2,null,3],explanation:\"The root is 1, with left subtree [2, 3] and no right subtree.\"},{input:[[\"preorder\",[7]],[\"inorder\",[7]]],output:[7],explanation:\"The tree consists of a single node with the value 7, which is both the root and the only node.\"}];var w={title:\"Binary Tree Rebuilding from Preorder and Inorder Traversals\",excerpt:\"Implement a function to construct a binary tree from preorder and inorder traversals\"};function u(n){let e=Object.assign({p:\"p\",code:\"code\",h3:\"h3\",ul:\"ul\",li:\"li\"},n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[\"Given two arrays of integers, \",(0,r.jsx)(e.code,{children:\"preorder\"}),\" and \",(0,r.jsx)(e.code,{children:\"inorder\"}),\", where \",(0,r.jsx)(e.code,{children:\"preorder\"}),\" represents the values of a preorder traversal of a binary tree, and \",(0,r.jsx)(e.code,{children:\"inorder\"}),\" represents the values of an inorder traversal of the same tree, construct and return the binary tree from these traversals.\"]}),`\n`,(0,r.jsx)(e.h3,{children:\"Input\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"preorder: number[]\"}),\": An array of positive integers\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"inorder: number[]\"}),\": An array of positive integers\"]}),`\n`]}),`\n`,(0,r.jsx)(c,{testCases:h}),`\n`,(0,r.jsx)(e.h3,{children:\"Constraints\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"1 <= Number of nodes <= 1000\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"1 <= \",(0,r.jsx)(e.code,{children:\"TreeNode.val\"}),\" <= 1,000,000\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:\"preorder\"}),\" and \",(0,r.jsx)(e.code,{children:\"inorder\"}),\" contain unique values\"]}),`\n`]})]})}function _(n={}){let{wrapper:e}=n.components||{};return e?(0,r.jsx)(e,Object.assign({},n,{children:(0,r.jsx)(u,n)})):u(n)}var C=_;return T(M);})();\n;return Component;",
  "info": {
    "excerpt": "Implement a function to construct a binary tree from preorder and inorder traversals",
    "title": "Binary Tree Rebuilding from Preorder and Inorder Traversals"
  },
  "solution": "var Component=(()=>{var f=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var b=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),T=(t,e)=>{for(var n in e)i(t,n,{get:e[n],enumerable:!0})},a=(t,e,n,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!y.call(t,o)&&o!==n&&i(t,o,{get:()=>e[o],enumerable:!(l=m(e,o))||l.enumerable});return t};var v=(t,e,n)=>(n=t!=null?f(g(t)):{},a(e||!t||!t.__esModule?i(n,\"default\",{value:t,enumerable:!0}):n,t)),x=t=>a(i({},\"__esModule\",{value:!0}),t);var h=b((j,s)=>{s.exports=_jsx_runtime});var I={};T(I,{default:()=>k});var r=v(h());var d=MDXCodeBlock;var c=`class TreeNode {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n\n  constructor(\n    val: number,\n    left: TreeNode | null = null,\n    right: TreeNode | null = null,\n  ) {\n    this.val = val;\n    this.left = left;\n    this.right = right;\n  }\n}\n\nexport default function binaryTreeRebuildingFromTraversals(\n  preorder: number[],\n  inorder: number[],\n): TreeNode | null {\n  let preorderIndex = 0;\n\n  // Create a map to store the index of each value in the inorder array for quick lookup\n  let inorderIndexMap = new Map();\n  for (let i = 0; i < inorder.length; i++) {\n    inorderIndexMap.set(inorder[i], i);\n  }\n\n  // Helper function to recursively build the tree\n  function arrayToTree(left: number, right: number): TreeNode | null {\n    // Base case: if there are no elements to construct the tree\n    if (left > right) {\n      return null;\n    }\n\n    // Select the current element from preorder as the root and increment the index\n    let rootValue = preorder[preorderIndex++];\n    let root = new TreeNode(rootValue);\n\n    // Build the left subtree using elements to the left of the root in the inorder array\n    root.left = arrayToTree(left, inorderIndexMap.get(rootValue)! - 1);\n\n    // Build the right subtree using elements to the right of the root in the inorder array\n    root.right = arrayToTree(inorderIndexMap.get(rootValue)! + 1, right);\n\n    // Return the constructed subtree rooted at this node\n    return root;\n  }\n\n  // Start constructing the tree from the full range of the inorder array\n  return arrayToTree(0, preorder.length - 1);\n}\n`;function u(t){let e=Object.assign({h2:\"h2\",p:\"p\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",strong:\"strong\"},t.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h2,{children:\"1. Using Recursion\"}),`\n`,(0,r.jsx)(e.p,{children:\"The goal is to reconstruct a binary tree from its preorder and inorder traversals. In the preorder traversal, the first element is always the root of the tree. The inorder traversal divides the tree into its left and right subtrees based on the root's position. By combining these two traversals, it is possible to identify the root and recursively reconstruct the left and right subtrees.\"}),`\n`,(0,r.jsx)(e.p,{children:\"To optimize this process, a map is created to store the indices of elements in the inorder traversal, allowing for O(1) lookup of a root's position in the inorder array. Using this map, the algorithm avoids repeatedly searching for elements in the inorder traversal, which would otherwise result in higher time complexity.\"}),`\n`,(0,r.jsx)(e.h3,{children:\"Algorithm\"}),`\n`,(0,r.jsxs)(e.ol,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Create a map to store the index of each value in the inorder array for quick lookups.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Define a recursive function to construct the tree within a given range of the inorder array.\"}),`\n`,(0,r.jsxs)(e.li,{children:[\"In the recursive function:\",`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsx)(e.li,{children:\"Select the current element in the preorder array as the root and increment the preorder index.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Use the inorder map to locate the root's position in the inorder array.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Recursively build the left subtree using elements to the left of the root in the inorder array.\"}),`\n`,(0,r.jsx)(e.li,{children:\"Recursively build the right subtree using elements to the right of the root in the inorder array.\"}),`\n`]}),`\n`]}),`\n`,(0,r.jsx)(e.li,{children:\"Return the constructed tree after processing all elements in the preorder array.\"}),`\n`]}),`\n`,(0,r.jsx)(d,{children:c}),`\n`,(0,r.jsx)(e.h3,{children:\"Big-O analysis\"}),`\n`,(0,r.jsxs)(e.ul,{children:[`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Time complexity: O(n)\"}),\". Each node is processed once, and the map allows O(1) lookups for indices in the inorder array.\"]}),`\n`,(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:\"Space complexity: O(n)\"}),\". Space is used for the recursion stack and the map storing the indices of elements in the inorder array.\"]}),`\n`]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,Object.assign({},t,{children:(0,r.jsx)(u,t)})):u(t)}var k=M;return x(I);})();\n;return Component;"
}