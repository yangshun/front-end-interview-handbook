{
  "description": "var Component=(()=>{var m=Object.create;var r=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var w=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),f=(i,e)=>{for(var n in e)r(i,n,{get:e[n],enumerable:!0})},a=(i,e,n,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!u.call(i,o)&&o!==n&&r(i,o,{get:()=>e[o],enumerable:!(s=d(e,o))||s.enumerable});return i};var x=(i,e,n)=>(n=i!=null?m(g(i)):{},a(e||!i||!i.__esModule?r(n,\"default\",{value:i,enumerable:!0}):n,i)),v=i=>a(r({},\"__esModule\",{value:!0}),i);var c=w((N,l)=>{l.exports=_jsx_runtime});var y={};f(y,{default:()=>_,frontmatter:()=>b});var t=x(c()),b={title:\"Video Streaming (e.g. Netflix)\",excerpt:\"Design a video streaming application like Netflix and YouTube\"};function h(i){let e=Object.assign({p:\"p\",h2:\"h2\",img:\"img\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},i.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.p,{children:\"Designing a video streaming application is a common but complex system design question, but there are limited resources that provide a comprehensive guide on how to design the front end for such platforms.\"}),`\n`,(0,t.jsx)(e.h2,{children:\"Question\"}),`\n`,(0,t.jsx)(e.p,{children:\"Design a video streaming application similar to platforms like Netflix and YouTube that allows users to browse through a library of video content to discover interesting videos and watch videos.\"}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-netflix-discovery-page.png\",alt:\"Netflix recommendations page\"})}),`\n`,(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-netflix-watch-page.png\",alt:\"Netflix watch page\"})}),`\n`,(0,t.jsx)(e.h3,{children:\"Real-life examples\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.netflix.com\",children:\"https://www.netflix.com\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.youtube.com\",children:\"https://www.youtube.com\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.hulu.com\",children:\"https://www.hulu.com\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://www.primevideo.com\",children:\"https://www.primevideo.com\"})}),`\n`]})]})}function j(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,Object.assign({},i,{children:(0,t.jsx)(h,i)})):h(i)}var _=j;return v(y);})();\n;return Component;",
  "metadata": {
    "access": "premium",
    "author": null,
    "companies": [
      "openai"
    ],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 45,
    "excerpt": "Design a video streaming application like Netflix and YouTube",
    "featured": false,
    "format": "system-design",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/system-design/video-streaming-netflix",
    "importance": "medium",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 6,
    "similarQuestions": [],
    "slug": "video-streaming-netflix",
    "subtitle": null,
    "title": "Video Streaming (e.g. Netflix)",
    "topics": [
      "networking",
      "performance"
    ]
  },
  "solution": "var Component=(()=>{var h=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),v=(n,e)=>{for(var t in e)o(n,t,{get:e[t],enumerable:!0})},s=(n,e,t,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!g.call(n,a)&&a!==t&&o(n,a,{get:()=>e[a],enumerable:!(r=p(e,a))||r.enumerable});return n};var b=(n,e,t)=>(t=n!=null?h(m(n)):{},s(e||!n||!n.__esModule?o(t,\"default\",{value:n,enumerable:!0}):t,n)),y=n=>s(o({},\"__esModule\",{value:!0}),n);var l=f((A,d)=>{d.exports=_jsx_runtime});var T={};v(T,{default:()=>k,tableOfContents:()=>w});var i=b(l()),w=[{depth:2,value:\"Requirements exploration\",id:\"requirements-exploration\",children:[{depth:3,value:\"What are the core features to be supported?\",id:\"what-are-the-core-features-to-be-supported\"},{depth:3,value:\"What is the desired video playback quality and resolution?\",id:\"what-is-the-desired-video-playback-quality-and-resolution\"},{depth:3,value:\"What functionality should the video player include?\",id:\"what-functionality-should-the-video-player-include\"},{depth:3,value:\"What devices will the application be used on?\",id:\"what-devices-will-the-application-be-used-on\"},{depth:3,value:\"What are the non-functional requirements?\",id:\"what-are-the-non-functional-requirements\"}]},{depth:2,value:\"Background\",id:\"background\",children:[{depth:3,value:\"Glossary\",id:\"glossary\"},{depth:3,value:\"Video playback on the web\",id:\"video-playback-on-the-web\"},{depth:3,value:\"Video formats\",id:\"video-formats\"}]},{depth:2,value:\"Architecture / high-level design\",id:\"architecture--high-level-design\",children:[{depth:3,value:\"Rendering approach\",id:\"rendering-approach\"},{depth:3,value:\"Single-page application (SPA) or Multi-page application (MPA)?\",id:\"single-page-application-spa-or-multi-page-application-mpa\"},{depth:3,value:\"Component responsibilities\",id:\"component-responsibilities\"}]},{depth:2,value:\"Data model\",id:\"data-model\"},{depth:2,value:\"Interface definition (API)\",id:\"interface-definition-api\",children:[{depth:3,value:\"Video recommendations API\",id:\"video-recommendations-api\"},{depth:3,value:\"Media streaming and subtitles API\",id:\"media-streaming-and-subtitles-api\"},{depth:3,value:\"Video player API\",id:\"video-player-api\"}]},{depth:2,value:\"Video player data model, architecture, and API\",id:\"video-player-data-model-architecture-and-api\"},{depth:2,value:\"Optimizations and deep dive\",id:\"optimizations-and-deep-dive\",children:[{depth:3,value:\"Understanding native HTML <video> elements\",id:\"understanding-native-html-video-elements\",children:[{depth:4,value:\"Progressive downloading\",id:\"progressive-downloading\"},{depth:4,value:\"<video> element attributes\",id:\"video-element-attributes\"},{depth:4,value:\"HTMLVideoElement methods\",id:\"htmlvideoelement-methods\"},{depth:4,value:\"HTMLVideoElement events\",id:\"htmlvideoelement-events\"},{depth:4,value:\"Drawbacks of using <video>\",id:\"drawbacks-of-using-video\"}]},{depth:3,value:\"Video streaming\",id:\"video-streaming\",children:[{depth:4,value:\"Media Source API\",id:\"media-source-api\"},{depth:4,value:\"Adaptive Bitrate Streaming\",id:\"adaptive-bitrate-streaming\"},{depth:4,value:\"Media Capabilities API\",id:\"media-capabilities-api\"},{depth:4,value:\"Streaming protocols\",id:\"streaming-protocols\"},{depth:4,value:\"Dynamic Adaptive Streaming over HTTP (DASH)\",id:\"dynamic-adaptive-streaming-over-http-dash\"},{depth:4,value:\"HTTP Live Streaming (HLS)\",id:\"http-live-streaming-hls\"},{depth:4,value:\"Manifest file\",id:\"manifest-file\"},{depth:4,value:\"Resources\",id:\"resources\"}]},{depth:3,value:\"Subtitles / Closed Captions\",id:\"subtitles--closed-captions\",children:[{depth:4,value:\"Separate subtitles files\",id:\"separate-subtitles-files\"},{depth:4,value:\"Embedded subtitles\",id:\"embedded-subtitles\"},{depth:4,value:\"Separate API\",id:\"separate-api\"},{depth:4,value:\"Accessibility features\",id:\"accessibility-features\"},{depth:4,value:\"Multilingual support\",id:\"multilingual-support\"},{depth:4,value:\"Resources\",id:\"resources-1\"}]},{depth:3,value:\"Performance\",id:\"performance\",children:[{depth:4,value:\"Minimizing latency and delay\",id:\"minimizing-latency-and-delay\"},{depth:4,value:\"Improving video startup time by separating video lifecycle from UI lifecycle\",id:\"improving-video-startup-time-by-separating-video-lifecycle-from-ui-lifecycle\"},{depth:4,value:\"Separating audio and video streams\",id:\"separating-audio-and-video-streams\"},{depth:4,value:\"Image optimizations\",id:\"image-optimizations\"},{depth:4,value:\"Bandwidth efficiency\",id:\"bandwidth-efficiency\"},{depth:4,value:\"Memory usage\",id:\"memory-usage\"}]},{depth:3,value:\"User experience\",id:\"user-experience\",children:[{depth:4,value:\"Ease of use\",id:\"ease-of-use\"},{depth:4,value:\"Customization\",id:\"customization\"},{depth:4,value:\"Enhanced experience\",id:\"enhanced-experience\"}]},{depth:3,value:\"Accessibility (a11y)\",id:\"accessibility-a11y\",children:[{depth:4,value:\"Subtitles\",id:\"subtitles\"},{depth:4,value:\"Visual assistance\",id:\"visual-assistance\"},{depth:4,value:\"Screen readers\",id:\"screen-readers\"},{depth:4,value:\"Keyboard support\",id:\"keyboard-support\"},{depth:4,value:\"External sources of control\",id:\"external-sources-of-control\"}]},{depth:3,value:\"Internationalization (i18n)\",id:\"internationalization-i18n\"},{depth:3,value:\"Bonus\",id:\"bonus\",children:[{depth:4,value:\"How to serve thumbnails when hover the seek bar\",id:\"how-to-serve-thumbnails-when-hover-the-seek-bar\"}]}]},{depth:2,value:\"References\",id:\"references\"}];function c(n){let e=Object.assign({h2:\"h2\",h3:\"h3\",ul:\"ul\",li:\"li\",p:\"p\",strong:\"strong\",a:\"a\",code:\"code\",ol:\"ol\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",img:\"img\",pre:\"pre\",em:\"em\",h4:\"h4\"},n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h2,{id:\"requirements-exploration\",children:\"Requirements exploration\"}),`\n`,(0,i.jsx)(e.h3,{id:\"what-are-the-core-features-to-be-supported\",children:\"What are the core features to be supported?\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Browsing of recommended videos on the homepage (Discover/recommendations page).\"}),`\n`,(0,i.jsx)(e.li,{children:\"Autoplaying billboard video at the top of the discover/recommendations page.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Playback of video content on a standalone page.\"}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"what-is-the-desired-video-playback-quality-and-resolution\",children:\"What is the desired video playback quality and resolution?\"}),`\n`,(0,i.jsx)(e.p,{children:\"Multiple resolutions and streaming quality options should be supported and automatically chosen depending on the device conditions.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"what-functionality-should-the-video-player-include\",children:\"What functionality should the video player include?\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video progress\"}),\": Play, pause, skip, seeking (jumping) to a specific timestamp of the video, adjusting playback rate.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Audio\"}),\": Changing language, adjusting volume.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Subtitles\"}),\": Subtitles display and selection of subtitle languages.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"what-devices-will-the-application-be-used-on\",children:\"What devices will the application be used on?\"}),`\n`,(0,i.jsx)(e.p,{children:\"Primarily desktop but it should also be usable on tablet and mobile.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"what-are-the-non-functional-requirements\",children:\"What are the non-functional requirements?\"}),`\n`,(0,i.jsx)(e.p,{children:\"Prioritize a smooth video watching experience, users shouldn't have to wait too long before they can start watching the video:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Users on slow internet connections should still be able to watch the videos even if a lower quality version is to be served.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Reduce stuttering and buffering.\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Fast \",(0,i.jsx)(e.a,{href:\"https://www.mux.com/blog/the-video-startup-time-metric-explained\",children:\"video startup time\"}),\".\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{id:\"background\",children:\"Background\"}),`\n`,(0,i.jsx)(e.p,{children:\"Since media playing on the web is a pretty specialized domain that most people would not have much experience in, we've provided a summary of the important technicalities you need to be aware of regarding video playing in the context of a system design interview. In fact, most of the contents covered here is more than expected of candidates, but it doesn't hurt to know more.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"glossary\",children:\"Glossary\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Streaming\"}),\": The process of delivering multimedia content, like video and audio, over the internet in a continuous and real-time manner. It allows users to watch or listen to the content while it is being transmitted, without the need to download the entire file before playback begins.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Buffering\"}),\": The process of preloading video content to ensure smooth playback, preventing interruptions due to slow network connections.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Bitrate\"}),\": Refers to the amount of data transferred per second in a video stream. It determines the quality and size of video files, with higher bitrates yielding better quality but larger file sizes.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Frame rate\"}),\": The number of video frames displayed per second, typically measured in frames per second (fps). Common frame rates include 24fps for film and 30fps or 60fps for television and online video.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Resolution\"}),\": Specifies the dimensions of a video in terms of width and height (e.g., 1920 x 1080 pixels for Full HD). Higher resolutions offer better visual quality but require more bandwidth.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Codec\"}),\": A software or hardware component that encodes and decodes video and audio data. Common video codecs include H.264, H.265 (HEVC), VP9, and AV1.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Bandwidth\"}),\": The amount of data that can be transmitted over a network connection in a given time frame. In video streaming, sufficient bandwidth is necessary to deliver video content smoothly and at the desired quality. Higher-quality videos with higher bitrates require more bandwidth for uninterrupted playback.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Poster\"}),\": Static thumbnail image of the video.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Closed captions (CC)\"}),\": Text-based subtitles displayed during video playback, typically used for providing accessibility and language translation. They're different from subtitles but can be treated the same for the purpose of interviews.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Playback controls\"}),\": User interface elements for video control, including play, pause, seek, and volume.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Seeking\"}),\": Seeking in video playback is the action of moving to a specific point or time in the video without playing it from the beginning. Users can jump to a specific scene or timecode within the video, often by interacting with a seek bar or timeline.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Scrubbing\"}),\": Scrubbing is a user action that involves dragging the playhead or seek bar of a video player to navigate through the video content. It allows users to quickly move forward or backward in the video to find specific scenes or moments.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"We will be using these terms frequently in the content below.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"video-playback-on-the-web\",children:\"Video playback on the web\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The most basic way of playing videos on websites is to use a \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" HTML tag on a page with the \",(0,i.jsx)(e.code,{children:\"src\"}),\" attribute pointing to an \",(0,i.jsx)(e.code,{children:\"mp4\"}),\" or \",(0,i.jsx)(e.code,{children:\"webm\"}),\" file, just like the \",(0,i.jsx)(e.code,{children:\"<img>\"}),\" tag. However, this most basic way of playing videos on a webpage doesn't offer the best user experience as they do not support adaptive bitrates.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Sophisticated video players on Netflix and YouTube leverage the following key components:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Player interface\"}),\": This includes the user interface of the video player, which provides controls like play, pause, and volume adjustment. Browsers offer a basic playback controls UI but often you'd want to have more control over the styling and appearance.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Streaming protocol\"}),\": Streaming involves progressively downloading a large video file that has been split into smaller segments. The player downloads and plays these segments in sequence, maintaining a buffer to handle network fluctuations. Common streaming protocols are HTTP Live Streaming (HLS) and Dynamic Adaptive Streaming over HTTP (DASH).\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Manifest file\"}),\": Manifest files guide the video player to the location of video segment files. They include a master manifest, which is the first point of contact and directs the player to various renditions of the video, and rendition manifests for each specific video quality. The format of the manifest files differ depending on the streaming protocol used.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Adaptive bitrate streaming\"}),\": This technique allows the player to select from different versions of a video (various resolutions and bitrates) to ensure smooth playback based on the user's internet speed. To avoid buffering, video players dynamically adjust the playback quality and use the manifest files to determine the location of the segment files for the desired quality.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"video-formats\",children:\"Video formats\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://www.webmproject.org/\",children:\"WebM\"}),\" and MP4 are common video formats and the differences between them are primarily related to their video encoding, browser support, licensing, and usage:\"]}),`\n`,(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Area\"}),(0,i.jsx)(e.th,{children:\"WebM\"}),(0,i.jsx)(e.th,{children:\"MP4\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Usage\"}),(0,i.jsx)(e.td,{children:\"Online streaming.\"}),(0,i.jsx)(e.td,{children:\"Video storage, video editing, broadcasting, and streaming.\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Browser support\"}),(0,i.jsx)(e.td,{children:\"Supported on Firefox, Chrome, and Opera. Support on mobile devices and non-web platforms is limited.\"}),(0,i.jsx)(e.td,{children:\"More universal support.\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Encoding and compression\"}),(0,i.jsx)(e.td,{children:\"Uses the VP8 or VP9 video codec and Vorbis or Opus for audio. VP8/VP9 codecs are known for efficient compression, making them suitable for online streaming with less bandwidth usage.\"}),(0,i.jsx)(e.td,{children:\"Uses the H.264 (or AVC) video codec and AAC for audio. H.264 is widely regarded for its high compression efficiency and excellent video quality, even at lower bitrates.\"})]})]})]}),`\n`,(0,i.jsx)(e.p,{children:\"Like WebP, WebM is also developed by Google as a performant file format for media on the web. WebM is more suited for web-based applications with an emphasis on open-source and efficient streaming, while MP4 is a versatile format with broad device and platform support, making it a popular choice for a wide range of video applications.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"architecture--high-level-design\",children:\"Architecture / high-level design\"}),`\n`,(0,i.jsx)(e.h3,{id:\"rendering-approach\",children:\"Rendering approach\"}),`\n`,(0,i.jsx)(e.p,{children:\"Video streaming applications have the following characteristics:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[\"Video titles are searchable via search engines. YouTube videos are mostly public while Netflix has a title page containing just the video details and some art/thumbnails (\",(0,i.jsx)(e.a,{href:\"https://www.netflix.com/title/80057281\",children:\"Netflix title page example\"}),\").\"]}),`\n`,(0,i.jsx)(e.li,{children:\"Certain video watching pages are only accessible by logged-in premium users (in the case of Netflix).\"}),`\n`,(0,i.jsx)(e.li,{children:\"Pages are interaction heavy due to browsing of video recommendations and video playing interactions.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Fast initial loading speed and video startup speed is desired.\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"For pages accessible by logged-in users only, server-side rendering (SSR) will improve performance slightly but SSR is not crucial. For pages that are discoverable by search engines (public videos), SEO and hence SSR will be important.\"}),`\n`,(0,i.jsx)(e.p,{children:\"YouTube SSRs a basic skeleton of their browse/discover page.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-youtube-discovery-page-ssr.png\",alt:\"YouTube discovery page SSR\"})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Netflix SSRs the entire \",(0,i.jsx)(e.a,{href:\"https://www.netflix.com/title/80057281\",children:\"video title page\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-netflix-title-page-ssr.png\",alt:\"Netflix title page SSR\"})}),`\n`,(0,i.jsx)(e.p,{children:\"For watch pages, especially in the case of Netflix where the video fills up the entire page, SSR is not as useful. The SSR-ed HTML doesn't include a loaded video or any buffered data needed to start playback and JavaScript is required for video streaming playback anyway.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-netflix-discovery-page-ssr.png\",alt:\"Netflix discovery page SSR\"})}),`\n`,(0,i.jsx)(e.p,{children:\"YouTube SSRs a static preview of the video (poster image) while Netflix does not SSR anything visible.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-youtube-watch-page-ssr.png\",alt:\"YouTube watch page SSR\"})}),`\n`,(0,i.jsx)(e.p,{children:\"However, Netflix's initial HTML contains data needed by the React application to boot up the video player on the page. If this data is not present in the initial HTML, the page needs to make a request to fetch the data, which requires an extra roundtrip and will be slower.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-netflix-watch-page-ssr.png\",alt:\"Netflix watch page SSR\"})}),`\n`,(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Service\"}),(0,i.jsx)(e.th,{children:\"Page\"}),(0,i.jsx)(e.th,{children:\"Access\"}),(0,i.jsx)(e.th,{children:\"Rendering\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Netflix\"}),(0,i.jsx)(e.td,{children:\"Video title page\"}),(0,i.jsx)(e.td,{children:\"Public\"}),(0,i.jsx)(e.td,{children:\"SSR full page\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Netflix\"}),(0,i.jsx)(e.td,{children:\"Browse/discover page\"}),(0,i.jsx)(e.td,{children:\"Logged in\"}),(0,i.jsx)(e.td,{children:\"SSR above the fold\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"Netflix\"}),(0,i.jsx)(e.td,{children:\"Watch page\"}),(0,i.jsx)(e.td,{children:\"Logged In\"}),(0,i.jsx)(e.td,{children:\"SSR just the app data (JSON)\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"YouTube\"}),(0,i.jsx)(e.td,{children:\"Homepage (recommendations)\"}),(0,i.jsx)(e.td,{children:\"Public\"}),(0,i.jsx)(e.td,{children:\"SSR a skeleton\"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:\"YouTube\"}),(0,i.jsx)(e.td,{children:\"Watch page\"}),(0,i.jsx)(e.td,{children:\"Public\"}),(0,i.jsx)(e.td,{children:\"SSR UI skeleton with video preview / poster image\"})]})]})]}),`\n`,(0,i.jsx)(e.p,{children:\"As seen from the table, there's no hard and fast rule here. YouTube SSRs only the skeleton for their pages. Netflix SSRs public pages and the browse page because it improves user engagement. SSR can be used for video listing pages which benefit from high user engagement. For video watching pages, SSR is less important and CSR can be used.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"single-page-application-spa-or-multi-page-application-mpa\",children:\"Single-page application (SPA) or Multi-page application (MPA)?\"}),`\n`,(0,i.jsx)(e.p,{children:\"As video streaming websites are highly interactive and navigation between discovery pages and watch pages can be pretty common (especially when the user is still choosing a video), persisting the data fetched on the discovery page across page navigations will improve the performance. Moreover, on SPAs, clients can prefetch the metadata needed by subsequent watch pages, improving the video startup time.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Netflix and YouTube are both single-page applications.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"component-responsibilities\",children:\"Component responsibilities\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-architecture.png\",alt:\"Video streaming client architecture\"})}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Server\"}),\": Provides HTTP APIs to fetch video recommendations and video object metadata.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video CDN server\"}),\": CDN server to fetch video contents itself. Allows individual fetching segments of the video.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Client store\"}),\": Stores data needed across the whole application. Most of the data in the store will be server-originated data needed by the video recommendations page. Persists data across navigation so that revisiting the recommendations page will not require fetching of the recommendations list again.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Discover page\"}),\": The page that users use to browse the recommended videos.\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Billboard video player\"}),\": Featured video at the top that plays immediately when the page is loaded.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video lists\"}),\": List of video categories. Each category shows a horizontal list of video thumbnails.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Watch page\"}),\": The page that users watch a full video.\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Full-screen video player\"}),\": Plays the video and contains video playback controls.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"The video player components (purple boxes) on each page will make requests to the video CDN server to fetch video segments in a streaming fashion.\"}),`\n`,(0,i.jsx)(e.h2,{id:\"data-model\",children:\"Data model\"}),`\n`,(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{children:\"Entity\"}),(0,i.jsx)(e.th,{children:\"Source\"}),(0,i.jsx)(e.th,{children:\"Belongs to\"}),(0,i.jsx)(e.th,{children:\"Fields\"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:\"Recommendations\"})}),(0,i.jsx)(e.td,{children:\"Server\"}),(0,i.jsx)(e.td,{children:\"Discover page\"}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.code,{children:\"lists\"}),\" (list of \",(0,i.jsx)(e.code,{children:\"VideoList\"}),\"s, \",(0,i.jsx)(e.code,{children:\"pagination\"}),\" (pagination metadata)\"]})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:\"VideoList\"})}),(0,i.jsx)(e.td,{children:\"Server\"}),(0,i.jsx)(e.td,{children:\"Discover page\"}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.code,{children:\"videos\"}),\" (list of \",(0,i.jsx)(e.code,{children:\"VideoMetadata\"}),\"s, \",(0,i.jsx)(e.code,{children:\"pagination\"}),\" (pagination metadata)\"]})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{children:(0,i.jsx)(e.code,{children:\"VideoMetadata\"})}),(0,i.jsx)(e.td,{children:\"Server\"}),(0,i.jsx)(e.td,{children:\"Discover page\"}),(0,i.jsxs)(e.td,{children:[(0,i.jsx)(e.code,{children:\"id\"}),\", \",(0,i.jsx)(e.code,{children:\"title\"}),\", \",(0,i.jsx)(e.code,{children:\"boxart_url\"}),\", etc.\"]})]})]})]}),`\n`,(0,i.jsx)(e.p,{children:'The video recommendations should be stored in the client store which is preserved across page navigations. This acts as a cache to allow presenting of the video recommendations immediately (without a network request) whenever the user goes back to the \"Discover page\" to browse more recommendations.'}),`\n`,(0,i.jsxs)(e.p,{children:[\"Video players contain standalone data models and APIs, which will be covered in a \",(0,i.jsx)(e.a,{href:\"#video-player-data-model-architecture-and-api\",children:\"dedicated section below\"}),\".\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"interface-definition-api\",children:\"Interface definition (API)\"}),`\n`,(0,i.jsx)(e.h3,{id:\"video-recommendations-api\",children:\"Video recommendations API\"}),`\n`,(0,i.jsx)(e.p,{children:\"This API is used on the browse/discovery page to render the list of video categories and the top videos within each category. Cursor-based pagination can be used to fetch more recommendation categories and more category videos.\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-json\",children:`{\n  \"recommendations\": {\n    \"items\": [\n      {\n        \"name\": \"TV Shows\",\n        \"videos\": {\n          \"items\": [\n            { \"videoId\": 123, \"title\": \"...\", \"boxArtUrl\": \"...\" },\n            { \"videoId\": 124, \"title\": \"...\", \"boxArtUrl\": \"...\" }\n          ],\n          \"pagination\": {}\n        }\n      },\n      {\n        \"name\": \"New Releases\",\n        \"videos\": {\n          \"items\": [\n            { \"videoId\": 125, \"title\": \"...\", \"boxArtUrl\": \"...\" },\n            { \"videoId\": 126, \"title\": \"...\", \"boxArtUrl\": \"...\" }\n          ],\n          \"pagination\": {}\n        }\n      }\n    ],\n    \"pagination\": {}\n  }\n}\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Both offset-based pagination and cursor-based pagination can be used.\"}),`\n`,(0,i.jsx)(e.p,{children:\"The data for the first page of recommendations and videos:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Is used to SSR the initial HTML (refer to image in rendering approach section).\"}),`\n`,(0,i.jsxs)(e.li,{children:[\"Rendered as JSON data within \",(0,i.jsx)(e.code,{children:\"<script>\"}),\" tags and is injected into the client store (\",(0,i.jsx)(e.code,{children:\"window.netflix.reactContext\"}),\").\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Data for subsequent pages is fetched from a HTTP API and added into the client store, which is then added to the page's DOM.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"media-streaming-and-subtitles-api\",children:\"Media streaming and subtitles API\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The APIs for streaming of the video data, audio data, and subtitles for a video depend on the selected streaming protocol (DASH, HLS) which is \",(0,i.jsx)(e.a,{href:\"#streaming-protocols\",children:\"covered in more detail below\"}),\".\"]}),`\n`,(0,i.jsx)(e.h3,{id:\"video-player-api\",children:\"Video player API\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Video players are covered in a \",(0,i.jsx)(e.a,{href:\"#video-player-data-model-architecture-and-api\",children:\"dedicated section below\"}),\".\"]}),`\n`,(0,i.jsx)(e.h2,{id:\"video-player-data-model-architecture-and-api\",children:\"Video player data model, architecture, and API\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"As a video player involves multiple properties (state), lots of actions resulting in state changes, and many components which rely on the central video player state, a unidirectional reducer + actions pattern is appropriate. This can be implemented using \",(0,i.jsx)(e.code,{children:\"useReducer\"}),\" in React or React + Redux where Redux provides more structure around the actions and reducers along with additional devtools for an enhanced developer experience.\"]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-video-player-parts.png\",alt:\"Video player UI example and their parts\"})}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-video-player-architecture.png\",alt:\"Video player architecture\"})}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"View\"}),\" (UI Components): Progress control, Control bar, Media\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"State\"}),\" (naming may differ from actual DOM properties): Player state, Buffered frames, Current time, Duration, Playback rate, Current timestamp, Volume, Muted, Audio language, Subtitle language, Audio tracks, Video tracks, Subtitles / text tracks, Poster, Height, Width\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Dispatcher\"}),\": Dispatches an action to the reducer. Alternatively, clients can directly dispatch the actions from within the UI components or event handlers.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Actions\"}),\": Play, Pause, Skip, Seek, Adjust volume, Mute, Toggle full screen\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Keyboard events\"}),\" resulting in actions:\",`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Space -> Play/Pause\"}),`\n`,(0,i.jsx)(e.li,{children:\"Volume key -> Adjust volume\"}),`\n`,(0,i.jsx)(e.li,{children:\"Mute key -> Mute sound\"}),`\n`,(0,i.jsx)(e.li,{children:\"Arrow keys -> Skip\"}),`\n`,(0,i.jsx)(e.li,{children:\"Full screen shortcut -> Toggle full screen\"}),`\n`]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Background events\"}),\": \",(0,i.jsx)(e.code,{children:\"loadstart\"}),\", \",(0,i.jsx)(e.code,{children:\"loadeddata\"}),\", \",(0,i.jsx)(e.code,{children:\"ended\"}),\", \",(0,i.jsx)(e.code,{children:\"error\"}),\", \",(0,i.jsx)(e.code,{children:\"stalled\"}),\", \",(0,i.jsx)(e.code,{children:\"waiting\"}),\", etc. See the \",(0,i.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#events\",children:[\"full list of events available on the \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" element\"]}),\".\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"A \",(0,i.jsx)(e.a,{href:\"https://facebookarchive.github.io/flux/docs/in-depth-overview\",children:\"Flux-like unidirectional flow model\"}),\" works well here. In a reducer pattern, \",(0,i.jsx)(e.code,{children:\"newState = reducer(action, state)\"}),\". Actions are operations that mutate state. A list of actions, known operations that can modify state, is defined. The only way to change the state is to dispatch an action, there is no way to update the state directly. This helps to centralize state mutation logic within the reducer.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Actions can also originate from different sources \\u2013 they can be triggered from various UI elements, keyboard events, or background events. The reducer does not need to care about where the actions were dispatched from, it simply has to take in an action + current state and return the new state.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"YouTube experienced performance issues due to its player video controls being over-componentized and certain interactions caused extra style recalculations due to circular dependencies and memory leaks. To fix the issue, YouTube updated the video player to synchronize all updates by refactoring the player to a top-level component that would pass down data to its children. This ensured only one UI update (paint) for any state change, eliminating chained updates. Although YouTube does not use React or Redux, this refactoring is essentially an implementation of the Flux-like reducer pattern. \",(0,i.jsxs)(e.em,{children:[\"Source: \",(0,i.jsx)(e.a,{href:\"https://web.dev/case-studies/better-youtube-web-part1\",children:\"Building a Better Web - Part 1: A faster YouTube on web\"}),\".\"]})]}),`\n`,(0,i.jsxs)(e.p,{children:[\"In 2018, Netflix rewrote their video player to React and Redux, they chose to use Redux in order to single-source and encapsulate the complex playback business logic. Redux is a well-known library/pattern in web UI engineering, and it facilitated separation of concerns in ways that met their goals. By combining Redux with data normalization, they enabled parallel development across teams in addition to providing standardized, predictable ways of expressing complex business logic. \",(0,i.jsxs)(e.em,{children:[\"Source: \",(0,i.jsx)(e.a,{href:\"https://netflixtechblog.com/modernizing-the-web-playback-ui-1ad2f184a5a0\",children:\"Modernizing the Web Playback UI. Since 2013, the user experience of\\u2026 | by Netflix Technology Blog\"}),\".\"]})]}),`\n`,(0,i.jsx)(e.p,{children:\"Buffered video data can be cached, especially for the billboard video which doesn't change across the session. However, clients should pay attention to the amount of buffered video data and release memory when it reaches the point where page performance is affected.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Media players inherently contain state as well because \",(0,i.jsx)(e.code,{children:\"HTMLVideoObject\"}),\"s in the DOM contain properties like \",(0,i.jsx)(e.code,{children:\"paused\"}),\", \",(0,i.jsx)(e.code,{children:\"muted\"}),\", etc. By building your own video player component in JavaScript, there will be state values that are duplicated and with duplication, values can go out-of-sync. The recommended approach is to let the UI component state be the source of truth and sync the component state with the DOM media player state, essentially making the media player a \",(0,i.jsx)(e.a,{href:\"https://react.dev/reference/react-dom/components/input#controlling-an-input-with-a-state-variable\",children:'\"controlled\" component'}),\" similar to how \",(0,i.jsx)(e.code,{children:\"<input>\"}),\" elements are controlled in React.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Here are some libraries that provide custom video players or help you build one:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:\"https://github.com/shaka-project/shaka-player\",children:\"Shaka Player\"}),\": An open-source JavaScript library for adaptive media that supports DASH and HLS.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:\"https://videojs.com/\",children:\"Video.js\"}),\": Similar to Shaka Player, with many different themes and skins.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.a,{href:\"https://www.media-chrome.org/\",children:\"Media Chrome\"}),\": Elements for building media players.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Tutorials:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://web.dev/articles/media-mobile-web-video-playback\",children:\"Mobile Web Video Playback | Articles | web.dev\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://www.youtube.com/watch?v=--KA2VrPDao&list=PLNYkxOF6rcIBykcJ7bvTpqU7vt-oey72J&index=20\",children:\"Building a Media Player Series | Chrome for Developers\"})}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{id:\"optimizations-and-deep-dive\",children:\"Optimizations and deep dive\"}),`\n`,(0,i.jsxs)(e.h3,{id:\"understanding-native-html-video-elements\",children:[\"Understanding native HTML \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" elements\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"HTML5 provides a \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" tag to play a video within a webpage. It was introduced with HTML5 and represents a significant improvement in web standards, allowing direct embedding of videos without the need for external plugins like Flash. In this section we introduce some basics about the \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" tag.\"]}),`\n`,(0,i.jsx)(e.h4,{id:\"progressive-downloading\",children:\"Progressive downloading\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The simplest way to render a video is similar to images, where the \",(0,i.jsx)(e.code,{children:\"src\"}),\" attribute is pointing to a video file.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-html\",children:`<video src=\"movie.mp4\" />\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"This method of using the \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" tag with a \",(0,i.jsx)(e.code,{children:\"src\"}),` attribute pointing to a video file is called \"progressive downloading\". In progressive downloading, the video file is downloaded from the server in a linear fashion and played simultaneously. Unlike streaming, where only the necessary parts of the video are sent to the user, progressive download involves downloading the entire file, starting from the beginning. The video can be played as soon as enough data has been downloaded to ensure uninterrupted playback. This method is simpler than true streaming but requires more bandwidth and storage, as the entire video file is downloaded, regardless of whether the user watches it to the end. This gives an appearance similar to streaming but isn't true streaming in the technical sense.`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Seeking can be achieved by using a \",(0,i.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests\",children:[\"HTTP \",(0,i.jsx)(e.code,{children:\"Range\"}),\" request\"]}),\" to download the appropriate segment. An HTTP \",(0,i.jsx)(e.code,{children:\"Range\"}),\" request asks the server to send only a portion of an HTTP message back to the client which is useful for media players because it wants to support random access of a file.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Video playing on Netflix and YouTube use streaming as opposed to progressive downloading. It is achieved through the \",(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\",children:\"Media Source API\"}),\" in combination with adaptive streaming formats like HLS and DASH and adaptive bitrate algorithms, to provide smooth streaming experiences regardless of device or network conditions. More on that \",(0,i.jsx)(e.a,{href:\"#media-source-api\",children:\"below\"}),\".\"]}),`\n`,(0,i.jsxs)(e.h4,{id:\"video-element-attributes\",children:[(0,i.jsx)(e.code,{children:\"<video>\"}),\" element attributes\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Supported HTML attributes include:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"src\"}),\": Specifies the source of the video file.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"width\"}),\" and \",(0,i.jsx)(e.code,{children:\"height\"}),\": Define the size of the video player on the webpage.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"controls\"}),\": Adds video controls like play, pause, and volume.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"autoplay\"}),\": Causes the video to start playing as soon as it is loaded (not recommended due to user experience and bandwidth considerations).\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"loop\"}),\": Enables the video to start over again, every time it is finished.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"muted\"}),\": Mutes the audio by default.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"poster\"}),\": Specifies an image to be shown while the video is downloading, or until the user hits the play button.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Most of these HTML attributes become the \",(0,i.jsx)(e.code,{children:\"HTMLVideoElement\"}),\"'s properties in the DOM when the HTML is parsed by the browser.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" element also allows specifying multiple video sources via the \",(0,i.jsx)(e.code,{children:\"source\"}),\" tag so that the browser can pick the format that works best. This is done to ensure compatibility across various browsers, as not all browsers support the same video formats.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-html\",children:`<video width=\"320\" height=\"240\" controls>\n  <source src=\"movie.webm\" type=\"video/webm\" />\n  <source src=\"movie.mp4\" type=\"video/mp4\" />\n  <source src=\"movie.ogg\" type=\"video/ogg\" />\n  Your browser does not support the video tag.\n</video>\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Text placed between the \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" tags (but outside the \",(0,i.jsx)(e.code,{children:\"<source>\"}),\" tags) serves as fallback content for browsers that do not support the \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" tag.\"]}),`\n`,(0,i.jsxs)(e.h4,{id:\"htmlvideoelement-methods\",children:[(0,i.jsx)(e.code,{children:\"HTMLVideoElement\"}),\" methods\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.code,{children:\"HTMLVideoElement\"}),\" element can be manipulated using JavaScript for further interactivity. \",(0,i.jsx)(e.code,{children:\"HTMLVideoElement\"}),\"s inherit from the \",(0,i.jsx)(e.code,{children:\"HTMLMediaElement\"}),\" interface which provides a range of methods that allow for controlling and interacting with media elements like \",(0,i.jsx)(e.code,{children:\"<audio>\"}),\" and \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" in HTML. Some of the important methods available on the \",(0,i.jsx)(e.code,{children:\"HTMLMediaElement\"}),\":\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"play()\"}),\": This method is used to start playing the media. If the media is already playing, this method has no effect. If playback is paused, it will resume.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"pause()\"}),\": This method pauses the media playback. If the media is already paused, this method has no effect.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"load()\"}),\": This method is used to reset the media element and reload the source media. It's useful when the source of the media has changed.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"addTextTrack()\"}),\": Adds a new text track to the media element. This can be used for subtitles, captions, descriptions, chapters, or metadata.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"fastSeek()\"}),\": This method allows for fast seeking to a specific time point in the media.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.h4,{id:\"htmlvideoelement-events\",children:[(0,i.jsx)(e.code,{children:\"HTMLVideoElement\"}),\" events\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.code,{children:\"HTMLVideoElement\"}),\" inherits from the \",(0,i.jsx)(e.code,{children:\"HTMLMediaElement\"}),\" interface which provides a range of events that allow developers to monitor and control media playback. These events are crucial for creating interactive and responsive media experiences on web pages.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Here are some of the important events associated with \",(0,i.jsx)(e.code,{children:\"HTMLMediaElement\"}),\":\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"loadstart\"}),\": Fired when the browser starts looking for the media; beginning of the loading process.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"loadeddata\"}),\": Triggered when the first frame of the media has finished loading and is ready to play.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"progress\"}),\": Fired periodically as the browser loads the media. Useful for showing media loading progress.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"play\"}),\": Triggered when the media playback has begun or resumed.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"playing\"}),\": Fired when the media actually begins to play after being paused or stopped for buffering.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"pause\"}),\": Occurs when the media playback is paused.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"ended\"}),\": Triggered when playback has stopped because the end of the media was reached.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"waiting\"}),\": Occurs when the media playback is stopped due to temporary lack of data.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"stalled\"}),\": Fired when there is an unexpected halt in media downloading, often due to network issues.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"volumechange\"}),\": Occurs when the volume changes, including when the \",(0,i.jsx)(e.code,{children:\"muted\"}),\" attribute changes.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:\"error\"}),\": Fired when an error occurs while fetching the media.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"These events are essential for creating a detailed control interface for media elements, handling errors, tracking progress, and responding to user interactions. By adding event listeners to these events, developers can manage media playback in a custom manner and also gather user analytics.\"}),`\n`,(0,i.jsxs)(e.h4,{id:\"drawbacks-of-using-video\",children:[\"Drawbacks of using \",(0,i.jsx)(e.code,{children:\"<video>\"})]}),`\n`,(0,i.jsxs)(e.p,{children:['Using \"vanilla\" ',(0,i.jsx)(e.code,{children:\"<video>\"}),\" elements also comes with some drawbacks:\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Limited adaptive streaming support\"}),\": The \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" element doesn't natively support adaptive streaming protocols like DASH or HLS in all browsers. These protocols dynamically adjust video quality based on the user's internet speed, ensuring a smooth streaming experience. Without this, users may experience buffering or low-quality video. The \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" element might not be optimized for scenarios where low latency is crucial, such as live streaming events.\"]}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Restricted customization and control\"}),\": \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" elements also contain playback controls, but like most native elements, each browser renders them differently. If you want a consistent and branded user interface across browsers you will have to build your own playback controls. However, styling these controls isn't straightforward unlike other HTML elements like \",(0,i.jsx)(e.code,{children:\"<button>\"}),\"s and \",(0,i.jsx)(e.code,{children:\"<input>\"}),\"s. You will have to build your own components.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"Note that \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" elements also contain their own state as mentioned in the attributes/properties above. If you are using a JavaScript framework/library (e.g. React, Vue) and have built your own \",(0,i.jsx)(e.code,{children:\"Video\"}),\" component that renders the \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" elements along with custom controls, you will need to do a two-way sync between your React component state and the \",(0,i.jsx)(e.code,{children:\"<video>\"}),\"/\",(0,i.jsx)(e.code,{children:\"HTMLVideoElement\"}),\" state as there can be native controls that directly affect the \",(0,i.jsx)(e.code,{children:\"HTMLVideoElement\"}),\" like the play/pause/volume buttons (also known as media keys) on some keyboards.\"]}),`\n`,(0,i.jsx)(e.p,{children:'In the following example, the React component state is synced with the DOM video state. Try playing the video using either \"Play\" buttons and see that the playback and custom UI states are synced properly.'}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-html\",children:`<iframe\n  src=\"https://codesandbox.io/embed/f6h325?fontsize=14&hidenavigation=1&theme=dark&module=/src/App.tsx&view=split\"\n  style={{\n    width: '100%',\n    height: 500,\n    border: 0,\n    borderRadius: 4,\n    overflow: 'hidden',\n  }}\n  title=\"React video component state sync\"\n  allow=\"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking\"\n  sandbox=\"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts\"\n/>\n`})}),`\n`,(0,i.jsx)(e.p,{children:\"Also ensure that custom-built video controls meet the accessibility requirements and standards provided by the native video controls.\"}),`\n`]}),`\n`,(0,i.jsxs)(e.li,{children:[`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"No support for advanced features\"}),\": Features like video previews, thumbnails on seek, multi-bitrate streaming, and live streaming are not natively supported or are limited in the \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" element.\"]}),`\n`]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Because of these drawbacks, it's clear that to create a world-class video streaming experience, a custom video player UI is the way to go.\"}),`\n`,(0,i.jsx)(e.h3,{id:\"video-streaming\",children:\"Video streaming\"}),`\n`,(0,i.jsx)(e.p,{children:\"Now that we have a better understanding of video playback using progressive downloading and its drawbacks, we can discuss how a world-class video watching experience is achieved through video streaming.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"media-source-api\",children:\"Media Source API\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\",children:\"Media Source API\"}),\", formally known as Media Source Extensions (MSE), is a web API that enhances the capabilities of streaming media in web applications. The Media Source API allows replacing the standard single progressive \",(0,i.jsx)(e.code,{children:\"src\"}),\" URI in media elements with a \",(0,i.jsx)(e.code,{children:\"MediaSource\"}),\" object. This object manages the media's ready state and references multiple \",(0,i.jsx)(e.code,{children:\"SourceBuffer\"}),\" objects, representing different chunks of the media stream.\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-js\",children:`// Setup the video element and MediaSource\nconst videoEl = document.getElementById('my-video');\nconst mediaSource = new MediaSource();\n\n// Set the MediaSource object as the source of the video element.\nvideoEl.src = URL.createObjectURL(mediaSource);\nmediaSource.addEventListener('sourceopen', sourceOpen);\n\nasync function sourceOpen() {\n  // Create a source buffer with a specific MIME type.\n  const sourceBuffer = mediaSource.addSourceBuffer(\n    'video/mp4; codecs=\"avc1.64001E\"',\n  );\n\n  sourceBuffer.addEventListener('updateend', () => {\n    // Check if the media source has ended and if there are more segments\n    // You can fetch and append additional segments.\n    if (!sourceBuffer.updating && mediaSource.readyState === 'open') {\n      mediaSource.endOfStream();\n    } else {\n      // Fetch next segment.\n    }\n  });\n\n  // Fetch the first segment of the video.\n  const response = await fetch('path/to/your/video/segment1.mp4');\n  const segment = await response.arrayBuffer();\n  // Append the fetched segment to the source buffer.\n  sourceBuffer.appendBuffer(segment);\n}\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Segmented video files, along with the Media Source API, allows for clients to stream video content. This API also allows for the creation of more interactive video experiences, such as the ability to insert ads dynamically, switch between multiple video angles, or synchronize additional content with video playback. \",(0,i.jsx)(e.a,{href:\"https://postperspective.com/netflixs-black-mirror-bandersnatch-lets-viewers-choose/\",children:\"Netflix's Bandersnatch\"}),' is an interactive film with 5 unique endings where users can \"choose their own adventure\" while watching. As such, the number of combinations is huge and it is not feasible to create video files for all possible film paths. Using ',(0,i.jsx)(e.code,{children:\"MediaSource\"}),\" helps to dynamically stitch the different parts of the film together depending on the user's choice.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[\"If you inspect the \",(0,i.jsx)(e.code,{children:\"src\"}),\" attribute of \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" elements on Netflix and YouTube, you'll see that they look like \",(0,i.jsx)(e.code,{children:'<video src=\"blob:https://www.netflix.com/b4bc251f-5b0d-47a3-b0cb-4fbf653a16f4\">'}),\". This is because the \",(0,i.jsx)(e.code,{children:\"src\"}),\" was created using \",(0,i.jsx)(e.code,{children:\"URL.createObjectURL()\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Read more about Media Source API on:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://web.dev/articles/media-mse-basics\",children:\"Media Source API | Articles | web.dev\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\",children:\"Media Source API | MDN\"})}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"Now we know how video streaming works, but that's not all there is to know! Streaming can be further improved with adaptive bitrate streaming.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"adaptive-bitrate-streaming\",children:\"Adaptive Bitrate Streaming\"}),`\n`,(0,i.jsx)(e.p,{children:\"While streaming helps to improve the video playback experience, it does not take into account the client's device and network conditions. If a user is on a choppy mobile network, they will not be able to watch a high resolution video immediately as they will have to wait longer for the segments to be downloaded. Users on mobile devices also do not benefit from high resolution videos when their screen size is not wide enough to display all the details.\"}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:\"Adaptive Bitrate Streaming\"}),\" is a technique used in online video and audio streaming that dynamically adjusts the quality of a video to suit the available bandwidth and processing capabilities of the user's device.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Clients use an adaptive bitrate (ABR) algorithm to automatically select the segment with the highest bitrate possible that can be downloaded in time for playback without causing stalls or re-buffering events in the playback.\"}),`\n`,(0,i.jsx)(e.p,{children:\"These factors are monitored in real-time and used by the algorithm:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"Available bandwidth\"}),`\n`,(0,i.jsx)(e.li,{children:\"Available codecs\"}),`\n`,(0,i.jsx)(e.li,{children:\"Connection quality\"}),`\n`,(0,i.jsx)(e.li,{children:\"Video player dimensions\"}),`\n`,(0,i.jsx)(e.li,{children:\"Playback rate\"}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"This decision is made dynamically as the video plays, adapting to changing network speeds.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"media-capabilities-api\",children:\"Media Capabilities API\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Media_Capabilities_API\",children:\"Media Capabilities API\"}),\" allows websites to get more information about the client's video decode performance and make an informed decision about which codec and resolution to deliver to the user.\"]}),`\n`,(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.a,{href:\"https://web.dev/case-studies/youtube-media-capabilities\",children:\"YouTube used the Media Capabilities API\"}),\" to prevent their adaptive bitrate algorithm from automatically selecting resolutions that a device could not play smoothly.\"]}),`\n`,(0,i.jsx)(e.h4,{id:\"streaming-protocols\",children:\"Streaming protocols\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"There are two popular streaming protocols that are used on the web that can be used to enable adaptive bitrate streaming: \",(0,i.jsx)(e.strong,{children:\"Dynamic Adaptive Streaming over HTTP (DASH)\"}),\" and \",(0,i.jsx)(e.strong,{children:\"HTTP Live Streaming (HLS)\"}),\".\"]}),`\n`,(0,i.jsx)(e.p,{children:\"These streaming protocols have the following in common:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Segmented media files\"}),\": Media content of various quality is divided into small segments, enabling seamless streaming and the ability to switch between different quality streams.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"HTTP-based delivery\"}),\": They utilize standard HTTP web servers for media delivery, simplifying distribution and reducing the need for specialized streaming servers. Using HTTP to fetch files moves much of the logic from the network protocol to the client-side application so media can also be streamed from static CDNs like Amazon S3.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Manifest files\"}),\": Each protocol uses a type of manifest file (like MPD for DASH, M3U8 for HLS) to provide information about the available streams, their resolutions, bitrates, and segment locations (URLs).\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"dynamic-adaptive-streaming-over-http-dash\",children:\"Dynamic Adaptive Streaming over HTTP (DASH)\"}),`\n`,(0,i.jsx)(e.p,{children:\"Dynamic Adaptive Streaming over HTTP (DASH) is a streaming protocol and technology that allows for the efficient delivery of multimedia content, such as video and audio, over the internet. DASH is designed to optimize the viewing experience for users by adapting to their network conditions and device capabilities in real-time.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Additional features of DASH:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Media Presentation Description (MPD)\"}),\": DASH relies on an XML-based manifest file known as the \",(0,i.jsx)(e.a,{href:\"https://ottverse.com/structure-of-an-mpeg-dash-mpd/\",children:\"Media Presentation Description (MPD)\"}),\". The MPD contains metadata about the video content, including information about available quality levels, segment URLs, and other attributes that guide the video player in making adaptive streaming decisions.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Latency control\"}),\": DASH can be designed to control latency based on specific use cases. Low-latency DASH (LL-DASH) is an extension that optimizes the protocol for live and interactive streaming applications.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Interoperability\"}),\": DASH is designed for interoperability across different devices and platforms. As a result, it's possible to use the same DASH-encoded content for various playback environments.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"DASH is commonly used by many streaming services, including popular platforms like Netflix, YouTube, and Amazon Prime Video, to provide a high-quality streaming experience to users. It helps ensure that users receive the best possible video quality while adapting to changing network conditions, device capabilities, and screen sizes. This technology has played a significant role in improving the reliability and performance of online video streaming.\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"The \",(0,i.jsx)(e.a,{href:\"https://reference.dashif.org/dash.js/\",children:\"dash.js\"}),\" library is a reference client implementation for the playback of DASH via JavaScript and compliant MSE platforms.\"]}),`\n`,(0,i.jsx)(e.h4,{id:\"http-live-streaming-hls\",children:\"HTTP Live Streaming (HLS)\"}),`\n`,(0,i.jsx)(e.p,{children:\"HTTP Live Streaming (HLS) is a streaming protocol and technology developed by Apple for the delivery of multimedia content, such as video and audio, over the internet. HLS is widely used for streaming video content, especially on iOS devices (iPhones and iPads), as well as in web browsers and other platforms.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Additional features of HLS:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"M3U8 playlist files\"}),\": HLS uses M3U8 playlist files, which are text-based manifest files that describe the media content and provide information about available quality levels, segment URLs, and other attributes. The playlist files are hosted on the server and are used by the client (the video player) to request and play the media content.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Media encryption\"}),\": HLS can support media content encryption using various encryption methods to protect content from unauthorized access. This can include methods like Advanced Encryption Standard (AES) encryption.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Compatibility\"}),\": HLS is compatible with a wide range of devices, including iOS devices, web browsers, Android devices, smart TVs, and more. Many media players and streaming platforms support HLS.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Low latency mode\"}),\": In more recent versions, HLS has introduced low latency modes to reduce the delay between live events and user reception, making it suitable for real-time streaming, including live sports and online gaming.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Adaptive streaming servers\"}),\": To implement HLS, specialized media servers are often used, such as Apple's macOS-based HTTP Live Streaming tools, or third-party servers like Wowza Streaming Engine and Nginx with the \",(0,i.jsx)(e.code,{children:\"ngx_http_hls_module\"}),\".\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"HLS has become a de facto standard for streaming video content, especially in the world of online video services and live streaming. It is widely adopted due to its compatibility with iOS devices and its adaptive streaming capabilities, which help ensure a high-quality viewing experience for users across different network conditions and device types.\"}),`\n`,(0,i.jsx)(e.p,{children:\"An M3U8 file can describe multiple video qualities, allowing the player to switch between different streams based on network conditions or user preferences. This is a key feature of adaptive streaming in HTTP Live Streaming (HLS). Here's an example of an M3U8 playlist with multiple video qualities:\"}),`\n`,(0,i.jsx)(e.h4,{id:\"manifest-file\",children:\"Manifest file\"}),`\n`,(0,i.jsx)(e.p,{children:\"The manifest file is a critical component that provides essential information about the video content, allowing the video player to properly play the video. The manifest file guides the video player on how to request and display the video segments.\"}),`\n`,(0,i.jsx)(e.p,{children:\"There are different types of manifest files used in various streaming protocols, such as:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"DASH\"}),\": In DASH, the manifest file is known as the \",(0,i.jsx)(e.a,{href:\"https://www.brendanlong.com/the-structure-of-an-mpeg-dash-mpd.html\",children:\"Media Presentation Description (MPD)\"}),\" file. This file, typically in XML format, contains information about the available quality levels, segment URLs, and other attributes necessary for the video player to request and play the content.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"HLS\"}),\": For HLS, the manifest file is known as the Media Playlist or \",(0,i.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/M3U\",children:\"M3U/M3U8\"}),\" file. It is a plain text file with an \",(0,i.jsx)(e.code,{children:\".m3u8\"}),\" extension that contains metadata and URLs to video segments.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"It is not important to know the exact format of the manifest files, but you should know what details they contain. Manifest files contain details about the video stream, such as:\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Available quality levels\"}),\": Information about different bitrates and resolutions available for the video, allowing the player to choose the appropriate quality based on network conditions.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Segment URLs\"}),\": Links to individual video segments or chunks. These segments make up the complete video and are requested by the player as needed for playback.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Playback timing and structure\"}),\": Details on the sequence and duration of segments, allowing the player to organize and play them in the correct order.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Adaptive streaming information\"}),\": Information that enables adaptive streaming, ensuring the player can switch between different bitrates or resolutions based on network conditions.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Audio and subtitle tracks\"}),\": Information about alternative audio tracks and subtitle options available for the video.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:\"The manifest file is crucial in facilitating the adaptive streaming process and enabling the player to fetch and play the video segments as needed, allowing for a smoother and uninterrupted viewing experience. It essentially serves as a guide for the player, providing the necessary information to request and present the video content.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Netflix primarily uses a proprietary adaptive bitrate streaming technology based on DASH and is similar to other adaptive streaming protocols like HLS, but with some unique features and optimizations tailored to Netflix's large-scale streaming service. Netflix optimizes its streams not only for the user's bandwidth but also for the type of content (like action vs. dialogue-heavy films) and the device being used (smart TVs, smartphones, tablets, etc.). YouTube uses DASH but supports HLS for certain applications, such as on Apple devices where HLS is more prevalent.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Here's a simplified example of what an MPD file used for DASH might look like:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-xml\",children:`<MPD xmlns=\"urn:mpeg:dash:schema:mpd:2011\" type=\"static\" mediaPresentationDuration=\"PT6M16S\" minBufferTime=\"PT1.5S\">\n  <Period start=\"PT0S\">\n    <AdaptationSet mimeType=\"video/mp4\" segmentAlignment=\"true\" startWithSAP=\"1\">\n      <Representation id=\"video_1\" width=\"1920\" height=\"1080\" bandwidth=\"8000000\" codecs=\"avc1.640028\">\n        <SegmentTemplate media=\"video_1_$Number$.m4s\" initialization=\"video_1_init.m4s\" duration=\"4\" timescale=\"1\" startNumber=\"1\"/>\n      </Representation>\n      <Representation id=\"video_2\" width=\"1280\" height=\"720\" bandwidth=\"4000000\" codecs=\"avc1.64001f\">\n        <SegmentTemplate media=\"video_2_$Number$.m4s\" initialization=\"video_2_init.m4s\" duration=\"4\" timescale=\"1\" startNumber=\"1\"/>\n      </Representation>\n      <!-- More Representations for different resolutions and bitrates -->\n    </AdaptationSet>\n    <AdaptationSet mimeType=\"audio/mp4\" lang=\"en\">\n      <Representation id=\"audio_1\" bandwidth=\"128000\" codecs=\"mp4a.40.2\">\n        <SegmentTemplate media=\"audio_1_$Number$.m4s\" initialization=\"audio_1_init.m4s\" duration=\"4\" timescale=\"1\" startNumber=\"1\"/>\n      </Representation>\n      <!-- More Representations for different audio qualities -->\n    </AdaptationSet>\n  </Period>\n</MPD>\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"In this example, the MPD file describes a video with two video quality options (1080p and 720p) and one audio track. Each \",(0,i.jsx)(e.code,{children:\"Representation\"}),\" element provides details about a specific version of the content, including resolution, bitrate, codec, and the naming pattern for the segment files (\",(0,i.jsx)(e.code,{children:\"SegmentTemplate\"}),\"). The client player uses this information to select the most appropriate stream based on current playback conditions.\"]}),`\n`,(0,i.jsx)(e.p,{children:\"Used in HLS, an M3U8 file can describe multiple video qualities, allowing the player to switch between different streams based on network conditions or user preferences. Here's example of an M3U8 playlist with multiple video qualities:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-txt\",children:`#EXTM3U\n#EXT-X-STREAM-INF:BANDWIDTH=800000,RESOLUTION=640x360\nhttp://example.com/low.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=1400000,RESOLUTION=960x540\nhttp://example.com/medium.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=2800000,RESOLUTION=1280x720\nhttp://example.com/high.m3u8\n#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080\nhttp://example.com/hd.m3u8\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"And an example of what \",(0,i.jsx)(e.code,{children:\"http://example.com/low.m3u8\"}),\" can contain:\"]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-txt\",children:`#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-TARGETDURATION:10\n#EXT-X-MEDIA-SEQUENCE:0\n\n#EXTINF:10.0,\nhttp://example.com/low/segment0.ts\n#EXTINF:10.0,\nhttp://example.com/low/segment1.ts\n#EXTINF:10.0,\nhttp://example.com/low/segment2.ts\n\n#EXT-X-ENDLIST\n`})}),`\n`,(0,i.jsxs)(e.p,{children:[\"Note that the \",(0,i.jsx)(e.code,{children:\".ts\"}),\" extension is an MPEG-2 Transport Stream file, which contains a segment of the media stream. It's not a TypeScript file!\"]}),`\n`,(0,i.jsx)(e.h4,{id:\"resources\",children:\"Resources\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Setting_up_adaptive_streaming_media_sources\",children:\"Setting up adaptive streaming media sources - Developer guides\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://streaminglearningcenter.com/encoding/how-netflix-pioneered-per-title-video-encoding-optimization.html\",children:\"How Netflix Pioneered Per-Title Video Encoding Optimization - Streaming Learning Center\"})}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"subtitles--closed-captions\",children:\"Subtitles / Closed Captions\"}),`\n`,(0,i.jsx)(e.p,{children:\"Subtitles and closed captions both provide on-screen text to accompany video content, but they serve different purposes and audiences:\"}),`\n`,(0,i.jsx)(e.p,{children:\"Subtitles are primarily intended for users who can hear the audio but do not understand the language spoken in the video. Typically, subtitles only include the dialogue or spoken words, and not much beyond that. They are used by people who are not deaf or hard of hearing.\"}),`\n`,(0,i.jsx)(e.p,{children:\"Closed captions are designed for users who are deaf or hard of hearing. Closed captions include not only the dialogue but also other relevant parts of the soundtrack such as sound effects, background noises, and music cues. They also indicate who is speaking or note significant sounds. They are particularly helpful for those who cannot hear the audio in the video.\"}),`\n`,(0,i.jsx)(e.p,{children:\"The differences are subtle but it is useful to know the them. From here on, we will refer to subtitles as a general term to mean on-screen text that accompanies video content.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"separate-subtitles-files\",children:\"Separate subtitles files\"}),`\n`,(0,i.jsx)(e.p,{children:\"Subtitles are often provided in separate files that are downloaded and displayed along with the video. The most common subtitle file formats include:\"}),`\n`,(0,i.jsxs)(e.ol,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"SubRip Subtitle (SRT)\"}),\": A simple and widely supported format that contains timestamped text.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Timed Text Markup Language (TTML)\"}),\": An XML-based format for captions and subtitles.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Scenarist Closed Caption (SCC)\"}),\": A format used for closed captions and captions for broadcast video.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"WebVTT (VTT)\"}),\": A format that offers more styling options and is commonly used for HTML5 video. You can use the \",(0,i.jsx)(e.code,{children:\"<track>\"}),\" element within the HTML5 \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" element to reference a WebVTT file, and the browser handles the rendering of subtitles.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-html\",children:`<video controls>\n  <source src=\"video.mp4\" type=\"video/mp4\" />\n  <track\n    label=\"English\"\n    kind=\"subtitles\"\n    srclang=\"en\"\n    src=\"subtitles.vtt\"\n    default />\n</video>\n`})}),`\n`,(0,i.jsx)(e.h4,{id:\"embedded-subtitles\",children:\"Embedded subtitles\"}),`\n`,(0,i.jsx)(e.p,{children:\"In some cases, subtitles are embedded directly into the video file itself. This method is common for broadcast and streaming video formats like DVB, ATSC, and some streaming protocols. The subtitles are decoded and displayed by the video player.\"}),`\n`,(0,i.jsx)(e.p,{children:\"DASH and HLS support delivering subtitles as part of the streaming package. The subtitles are included in the manifest files and can be selected by the user through the video player.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"separate-api\",children:\"Separate API\"}),`\n`,(0,i.jsx)(e.p,{children:\"Some web video player libraries offer APIs that allow developers to dynamically load subtitles from external sources or services. This can be useful for applications where subtitles change based on user preferences or dynamic content.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"accessibility-features\",children:\"Accessibility features\"}),`\n`,(0,i.jsx)(e.p,{children:\"When displaying subtitles, it's important to ensure that they are accessible to all users, including those with disabilities. This involves providing proper markup and interaction support for screen readers and keyboard navigation. It also includes enabling users to customize the appearance of subtitles, such as font size and color, to improve readability.\"}),`\n`,(0,i.jsx)(e.p,{children:\"In addition to spoken dialog, subtitles and transcripts should also identify music and sound effects that communicate important information. This includes emotion and tone:\"}),`\n`,(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:\"language-txt\",children:`14\n00:03:14 --> 00:03:18\n[Dramatic rock music]\n\n15\n00:03:19 --> 00:03:21\n[whispering] What's that off in the distance?\n`})}),`\n`,(0,i.jsx)(e.h4,{id:\"multilingual-support\",children:\"Multilingual support\"}),`\n`,(0,i.jsx)(e.p,{children:\"To cater to a global audience, video players typically allow users to select from multiple languages and subtitle tracks, making it possible to switch between different languages or caption styles.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"resources-1\",children:\"Resources\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://netflixtechblog.com/implementing-japanese-subtitles-on-netflix-c165fbe61989\",children:\"Implementing Japanese Subtitles on Netflix | by Netflix Technology Blog\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API\",children:\"Web Video Text Tracks Format (WebVTT) - Web APIs | MDN\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://www.mux.com/blog/subtitles-captions-webvtt-hls-and-those-magic-flags\",children:\"Subtitles, Captions, WebVTT, HLS, and those magic flags | Mux\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Adding_captions_and_subtitles_to_HTML5_video\",children:\"Adding captions and subtitles to HTML video - Developer guides | MDN\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://webaim.org/techniques/captions/\",children:\"WebAIM: Captions, Transcripts, and Audio Descriptions\"})}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"performance\",children:\"Performance\"}),`\n`,(0,i.jsx)(e.p,{children:\"Performance in video streaming is vital for a seamless and enjoyable viewing experience, free from buffering and quality issues. For businesses, high performance in streaming is critical for customer retention, brand reputation, and efficient bandwidth usage, which impacts operational costs and scalability.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"minimizing-latency-and-delay\",children:\"Minimizing latency and delay\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video loading time\"}),\": Reduce video loading times to minimize buffering delays. Use adaptive streaming techniques to deliver the appropriate quality based on the user's network conditions.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Buffering optimization\"}),\": Optimize video buffering to provide smooth playback. Preload video content where possible, and use efficient buffering algorithms. Buffer ahead of the current timestamp.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Network efficiency\"}),\": Leverage adaptive bitrate streaming to adjust video quality based on the user's available bandwidth. This ensures that users with slower connections can still watch videos (albeit at a lower quality) without frequent buffering.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video compression\"}),\": Use modern video compression codecs (e.g., H.264, H.265, VP9) to minimize the size of video files, reducing the amount of data that needs to be transferred over the internet.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"CDN usage\"}),\": Utilize Content Delivery Networks (CDNs) to serve video content from servers located closer to users, reducing latency and improving playback performance.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Lazy loading\"}),\": Implement lazy loading for videos so that they only load when they come into the user's viewport. Lazy load non-visible UI like dropdowns and modals during idle cycles or when it's being interacted with. This reduces initial page load times.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Player responsiveness\"}),\": Ensure that video player controls and the user interface remain responsive during video playback. Users should be able to interact with the player without delays.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Preloading media files\"}),\": Preload media either by using the \",(0,i.jsx)(e.code,{children:\"preload\"}),\" attribute (only for predefined \",(0,i.jsx)(e.code,{children:\"src\"}),\", not compatible with Media Source API) or use link preload (\",(0,i.jsx)(e.a,{href:\"https://web.dev/articles/fast-playback-with-preload\",children:\"source\"}),\").\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"improving-video-startup-time-by-separating-video-lifecycle-from-ui-lifecycle\",children:\"Improving video startup time by separating video lifecycle from UI lifecycle\"}),`\n`,(0,i.jsx)(e.p,{children:\"The conventional approach of allowing the UI component tree to control the lifecycle of video playback can lead to a sluggish user experience. This is primarily due to the dependency on UI lifecycle methods, like those in React, where video initiation is tied to specific component calls, causing users to wait until the playback is sufficiently loaded before viewing the content.\"}),`\n`,(0,i.jsx)(e.p,{children:\"A more efficient alternative involves separating the logic for managing video playback from the UI component tree. This allows the execution of video-related processes from any point within the application, including before the UI tree is rendered during the initial application loading. By initiating video creation in parallel with UI rendering, the application gains valuable time to create, initialize, and buffer video playback. Consequently, this approach enables users to start playing the video sooner, enhancing the overall responsiveness and user experience.\"}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsxs)(e.em,{children:[\"Source: \",(0,i.jsx)(e.a,{href:\"https://netflixtechblog.com/modernizing-the-web-playback-ui-1ad2f184a5a0\",children:\"Modernizing the Web Playback UI | by Netflix Technology Blog\"})]})}),`\n`,(0,i.jsx)(e.h4,{id:\"separating-audio-and-video-streams\",children:\"Separating audio and video streams\"}),`\n`,(0,i.jsx)(e.p,{children:\"Audio and video streams can be separated so that the video stream can be reused even if the audio changes, e.g. when audio changes to a different language. This granular separation allows for other optimizations such as when users play videos in a background tab (e.g. common for lyrics videos), video data does not need to be streamed.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"image-optimizations\",children:\"Image optimizations\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Preload poster image\"}),\": \",(0,i.jsx)(e.code,{children:'<link as=\"image\" rel=\"preload\" href=\"poster.jpg\" fetchpriority=\"high\">'}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video thumbnails\"}),\": Optimize the generation and display of video thumbnails, which can contribute to faster loading times and improve the user experience when seeking through a video.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Responsive images\"}),\": Use responsive thumbnail images to load images of the suitable dimensions for the current device.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"bandwidth-efficiency\",children:\"Bandwidth efficiency\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Selective autoplay\"}),\": When opening a video in a new tab, YouTube does not start playing the video until the tab is in focus.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Non-visible tabs\"}),\": Only audio data needs to be streamed when the tab is in the background and not visible.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Buffer sufficiently but not excessively\"}),\": Don't buffer more than necessary, especially if the video is paused as the user might not intend to resume watching.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"memory-usage\",children:\"Memory usage\"}),`\n`,(0,i.jsx)(e.p,{children:\"Video watching requires pages to be long-lived, so it is important to pay attention to memory usage and efficiency.\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Memory usage\"}),\": Minimize memory consumption to prevent performance degradation over time, especially on devices with limited RAM. Not streaming video data when the tab is in the background helps to lower the amount of data in the buffer, thereby keeping memory usage low.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Resource cleanup\"}),\": Properly release resources, including video buffers and memory, when a video is no longer needed to prevent memory leaks and performance issues.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"user-experience\",children:\"User experience\"}),`\n`,(0,i.jsx)(e.p,{children:\"A positive user experience in video streaming is crucial as it ensures user satisfaction and engagement from the user's perspective. For businesses, it translates into higher user retention, brand loyalty, and potential revenue growth, as satisfied users are more likely to recommend the service and continue their subscriptions.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"ease-of-use\",children:\"Ease of use\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Playback controls\"}),\": The player should provide essential playback controls, including play/pause, volume control, mute, and fullscreen mode. These controls should be easily accessible and responsive.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Consistent user interface\"}),\": Maintain a consistent and familiar user interface across different devices and platforms. Users should feel comfortable with the player's layout and controls and their positioning should conform to common standards.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Responsive design\"}),\": The video player should adapt to various screen sizes and orientations, ensuring that it works well on desktops, laptops, tablets, and mobile devices.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Seeking and scrubbing\"}),\": Ensure that seeking (moving forward or backward in the video) is easy and precise. Users should be able to scrub through the video accurately.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"customization\",children:\"Customization\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Customization options\"}),\": Allow users to customize aspects of the player, such as subtitles, captions, video quality, and playback speed to suit their preferences.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video quality settings\"}),\": Provide options for users to adjust video quality based on their internet connection and device capabilities. This can help prevent buffering issues and provide a smoother viewing experience.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Playback speed control\"}),\": Some users prefer to watch videos at a faster or slower speed. Include an option to adjust the playback speed to cater to individual preferences.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Error handling\"}),\": Display clear and informative error messages when playback issues occur, such as when the video can't be loaded or an error is encountered during playback.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"enhanced-experience\",children:\"Enhanced experience\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Prevent layout shifts\"}),\": Set the \",(0,i.jsx)(e.code,{children:\"width\"}),\" and \",(0,i.jsx)(e.code,{children:\"height\"}),\" attributes on \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" tag to \",(0,i.jsx)(e.a,{href:\"https://web.dev/patterns/web-vitals-patterns/video/video\",children:\"prevent layout shifts\"}),\".\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video thumbnail previews\"}),\": Offer video thumbnails or previews when users hover over the timeline. This helps users quickly identify specific scenes in the video.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Poster image\"}),\": For autoplay videos, \",(0,i.jsx)(e.a,{href:\"https://web.dev/case-studies/better-youtube-web-part1#improving_core_web_vitals\",children:\"YouTube found that using a solid black poster image\"}),\" for autoplay videos was a better experience because the transition from solid black to the first frame of the video to be less-jarring.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"accessibility-a11y\",children:\"Accessibility (a11y)\"}),`\n`,(0,i.jsx)(e.p,{children:\"Since video streaming applications serve a broad, international audience, accessibility is vital because it ensures that all users, including those with disabilities, have equal access to content. A high standard of a11y also helps the business uphold the principles of equality and non-discrimination in digital content consumption.\"}),`\n`,(0,i.jsx)(e.h4,{id:\"subtitles\",children:\"Subtitles\"}),`\n`,(0,i.jsxs)(e.p,{children:[\"Accessibility for subtitles have been covered in the \",(0,i.jsx)(e.a,{href:\"#subtitles--closed-captions\",children:'\"Subtitles\"'}),\" section above. To recap:\"]}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Audio impairment issues\"}),\": Closed captions or subtitles should be provided for videos to assist users who are deaf or hard of hearing.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Implementation\"}),\": One way to implement subtitles is to use \",(0,i.jsx)(e.code,{children:\"<track>\"}),\" tags within \",(0,i.jsx)(e.code,{children:\"<video>\"}),\" tags.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Readability\"}),\": Ensure subtitles are easy to read, with clear fonts, appropriate sizes, and high contrast against the video in the background. Common choices are white text with a drop shadow or white text highlighted in a dark color.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Inclusion of non-speech elements\"}),\": Capture not just dialogue but also significant sounds and audio cues in the subtitles to provide a fuller understanding of the content.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Customization options\"}),\": Support the display and customization of captions, including font size, color, and background.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Multilingual support\"}),\": Subtitles should be offered in multiple languages to cater to a diverse audience with different linguistic backgrounds.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"visual-assistance\",children:\"Visual assistance\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Contrast and color choices\"}),\": Ensure that the video player's user interface, including controls and text, meets minimum contrast ratios to make it easier to read and interact with. Avoid relying solely on color to convey important information.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Load progress indicator\"}),\": Display a loading progress bar or spinner to inform users that the video content is loading. This can help manage user expectations and reduce frustration.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Buffering indicator\"}),\": Clearly indicate when the video is buffering to manage user expectations and provide feedback on the loading process.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Description of site's capabilities\"}),\": Netflix describes the video's features to screen reader users.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsx)(e.img,{src:\"/img/questions/video-streaming-netflix/video-streaming-netflix-netflix-video-capabilities-a11y.png\",alt:\"Netflix video capabilities description for screen readers\"})}),`\n`,(0,i.jsx)(e.h4,{id:\"screen-readers\",children:\"Screen readers\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Buttons have labels\"}),\": Providing alternative text for video controls, offering descriptive labels for buttons (which are usually icon-only).\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Video playback information\"}),\": Screen reader users should receive pertinent information about the video, such as title, duration, and playback status.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Text-to-speech compatibility\"}),\": Video players should not interfere with or disrupt assistive technologies that convert on-screen text to speech.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"keyboard-support\",children:\"Keyboard support\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Keyboard accessibility\"}),\": Video players should be operable using keyboard navigation alone. This includes allowing users to play, pause, adjust volume, and seek through the video using keyboard shortcuts. Keyboard focus should be visible and logical.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Keyboard shortcuts\"}),\": Offer keyboard shortcuts for common actions, such as volume control, playback, and seeking within the video.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Focus management\"}),\": Maintain a clear and logical focus order, ensuring that keyboard and screen reader users can easily navigate through controls without getting stuck.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h4,{id:\"external-sources-of-control\",children:\"External sources of control\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Multiple input methods\"}),\": Ensure that the video player can be operated using a variety of input methods, including touchscreens and pointing devices.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"External peripherals\"}),\": External peripherals can also control the media object state, the web user interface is not the only source of control. Media object's state should be synced with the UI component state so that custom-built controls can accurately reflect playback state.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.p,{children:(0,i.jsxs)(e.em,{children:[\"Source: \",(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Learn/Accessibility/Multimedia#accessible_audio_and_video_controls\",children:\"Accessible multimedia - Learn web development | MDN\"})]})}),`\n`,(0,i.jsx)(e.h3,{id:\"internationalization-i18n\",children:\"Internationalization (i18n)\"}),`\n`,(0,i.jsx)(e.p,{children:\"Internationalization concerns for a web video player involve making sure that the player is designed and developed to support users from various regions and languages.\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Language support\"}),\": User interface should be translated into multiple languages to support a global audience. Use internationalization libraries or frameworks like i18next or \",(0,i.jsx)(e.code,{children:\"react-intl\"}),\" to manage language translations.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Translated labels for buttons\"}),\": Non-visible button labels like \",(0,i.jsx)(e.code,{children:\"aria-label\"}),\"s should also be translated for the user's selected language.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Subtitle and captioning\"}),\": Support multiple languages for subtitles and closed captions. Users from different regions may require subtitles in their native languages to fully understand the content.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Audio track selection\"}),\": Provide the ability for users to select audio tracks in different languages if the video offers multiple audio options, such as dubbing.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Region-based content\"}),\": Some content may be geographically restricted due to licensing or regional regulations. The player should handle content availability based on the user's location.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"RTL (Right-to-Left) support\"}),\": If supporting languages with right-to-left writing systems (e.g., Arabic or Hebrew), ensure that the video player's interface adapts to RTL layout when necessary.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Localization of content metadata\"}),\": If the video player displays metadata about the content, such as titles and descriptions, ensure that this information can be localized and is presented accurately for different regions.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Content ratings and guidelines\"}),\": Some regions have specific content rating systems and guidelines. Make sure that content ratings and warnings comply with local regulations and standards.\"]}),`\n`,(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:\"Legal and compliance\"}),\": Be aware of international copyright and intellectual property laws. Ensure that the video player and content distribution comply with local regulations and licensing agreements.\"]}),`\n`]}),`\n`,(0,i.jsx)(e.h3,{id:\"bonus\",children:\"Bonus\"}),`\n`,(0,i.jsx)(e.h4,{id:\"how-to-serve-thumbnails-when-hover-the-seek-bar\",children:\"How to serve thumbnails when hover the seek bar\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:\"YouTube creates low-res images for each timestamp and stitches a few frames together into a sprite sheet uploaded to a CDN. When the seek bar is hovered, a request is made to fetch the sprite sheet that contains the thumbnail for the current timestamp.\"}),`\n`,(0,i.jsx)(e.li,{children:\"Netflix includes the thumbnails as part of their streamed data.\"}),`\n`]}),`\n`,(0,i.jsx)(e.h2,{id:\"references\",children:\"References\"}),`\n`,(0,i.jsxs)(e.ul,{children:[`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://howvideo.works/\",children:\"How video works\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://web.dev/better-youtube-web-part1/\",children:\"Building a Better Web - Part 1: A faster YouTube on web\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://web.dev/youtube-media-capabilities/\",children:\"How YouTube improved video performance with the Media Capabilities API\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Media_Source_Extensions_API\",children:\"Media Source API\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://medium.com/axon-enterprise/ui-frameworks-and-media-elements-c0c6832528e5\",children:\"UI frameworks and Media Elements\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://netflixtechblog.com/modernizing-the-web-playback-ui-1ad2f184a5a0\",children:\"Modernizing the Web Playback UI | by Netflix Technology Blog\"})}),`\n`,(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/Guide/Audio_and_video_delivery/Setting_up_adaptive_streaming_media_sources\",children:\"Setting up adaptive streaming media sources - Developer guides\"})}),`\n`]})]})}function S(n={}){let{wrapper:e}=n.components||{};return e?(0,i.jsx)(e,Object.assign({},n,{children:(0,i.jsx)(c,n)})):c(n)}var k=S;return y(T);})();\n;return Component;"
}