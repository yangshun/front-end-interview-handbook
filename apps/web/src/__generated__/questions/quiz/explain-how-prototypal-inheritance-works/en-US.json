{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/explain-how-prototypal-inheritance-works",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 130,
    "similarQuestions": [],
    "slug": "explain-how-prototypal-inheritance-works",
    "subtitle": null,
    "title": "Explain how prototypal inheritance works in JavaScript",
    "topics": [
      "javascript",
      "oop"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/explain-how-prototypal-inheritance-works/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var y=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var f=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),b=(o,e)=>{for(var t in e)c(o,t,{get:e[t],enumerable:!0})},a=(o,e,t,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of y(e))!u.call(o,r)&&r!==t&&c(o,r,{get:()=>e[r],enumerable:!(i=p(e,r))||i.enumerable});return o};var j=(o,e,t)=>(t=o!=null?d(m(o)):{},a(e||!o||!o.__esModule?c(t,\"default\",{value:o,enumerable:!0}):t,o)),g=o=>a(c({},\"__esModule\",{value:!0}),o);var h=f((D,s)=>{s.exports=_jsx_runtime});var v={};b(v,{default:()=>O,frontmatter:()=>w});var n=j(h()),w={title:\"Explain how prototypal inheritance works in JavaScript\"};function l(o){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",a:\"a\",pre:\"pre\",ul:\"ul\",li:\"li\",hr:\"hr\",h3:\"h3\",ol:\"ol\",strong:\"strong\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Prototypical inheritance in JavaScript is a way for objects to inherit properties and methods from other objects. Every JavaScript object has a special hidden property called \",(0,n.jsx)(e.code,{children:\"[[Prototype]]\"}),\" (commonly accessed via \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\" or using \",(0,n.jsx)(e.code,{children:\"Object.getPrototypeOf()\"}),`) that is a reference to another object, which is called the object's \"prototype\".`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"When a property is accessed on an object and if the property is not found on that object, the JavaScript engine looks at the object's \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\", and the \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\"'s \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\" and so on, until it finds the property defined on one of the \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\"s or until it reaches the end of the prototype chain.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This behavior simulates classical inheritance, but it is really more of \",(0,n.jsx)(e.a,{href:\"https://davidwalsh.name/javascript-objects\",children:\"delegation than inheritance\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Here's an example of prototypal inheritance:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Parent object constructor.\nfunction Animal(name) {\n  this.name = name;\n}\n\n// Add a method to the parent object's prototype.\nAnimal.prototype.makeSound = function () {\n  console.log('The ' + this.constructor.name + ' makes a sound.');\n};\n\n// Child object constructor.\nfunction Dog(name) {\n  Animal.call(this, name); // Call the parent constructor.\n}\n\n// Set the child object's prototype to be the parent's prototype.\nObject.setPrototypeOf(Dog.prototype, Animal.prototype);\n\n// Add a method to the child object's prototype.\nDog.prototype.bark = function () {\n  console.log('Woof!');\n};\n\n// Create a new instance of Dog.\nconst bolt = new Dog('Bolt');\n\n// Call methods on the child object.\nconsole.log(bolt.name); // \"Bolt\"\nbolt.makeSound(); // \"The Dog makes a sound.\"\nbolt.bark(); // \"Woof!\"\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Things to note are:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\".makeSound\"}),\" is not defined on \",(0,n.jsx)(e.code,{children:\"Dog\"}),\", so the JavaScript engine goes up the prototype chain and finds \",(0,n.jsx)(e.code,{children:\".makeSound\"}),\" on the inherited \",(0,n.jsx)(e.code,{children:\"Animal\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"Object.create()\"}),\" to build the inheritance chain is no longer recommended. Use \",(0,n.jsx)(e.code,{children:\"Object.setPrototypeOf()\"}),\" instead.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Prototypical Inheritance in Javascript\"}),`\n`,(0,n.jsx)(e.p,{children:\"Prototypical inheritance is a feature in JavaScript used to create objects that inherit properties and methods from other objects. Instead of a class-based inheritance model, JavaScript uses a prototype-based model, where objects can directly inherit from other objects.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Key Concepts\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Prototypes\"}),\" : Every object in Javascript has a prototype, which is another object. When you create an object using an object literal or a constructor function, the new object is linked to the prototype of its constructor function or the \",(0,n.jsx)(e.code,{children:\"Object.prototype\"}),\" if no prototype is specified. This is commonly referenced using \",(0,n.jsx)(e.code,{children:\"__proto__\"}),\" or \",(0,n.jsx)(e.code,{children:\"[[Prototype]]\"}),\". You can also get the prototype by using inbuilt method \",(0,n.jsx)(e.code,{children:\"Object.getPrototypeOf()\"}),\" and you can set the prototype of an object via \",(0,n.jsx)(e.code,{children:\"Object.setPrototypeOf()\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Define a constructor function\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\n// Add a method to the prototype\nPerson.prototype.sayHello = function () {\n  console.log(\\`Hello, my name is \\${this.name} and I am \\${this.age} years old.\\`);\n};\n\n// Create a new object using the constructor function\nlet john = new Person('John', 30);\n\n// The new object has access to the methods defined on the prototype\njohn.sayHello(); // \"Hello, my name is John and I am 30 years old.\"\n\n// The prototype of the new object is the prototype of the constructor function\nconsole.log(john.__proto__ === Person.prototype); // true\n\n// You can also get the prototype using Object.getPrototypeOf()\nconsole.log(Object.getPrototypeOf(john) === Person.prototype); // true\n\n// You can set the prototype of an object using Object.setPrototypeOf()\nlet newProto = {\n  sayGoodbye: function () {\n    console.log(\\`Goodbye, my name is \\${this.name}\\`);\n  },\n};\n\nObject.setPrototypeOf(john, newProto);\n\n// Now john has access to the methods defined on the new prototype\njohn.sayGoodbye(); // \"Goodbye, my name is John\"\n\n// But no longer has access to the methods defined on the old prototype\nconsole.log(john.sayHello); // undefined\n`})}),`\n`,(0,n.jsxs)(e.ol,{start:\"2\",children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Prototype chain\"}),\": When a property or method is accessed on an object, JavaScript first looks for it on the object itself. If it doesn't find it there, it looks at the object's prototype, and then the prototype's prototype, and so on, until it either finds the property or reaches the end of the chain (i.e., \",(0,n.jsx)(e.code,{children:\"null\"}),\").\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Constructor functions\"}),\": JavaScript provides constructor functions to create objects. When a function is used as a constructor with the new keyword, the new object's prototype (\",(0,n.jsx)(e.code,{children:\"[[Prototype]]\"}),\") is set to the constructor's prototype property.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Define a constructor function\nfunction Animal(name) {\n  this.name = name;\n}\n\n// Add a method to the prototype\nAnimal.prototype.sayName = function () {\n  console.log(\\`My name is \\${this.name}\\`);\n};\n\n// Define a new constructor function\nfunction Dog(name, breed) {\n  Animal.call(this, name);\n  this.breed = breed;\n}\n\n// Set the prototype of Dog to be a new instance of Animal\nDog.prototype = Object.create(Animal.prototype);\n\n// Add a method to the Dog prototype\nDog.prototype.bark = function () {\n  console.log('Woof!');\n};\n\n// Create a new object using the Dog constructor function\nlet fido = new Dog('Fido', 'Labrador');\n\n// The new object has access to the methods defined on its own prototype and the Animal prototype\nfido.bark(); // \"Woof!\"\nfido.sayName(); // \"My name is Fido\"\n\n// If we try to access a method that doesn't exist on the Dog prototype or the Animal prototype, JavaScript will return undefined\nconsole.log(fido.fly); // undefined\n`})}),`\n`,(0,n.jsxs)(e.ol,{start:\"4\",children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.code,{children:\"Object.create()\"})}),\": This method creates a new object with the specified prototype object and properties. It's a straightforward way to set up prototypical inheritance. If you create a object via \",(0,n.jsx)(e.code,{children:\"Object.create(null)\"}),\" it will not inherit any properties from \",(0,n.jsx)(e.code,{children:\"Object.prototype\"}),\". This means the object will not have any built-in properties or methods like \",(0,n.jsx)(e.code,{children:\"toString()\"}),\", \",(0,n.jsx)(e.code,{children:\"hasOwnProperty()\"}),\",\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Define a prototype object\nlet proto = {\n  greet: function () {\n    console.log(\\`Hello, my name is \\${this.name}\\`);\n  },\n};\n\n// Use \\`Object.create()\\` to create a new object with the specified prototype\nlet person = Object.create(proto);\nperson.name = 'John';\n\n// The new object has access to the methods defined on the prototype\nperson.greet(); // \"Hello, my name is John\"\n\n// Check if the object has a property\nconsole.log(person.hasOwnProperty('name')); // true\n\n// Create an object that does not inherit from Object.prototype\nlet animal = Object.create(null);\nanimal.name = 'Rocky';\n\n// The new object does not have any built-in properties or methods\nconsole.log(animal.toString); // undefined\nconsole.log(animal.hasOwnProperty); // undefined\n\n// But you can still add and access custom properties\nanimal.describe = function () {\n  console.log(\\`Name of the animal is \\${this.name}\\`);\n};\n\nanimal.describe(); // \"Name of the animal is Rocky\"\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Resources\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain\",children:\"Inheritance and the prototype chain | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://dev.to/lydiahallie/javascript-visualized-prototypal-inheritance-47co\",children:\"JavaScript Visualized: Prototypal Inheritance\"})}),`\n`]})]})}function _(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(l,o)})):l(o)}var O=_;return g(v);})();\n;return Component;"
}