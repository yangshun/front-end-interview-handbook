{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/why-is-it-in-general-a-good-idea-to-leave-the-global-scope-of-a-website-as-is-and-never-touch-it",
    "importance": "medium",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 330,
    "similarQuestions": [],
    "slug": "why-is-it-in-general-a-good-idea-to-leave-the-global-scope-of-a-website-as-is-and-never-touch-it",
    "subtitle": null,
    "title": "Why is it, in general, a good idea to leave the global JavaScript scope of a website as-is and never touch it?",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/why-is-it-in-general-a-good-idea-to-leave-the-global-scope-of-a-website-as-is-and-never-touch-it/en-US.mdx"
  },
  "solution": "var Component=(()=>{var u=Object.create;var t=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var y=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),f=(o,e)=>{for(var i in e)t(o,i,{get:e[i],enumerable:!0})},s=(o,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of g(e))!m.call(o,a)&&a!==i&&t(o,a,{get:()=>e[a],enumerable:!(l=p(e,a))||l.enumerable});return o};var v=(o,e,i)=>(i=o!=null?u(b(o)):{},s(e||!o||!o.__esModule?t(i,\"default\",{value:o,enumerable:!0}):i,o)),w=o=>s(t({},\"__esModule\",{value:!0}),o);var c=y((C,r)=>{r.exports=_jsx_runtime});var x={};f(x,{default:()=>h,frontmatter:()=>k});var n=v(c()),k={title:\"Why is it, in general, a good idea to leave the global JavaScript scope of a website as-is and never touch it?\"};function d(o){let e={a:\"a\",code:\"code\",h2:\"h2\",hr:\"hr\",li:\"li\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...o.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"JavaScript that is executed in the browser has access to the global scope (the \",(0,n.jsx)(e.code,{children:\"window\"}),\" object). In general it's a good software engineering practice to not pollute the global namespace unless you are working on a feature that truly needs to be global \\u2013 it is needed by the entire page. Several reasons to avoid touching the global scope:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Naming conflicts\"}),\": Sharing the global scope across scripts can cause conflicts and bugs when new global variables or changes are introduced.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Cluttered global namespace\"}),\": Keeping the global namespace minimal avoids making the codebase hard to manage and maintain.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Scope leaks\"}),\": Unintentional references to global variables in closures or event handlers can cause memory leaks and performance issues.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Modularity and encapsulation\"}),\": Good design promotes keeping variables and functions within their specific scopes, enhancing organization, reusability, and maintainability.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Security concerns\"}),\": Global variables are accessible by all scripts, including potentially malicious ones, posing security risks, especially if sensitive data is stored there.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Compatibility and portability\"}),\": Heavy reliance on global variables reduces code portability and integration ease with other libraries or frameworks.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Follow these best practices to avoid global scope pollution:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Use local variables\"}),\": Declare variables within functions or blocks using \",(0,n.jsx)(e.code,{children:\"var\"}),\", \",(0,n.jsx)(e.code,{children:\"let\"}),\", or \",(0,n.jsx)(e.code,{children:\"const\"}),\" to limit their scope.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Pass variables as function parameters\"}),\": Maintain encapsulation by passing variables as parameters instead of accessing them globally.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Use immediately invoked function expressions (IIFE)\"}),\": Create new scopes with IIFEs to prevent adding variables to the global scope.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Use modules\"}),\": Encapsulate code with module systems to maintain separate scopes and manageability.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"What is the global scope?\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the browser, the global scope is the top-level context where variables, functions, and objects are accessible from anywhere in the code. The global scope is represented by the \",(0,n.jsx)(e.code,{children:\"window\"}),\" object. Any variables or functions declared outside of any function or block (that is not within any module) are added to the \",(0,n.jsx)(e.code,{children:\"window\"}),\" object and can be accessed globally.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"For example:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Assuming this is run in the global scope and not within a module.\nvar globalVariable = 'I am global';\nfunction globalFunction() {\n  console.log('I am a global function');\n}\n\nconsole.log(window.globalVariable); // 'I am global'\nwindow.globalFunction(); // 'I am a global function'\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this example, \",(0,n.jsx)(e.code,{children:\"globalVariable\"}),\" and \",(0,n.jsx)(e.code,{children:\"globalFunction\"}),\" are added to the \",(0,n.jsx)(e.code,{children:\"window\"}),\" object and can be accessed from anywhere in the global context.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Pitfalls of global scope\"}),`\n`,(0,n.jsx)(e.p,{children:\"In general, it's a good software engineering practice to not pollute the global namespace unless you are working on a feature that truly needs to be global \\u2013 it is needed by the entire page. There are many reasons to avoid touching the global scope:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Naming conflicts\"}),\": The global scope is shared across all scripts on a web page. If you introduce new global variables or modify existing ones, you risk causing naming conflicts with other scripts or libraries used on the same page. This can lead to unexpected behavior and difficult-to-debug issues.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Cluttered global namespace\"}),\": The global namespace should be kept as clean and minimal as possible. Adding unnecessary global variables or functions can clutter the namespace and make it harder to manage and maintain the codebase over time.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Scope leaks\"}),\": When working with closures or event handlers, it's easy to accidentally create unintended references to global variables, leading to memory leaks and performance issues. By avoiding global variables altogether, you can prevent these types of scope leaks.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Modularity and encapsulation\"}),\": One of the principles of good software design is modularity and encapsulation. By keeping variables and functions within their respective scopes (e.g., module, function, or block scope), you promote better code organization, reusability, and maintainability.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Security concerns\"}),\": Global variables can be accessed and modified by any script running on the page, including potentially malicious scripts. It is quite common for websites to load third-party scripts and in the event someone's network is compromised, it can pose security risks, especially if sensitive data is stored in global variables. However, in the first place you should not expose any sensitive data on the client.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Compatibility and portability\"}),\": By relying heavily on global variables, your code becomes less portable and more dependent on the specific environment it was written for. This can make it harder to integrate with other libraries or frameworks, or to run the code in different environments (e.g., server-side vs browser).\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Here's an example of global scope being used.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Assuming this is run in the global scope, not within a module.\nlet count = 0;\n\nfunction incrementCount() {\n  count++;\n  console.log(count);\n}\n\nfunction decrementCount() {\n  count--;\n  console.log(count);\n}\n\nincrementCount(); // Output: 1\ndecrementCount(); // Output: 0\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this example, \",(0,n.jsx)(e.code,{children:\"count\"}),\", \",(0,n.jsx)(e.code,{children:\"incrementCount\"}),\", and \",(0,n.jsx)(e.code,{children:\"decrementCount\"}),\" are defined on the global scope. Any script on the page can access and modify the \",(0,n.jsx)(e.code,{children:\"count\"}),\", as well as all variables on \",(0,n.jsx)(e.code,{children:\"window\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Avoiding global scope pollution\"}),`\n`,(0,n.jsx)(e.p,{children:\"By now we hope that you're convinced that it's not a good idea to define variables on the global scope. To avoid polluting the global scope, it is recommended to follow best practices such as:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Use local variables\"}),\": Declare variables within functions or blocks to limit their scope and prevent them from being accessed globally. Use \",(0,n.jsx)(e.code,{children:\"var\"}),\", \",(0,n.jsx)(e.code,{children:\"let\"}),\", or \",(0,n.jsx)(e.code,{children:\"const\"}),\" to declare variables within a specific scope, ensuring they are not accidentally made global.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Pass variables as function parameters:\"}),\": Instead of accessing variables directly from the outer scope, pass them as parameters to functions to maintain encapsulation and avoid global scope pollution.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Use modules\"}),\": Utilize module systems to encapsulate your code and prevent global scope pollution. Each module has its own scope, making it easier to manage and maintain your code.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Use immediately invoked function expressions (IIFE)\"}),\": If modules are not available, wrap your code in an IIFE to create a new scope, preventing variables from being added to the global scope unless you explicitly expose them.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Assuming this is run in the global scope, not within a module.\n(function () {\n  let count = 0;\n\n  window.incrementCount = function () {\n    count++;\n    console.log(count);\n  };\n\n  window.decrementCount = function () {\n    count--;\n    console.log(count);\n  };\n})();\n\nincrementCount(); // Output: 1\ndecrementCount(); // Output: 0\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this example, \",(0,n.jsx)(e.code,{children:\"count\"}),\" is not accessible in the global scope. It can only be accessed and modified by the \",(0,n.jsx)(e.code,{children:\"incrementCount\"}),\" and \",(0,n.jsx)(e.code,{children:\"decrementCount\"}),\" functions. These functions are exposed to the global scope by attaching them to the \",(0,n.jsx)(e.code,{children:\"window\"}),\" object, but they still have access to the \",(0,n.jsx)(e.code,{children:\"count\"}),\" variable in their parent scope. This provides a way to encapsulate the underlying data and only expose the necessary operations \\u2013 no direct manipulation of the value is allowed.\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules\",children:\"JavaScript modules - MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/modules-intro\",children:\"Modules, introduction\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://lucybain.com/blog/2014/js-dont-touch-global-scope/\",children:\"JS: don't touch the global scope\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://exploringjs.com/es5/ch16.html\",children:\"Variables: Scopes, Environments, and Closures\"})}),`\n`]})]})}function h(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,{...o,children:(0,n.jsx)(d,{...o})}):d(o)}return w(x);})();\n;return Component;"
}