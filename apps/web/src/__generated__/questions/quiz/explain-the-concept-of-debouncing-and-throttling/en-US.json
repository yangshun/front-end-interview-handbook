{
  "description": null,
  "format": "quiz",
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "easy",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/explain-the-concept-of-debouncing-and-throttling",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 999,
    "similarQuestions": [],
    "slug": "explain-the-concept-of-debouncing-and-throttling",
    "subtitle": null,
    "title": "Explain the concept of debouncing and throttling",
    "topics": [
      "async",
      "javascript",
      "performance"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/explain-the-concept-of-debouncing-and-throttling/en-US.mdx"
  },
  "solution": "var Component=(()=>{var u=Object.create;var s=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),w=(t,e)=>{for(var i in e)s(t,i,{get:e[i],enumerable:!0})},l=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!p.call(t,a)&&a!==i&&s(t,a,{get:()=>e[a],enumerable:!(o=d(e,a))||o.enumerable});return t};var y=(t,e,i)=>(i=t!=null?u(f(t)):{},l(e||!t||!t.__esModule?s(i,\"default\",{value:t,enumerable:!0}):i,t)),b=t=>l(s({},\"__esModule\",{value:!0}),t);var c=g((j,r)=>{r.exports=_jsx_runtime});var I={};w(I,{default:()=>v,frontmatter:()=>T});var n=y(c()),T={title:\"Explain the concept of debouncing and throttling\"};function h(t){let e=Object.assign({h2:\"h2\",p:\"p\",pre:\"pre\",code:\"code\",hr:\"hr\",h3:\"h3\",h4:\"h4\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:\"Debouncing and throttling are techniques used to control the rate at which a function is executed. Debouncing ensures that a function is only called after a specified delay has passed since the last time it was invoked. Throttling ensures that a function is called at most once in a specified time interval.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Debouncing delays the execution of a function until a certain amount of time has passed since it was last called. This is useful for scenarios like search input fields where you want to wait until the user has stopped typing before making an API call.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function debounce(func, delay) {\n  let timeoutId;\n  return function (...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Throttling ensures that a function is called at most once in a specified time interval. This is useful for scenarios like window resizing or scrolling where you want to limit the number of times a function is called.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function throttle(func, limit) {\n  let inThrottle;\n  return function (...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n}\n`})}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Debouncing and throttling\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Debouncing\"}),`\n`,(0,n.jsx)(e.p,{children:\"Debouncing is a technique used to ensure that a function is only executed after a certain amount of time has passed since it was last invoked. This is particularly useful in scenarios where you want to limit the number of times a function is called, such as when handling user input events like keypresses or mouse movements.\"}),`\n`,(0,n.jsx)(e.h4,{children:\"Example use case\"}),`\n`,(0,n.jsx)(e.p,{children:\"Imagine you have a search input field and you want to make an API call to fetch search results. Without debouncing, an API call would be made every time the user types a character, which could lead to a large number of unnecessary calls. Debouncing ensures that the API call is only made after the user has stopped typing for a specified amount of time.\"}),`\n`,(0,n.jsx)(e.h4,{children:\"Code example\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function debounce(func, delay) {\n  let timeoutId;\n  return function (...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => func.apply(this, args), delay);\n  };\n}\n\n// Usage\nconst handleSearch = debounce((query) => {\n  // Make API call\n  console.log('API call with query:', query);\n}, 300);\n\ndocument.getElementById('searchInput').addEventListener('input', (event) => {\n  handleSearch(event.target.value);\n});\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Throttling\"}),`\n`,(0,n.jsx)(e.p,{children:\"Throttling is a technique used to ensure that a function is called at most once in a specified time interval. This is useful in scenarios where you want to limit the number of times a function is called, such as when handling events like window resizing or scrolling.\"}),`\n`,(0,n.jsx)(e.h4,{children:\"Example use case\"}),`\n`,(0,n.jsx)(e.p,{children:\"Imagine you have a function that updates the position of elements on the screen based on the window size. Without throttling, this function could be called many times per second as the user resizes the window, leading to performance issues. Throttling ensures that the function is only called at most once in a specified time interval.\"}),`\n`,(0,n.jsx)(e.h4,{children:\"Code example\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function throttle(func, limit) {\n  let inThrottle;\n  return function (...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n}\n\n// Usage\nconst handleResize = throttle(() => {\n  // Update element positions\n  console.log('Window resized');\n}, 100);\n\nwindow.addEventListener('resize', handleResize);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://css-tricks.com/debouncing-throttling-explained-examples/\",children:\"Debouncing and Throttling Explained Through Examples\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.freecodecamp.org/news/javascript-debounce-example/\",children:\"Understanding the Difference Between Debounce and Throttle\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://lodash.com/docs/4.17.15#debounce\",children:\"Lodash Documentation for Debounce and Throttle\"})}),`\n`]})]})}function x(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var v=x;return b(I);})();\n;return Component;"
}