{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-do-you-think-of-amd-vs-commonjs",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 999,
    "similarQuestions": [],
    "slug": "what-do-you-think-of-amd-vs-commonjs",
    "subtitle": null,
    "title": "O que vocÃª acha de AMD versus CommonJS?",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-do-you-think-of-amd-vs-commonjs/pt-BR.mdx"
  },
  "solution": "var Component=(()=>{var p=Object.create;var s=Object.defineProperty;var l=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var x=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var S=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),f=(o,e)=>{for(var n in e)s(o,n,{get:e[n],enumerable:!0})},d=(o,e,n,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of v(e))!g.call(o,r)&&r!==n&&s(o,r,{get:()=>e[r],enumerable:!(t=l(e,r))||t.enumerable});return o};var q=(o,e,n)=>(n=o!=null?p(x(o)):{},d(e||!o||!o.__esModule?s(n,\"default\",{value:o,enumerable:!0}):n,o)),M=o=>d(s({},\"__esModule\",{value:!0}),o);var i=S((b,m)=>{m.exports=_jsx_runtime});var D={};f(D,{default:()=>u,frontmatter:()=>A});var a=q(i()),A={title:\"O que voc\\xEA acha de AMD versus CommonJS?\"};function c(o){let e={p:\"p\",...o.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.p,{children:\"Ambas s\\xE3o formas de implementar um sistema de m\\xF3dulos, que n\\xE3o estava nativamente presente em JavaScript at\\xE9 o surgimento da ES2015. CommonJS \\xE9 s\\xEDncrono enquanto AMD (Defini\\xE7\\xE3o de M\\xF3dulo Ass\\xEDncrona) \\xE9 obviamente ass\\xEDncrona. O CommonJS foi projetado com o desenvolvimento do lado do servidor em mente, enquanto o AMD, com seu suporte para carregamento ass\\xEDncrono de m\\xF3dulos, \\xE9 mais destinado a navegadores.\"}),`\n`,(0,a.jsx)(e.p,{children:\"A sintaxe do AMD pode ser bastante verbosa, enquanto o CommonJS \\xE9 mais pr\\xF3ximo do estilo que voc\\xEA usaria em outras linguagens para escrever declara\\xE7\\xF5es de importa\\xE7\\xE3o (import statements). Na maioria das vezes, o AMD \\xE9 desnecess\\xE1rio, porque se voc\\xEA servir todo o seu JavaScript em um \\xFAnico arquivo de pacote concatenado, n\\xE3o se beneficiar\\xE1 das propriedades de carregamento ass\\xEDncrono. Al\\xE9m disso, a sintaxe do CommonJS \\xE9 mais pr\\xF3xima do estilo de escrita/importa\\xE7\\xE3o de m\\xF3dulos do Node.js e h\\xE1 menos sobrecarga de troca de contexto ao alternar entre o desenvolvimento JavaScript do lado do cliente e do servidor.\"}),`\n`,(0,a.jsx)(e.p,{children:\"O padr\\xE3o futuro, ES modules (ESM), tem suporte tanto para carregamento s\\xEDncrono quanto ass\\xEDncrono e \\xE9 suportado tanto por navegadores quanto por runtimes do lado do servidor. Finalmente, podemos apenas aderir a uma abordagem (exceto em aplicativos legados).\"})]})}function u(o={}){let{wrapper:e}=o.components||{};return e?(0,a.jsx)(e,{...o,children:(0,a.jsx)(c,{...o})}):c(o)}return M(D);})();\n;return Component;"
}