{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "What is async/await and how does it simplify asynchronous code?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-is-asyncawait-and-how-does-it-simplify-asynchronous-code/en-US.mdx"
  },
  "solution": "var Component=(()=>{var l=Object.create;var t=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var f=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),w=(o,e)=>{for(var a in e)t(o,a,{get:e[a],enumerable:!0})},i=(o,e,a,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!m.call(o,r)&&r!==a&&t(o,r,{get:()=>e[r],enumerable:!(c=p(e,r))||c.enumerable});return o};var g=(o,e,a)=>(a=o!=null?l(y(o)):{},i(e||!o||!o.__esModule?t(a,\"default\",{value:o,enumerable:!0}):a,o)),j=o=>i(t({},\"__esModule\",{value:!0}),o);var h=f((E,s)=>{s.exports=_jsx_runtime});var b={};w(b,{default:()=>x,frontmatter:()=>v});var n=g(h()),v={title:\"What is async/await and how does it simplify asynchronous code?\"};function d(o){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\",hr:\"hr\",h3:\"h3\",h4:\"h4\",ul:\"ul\",li:\"li\",a:\"a\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"async/await\"}),\" is a modern syntax in JavaScript that simplifies working with promises. By using the \",(0,n.jsx)(e.code,{children:\"async\"}),\" keyword before a function, you can use the \",(0,n.jsx)(e.code,{children:\"await\"}),\" keyword inside that function to pause execution until a promise is resolved. This makes asynchronous code look and behave more like synchronous code, making it easier to read and maintain.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function fetchData() {\n  try {\n    const response = await fetch(\n      'https://jsonplaceholder.typicode.com/posts/1',\n    );\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n}\nfetchData();\n`})}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"What is async/await and how does it simplify asynchronous code?\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Introduction to async/await\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"async/await\"}),\" is a feature introduced in ECMAScript 2017 (ES8) that allows you to write asynchronous code in a more synchronous-looking manner. It is built on top of promises and provides a cleaner and more readable way to handle asynchronous operations.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Using the \",(0,n.jsx)(e.code,{children:\"async\"}),\" keyword\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"async\"}),\" keyword is used to declare an asynchronous function. When a function is declared as \",(0,n.jsx)(e.code,{children:\"async\"}),\", it automatically returns a promise. This means you can use the \",(0,n.jsx)(e.code,{children:\"await\"}),\" keyword inside it to pause the execution of the function until a promise is resolved.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function exampleFunction() {\n  return 'Hello, World!';\n}\n\nexampleFunction().then(console.log); // Output: Hello, World!\n`})}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Using the \",(0,n.jsx)(e.code,{children:\"await\"}),\" keyword\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"await\"}),\" keyword can only be used inside an \",(0,n.jsx)(e.code,{children:\"async\"}),\" function. It pauses the execution of the function until the promise is resolved, and then returns the resolved value. If the promise is rejected, it throws an error, which can be caught using a \",(0,n.jsx)(e.code,{children:\"try...catch\"}),\" block.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function fetchData() {\n  try {\n    const response = await fetch(\n      'https://jsonplaceholder.typicode.com/posts/1',\n    );\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n}\nfetchData();\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Simplifying asynchronous code\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Before \",(0,n.jsx)(e.code,{children:\"async/await\"}),\", handling asynchronous operations often involved chaining multiple \",(0,n.jsx)(e.code,{children:\".then()\"}),' calls, which could lead to \"callback hell\" or \"pyramid of doom.\" ',(0,n.jsx)(e.code,{children:\"async/await\"}),\" flattens this structure, making the code more readable and easier to maintain.\"]}),`\n`,(0,n.jsx)(e.h4,{children:\"Example with promises\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('https://jsonplaceholder.typicode.com/posts/1')\n  .then((response) => response.json())\n  .then((data) => {\n    console.log(data);\n  })\n  .catch((error) => {\n    console.error('Error fetching data:', error);\n  });\n`})}),`\n`,(0,n.jsx)(e.h4,{children:\"Example with async/await\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function fetchData() {\n  try {\n    const response = await fetch(\n      'https://jsonplaceholder.typicode.com/posts/1',\n    );\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n}\nfetchData();\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Error handling\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Error handling with \",(0,n.jsx)(e.code,{children:\"async/await\"}),\" is more straightforward compared to promises. You can use \",(0,n.jsx)(e.code,{children:\"try...catch\"}),\" blocks to handle errors, making the code cleaner and more intuitive.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`async function fetchData() {\n  try {\n    const response = await fetch('https://jsonplaceholder.typicod.com/posts/1'); // Typo in URL\n    const data = await response.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n}\nfetchData();\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\",children:\"MDN Web Docs: async function\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await\",children:\"MDN Web Docs: await\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/async-await\",children:\"JavaScript.info: Async/await\"})}),`\n`]})]})}function k(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(d,o)})):d(o)}var x=k;return j(b);})();\n;return Component;"
}