{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-is-css-selector-specificity-and-how-does-it-work",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 1,
    "similarQuestions": [],
    "slug": "what-is-css-selector-specificity-and-how-does-it-work",
    "subtitle": null,
    "title": "What is CSS selector specificity and how does it work?",
    "topics": [
      "css"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/front-end-interview-handbook/blob/main/packages/quiz/questions/what-is-css-selector-specificity-and-how-does-it-work/en-US.mdx"
  },
  "solution": "var Component=(()=>{var p=Object.create;var r=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),S=(i,e)=>{for(var n in e)r(i,n,{get:e[n],enumerable:!0})},s=(i,e,n,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of u(e))!g.call(i,c)&&c!==n&&r(i,c,{get:()=>e[c],enumerable:!(o=m(e,c))||o.enumerable});return i};var w=(i,e,n)=>(n=i!=null?p(f(i)):{},s(e||!i||!i.__esModule?r(n,\"default\",{value:i,enumerable:!0}):n,i)),b=i=>s(r({},\"__esModule\",{value:!0}),i);var h=y((x,l)=>{l.exports=_jsx_runtime});var C={};S(C,{default:()=>d,frontmatter:()=>v});var t=w(h()),v={title:\"What is CSS selector specificity and how does it work?\"};function a(i){let e={a:\"a\",code:\"code\",h2:\"h2\",li:\"li\",ol:\"ol\",p:\"p\",strong:\"strong\",ul:\"ul\",...i.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.p,{children:[\"When multiple CSS rules could apply to the same HTML element, the browser needs a way to decide which rule takes precedence. This is determined by the \",(0,t.jsx)(e.strong,{children:\"CSS cascade\"}),\", which considers importance, inline styles, selector specificity, and source order. \",(0,t.jsx)(e.strong,{children:\"Selector specificity\"}),\" is a key part of this process, calculating a weight for each selector.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"The browser determines what styles to show on an element depending on the \",(0,t.jsx)(e.strong,{children:\"specificity\"}),\" of the CSS rules that match it. Specificity is calculated for each rule to decide which one takes precedence.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"How is specificity computed?\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"The specificity algorithm is basically a three-column value of three categories or weights - ID, CLASS, and TYPE - corresponding to the three types of selectors. The value represents the count of selector components in each weight category and is written as \",(0,t.jsx)(e.code,{children:\"ID - CLASS - TYPE\"}),\". The three columns are created by counting the number of selector components for each selector weight category in the selectors that match the element.\"]}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"ID\"}),\": This is the count of ID selectors (e.g., \",(0,t.jsx)(e.code,{children:\"#example\"}),\").\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"CLASS\"}),\": This is the count of class selectors (e.g., \",(0,t.jsx)(e.code,{children:\".my-class\"}),\"), attribute selectors (e.g., \",(0,t.jsx)(e.code,{children:'[type=\"radio\"]'}),\"), and pseudo-classes (e.g., \",(0,t.jsx)(e.code,{children:\":hover\"}),\").\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"TYPE\"}),\": This is the count of type selectors (element names, e.g., \",(0,t.jsx)(e.code,{children:\"h1\"}),\", \",(0,t.jsx)(e.code,{children:\"div\"}),\") and pseudo-elements (e.g., \",(0,t.jsx)(e.code,{children:\"::before\"}),\").\"]}),`\n`]}),`\n`,(0,t.jsxs)(e.p,{children:[\"When comparing selectors to determine which has the highest specificity, look from left to right (ID, then CLASS, then TYPE), and compare the highest value in each column. A value in the ID column will override values in the CLASS and TYPE columns, no matter how large they are. Similarly, a value in the CLASS column overrides any value in the TYPE column. For example, a specificity of \",(0,t.jsx)(e.code,{children:\"1,0,0\"}),\" (one ID) is greater than \",(0,t.jsx)(e.code,{children:\"0,10,10\"}),\" (ten classes and ten types).\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"It's important to remember that specificity is part of the broader \",(0,t.jsx)(e.strong,{children:\"CSS cascade\"}),\". Declarations marked \",(0,t.jsx)(e.code,{children:\"!important\"}),\" have the highest precedence, followed by inline styles (using the \",(0,t.jsx)(e.code,{children:\"style\"}),\" attribute). Selector specificity comes next.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"In cases of \",(0,t.jsx)(e.strong,{children:\"equal specificity\"}),\" among competing rules (that aren't inline or \",(0,t.jsx)(e.code,{children:\"!important\"}),\"), the rule that appears \",(0,t.jsx)(e.strong,{children:\"last\"}),\" in the CSS source order is the one that counts and will be applied.\"]}),`\n`,(0,t.jsxs)(e.p,{children:[\"It's a better practice to write CSS rules with low specificity so that they can be easily overridden if necessary. When writing CSS for UI component libraries, it is important that styles have low specificities so that users of the library can customize them without needing overly complex selectors or resorting to \",(0,t.jsx)(e.code,{children:\"!important\"}),\".\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"References\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascade/Specificity\",children:\"Specificity | MDN\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://web.dev/learn/css/specificity\",children:\"Specificity | web.dev\"})}),`\n`]})]})}function d(i={}){let{wrapper:e}=i.components||{};return e?(0,t.jsx)(e,{...i,children:(0,t.jsx)(a,{...i})}):a(i)}return b(C);})();\n;return Component;"
}