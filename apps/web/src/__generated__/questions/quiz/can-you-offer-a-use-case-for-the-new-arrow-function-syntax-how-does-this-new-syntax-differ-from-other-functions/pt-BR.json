{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/can-you-offer-a-use-case-for-the-new-arrow-function-syntax-how-does-this-new-syntax-differ-from-other-functions",
    "importance": "medium",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 999,
    "similarQuestions": [],
    "slug": "can-you-offer-a-use-case-for-the-new-arrow-function-syntax-how-does-this-new-syntax-differ-from-other-functions",
    "subtitle": "Como essa nova sintaxe difere de outras funções?",
    "title": "Você pode oferecer um caso de uso para a nova sintaxe de arrow function =>?",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/can-you-offer-a-use-case-for-the-new-arrow-function-syntax-how-does-this-new-syntax-differ-from-other-functions/pt-BR.mdx"
  },
  "solution": "var Component=(()=>{var u=Object.create;var r=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var h=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),v=(o,e)=>{for(var s in e)r(o,s,{get:e[s],enumerable:!0})},i=(o,e,s,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of h(e))!f.call(o,a)&&a!==s&&r(o,a,{get:()=>e[a],enumerable:!(d=m(e,a))||d.enumerable});return o};var b=(o,e,s)=>(s=o!=null?u(p(o)):{},i(e||!o||!o.__esModule?r(s,\"default\",{value:o,enumerable:!0}):s,o)),x=o=>i(r({},\"__esModule\",{value:!0}),o);var t=g((_,c)=>{c.exports=_jsx_runtime});var C={};v(C,{default:()=>S,frontmatter:()=>j});var n=b(t()),j={title:\"Voc\\xEA pode oferecer um caso de uso para a nova sintaxe de arrow function =>?\",subtitle:\"Como essa nova sintaxe difere de outras fun\\xE7\\xF5es?\"};function l(o){let e=Object.assign({p:\"p\",code:\"code\",h2:\"h2\",h3:\"h3\",pre:\"pre\",ol:\"ol\",li:\"li\",strong:\"strong\",ul:\"ul\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"A sintaxe de fun\\xE7\\xE3o \",(0,n.jsx)(e.code,{children:\"=>\"}),', tamb\\xE9m conhecida como \"fun\\xE7\\xF5es de seta\", \\xE9 um recurso introduzido no ECMAScript 6 (ES6) para o JavaScript. Ela fornece uma maneira mais concisa de escrever fun\\xE7\\xF5es e tamb\\xE9m apresenta algumas diferen\\xE7as em rela\\xE7\\xE3o ao comportamento do ',(0,n.jsx)(e.code,{children:\"this\"}),\" em compara\\xE7\\xE3o com express\\xF5es de fun\\xE7\\xE3o tradicionais. Aqui est\\xE1 um caso de uso simples para ilustrar sua utilidade:\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Caso de Uso: filtrando um array\"}),`\n`,(0,n.jsx)(e.p,{children:\"Imagine que voc\\xEA tenha um array de n\\xFAmeros e queira filtrar todos os n\\xFAmeros menores que 10. Usando a sintaxe de fun\\xE7\\xE3o tradicional e a nova sintaxe de fun\\xE7\\xE3o de seta, voc\\xEA pode realizar isso das seguintes maneiras:\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Sintaxe de fun\\xE7\\xE3o tradicional\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const numbers = [1, 5, 10, 15, 20];\nconst numbersFiltrados = numbers.filter(function (number) {\n  return number >= 10;\n});\n\nconsole.log(numbersFiltrados); // Sa\\xEDda: [10, 15, 20]\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Sintaxe de fun\\xE7\\xE3o de seta\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const numbers = [1, 5, 10, 15, 20];\nconst numbersFiltrados = numbers.filter((number) => number >= 10);\n\nconsole.log(numbersFiltrados); // Sa\\xEDda: [10, 15, 20]\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Vantagens das fun\\xE7\\xF5es de seta\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Concis\\xE3o\"}),\": As fun\\xE7\\xF5es de seta s\\xE3o mais concisas, tornando seu c\\xF3digo mais curto e mais f\\xE1cil de ler.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsxs)(e.strong,{children:[\"Comportamento do \",(0,n.jsx)(e.code,{children:\"this\"})]}),\": As fun\\xE7\\xF5es de seta n\\xE3o possuem seu pr\\xF3prio \",(0,n.jsx)(e.code,{children:\"this\"}),\". Em vez disso, elas herdam o \",(0,n.jsx)(e.code,{children:\"this\"}),\" do escopo pai no momento em que s\\xE3o definidas. Isso \\xE9 particularmente \\xFAtil em cen\\xE1rios em que voc\\xEA est\\xE1 lidando com callbacks e deseja manter o contexto do \",(0,n.jsx)(e.code,{children:\"this\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Retorno Impl\\xEDcito\"}),\": Se o corpo da fun\\xE7\\xE3o consistir em uma \\xFAnica express\\xE3o, as fun\\xE7\\xF5es de seta permitem omitir a palavra-chave \",(0,n.jsx)(e.code,{children:\"return\"}),\" e as chaves.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Quando usar fun\\xE7\\xF5es de seta\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Quando voc\\xEA precisa de uma fun\\xE7\\xE3o r\\xE1pida de uma \\xFAnica linha.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Em fun\\xE7\\xF5es de retorno de chamada (callbacks) onde voc\\xEA deseja preservar o escopo l\\xE9xico do \",(0,n.jsx)(e.code,{children:\"this\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Ao trabalhar com fun\\xE7\\xF5es de ordem superior como \",(0,n.jsx)(e.code,{children:\"map\"}),\", \",(0,n.jsx)(e.code,{children:\"filter\"}),\", \",(0,n.jsx)(e.code,{children:\"reduce\"}),\", etc.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Quando n\\xE3o usar fun\\xE7\\xF5es de seta\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"M\\xE9todos em objetos\"}),\": As fun\\xE7\\xF5es de seta n\\xE3o t\\xEAm seu pr\\xF3prio contexto \",(0,n.jsx)(e.code,{children:\"this\"}),\", o que pode levar a comportamentos inesperados em m\\xE9todos de objetos.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Como construtores\"}),\": As fun\\xE7\\xF5es de seta n\\xE3o podem ser usadas como construtores e gerar\\xE3o um erro se usadas com a palavra-chave \",(0,n.jsx)(e.code,{children:\"new\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Quando voc\\xEA precisa de hoisting de fun\\xE7\\xE3o\"}),\": As fun\\xE7\\xF5es de seta n\\xE3o s\\xE3o i\\xE7adas (hoisted), ao contr\\xE1rio das declara\\xE7\\xF5es de fun\\xE7\\xE3o tradicionais.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"As fun\\xE7\\xF5es de seta s\\xE3o uma adi\\xE7\\xE3o poderosa ao JavaScript, simplificando a sintaxe das fun\\xE7\\xF5es e abordando algumas armadilhas comuns associadas \\xE0 palavra-chave \",(0,n.jsx)(e.code,{children:\"this\"}),\" em fun\\xE7\\xF5es tradicionais. Elas s\\xE3o especialmente \\xFAteis nos padr\\xF5es de desenvolvimento JavaScript modernos.\"]})]})}function A(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(l,o)})):l(o)}var S=A;return x(C);})();\n;return Component;"
}