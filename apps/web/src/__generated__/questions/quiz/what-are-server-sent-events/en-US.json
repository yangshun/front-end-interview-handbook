{
  "description": null,
  "format": "quiz",
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-server-sent-events",
    "importance": "medium",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 440,
    "similarQuestions": [],
    "slug": "what-are-server-sent-events",
    "subtitle": null,
    "title": "What are server-sent events?",
    "topics": [
      "javascript",
      "networking"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-server-sent-events/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var v=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),S=(t,e)=>{for(var r in e)i(t,r,{get:e[r],enumerable:!0})},a=(t,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of p(e))!u.call(t,s)&&s!==r&&i(t,s,{get:()=>e[s],enumerable:!(o=v(e,s))||o.enumerable});return t};var f=(t,e,r)=>(r=t!=null?h(m(t)):{},a(e||!t||!t.__esModule?i(r,\"default\",{value:t,enumerable:!0}):r,t)),w=t=>a(i({},\"__esModule\",{value:!0}),t);var l=g((j,c)=>{c.exports=_jsx_runtime});var T={};S(T,{default:()=>E,frontmatter:()=>b});var n=f(l()),b={title:\"What are server-sent events?\"};function d(t){let e=Object.assign({h2:\"h2\",p:\"p\",a:\"a\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",strong:\"strong\",pre:\"pre\",hr:\"hr\",ol:\"ol\",li:\"li\",ul:\"ul\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.a,{href:\"https://html.spec.whatwg.org/multipage/comms.html#the-eventsource-interface\",children:\"Server-sent events (SSE)\"}),\" is a standard that allows a web page to receive automatic updates from a server via an HTTP connection. Server-sent events are used with \",(0,n.jsx)(e.code,{children:\"EventSource\"}),\" instances that opens a connection with a server and allows client to receive events from the server. Connections created by server-sent events are persistent (similar to the \",(0,n.jsx)(e.code,{children:\"WebSocket\"}),\"s), however there are a few differences:\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Property\"}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"WebSocket\"})}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"EventSource\"})})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Direction\"}),(0,n.jsx)(e.td,{children:\"Bi-directional \\u2013 both client and server can exchange messages\"}),(0,n.jsx)(e.td,{children:\"Unidirectional \\u2013 only server sends data\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Data type\"}),(0,n.jsx)(e.td,{children:\"Binary and text data\"}),(0,n.jsx)(e.td,{children:\"Only text\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Protocol\"}),(0,n.jsxs)(e.td,{children:[\"WebSocket protocol (\",(0,n.jsx)(e.code,{children:\"ws://\"}),\")\"]}),(0,n.jsxs)(e.td,{children:[\"Regular HTTP (\",(0,n.jsx)(e.code,{children:\"http://\"}),\")\"]})]})]})]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"Creating an event source\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const eventSource = new EventSource('/sse-stream');\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"Listening for events\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Fired when the connection is established.\neventSource.addEventListener('open', () => {\n  console.log('Connection opened');\n});\n\n// Fired when a message is received from the server.\neventSource.addEventListener('message', (event) => {\n  console.log('Received message:', event.data);\n});\n\n// Fired when an error occurs.\neventSource.addEventListener('error', (error) => {\n  console.error('Error occurred:', error);\n});\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"Sending events from server\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const express = require('express');\nconst app = express();\n\napp.get('/sse-stream', (req, res) => {\n  // \\`Content-Type\\` need to be set to \\`text/event-stream\\`.\n  res.setHeader('Content-Type', 'text/event-stream');\n  res.setHeader('Cache-Control', 'no-cache');\n  res.setHeader('Connection', 'keep-alive');\n\n  // Each message should be prefixed with data.\n  const sendEvent = (data) => res.write(\\`data: \\${data}\\\\n\\\\n\\`);\n\n  sendEvent('Hello from server');\n\n  const intervalId = setInterval(() => sendEvent(new Date().toString()), 1000);\n\n  res.on('close', () => {\n    console.log('Client closed connection');\n    clearInterval(intervalId);\n  });\n});\n\napp.listen(3000, () => console.log('Server started on port 3000'));\n`})}),`\n`,(0,n.jsx)(e.p,{children:'In this example, the server sends a \"Hello from server\" message initially, and then sends the current date every second. The connection is kept alive until the client closes it'}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Server-sent events (SSE)\"}),`\n`,(0,n.jsx)(e.p,{children:\"Server-sent events (SSE) is a standard that allows a server to push updates to a web client over a single, long-lived HTTP connection. It enables real-time updates without the client having to constantly poll the server for new data.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"How SSE works\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The client creates a new \",(0,n.jsx)(e.code,{children:\"EventSource\"}),\" object, passing the URL of the \",(0,n.jsx)(e.code,{children:\"server-side\"}),\" script that will generate the event stream:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const eventSource = new EventSource('/event-stream');\n`})}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The server-side script sets the appropriate headers to indicate that it will be sending an event stream (\",(0,n.jsx)(e.code,{children:\"Content-Type: text/event-stream\"}),\"), and then starts sending events to the client.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"Each event sent by the server follows a specific format, with fields like \",(0,n.jsx)(e.code,{children:\"event\"}),\", \",(0,n.jsx)(e.code,{children:\"data\"}),\", and \",(0,n.jsx)(e.code,{children:\"id\"}),\". For example:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`event: message\ndata: Hello, world!\n\nevent: update\nid: 123\ndata: {\"temperature\": 25, \"humidity\": 60}\n`})}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"On the client-side, the \",(0,n.jsx)(e.code,{children:\"EventSource\"}),\" object receives these events and dispatches them as browser events, which can be handled using event listeners or the \",(0,n.jsx)(e.code,{children:\"onmessage\"}),\" event handler:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`eventSource.onmessage = function (event) {\n  console.log('Received message:', event.data);\n};\n\neventSource.addEventListener('update', function (event) {\n  console.log('Received update:', JSON.parse(event.data));\n});\n`})}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"EventSource\"}),\" object automatically handles reconnection if the connection is lost, and it can resume the event stream from the last received event ID using the \",(0,n.jsx)(e.code,{children:\"Last-Event-ID HTTP header\"}),\".\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"SSE features\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Unidirectional\"}),\": Only the server can send data to the client. For bidirectional communication, web sockets would be more appropriate.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Retry mechanism\"}),\": The client will retry the connection if it fails, with the retry interval specified by the \",(0,n.jsx)(e.code,{children:\"retry:\"}),\" field from the server.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Text-only data\"}),\": SSE can only transmit text data, which means binary data needs to be encoded (e.g., Base64) before transmission. This can lead to increased overhead and inefficiency for applications that need to transmit large binary payloads.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Built-in browser support\"}),\": Supported by most modern browsers without additional libraries.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Event types\"}),\": SSE supports custom event types using the \",(0,n.jsx)(e.code,{children:\"event:\"}),\" field, allowing categorization of messages.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.code,{children:\"Last-Event-Id\"})}),\": The client sends the \",(0,n.jsx)(e.code,{children:\"Last-Event-Id\"}),\" header when reconnecting, allowing the server to resume the stream from the last received event. However, there is no built-in mechanism to replay missed events during the disconnection period. You may need to implement a mechanism to handle missed events, such as using the \",(0,n.jsx)(e.code,{children:\"Last-Event-Id\"}),\" header.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Connection limitations\"}),\": Browsers have a limit on the maximum number of concurrent SSE connections, typically around 6 per domain. This can be a bottleneck if you need to establish multiple SSE connections from the same client. Using HTTP/2 will mitigate this issue.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Implementing SSE in JavaScript\"}),`\n`,(0,n.jsx)(e.p,{children:\"The following code demonstrates a minimal implementation of SSE on the client and the server:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"The server sets the appropriate headers to establish an SSE connection.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Messages are sent to the client every 5 seconds.\"}),`\n`,(0,n.jsx)(e.li,{children:\"The server cleans up the interval and ends the response when the client disconnects.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"On the client:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Create a new EventSource object\nconst eventSource = new EventSource('/sse');\n\n// Event listener for receiving messages\neventSource.onmessage = function (event) {\n  console.log('New message:', event.data);\n};\n\n// Event listener for errors\neventSource.onerror = function (error) {\n  console.error('Error occurred:', error);\n};\n\n// Optional: Event listener for open connection\neventSource.onopen = function () {\n  console.log('Connection opened');\n};\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"On the server:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const http = require('http');\n\nhttp\n  .createServer((req, res) => {\n    if (req.url === '/sse') {\n      // Set headers for SSE\n      res.writeHead(200, {\n        'Content-Type': 'text/event-stream',\n        'Cache-Control': 'no-cache',\n        Connection: 'keep-alive',\n      });\n\n      // Function to send a message\n      const sendMessage = (message) => {\n        res.write(\\`data: \\${message}\\\\n\\\\n\\`); // Messages are delimited with double line breaks.\n      };\n\n      // Send a message every 5 seconds\n      const intervalId = setInterval(() => {\n        sendMessage(\\`Current time: \\${new Date().toLocaleTimeString()}\\`);\n      }, 5000);\n\n      // Handle client disconnect\n      req.on('close', () => {\n        clearInterval(intervalId);\n        res.end();\n      });\n    } else {\n      res.writeHead(404);\n      res.end();\n    }\n  })\n  .listen(8080, () => {\n    console.log('SSE server running on port 8080');\n  });\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Summary\"}),`\n`,(0,n.jsx)(e.p,{children:\"Server-sent events provide an efficient and straightforward way to push updates from a server to a client in real-time. They are particularly well-suited for applications that require continuous data streams but do not need full bidirectional communication. With built-in support in modern browsers, SSE is a reliable choice for many real-time web applications.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events\",children:\"Using server-sent events - MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/server-sent-events\",children:\"Server-sent Events - javascript.info\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://ably.com/topic/server-sent-events\",children:\"Server-sent Events: A WebSockets alternative ready for another look\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://bunny.net/academy/http/what-is-sse-server-sent-events-and-how-do-they-work/\",children:\"What are SSE (Server-Sent Events) and how do they work?\"})}),`\n`]})]})}function y(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var E=y;return w(T);})();\n;return Component;"
}