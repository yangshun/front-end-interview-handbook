{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": "react",
    "frameworks": [
      {
        "framework": "react",
        "href": "/questions/quiz/how-does-virtual-dom-in-react-work-what-are-its-benefits-and-downsides/react"
      }
    ],
    "href": "/questions/quiz/how-does-virtual-dom-in-react-work-what-are-its-benefits-and-downsides",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 460,
    "similarQuestions": [],
    "slug": "how-does-virtual-dom-in-react-work-what-are-its-benefits-and-downsides",
    "subtitle": null,
    "title": "How does virtual DOM in React work? What are its benefits and downsides?",
    "topics": [
      "react"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-reactjs-interview-questions/blob/main/questions/how-does-virtual-dom-in-react-work-what-are-its-benefits-and-downsides/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var i in e)a(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!f.call(t,r)&&r!==i&&a(t,r,{get:()=>e[r],enumerable:!(o=p(e,r))||o.enumerable});return t};var w=(t,e,i)=>(i=t!=null?d(m(t)):{},c(e||!t||!t.__esModule?a(i,\"default\",{value:t,enumerable:!0}):i,t)),D=t=>c(a({},\"__esModule\",{value:!0}),t);var l=g((x,h)=>{h.exports=_jsx_runtime});var b={};v(b,{default:()=>y,frontmatter:()=>M});var n=w(l()),M={title:\"How does virtual DOM in React work? What are its benefits and downsides?\"};function s(t){let e=Object.assign({h2:\"h2\",p:\"p\",hr:\"hr\",h3:\"h3\",ol:\"ol\",li:\"li\",strong:\"strong\",pre:\"pre\",code:\"code\",ul:\"ul\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:'The virtual DOM in React is a lightweight copy of the actual DOM. When the state of a component changes, React creates a new virtual DOM tree and compares it with the previous one using a process called \"reconciliation.\" Only the differences are then updated in the actual DOM, making updates more efficient. The benefits include improved performance and a more declarative way to manage UI. However, it can add complexity and may not be as performant for very simple applications.'}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"How does virtual DOM in React work?\"}),`\n`,(0,n.jsx)(e.h3,{children:\"What is the virtual DOM?\"}),`\n`,(0,n.jsx)(e.p,{children:'The virtual DOM is a concept where a virtual representation of the UI is kept in memory and synced with the real DOM by a library such as React. This process is called \"reconciliation.\"'}),`\n`,(0,n.jsx)(e.h3,{children:\"How does it work?\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Initial render\"}),\": When a React component is first rendered, a virtual DOM tree is created. This tree is a lightweight copy of the actual DOM.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"State change\"}),\": When the state of a component changes, React creates a new virtual DOM tree.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Diffing\"}),': React compares the new virtual DOM tree with the previous one to find the differences. This process is known as \"diffing.\"']}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Reconciliation\"}),\": React updates only the parts of the actual DOM that have changed, based on the differences found during the diffing process.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Code example\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>{this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this example, when the button is clicked, the state changes, triggering a new virtual DOM tree to be created. React then compares this new tree with the previous one and updates only the \",(0,n.jsx)(e.code,{children:\"<p>\"}),\" element in the actual DOM.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Benefits of virtual DOM\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Improved performance\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Efficient updates\"}),\": By updating only the parts of the DOM that have changed, React minimizes the number of costly DOM operations.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Batch updates\"}),\": React can batch multiple updates together, reducing the number of re-renders.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Declarative UI\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Simplified development\"}),\": Developers can describe what the UI should look like for a given state, and React takes care of updating the DOM to match that state.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Cross-platform\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"React Native\"}),\": The virtual DOM concept allows React to be used for mobile app development with React Native, providing a consistent development experience across platforms.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Downsides of virtual DOM\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Complexity\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Learning curve\"}),\": Understanding how the virtual DOM works and how to optimize components can be challenging for beginners.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Overhead\"}),\": For very simple applications, the overhead of maintaining a virtual DOM may not be justified.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Performance limitations\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Not a silver bullet\"}),\": While the virtual DOM improves performance for many use cases, it may not be as performant as manual DOM manipulation for very specific, highly optimized scenarios.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://reactjs.org/docs/reconciliation.html\",children:\"React documentation on reconciliation\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060\",children:\"Understanding the virtual DOM\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://reactjs.org/docs/optimizing-performance.html\",children:\"React performance optimization\"})}),`\n`]})]})}function O(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(s,t)})):s(t)}var y=O;return D(b);})();\n;return Component;"
}