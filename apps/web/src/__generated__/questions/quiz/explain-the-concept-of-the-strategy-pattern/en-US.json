{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "easy",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/explain-the-concept-of-the-strategy-pattern",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 999,
    "similarQuestions": [],
    "slug": "explain-the-concept-of-the-strategy-pattern",
    "subtitle": null,
    "title": "Explain the concept of the Strategy pattern",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/explain-the-concept-of-the-strategy-pattern/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var p=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),f=(n,e)=>{for(var a in e)i(n,a,{get:e[a],enumerable:!0})},s=(n,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!y.call(n,r)&&r!==a&&i(n,r,{get:()=>e[r],enumerable:!(o=g(e,r))||o.enumerable});return n};var x=(n,e,a)=>(a=n!=null?d(u(n)):{},s(e||!n||!n.__esModule?i(a,\"default\",{value:n,enumerable:!0}):a,n)),S=n=>s(i({},\"__esModule\",{value:!0}),n);var l=p((j,c)=>{c.exports=_jsx_runtime});var A={};f(A,{default:()=>b,frontmatter:()=>w});var t=x(l()),w={title:\"Explain the concept of the Strategy pattern\"};function h(n){let e=Object.assign({h2:\"h2\",p:\"p\",pre:\"pre\",code:\"code\",hr:\"hr\",h3:\"h3\",ol:\"ol\",li:\"li\",strong:\"strong\",ul:\"ul\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,t.jsx)(e.p,{children:\"The Strategy pattern is a behavioral design pattern that allows you to define a family of algorithms, encapsulate each one as a separate class, and make them interchangeable. This pattern lets the algorithm vary independently from the clients that use it. For example, if you have different sorting algorithms, you can define each one as a strategy and switch between them without changing the client code.\"}),`\n`,(0,t.jsx)(e.pre,{live:!0,children:(0,t.jsx)(e.code,{className:\"language-js\",children:`class Context {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeStrategy(data) {\n    return this.strategy.doAlgorithm(data);\n  }\n}\n\nclass ConcreteStrategyA {\n  doAlgorithm(data) {\n    // Implementation of algorithm A\n    return 'Algorithm A was run on ' + data;\n  }\n}\n\nclass ConcreteStrategyB {\n  doAlgorithm(data) {\n    // Implementation of algorithm B\n    return 'Algorithm B was run on ' + data;\n  }\n}\n\n// Usage\nconst context = new Context(new ConcreteStrategyA());\ncontext.executeStrategy('someData'); // Output: Algorithm A was run on someData\n`})}),`\n`,(0,t.jsx)(e.hr,{}),`\n`,(0,t.jsx)(e.h2,{children:\"The Strategy pattern\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Definition\"}),`\n`,(0,t.jsx)(e.p,{children:\"The Strategy pattern is a behavioral design pattern that enables selecting an algorithm's behavior at runtime. It defines a family of algorithms, encapsulates each one, and makes them interchangeable. This pattern allows the algorithm to vary independently from the clients that use it.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Components\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Context\"}),\": Maintains a reference to a \",(0,t.jsx)(e.code,{children:\"Strategy\"}),\" object and is configured with a \",(0,t.jsx)(e.code,{children:\"ConcreteStrategy\"}),\" object.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Strategy\"}),\": An interface common to all supported algorithms. The \",(0,t.jsx)(e.code,{children:\"Context\"}),\" uses this interface to call the algorithm defined by a \",(0,t.jsx)(e.code,{children:\"ConcreteStrategy\"}),\".\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"ConcreteStrategy\"}),\": Implements the \",(0,t.jsx)(e.code,{children:\"Strategy\"}),\" interface to provide a specific algorithm.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Example\"}),`\n`,(0,t.jsx)(e.p,{children:\"Consider a scenario where you have different sorting algorithms and you want to switch between them without changing the client code.\"}),`\n`,(0,t.jsx)(e.pre,{live:!0,children:(0,t.jsx)(e.code,{className:\"language-js\",children:`// Strategy interface\nclass Strategy {\n  doAlgorithm(data) {\n    throw new Error('This method should be overridden!');\n  }\n}\n\n// ConcreteStrategyA\nclass ConcreteStrategyA extends Strategy {\n  doAlgorithm(data) {\n    return data.sort((a, b) => a - b); // Example: ascending sort\n  }\n}\n\n// ConcreteStrategyB\nclass ConcreteStrategyB extends Strategy {\n  doAlgorithm(data) {\n    return data.sort((a, b) => b - a); // Example: descending sort\n  }\n}\n\n// Context\nclass Context {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n\n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n\n  executeStrategy(data) {\n    return this.strategy.doAlgorithm(data);\n  }\n}\n\n// Usage\nconst data = [3, 1, 4, 1, 5, 9];\nconst context = new Context(new ConcreteStrategyA());\nconsole.log(context.executeStrategy([...data])); // Output: [1, 1, 3, 4, 5, 9]\n\ncontext.setStrategy(new ConcreteStrategyB());\nconsole.log(context.executeStrategy([...data])); // Output: [9, 5, 4, 3, 1, 1]\n`})}),`\n`,(0,t.jsx)(e.h3,{children:\"Benefits\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Flexibility\"}),\": You can change the algorithm at runtime.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Maintainability\"}),\": Adding new strategies does not affect existing code.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Encapsulation\"}),\": Each algorithm is encapsulated in its own class.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Drawbacks\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Overhead\"}),\": Increased number of classes and objects.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Complexity\"}),\": Can make the system more complex if not used judiciously.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://en.wikipedia.org/wiki/Strategy_pattern\",children:\"Strategy pattern on Wikipedia\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://refactoring.guru/design-patterns/strategy\",children:\"Refactoring Guru: Strategy pattern\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\",children:\"MDN Web Docs: JavaScript classes\"})}),`\n`]})]})}function C(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(h,n)})):h(n)}var b=C;return S(A);})();\n;return Component;"
}