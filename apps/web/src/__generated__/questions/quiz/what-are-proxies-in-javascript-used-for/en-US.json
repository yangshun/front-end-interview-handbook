{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "easy",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-proxies-in-javascript-used-for",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 470,
    "similarQuestions": [],
    "slug": "what-are-proxies-in-javascript-used-for",
    "subtitle": null,
    "title": "What are proxies in JavaScript used for?",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-proxies-in-javascript-used-for/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var m=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var r in e)a(t,r,{get:e[r],enumerable:!0})},s=(t,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!y.call(t,o)&&o!==r&&a(t,o,{get:()=>e[o],enumerable:!(i=h(e,o))||i.enumerable});return t};var b=(t,e,r)=>(r=t!=null?d(u(t)):{},s(e||!t||!t.__esModule?a(r,\"default\",{value:t,enumerable:!0}):r,t)),x=t=>s(a({},\"__esModule\",{value:!0}),t);var l=m((J,c)=>{c.exports=_jsx_runtime});var P={};f(P,{default:()=>w,frontmatter:()=>v});var n=b(l()),v={title:\"What are proxies in JavaScript used for?\"};function p(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\",ul:\"ul\",li:\"li\",strong:\"strong\",hr:\"hr\",h3:\"h3\",h4:\"h4\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:\"In JavaScript, a proxy is an object that acts as an intermediary between an object and the code. Proxies are used to intercept and customize the fundamental operations of JavaScript objects, such as property access, assignment, function invocation, and more.\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here's a basic example of using a \",(0,n.jsx)(e.code,{children:\"Proxy\"}),\" to log every property access:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const myObject = {\n  name: 'John',\n  age: 42,\n};\n\nconst handler = {\n  get: function (target, prop, receiver) {\n    console.log(\\`Someone accessed property \"\\${prop}\"\\`);\n    return target[prop];\n  },\n};\n\nconst proxiedObject = new Proxy(myObject, handler);\n\nconsole.log(proxiedObject.name); // 'John'\n// Someone accessed property \"name\"\n\nconsole.log(proxiedObject.age); // 42\n// Someone accessed property \"age\"\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Use cases include:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Property access interception\"}),\": Intercept and customize property access on an object.\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Property assignment validation\"}),\": Validate property values before they are set on the target object.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Logging and debugging\"}),\": Create wrappers for logging and debugging interactions with an object\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Creating reactive systems\"}),\": Trigger updates in other parts of your application when object properties change (data binding).\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Data transformation\"}),\": Transforming data being set or retrieved from an object.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Mocking and stubbing in tests\"}),\": Create mock or stub objects for testing purposes, allowing you to isolate dependencies and focus on the unit under test\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Function invocation interception\"}),\": Used to cache and return the result of frequently accessed methods if they involve network calls or computationally intensive logic, improving performance\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Dynamic property creation\"}),\": Useful for defining properties on-the-fly with default values and avoid storing redundant data in objects.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"JavaScript proxies\"}),`\n`,(0,n.jsx)(e.p,{children:\"In JavaScript, a proxy is an object that allows you to customize the behavior of another object, often referred to as the target object. Proxies can intercept and redefine various operations for the target object, such as property access, assignment, enumeration, function invocation, and more. This makes proxies a powerful tool for a variety of use cases, including but not limited to validation, logging, performance monitoring, and implementing advanced data structures.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here are some common use cases and examples of how proxies can be used in JavaScript:\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Property access interception\"}),`\n`,(0,n.jsx)(e.p,{children:\"Proxies can be used to intercept and customize property access on an object.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const target = {\n  message: 'Hello, world!',\n};\n\nconst handler = {\n  get: function (target, property) {\n    if (property in target) {\n      return target[property];\n    }\n\n    return \\`Property \\${property} does not exist.\\`;\n  },\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.message); // Hello, world!\nconsole.log(proxy.nonExistentProperty); // Property nonExistentProperty does not exist.\n`})}),`\n`,(0,n.jsx)(e.h4,{children:\"Creating wrappers for logging and debugging\"}),`\n`,(0,n.jsx)(e.p,{children:\"This is useful for creating wrappers for logging and debugging interactions with an object.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const target = {\n  name: 'Alice',\n  age: 30,\n};\n\nconst handler = {\n  get: function (target, property) {\n    console.log(\\`Getting property \\${property}\\`);\n    return target[property];\n  },\n  set: function (target, property, value) {\n    console.log(\\`Setting property \\${property} to \\${value}\\`);\n    target[property] = value;\n    return true;\n  },\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.name); // Output: Getting property name\n//         Alice\nproxy.age = 31; // Output: Setting property age to 31\nconsole.log(proxy.age); // Output: Getting property age\n//         31\n`})}),`\n`,(0,n.jsx)(e.h4,{children:\"Property assignment validation\"}),`\n`,(0,n.jsx)(e.p,{children:\"Proxies can be used to validate property values before they are set on the target object.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const target = {\n  age: 25,\n};\n\nconst handler = {\n  set: function (target, property, value) {\n    if (property === 'age' && typeof value !== 'number') {\n      throw new TypeError('Age must be a number');\n    }\n    target[property] = value;\n    return true;\n  },\n};\n\nconst proxy = new Proxy(target, handler);\n\nproxy.age = 30; // Works fine\nproxy.age = 'thirty'; // Throws TypeError: Age must be a number\n`})}),`\n`,(0,n.jsx)(e.h4,{children:\"Creating reactive systems\"}),`\n`,(0,n.jsx)(e.p,{children:\"Proxies are often used to trigger updates in other parts of your application when object properties change (data binding).\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"A practical example is JavaScript frameworks like \",(0,n.jsx)(e.a,{href:\"https://vuejs.org/\",children:\"Vue.js\"}),\", where proxies are used to \",(0,n.jsx)(e.a,{href:\"https://vuejs.org/guide/extras/reactivity-in-depth.html\",children:\"create reactive systems that automatically update the UI when data changes\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const target = {\n  firstName: 'John',\n  lastName: 'Doe',\n};\n\nconst handler = {\n  set: function (target, property, value) {\n    console.log(\\`Property \\${property} set to \\${value}\\`);\n    target[property] = value;\n    // Automatically update the UI or perform other actions\n    return true;\n  },\n};\n\nconst proxy = new Proxy(target, handler);\n\nproxy.firstName = 'Jane'; // Output: Property firstName set to Jane\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Other use cases for access interception include:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Mocking and stubbing\"}),\": Proxies can be used to create mock or stub objects for testing purposes, allowing you to isolate dependencies and focus on the unit under test.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Function invocation interception\"}),`\n`,(0,n.jsx)(e.p,{children:\"Proxies can intercept and customize function calls.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const target = function (name) {\n  return \\`Hello, \\${name}!\\`;\n};\n\nconst handler = {\n  apply: function (target, thisArg, argumentsList) {\n    console.log(\\`Called with arguments: \\${argumentsList}\\`);\n    return target.apply(thisArg, argumentsList);\n  },\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy('Alice')); // Called with arguments: Alice\n// Hello, Alice!\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This interception can be used to cache and return the result of frequently accessed methods if they involve network calls or computationally intensive logic, improving performance by reducing the number of requests/computations made.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Dynamic property creation\"}),`\n`,(0,n.jsx)(e.p,{children:\"Proxies can be used to dynamically create properties or methods on an object. This is useful for defining properties on-the-fly with default values and avoid storing redundant data in objects.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const target = {};\n\nconst handler = {\n  get: function (target, property) {\n    if (!(property in target)) {\n      target[property] = \\`Dynamic property \\${property}\\`;\n    }\n    return target[property];\n  },\n};\n\nconst proxy = new Proxy(target, handler);\n\nconsole.log(proxy.newProp); // Output: Dynamic property newProp\nconsole.log(proxy.anotherProp); // Output: Dynamic property anotherProp\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Implementing object relational mappers (ORMs)\"}),`\n`,(0,n.jsx)(e.p,{children:\"Proxies can be used to create objects for database records by intercepting property access to lazily load data from the database. This provides a more object-oriented interface to interact with a database.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Real world use cases\"}),`\n`,(0,n.jsx)(e.p,{children:\"Many popular libraries, especially state management solutions, are built on top of JavaScript proxies:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.a,{href:\"https://vuejs.org/\",children:\"Vue.js\"})}),\": Vue.js is a progressive framework for building user interfaces. In Vue 3, proxies are used extensively to implement the reactivity system.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.a,{href:\"https://mobx.js.org/\",children:\"MobX\"})}),\": MobX uses proxies to make objects and arrays observable, allowing components to automatically react to state changes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.a,{href:\"https://immerjs.github.io/\",children:\"Immer\"})}),\": Immer is a library that allows you to work with immutable state in a more convenient way. It uses proxies to track changes and produce the next immutable state.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Summary\"}),`\n`,(0,n.jsx)(e.p,{children:\"Proxies in JavaScript provide a powerful and flexible way to intercept and customize operations on objects. They are useful for a wide range of applications, including validation, logging, debugging, dynamic property creation, and implementing reactive systems. By using proxies, developers can create more robust, maintainable, and feature-rich applications.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy\",children:\"Proxy - JavaScript | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/proxy\",children:\"Proxy and Reflect | JavaScript.info\"})}),`\n`]})]})}function j(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(p,t)})):p(t)}var w=j;return x(P);})();\n;return Component;"
}