{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "What are the benefits of using spread syntax in JavaScript and how is it different from rest syntax?"
  },
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-the-benefits-of-using-spread-syntax-and-how-is-it-different-from-rest-syntax",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 370,
    "similarQuestions": [],
    "slug": "what-are-the-benefits-of-using-spread-syntax-and-how-is-it-different-from-rest-syntax",
    "subtitle": null,
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-the-benefits-of-using-spread-syntax-and-how-is-it-different-from-rest-syntax/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var b=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),y=(r,e)=>{for(var t in e)s(r,t,{get:e[t],enumerable:!0})},i=(r,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of g(e))!m.call(r,a)&&a!==t&&s(r,a,{get:()=>e[a],enumerable:!(o=u(e,a))||o.enumerable});return r};var f=(r,e,t)=>(t=r!=null?h(p(r)):{},i(e||!r||!r.__esModule?s(t,\"default\",{value:r,enumerable:!0}):t,r)),j=r=>i(s({},\"__esModule\",{value:!0}),r);var l=b((N,c)=>{c.exports=_jsx_runtime});var O={};y(O,{default:()=>v,frontmatter:()=>x});var n=f(l()),x={title:\"What are the benefits of using spread syntax in JavaScript and how is it different from rest syntax?\"};function d(r){let e=Object.assign({h2:\"h2\",p:\"p\",strong:\"strong\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",pre:\"pre\",hr:\"hr\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Spread syntax\"}),\" (\",(0,n.jsx)(e.code,{children:\"...\"}),\") allows an iterable (like an array or string) to be expanded into individual elements. This is often used as a convenient and modern way to create new arrays or objects by combining existing ones.\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Operation\"}),(0,n.jsx)(e.th,{children:\"Traditional\"}),(0,n.jsx)(e.th,{children:\"Spread\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Array cloning\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"arr.slice()\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"[...arr]\"})})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Array merging\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"arr1.concat(arr2)\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"[...arr1, ...arr2]\"})})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Object cloning\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"Object.assign({}, obj)\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"{ ...obj }\"})})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Object merging\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"Object.assign({}, obj1, obj2)\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"{ ...obj1, ...obj2 }\"})})]})]})]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Rest syntax\"}),\" is the opposite of what spread syntax does. It collects a variable number of arguments into an array. This is often used in function parameters to handle a dynamic number of arguments.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Using rest syntax in a function\nfunction sum(...numbers) {\n  return numbers.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum(1, 2, 3)); // Output: 6\n`})}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Spread syntax\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"ES2015's spread syntax is very useful when coding in a functional paradigm as we can easily create copies of / merge arrays or objects without resorting to \",(0,n.jsx)(e.code,{children:\"Object.create\"}),\", \",(0,n.jsx)(e.code,{children:\"Object.assign\"}),\", \",(0,n.jsx)(e.code,{children:\"Array.prototype.slice\"}),\", or a library function. This language feature is used often in Redux and RxJS projects.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Copying arrays/objects\"}),`\n`,(0,n.jsx)(e.p,{children:\"The spread syntax provides a concise way to create copies of arrays or objects without modifying the originals. This is useful for creating immutable data structures. However do note that arrays copied via the spread operator are shallowly-copied.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Copying arrays\nconst array = [1, 2, 3];\nconst newArray = [...array];\nconsole.log(newArray); // Output: [1, 2, 3]\n\n// Copying objects\nconst person = { name: 'John', age: 30 };\nconst newObj = { ...person, city: 'New York' };\nconsole.log(newObj); // Output: { name: 'John', age: 30, city: 'New York' }\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Merging arrays/objects\"}),`\n`,(0,n.jsx)(e.p,{children:\"The spread syntax allows you to merge arrays or objects by spreading their elements/properties into a new array or object.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Merging arrays\nconst arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\nconst mergedArray = [...arr1, ...arr2];\nconsole.log(mergedArray); // Output: [1, 2, 3, 4, 5, 6]\n\n// Merging objects\nconst obj1 = {\n  foo: 'bar',\n};\n\nconst obj2 = {\n  qux: 'baz',\n};\n\nconst mergedObj = { ...obj1, ...obj2 };\nconsole.log(mergedObj); // Output: { foo: \"bar\", qux: \"baz\" }\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Passing arguments to functions\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Use the spread syntax to pass an array of values as individual arguments to a function, avoiding the need for \",(0,n.jsx)(e.code,{children:\"apply()\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const numbers = [1, 2, 3];\nconst max = Math.max(...numbers); // Same as Math.max(1, 2, 3)\nconsole.log(max); // Output: 3\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Array vs object spreads\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Only iterable values like \",(0,n.jsx)(e.code,{children:\"Array\"}),\"s and \",(0,n.jsx)(e.code,{children:\"String\"}),\"s can be spread in an array. Trying to spread non-iterables will result in a \",(0,n.jsx)(e.code,{children:\"TypeError\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Spreading object into array:\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const person = {\n  name: 'Todd',\n  age: 29,\n};\nconst array = [...person]; // Error: Uncaught TypeError: person is not iterable\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"On the other hand, arrays can be spread into objects.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const array = [1, 2, 3];\nconst obj = { ...array };\nconsole.log(obj); // { 0: 1, 1: 2, 2: 3 }\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Rest syntax\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The rest syntax (\",(0,n.jsx)(e.code,{children:\"...\"}),\") in JavaScript allows you to represent an indefinite number of elements as an array or object. It is like an inverse of the spread syntax, taking data and stuffing it into an array rather than unpacking an array of data, and it works in function arguments, as well as in array and object destructuring assignments.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Rest parameters in functions\"}),`\n`,(0,n.jsx)(e.p,{children:\"The rest syntax can be used in function parameters to collect all remaining arguments into an array. This is particularly useful when you don't know how many arguments will be passed to the function.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function addFiveToABunchOfNumbers(...numbers) {\n  return numbers.map((x) => x + 5);\n}\n\nconst result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10);\nconsole.log(result); // Output: [9, 10, 11, 12, 13, 14, 15]\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Provides a cleaner syntax than using the \",(0,n.jsx)(e.code,{children:\"arguments\"}),\" object, which is unsupported for arrow functions and represents \",(0,n.jsx)(e.strong,{children:\"all\"}),\" arguments whereas the usage of the rest syntax below allows \",(0,n.jsx)(e.code,{children:\"remaining\"}),\" to represent the 3rd argument and beyond.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const [first, second, ...remaining] = [1, 2, 3, 4, 5];\nconsole.log(first); // Output: 1\nconsole.log(second); // Output: 2\nconsole.log(remaining); // Output: [3, 4, 5]\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Note that the rest parameters must be at the end. The rest parameters gather all remaining arguments, so the following does not make sense and causes an error:\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function addFiveToABunchOfNumbers(arg1, ...numbers, arg2) {\n  // Error: Rest parameter must be last formal parameter.\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Array destructuring\"}),`\n`,(0,n.jsx)(e.p,{children:\"The rest syntax can be used in array destructuring to collect the remaining elements into a new array.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const [a, b, ...rest] = [1, 2, 3, 4];\nconsole.log(a); // Output: 1\nconsole.log(b); // Output: 2\nconsole.log(rest); // Output: [3, 4]\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Object destructuring\"}),`\n`,(0,n.jsx)(e.p,{children:\"The rest syntax can be used in object destructuring to collect the remaining properties into a new object.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const { e, f, ...others } = {\n  e: 1,\n  f: 2,\n  g: 3,\n  h: 4,\n};\nconsole.log(e); // Output: 1\nconsole.log(f); // Output: 2\nconsole.log(others); // Output: { g: 3, h: 4 }\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Further Reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\",children:\"Spread syntax | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\",children:\"Rest parameters | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/rest-parameters-spread\",children:\"Rest parameters and spread syntax | JavaScript.info\"})}),`\n`]})]})}function w(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(d,r)})):d(r)}var v=w;return j(O);})();\n;return Component;"
}