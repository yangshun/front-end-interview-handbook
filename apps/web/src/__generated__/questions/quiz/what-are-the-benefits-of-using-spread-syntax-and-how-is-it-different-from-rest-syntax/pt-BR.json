{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "Quais são os benefícios de usar a sintaxe de spread e como ela é diferente da sintaxe de rest?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-the-benefits-of-using-spread-syntax-and-how-is-it-different-from-rest-syntax/pt-BR.mdx"
  },
  "solution": "var Component=(()=>{var m=Object.create;var s=Object.defineProperty;var l=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var x=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),b=(n,e)=>{for(var r in e)s(n,r,{get:e[r],enumerable:!0})},d=(n,e,r,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!g.call(n,a)&&a!==r&&s(n,a,{get:()=>e[a],enumerable:!(t=l(e,a))||t.enumerable});return n};var h=(n,e,r)=>(r=n!=null?m(f(n)):{},d(e||!n||!n.__esModule?s(r,\"default\",{value:n,enumerable:!0}):r,n)),j=n=>d(s({},\"__esModule\",{value:!0}),n);var i=x((v,c)=>{c.exports=_jsx_runtime});var k={};b(k,{default:()=>_,frontmatter:()=>y});var o=h(i()),y={title:\"Quais s\\xE3o os benef\\xEDcios de usar a sintaxe de spread e como ela \\xE9 diferente da sintaxe de rest?\"};function u(n){let e=Object.assign({p:\"p\",code:\"code\",pre:\"pre\"},n.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.p,{children:[\"A sintaxe spread do ES2015 \\xE9 muito \\xFAtil quando programando em um paradigma funcional, pois podemos facilmente criar c\\xF3pias de arrays ou objetos sem recorrer a \",(0,o.jsx)(e.code,{children:\"Object.create\"}),\", \",(0,o.jsx)(e.code,{children:\"slice\"}),\", ou uma fun\\xE7\\xE3o de biblioteca. Esse recurso de linguagem \\xE9 frequentemente utilizado em projetos Redux e RxJS.\"]}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`function putDookieInAnyArray(arr) {\n  return [...arr, 'dookie'];\n}\n\nconst result = putDookieInAnyArray(['I', 'really', \"don't\", 'like']); // [\"I\", \"really\", \"don't\", \"like\", \"dookie\"]\n\nconst person = {\n  name: 'Todd',\n  age: 29,\n};\n\nconst copyOfTodd = { ...person };\n`})}),`\n`,(0,o.jsx)(e.p,{children:\"A sintaxe rest do ES2015 oferece uma maneira mais f\\xE1cil de incluir um n\\xFAmero arbitr\\xE1rio de argumentos para serem passados para uma fun\\xE7\\xE3o. \\xC9 como uma invers\\xE3o da sintaxe spread, pegando dados e colocando-os em um array em vez de desempacotar um array de dados, e funciona em argumentos de fun\\xE7\\xE3o, bem como em atribui\\xE7\\xF5es de desconstru\\xE7\\xE3o de arrays e objetos.\"}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`function addFiveToABunchOfNumbers(...numbers) {\n  return numbers.map((x) => x + 5);\n}\n\nconst result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15]\n\nconst [a, b, ...rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4]\n\nconst { e, f, ...others } = {\n  e: 1,\n  f: 2,\n  g: 3,\n  h: 4,\n}; // e: 1, f: 2, others: { g: 3, h: 4 }\n`})})]})}function A(n={}){let{wrapper:e}=n.components||{};return e?(0,o.jsx)(e,Object.assign({},n,{children:(0,o.jsx)(u,n)})):u(n)}var _=A;return j(k);})();\n;return Component;"
}