{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "Explain the differences on the usage of `foo` between `function foo() {}` and `var foo = function() {}` in JavaScript",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/explain-the-differences-on-the-usage-of-foo-between-function-foo-and-var-foo-function/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var t=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var m=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),O=(i,e)=>{for(var o in e)t(i,o,{get:e[o],enumerable:!0})},s=(i,e,o,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of f(e))!g.call(i,c)&&c!==o&&t(i,c,{get:()=>e[c],enumerable:!(r=u(e,c))||r.enumerable});return i};var y=(i,e,o)=>(o=i!=null?h(p(i)):{},s(e||!i||!i.__esModule?t(o,\"default\",{value:i,enumerable:!0}):o,i)),b=i=>s(t({},\"__esModule\",{value:!0}),i);var l=m((k,a)=>{a.exports=_jsx_runtime});var w={};O(w,{default:()=>x,frontmatter:()=>v});var n=y(l()),v={title:\"Explain the differences on the usage of `foo` between `function foo() {}` and `var foo = function() {}` in JavaScript\"};function d(i){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\",strong:\"strong\",hr:\"hr\",h3:\"h3\",a:\"a\",ul:\"ul\",li:\"li\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"function foo() {}\"}),\" a function declaration while the \",(0,n.jsx)(e.code,{children:\"var foo = function() {}\"}),\" is a function expression. The key difference is that function declarations have its body hoisted but the bodies of function expressions are not (they have the same hoisting behavior as \",(0,n.jsx)(e.code,{children:\"var\"}),\"-declared variables).\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"If you try to invoke a function expression before it is declared, you will get an \",(0,n.jsx)(e.code,{children:\"Uncaught TypeError: XXX is not a function\"}),\" error.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Function declarations can be called in the enclosing scope even before they are declared.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`foo(); // 'FOOOOO'\nfunction foo() {\n  console.log('FOOOOO');\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Function expressions if called before they are declared will result in an error.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`foo(); // Uncaught TypeError: foo is not a function\nvar foo = function () {\n  console.log('FOOOOO');\n};\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Another key difference is in the scope of the function name. Function expressions can be named by defining it after the \",(0,n.jsx)(e.code,{children:\"function\"}),\" and before the parenthesis. However when using named function expressions, the function name is only accessible within the function itself. Trying to access it outside will result in an error or \",(0,n.jsx)(e.code,{children:\"undefined\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const myFunc = function namedFunc() {\n  console.log(namedFunc); // Works\n};\n\nmyFunc(); // Runs the function and logs the function reference\nconsole.log(namedFunc); // ReferenceError: namedFunc is not defined\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note\"}),\": The examples uses \",(0,n.jsx)(e.code,{children:\"var\"}),\" due to legacy reasons. Function expressions can be defined using \",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" and the key difference is in the hoisting behavior of those keywords.\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Function declarations\"}),`\n`,(0,n.jsx)(e.p,{children:\"A function declaration is a statement that defines a function with a name. It is typically used to declare a function that can be called multiple times throughout the enclosing scope.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function foo() {\n  console.log('FOOOOO');\n}\nfoo(); // 'FOOOOO'\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Function expressions\"}),`\n`,(0,n.jsx)(e.p,{children:\"A function expression is an expression that defines a function and assigns it to a variable. It is often used when a function is needed only once or in a specific context.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`var foo = function () {\n  console.log('FOOOOO');\n};\nfoo(); // 'FOOOOO'\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note\"}),\": The examples uses \",(0,n.jsx)(e.code,{children:\"var\"}),\" due to legacy reasons. Function expressions can be defined using \",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" and the key difference is in the hoisting behavior of those keywords.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Key differences\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Hoisting\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"The key difference is that function declarations have its body hoisted but the bodies of function expressions are not (they have the same hoisting behavior as \",(0,n.jsx)(e.code,{children:\"var\"}),\"-declared variables). For more explanation on hoisting, refer to the quiz question on \",(0,n.jsx)(e.a,{href:\"/questions/quiz/explain-hoisting\",children:\"hoisting\"}),\". If you try to invoke a function expression before it is defined, you will get an \",(0,n.jsx)(e.code,{children:\"Uncaught TypeError: XXX is not a function\"}),\" error.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Function declarations:\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`foo(); // 'FOOOOO'\nfunction foo() {\n  console.log('FOOOOO');\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Function expressions:\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`foo(); // Uncaught TypeError: foo is not a function\nvar foo = function () {\n  console.log('FOOOOO');\n};\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Name scope\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Function expressions can be named by defining it after the \",(0,n.jsx)(e.code,{children:\"function\"}),\" and before the parenthesis. However when using named function expressions, the function name is only accessible within the function itself. Trying to access it outside will result in \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" and calling it will result in an error.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const myFunc = function namedFunc() {\n  console.log(namedFunc); // Works\n};\n\nmyFunc(); // Runs the function and logs the function reference\nconsole.log(namedFunc); // ReferenceError: namedFunc is not defined\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"When to use each\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Function declarations:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"When you want to create a function on the global scope and make it available throughout the enclosing scope.\"}),`\n`,(0,n.jsx)(e.li,{children:\"If a function is reusable and needs to be called multiple times.\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Function expressions:\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"If a function is only needed once or in a specific context.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Use to limit the function availability to subsequent code and keep the enclosing scope clean.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"In general, it's preferable to use function declarations to avoid the mental overhead of determining if a function can be called. The practical usages of function expressions is quite rare.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function\",children:\"Function declaration | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\",children:\"Function expression | MDN\"})}),`\n`]})]})}function F(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(d,i)})):d(i)}var x=F;return b(w);})();\n;return Component;"
}