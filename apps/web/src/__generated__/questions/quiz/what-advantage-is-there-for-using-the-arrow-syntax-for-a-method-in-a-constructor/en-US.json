{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "What advantage is there for using the JavaScript arrow syntax for a method in a constructor?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-advantage-is-there-for-using-the-arrow-syntax-for-a-method-in-a-constructor/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var p=(o,n)=>()=>(n||o((n={exports:{}}).exports,n),n.exports),y=(o,n)=>{for(var t in n)i(o,t,{get:n[t],enumerable:!0})},s=(o,n,t,r)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let a of m(n))!w.call(o,a)&&a!==t&&i(o,a,{get:()=>n[a],enumerable:!(r=u(n,a))||r.enumerable});return o};var g=(o,n,t)=>(t=o!=null?d(f(o)):{},s(n||!o||!o.__esModule?i(t,\"default\",{value:o,enumerable:!0}):t,o)),v=o=>s(i({},\"__esModule\",{value:!0}),o);var h=p((J,c)=>{c.exports=_jsx_runtime});var x={};y(x,{default:()=>N,frontmatter:()=>b});var e=g(h()),b={title:\"What advantage is there for using the JavaScript arrow syntax for a method in a constructor?\"};function l(o){let n=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\",hr:\"hr\",h3:\"h3\",ul:\"ul\",li:\"li\",strong:\"strong\",a:\"a\"},o.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h2,{children:\"TL;DR\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"The main advantage of using an arrow function as a method inside a constructor is that the value of \",(0,e.jsx)(n.code,{children:\"this\"}),\" gets set at the time of the function creation and can't change after that. When the constructor is used to create a new object, \",(0,e.jsx)(n.code,{children:\"this\"}),\" will always refer to that object.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"For example, let's say we have a \",(0,e.jsx)(n.code,{children:\"Person\"}),\" constructor that takes a first name as an argument has two methods to \",(0,e.jsx)(n.code,{children:\"console.log()\"}),\" that name, one as a regular function and one as an arrow function:\"]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const Person = function (name) {\n  this.firstName = name;\n  this.sayName1 = function () {\n    console.log(this.firstName);\n  };\n  this.sayName2 = () => {\n    console.log(this.firstName);\n  };\n};\n\nconst john = new Person('John');\nconst dave = new Person('Dave');\n\njohn.sayName1(); // John\njohn.sayName2(); // John\n\n// The regular function can have its \\`this\\` value changed, but the arrow function cannot\njohn.sayName1.call(dave); // Dave (because \\`this\\` is now the dave object)\njohn.sayName2.call(dave); // John\n\njohn.sayName1.apply(dave); // Dave (because \\`this\\` is now the dave object)\njohn.sayName2.apply(dave); // John\n\njohn.sayName1.bind(dave)(); // Dave (because \\`this\\` is now the dave object)\njohn.sayName2.bind(dave)(); // John\n\nconst sayNameFromWindow1 = john.sayName1;\nsayNameFromWindow1(); // undefined (because \\`this\\` is now the window object)\n\nconst sayNameFromWindow2 = john.sayName2;\nsayNameFromWindow2(); // John\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"The main takeaway here is that \",(0,e.jsx)(n.code,{children:\"this\"}),\" can be changed for a normal function, but \",(0,e.jsx)(n.code,{children:\"this\"}),\" always stays the same for an arrow function. So even if you are passing around your arrow function to different parts of your application, you wouldn't have to worry about the value of \",(0,e.jsx)(n.code,{children:\"this\"}),\" changing.\"]}),`\n`,(0,e.jsx)(n.hr,{}),`\n`,(0,e.jsx)(n.h2,{children:\"Arrow functions\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"Arrow functions are introduced in ES2015 and it provides a concise way to write functions in Javascript. One of the key features of arrow function is that it lexically bind the \",(0,e.jsx)(n.code,{children:\"this\"}),\" value, which means that it takes the \",(0,e.jsx)(n.code,{children:\"this\"}),\" value from enclosing scope.\"]}),`\n`,(0,e.jsx)(n.h3,{children:\"Syntax\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"Arrow functions use the \",(0,e.jsx)(n.code,{children:\"=>\"}),\" syntax instead of the function keyword. The basic syntax is:\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const myFunction = (arg1, arg2, ...argN) => {\n  // function body\n};\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"If the function body has only one expression, you can omit the curly braces and the return keyword:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const myFunction = (arg1, arg2, ...argN) => expression;\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Examples\"}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// Arrow function with parameters\nconst multiply = (x, y) => x * y;\nconsole.log(multiply(2, 3)); // Output: 6\n\n// Arrow function with no parameters\nconst sayHello = () => 'Hello, World!';\nconsole.log(sayHello()); // Output: 'Hello, World!'\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Advantages\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Concise\"}),\": Arrow functions provide a more concise syntax, especially for short functions.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Implicit return\"}),\": They have an implicit return for single-line functions.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsxs)(n.strong,{children:[\"Value of \",(0,e.jsx)(n.code,{children:\"this\"}),\" is predictable\"]}),\": Arrow functions lexically bind the \",(0,e.jsx)(n.code,{children:\"this\"}),\" value, inheriting it from the enclosing scope.\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Limitations\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"Arrow functions cannot be used as constructors and will throw an error when used with the \",(0,e.jsx)(n.code,{children:\"new\"}),\" keyword.\"]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const Foo = () => {};\nconst foo = new Foo(); // TypeError: Foo is not a constructor\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"They also do not have \",(0,e.jsx)(n.code,{children:\"arguments\"}),\" keyword; the arguments have to be obtained from using the rest operator (\",(0,e.jsx)(n.code,{children:\"...\"}),\") in the arguments.\"]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const arrowFunction = (...args) => {\n  console.log(arguments); // Throws a ReferenceError\n  console.log(args); // [1, 2, 3]\n};\n\narrowFunction(1, 2, 3);\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"Since arrow functions do not have their own \",(0,e.jsx)(n.code,{children:\"this\"}),\", they are not suitable for defining methods in an object. Traditional function expressions or function declarations should be used instead.\"]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const obj = {\n  value: 42,\n  getValue: () => this.value, // \\`this\\` does not refer to \\`obj\\`\n};\n\nconsole.log(obj.getValue()); // undefined\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"Why arrow functions are useful\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"One of the most notable features of arrow functions is their behavior with \",(0,e.jsx)(n.code,{children:\"this\"}),\". Unlike regular functions, arrow functions do not have their own \",(0,e.jsx)(n.code,{children:\"this\"}),\". Instead, they inherit \",(0,e.jsx)(n.code,{children:\"this\"}),\" from the parent scope at the time they are defined. This makes arrow functions particularly useful for scenarios like event handlers, callbacks, and methods in classes.\"]}),`\n`,(0,e.jsx)(n.h3,{children:\"Arrow functions inside function constructors\"}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const Person = function (name) {\n  this.firstName = name;\n  this.sayName1 = function () {\n    console.log(this.firstName);\n  };\n  this.sayName2 = () => {\n    console.log(this.firstName);\n  };\n};\n\nconst john = new Person('John');\nconst dave = new Person('Dave');\n\njohn.sayName1(); // John\njohn.sayName2(); // John\n\n// The regular function can have its \\`this\\` value changed, but the arrow function cannot\njohn.sayName1.call(dave); // Dave (because \\`this\\` is now the dave object)\njohn.sayName2.call(dave); // John\n\njohn.sayName1.apply(dave); // Dave (because \\`this\\` is now the dave object)\njohn.sayName2.apply(dave); // John\n\njohn.sayName1.bind(dave)(); // Dave (because \\`this\\` is now the dave object)\njohn.sayName2.bind(dave)(); // John\n\nconst sayNameFromWindow1 = john.sayName1;\nsayNameFromWindow1(); // undefined (because \\`this\\` is now the window object)\n\nconst sayNameFromWindow2 = john.sayName2;\nsayNameFromWindow2(); // John\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Arrow functions in event handlers\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const button = document.getElementById('myButton');\n\nbutton.addEventListener('click', function () {\n  console.log(this); // Output: Button\n  console.log(this === button); // Output: true\n});\n\nbutton.addEventListener('click', () => {\n  console.log(this); // Output: Window\n  console.log(this === window); // Output: true\n});\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"This can be particularly helpful in React class components. If you define a class method for something such as a click handler using a normal function, and then you pass that click handler down into a child component as a prop, you will need to also bind \",(0,e.jsx)(n.code,{children:\"this\"}),\" in the constructor of the parent component. If you instead use an arrow function, there is no need to bind \",(0,e.jsx)(n.code,{children:\"this\"}),\", as the method will automatically get its \",(0,e.jsx)(n.code,{children:\"this\"}),\" value from its enclosing lexical context. See this \",(0,e.jsx)(n.a,{href:\"https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb\",children:\"article\"}),\" for an excellent demonstration and sample code.\"]}),`\n`,(0,e.jsx)(n.h2,{children:\"Further reading\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\",children:\"Arrow function expressions - MDN \"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://www.freecodecamp.org/news/javascript-arrow-functions-in-dep\",children:\"How to Use JavaScript Arrow Functions \\u2013 Explained in Detail\"})}),`\n`]})]})}function j(o={}){let{wrapper:n}=o.components||{};return n?(0,e.jsx)(n,Object.assign({},o,{children:(0,e.jsx)(l,o)})):l(o)}var N=j;return v(x);})();\n;return Component;"
}