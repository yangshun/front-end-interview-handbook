{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-language-constructs-do-you-use-for-iterating-over-object-properties-and-array-items",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 360,
    "similarQuestions": [],
    "slug": "what-language-constructs-do-you-use-for-iterating-over-object-properties-and-array-items",
    "subtitle": null,
    "title": "What language constructs do you use for iterating over object properties and array items in JavaScript?",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-language-constructs-do-you-use-for-iterating-over-object-properties-and-array-items/en-US.mdx"
  },
  "solution": "var Component=(()=>{var p=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),g=(r,e)=>{for(var o in e)c(r,o,{get:e[o],enumerable:!0})},i=(r,e,o,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of m(e))!b.call(r,t)&&t!==o&&c(r,t,{get:()=>e[t],enumerable:!(a=u(e,t))||a.enumerable});return r};var j=(r,e,o)=>(o=r!=null?p(y(r)):{},i(e||!r||!r.__esModule?c(o,\"default\",{value:r,enumerable:!0}):o,r)),v=r=>i(c({},\"__esModule\",{value:!0}),r);var d=f((S,l)=>{l.exports=_jsx_runtime});var O={};g(O,{default:()=>s,frontmatter:()=>w});var n=j(d()),w={title:\"What language constructs do you use for iterating over object properties and array items in JavaScript?\"};function h(r){let e={a:\"a\",code:\"code\",h2:\"h2\",h3:\"h3\",hr:\"hr\",li:\"li\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...r.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:\"There are multiple ways to iterate over object properties as well as arrays in JavaScript:\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.strong,{children:[(0,n.jsx)(e.code,{children:\"for...in\"}),\" loop\"]})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"for...in\"}),\" loop iterates over all enumerable properties of an object, including inherited enumerable properties. So it is important to have a check if you only want to iterate over object's own properties\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\n\nfor (const key in obj) {\n  // To avoid iterating over inherited properties\n  if (Object.hasOwn(obj, key)) {\n    console.log(\\`\\${key}: \\${obj[key]}\\`);\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.code,{children:\"Object.keys()\"})})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Object.keys()\"}),\" returns an array of the object's own enumerable property names. You can then use a for...of loop or forEach to iterate over this array.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\n\nObject.keys(obj).forEach((key) => {\n  console.log(\\`\\${key}: \\${obj[key]}\\`);\n});\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Most common ways to iterate over array are using \",(0,n.jsx)(e.code,{children:\"for\"}),\" loop and \",(0,n.jsx)(e.code,{children:\"Array.prototype.forEach\"}),\" method.\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.strong,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"for\"}),\" loop\"]})}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let array = [1, 2, 3, 4, 5, 6];\nfor (let index = 0; index < array.length; index++) {\n  console.log(array[index]);\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.strong,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"Array.prototype.forEach\"}),\" method\"]})}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:\"let array = [1, 2, 3, 4, 5, 6];\\narray.forEach((number, index) => {\\n  console.log(`${number} at index ${index}`);\\n});\\n\"})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsxs)(e.strong,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"for...of\"})]})}),`\n`,(0,n.jsx)(e.p,{children:\"This method is the newest and most convenient way to iterate over arrays. It automatically iterates over each element without requiring you to manage the index.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const numbers = [1, 2, 3, 4, 5];\n\nfor (const number of numbers) {\n  console.log(number);\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"There are also other inbuilt methods available which are suitable for specific scenarios for example:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Array.prototype.filter\"}),\": You can use the \",(0,n.jsx)(e.code,{children:\"filter\"}),\" method to create a new array containing only the elements that satisfy a certain condition.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Array.prototype.map\"}),\": You can use the \",(0,n.jsx)(e.code,{children:\"map\"}),\" method to create a new array based on the existing one, transforming each element with a provided function.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Array.prototype.reduce\"}),\": You can use the \",(0,n.jsx)(e.code,{children:\"reduce\"}),\" method to combine all elements into a single value by repeatedly calling a function that takes two arguments: the accumulated value and the current element.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Iterating over objects\"}),`\n`,(0,n.jsx)(e.p,{children:\"Iterating over object properties and array is very common in JavaScript and we have various ways to achieve this. Here are some of the ways to do it:\"}),`\n`,(0,n.jsxs)(e.h3,{children:[(0,n.jsx)(e.code,{children:\"for...in\"}),\" statement\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This loop iterates over all \",(0,n.jsx)(e.strong,{children:\"enumerable\"}),\" properties of an object, including those inherited from its prototype chain.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const obj = {\n  status: 'working',\n  hoursWorked: 3,\n};\n\nfor (const property in obj) {\n  console.log(property);\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Since \",(0,n.jsx)(e.code,{children:\"for...in\"}),\" statement iterates over all the object's \",(0,n.jsx)(e.strong,{children:\"enumerable\"}),\" properties (including inherited enumerable properties). Hence most of the time you should check whether the property exists on directly on the object via \",(0,n.jsx)(e.code,{children:\"Object.hasOwn(object, property)\"}),\" before using it.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const obj = {\n  status: 'working',\n  hoursWorked: 3,\n};\n\nfor (const property in obj) {\n  if (Object.hasOwn(obj, property)) {\n    console.log(property);\n  }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Note that \",(0,n.jsx)(e.code,{children:\"obj.hasOwnProperty()\"}),\" is not recommended because it doesn't work for objects created using \",(0,n.jsx)(e.code,{children:\"Object.create(null)\"}),\". It is recommended to use \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn\",children:(0,n.jsx)(e.code,{children:\"Object.hasOwn()\"})}),\" in newer browsers, or use the good old \",(0,n.jsx)(e.code,{children:\"Object.prototype.hasOwnProperty.call(object, key)\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"Object.keys()\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Object.keys()\"}),\" is a static method that will return an array of all the enumerable property names of the object that you pass it. Since \",(0,n.jsx)(e.code,{children:\"Object.keys()\"}),\" returns an array, you can also use the array iteration approaches listed below to iterate through it.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const obj = {\n  status: 'working',\n  hoursWorked: 3,\n};\n\nObject.keys(obj).forEach((property) => {\n  console.log(property);\n});\n`})}),`\n`,(0,n.jsxs)(e.h3,{children:[(0,n.jsx)(e.code,{children:\"Object.entries()\"}),\":\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"This method returns an array of an object's enumerable properties in \",(0,n.jsx)(e.code,{children:\"[key, value]\"}),\" pairs.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:\"const obj = { a: 1, b: 2, c: 3 };\\nObject.entries(obj).forEach(([key, value]) => {\\n  console.log(`${key}: ${value}`);\\n});\\n\"})}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"Object.getOwnPropertyNames()\"})}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const obj = { a: 1, b: 2, c: 3 };\nObject.getOwnPropertyNames(obj).forEach((property) => {\n  console.log(property);\n});\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Object.getOwnPropertyNames()\"}),\" is a static method that will lists all enumerable and non-enumerable properties of the object that you pass it. Since \",(0,n.jsx)(e.code,{children:\"Object.getOwnPropertyNames()\"}),\" returns an array, you can also use the array iteration approaches listed below to iterate through it.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Arrays\"}),`\n`,(0,n.jsxs)(e.h3,{children:[(0,n.jsx)(e.code,{children:\"for\"}),\" loop\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const arr = [1, 2, 3, 4, 5];\nfor (var i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"A common pitfall here is that \",(0,n.jsx)(e.code,{children:\"var\"}),\" is in the function scope and not the block scope and most of the time you would want block scoped iterator variable. ES2015 introduces \",(0,n.jsx)(e.code,{children:\"let\"}),\" which has block scope and it is recommended to use \",(0,n.jsx)(e.code,{children:\"let\"}),\" over \",(0,n.jsx)(e.code,{children:\"var\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const arr = [1, 2, 3, 4, 5];\nfor (let i = 0; i < arr.length; i++) {\n  console.log(arr[i]);\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"Array.prototype.forEach()\"})}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:\"const arr = [1, 2, 3, 4, 5];\\narr.forEach((element, index) => {\\n  console.log(`${element} at index ${index}`);\\n});\\n\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Array.prototype.forEach()\"}),\" method can be more convenient at times if you do not need to use the \",(0,n.jsx)(e.code,{children:\"index\"}),\" and all you need is the individual array elements. However, the downside is that you cannot stop the iteration halfway and the provided function will be executed on the elements once. A \",(0,n.jsx)(e.code,{children:\"for\"}),\" loop or \",(0,n.jsx)(e.code,{children:\"for...of\"}),\" statement is more relevant if you need finer control over the iteration.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[(0,n.jsx)(e.code,{children:\"for...of\"}),\" statement\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const arr = [1, 2, 3, 4, 5];\nfor (let element of arr) {\n  console.log(element);\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"ES2015 introduces a new way to iterate, the \",(0,n.jsx)(e.code,{children:\"for-of\"}),\" loop, that allows you to loop over objects that conform to the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol\",children:\"iterable protocol\"}),\" such as \",(0,n.jsx)(e.code,{children:\"String\"}),\", \",(0,n.jsx)(e.code,{children:\"Array\"}),\", \",(0,n.jsx)(e.code,{children:\"Map\"}),\", \",(0,n.jsx)(e.code,{children:\"Set\"}),\", etc. It combines the advantages of the \",(0,n.jsx)(e.code,{children:\"for\"}),\" loop and the \",(0,n.jsx)(e.code,{children:\"forEach()\"}),\" method. The advantage of the \",(0,n.jsx)(e.code,{children:\"for\"}),\" loop is that you can break from it, and the advantage of \",(0,n.jsx)(e.code,{children:\"forEach()\"}),\" is that it is more concise than the \",(0,n.jsx)(e.code,{children:\"for\"}),\" loop because you don't need a counter variable. With the \",(0,n.jsx)(e.code,{children:\"for...of\"}),\" statement, you get both the ability to break from a loop and a more concise syntax.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Most of the time, prefer the \",(0,n.jsx)(e.code,{children:\".forEach\"}),\" method, but it really depends on what you are trying to do. Before ES2015, we used \",(0,n.jsx)(e.code,{children:\"for\"}),\" loops when we needed to prematurely terminate the loop using \",(0,n.jsx)(e.code,{children:\"break\"}),\". But now with ES2015, we can do that with \",(0,n.jsx)(e.code,{children:\"for...of\"}),\" statement. Use \",(0,n.jsx)(e.code,{children:\"for\"}),\" loops when you need more flexibility, such as incrementing the iterator more than once per loop.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Also, when using the \",(0,n.jsx)(e.code,{children:\"for...of\"}),\" statement, if you need to access both the index and value of each array element, you can do so with ES2015 \",(0,n.jsx)(e.code,{children:\"Array.prototype.entries()\"}),\" method:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const arr = ['a', 'b', 'c'];\n\nfor (let [index, elem] of arr.entries()) {\n  console.log(index, elem);\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\",children:\"Object.getOwnPropertyNames() - JavaScript | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\",children:\"Object.keys() - JavaScript | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of\",children:\"for...of - JavaScript | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\",children:\"Array.prototype.forEach() - JavaScript | MDN\"})}),`\n`]})]})}function s(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,{...r,children:(0,n.jsx)(h,{...r})}):h(r)}return v(O);})();\n;return Component;"
}