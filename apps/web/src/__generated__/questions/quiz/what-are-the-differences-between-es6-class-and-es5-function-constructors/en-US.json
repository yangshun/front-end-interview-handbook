{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-the-differences-between-es6-class-and-es5-function-constructors",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 200,
    "similarQuestions": [],
    "slug": "what-are-the-differences-between-es6-class-and-es5-function-constructors",
    "subtitle": null,
    "title": "What are the differences between JavaScript ES2015 classes and ES5 function constructors?",
    "topics": [
      "javascript",
      "oop"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-the-differences-between-es6-class-and-es5-function-constructors/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var S=(t,n)=>()=>(n||t((n={exports:{}}).exports,n),n.exports),y=(t,n)=>{for(var s in n)i(t,s,{get:n[s],enumerable:!0})},o=(t,n,s,c)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let r of m(n))!g.call(t,r)&&r!==s&&i(t,r,{get:()=>n[r],enumerable:!(c=u(n,r))||c.enumerable});return t};var f=(t,n,s)=>(s=t!=null?h(p(t)):{},o(n||!t||!t.__esModule?i(s,\"default\",{value:t,enumerable:!0}):s,t)),E=t=>o(i({},\"__esModule\",{value:!0}),t);var d=S((P,a)=>{a.exports=_jsx_runtime});var I={};y(I,{default:()=>b,frontmatter:()=>w});var e=f(d()),w={title:\"What are the differences between JavaScript ES2015 classes and ES5 function constructors?\"};function l(t){let n=Object.assign({h2:\"h2\",p:\"p\",pre:\"pre\",code:\"code\",strong:\"strong\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",hr:\"hr\",h3:\"h3\",ol:\"ol\",li:\"li\",ul:\"ul\",a:\"a\"},t.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h2,{children:\"TL;DR\"}),`\n`,(0,e.jsx)(n.p,{children:\"ES2015 introduces a new way of creating classes, which provides a more intuitive and concise way to define and work with objects and inheritance compared to the ES5 function constructor syntax. Here's an example of each:\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// ES5 function constructor\nfunction Person(name) {\n  this.name = name;\n}\n\n// ES2015 Class\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"For simple constructors, they look pretty similar. The main difference in the constructor comes when using inheritance. If we want to create a \",(0,e.jsx)(n.code,{children:\"Student\"}),\" class that subclasses \",(0,e.jsx)(n.code,{children:\"Person\"}),\" and add a \",(0,e.jsx)(n.code,{children:\"studentId\"}),\" field, this is what we have to do.\"]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// ES5 inheritance\n// Superclass\nfunction Person1(name) {\n  this.name = name;\n}\n\n// Subclass\nfunction Student1(name, studentId) {\n  // Call constructor of superclass to initialize superclass-derived members.\n  Person1.call(this, name);\n\n  // Initialize subclass's own members.\n  this.studentId = studentId;\n}\nStudent1.prototype = Object.create(Person1.prototype);\nStudent1.prototype.constructor = Student1;\n\nconst student1 = new Student1('John', 1234);\nconsole.log(student1.name, student1.studentId); // \"John\" 1234\n\n// ES2015 inheritance\n// Superclass\nclass Person2 {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\n// Subclass\nclass Student2 extends Person2 {\n  constructor(name, studentId) {\n    super(name);\n    this.studentId = studentId;\n  }\n}\n\nconst student2 = new Student2('Alice', 5678);\nconsole.log(student2.name, student2.studentId); // \"Alice\" 5678\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"It's much more verbose to use inheritance in ES5 and the ES2015 version is easier to understand and remember.\"}),`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.strong,{children:\"Comparison of ES5 function constructors vs ES2015 classes\"})}),`\n`,(0,e.jsxs)(n.table,{children:[(0,e.jsx)(n.thead,{children:(0,e.jsxs)(n.tr,{children:[(0,e.jsx)(n.th,{children:\"Feature\"}),(0,e.jsx)(n.th,{children:\"ES5 Function Constructor\"}),(0,e.jsx)(n.th,{children:\"ES2015 Class\"})]})}),(0,e.jsxs)(n.tbody,{children:[(0,e.jsxs)(n.tr,{children:[(0,e.jsx)(n.td,{children:\"Syntax\"}),(0,e.jsx)(n.td,{children:\"Uses function constructors and prototypes\"}),(0,e.jsxs)(n.td,{children:[\"Uses \",(0,e.jsx)(n.code,{children:\"class\"}),\" keyword\"]})]}),(0,e.jsxs)(n.tr,{children:[(0,e.jsx)(n.td,{children:\"Constructor\"}),(0,e.jsxs)(n.td,{children:[\"Function with properties assigned using \",(0,e.jsx)(n.code,{children:\"this\"})]}),(0,e.jsxs)(n.td,{children:[(0,e.jsx)(n.code,{children:\"constructor\"}),\" method inside the class\"]})]}),(0,e.jsxs)(n.tr,{children:[(0,e.jsx)(n.td,{children:\"Method Definition\"}),(0,e.jsx)(n.td,{children:\"Defined on the prototype\"}),(0,e.jsx)(n.td,{children:\"Defined inside the class body\"})]}),(0,e.jsxs)(n.tr,{children:[(0,e.jsx)(n.td,{children:\"Static Methods\"}),(0,e.jsx)(n.td,{children:\"Added directly to the constructor function\"}),(0,e.jsxs)(n.td,{children:[\"Defined using the \",(0,e.jsx)(n.code,{children:\"static\"}),\" keyword\"]})]}),(0,e.jsxs)(n.tr,{children:[(0,e.jsx)(n.td,{children:\"Inheritance\"}),(0,e.jsxs)(n.td,{children:[\"Uses \",(0,e.jsx)(n.code,{children:\"Object.create()\"}),\" and manually sets prototype chain\"]}),(0,e.jsxs)(n.td,{children:[\"Uses \",(0,e.jsx)(n.code,{children:\"extends\"}),\" keyword and \",(0,e.jsx)(n.code,{children:\"super\"}),\" function\"]})]}),(0,e.jsxs)(n.tr,{children:[(0,e.jsx)(n.td,{children:\"Readability\"}),(0,e.jsx)(n.td,{children:\"Less intuitive and more verbose\"}),(0,e.jsx)(n.td,{children:\"More concise and intuitive\"})]})]})]}),`\n`,(0,e.jsx)(n.hr,{}),`\n`,(0,e.jsx)(n.h2,{children:\"ES5 function constructor vs ES2015 classes\"}),`\n`,(0,e.jsx)(n.p,{children:\"ES5 function constructors and ES2015 classes are two different ways of defining classes in JavaScript. They both serve the same purpose, but they have different syntax and behavior.\"}),`\n`,(0,e.jsx)(n.h3,{children:\"ES5 function constructors\"}),`\n`,(0,e.jsx)(n.p,{children:\"In ES5, you define a class-like structure using a function constructor and prototypes. Here's an example:\"}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// ES5 function constructor\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson.prototype.greet = function () {\n  console.log(\n    'Hello, my name is ' + this.name + ' and I am ' + this.age + ' years old.',\n  );\n};\n\n// Creating an instance\nvar person1 = new Person('John', 30);\nperson1.greet(); // Hello, my name is John and I am 30 years old.\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"ES2015 classes\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"ES2015 introduced the \",(0,e.jsx)(n.code,{children:\"class\"}),\" syntax, which simplifies the definition of classes and supports more features such as static methods and subclassing. Here's the same example using ES2015:\"]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// ES2015 Class\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    console.log(\n      \\`Hello, my name is \\${this.name} and I am \\${this.age} years old.\\`,\n    );\n  }\n}\n\n// Creating an instance\nconst person1 = new Person('John', 30);\nperson1.greet(); // Hello, my name is John and I am 30 years old.\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Key Differences\"}),`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Syntax and Readability\"}),\":\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"ES5\"}),\": Uses function constructors and prototypes, which can be less intuitive and harder to read.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"ES2015\"}),\": Uses the \",(0,e.jsx)(n.code,{children:\"class\"}),\" keyword, making the code more concise and easier to understand.\"]}),`\n`]}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.strong,{children:\"Static Methods\"}),\":\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"ES5\"}),\": Static methods are added directly to the constructor function.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"ES2015\"}),\": Static methods are defined within the class using the \",(0,e.jsx)(n.code,{children:\"static\"}),\" keyword.\"]}),`\n`]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// ES5\nfunction Person1(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson1.sayHi = function () {\n  console.log('Hi from ES5!');\n};\n\nPerson1.sayHi(); // Hi from ES5!\n\n// ES2015\nclass Person2 {\n  static sayHi() {\n    console.log('Hi from ES2015!');\n  }\n}\nPerson2.sayHi(); // Hi from ES2015!\n`})}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsx)(n.p,{children:(0,e.jsx)(n.strong,{children:\"Inheritance\"})}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"ES5\"}),\": Inheritance is achieved using \",(0,e.jsx)(n.code,{children:\"Object.create()\"}),\" and manually setting the prototype chain.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"ES2015\"}),\": Inheritance is much simpler and more intuitive with the extends keyword.\"]}),`\n`]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// ES5 Inheritance\n\n// ES5 function constructor\nfunction Person1(name, age) {\n  this.name = name;\n  this.age = age;\n}\n\nPerson1.prototype.greet = function () {\n  console.log(\n    \\`Hello, my name is \\${this.name} and I am \\${this.age} years old.\\`,\n  );\n};\n\nfunction Student1(name, age, grade) {\n  Person1.call(this, name, age);\n  this.grade = grade;\n}\n\nStudent1.prototype = Object.create(Person1.prototype);\nStudent1.prototype.constructor = Student1;\n\nStudent1.prototype.study = function () {\n  console.log(this.name + ' is studying.');\n};\n\nvar student1 = new Student1('John', 22, 'B+');\nstudent1.greet(); // Hello, my name is John and I am 22 years old.\nstudent1.study(); // John is studying.\n\n// ES2015 Inheritance\n\n// ES2015 Class\nclass Person2 {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n\n  greet() {\n    console.log(\n      \\`Hello, my name is \\${this.name} and I am \\${this.age} years old.\\`,\n    );\n  }\n}\n\nclass Student2 extends Person2 {\n  constructor(name, age, grade) {\n    super(name, age);\n    this.grade = grade;\n  }\n\n  study() {\n    console.log(\\`\\${this.name} is studying.\\`);\n  }\n}\n\nconst student2 = new Student2('Alice', 20, 'A');\nstudent2.greet(); // Hello, my name is Alice and I am 20 years old.\nstudent2.study(); // Alice is studying.\n`})}),`\n`]}),`\n`,(0,e.jsxs)(n.li,{children:[`\n`,(0,e.jsxs)(n.p,{children:[(0,e.jsx)(n.code,{children:\"super\"}),\" calls:\"]}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"ES5\"}),\": Manually call the parent constructor function.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"ES2015\"}),\": Use the \",(0,e.jsx)(n.code,{children:\"super\"}),\" keyword to call the parent class's constructor and methods.\"]}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Conclusion\"}),`\n`,(0,e.jsx)(n.p,{children:\"While both ES5 and ES2015 approaches can achieve the same functionality, ES2015 classes provide a clearer and more concise way to define and work with object-oriented constructs in JavaScript, which makes the code easier to write, read, and maintain. If you are working with modern JavaScript, it is generally recommended to use ES2015 classes over ES5 function constructors.\"}),`\n`,(0,e.jsx)(n.h2,{children:\"Resources\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes\",children:\"Classes - MDN\"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#inheritance\",children:\"Inheritance- MDN \"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://eloquentjavascript.net/06_object.html\",children:\"The Secret Life Of Objects\"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://www.educative.io/courses/learn-object-oriented-programming-in-javascript/es2015-vs-es5\",children:\"ES2015 vs ES5\"})}),`\n`]})]})}function v(t={}){let{wrapper:n}=t.components||{};return n?(0,e.jsx)(n,Object.assign({},t,{children:(0,e.jsx)(l,t)})):l(t)}var b=v;return E(I);})();\n;return Component;"
}