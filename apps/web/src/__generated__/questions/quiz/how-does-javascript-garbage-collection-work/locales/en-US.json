{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "How does JavaScript garbage collection work?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/how-does-javascript-garbage-collection-work/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var u=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),f=(r,e)=>{for(var a in e)o(r,a,{get:e[a],enumerable:!0})},l=(r,e,a,t)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of m(e))!p.call(r,i)&&i!==a&&o(r,i,{get:()=>e[i],enumerable:!(t=g(e,i))||t.enumerable});return r};var v=(r,e,a)=>(a=r!=null?d(b(r)):{},l(e||!r||!r.__esModule?o(a,\"default\",{value:r,enumerable:!0}):a,r)),y=r=>l(o({},\"__esModule\",{value:!0}),r);var s=u((J,c)=>{c.exports=_jsx_runtime});var M={};f(M,{default:()=>k,frontmatter:()=>w});var n=v(s()),w={title:\"How does JavaScript garbage collection work?\"};function h(r){let e=Object.assign({h2:\"h2\",p:\"p\",strong:\"strong\",ul:\"ul\",li:\"li\",hr:\"hr\",h3:\"h3\",ol:\"ol\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:\"Garbage collection in JavaScript is an automatic memory management mechanism that reclaims memory occupied by objects and variables that are no longer in use by the program. The two most common algorithms are mark-and-sweep and generational garbage collection.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"Mark-and-sweep\"})}),`\n`,(0,n.jsx)(e.p,{children:\"The most common garbage collection algorithm used in JavaScript is the Mark-and-sweep algorithm. It operates in two phases:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Marking phase\"}),': The garbage collector traverses the object graph, starting from the root objects (global variables, currently executing functions, etc.), and marks all reachable objects as \"in-use\".']}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Sweeping phase\"}),\": The garbage collector sweeps through memory, removing all unmarked objects, as they are considered unreachable and no longer needed.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"This algorithm effectively identifies and removes objects that have become unreachable, freeing up memory for new allocations.\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"Generational garbage collection\"})}),`\n`,(0,n.jsx)(e.p,{children:\"Leveraged by modern JavaScript engines, objects are divided into different generations based on their age and usage patterns. Frequently accessed objects are moved to younger generations, while less frequently used objects are promoted to older generations. This optimization reduces the overhead of garbage collection by focusing on the younger generations, where most objects are short-lived.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Different JavaScript engines (differs according to browsers) implement different garbage collection algorithms and there's no standard way of doing garbage collection.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Garbage collection in JavaScript\"}),`\n`,(0,n.jsx)(e.p,{children:\"Garbage collection in JavaScript is an automatic process managed by the JavaScript engine, designed to reclaim memory occupied by objects that are no longer needed. This helps prevent memory leaks and optimizes the use of available memory. Here's an overview of how garbage collection works in JavaScript:\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Memory management basics\"}),`\n`,(0,n.jsx)(e.p,{children:\"JavaScript allocates memory for objects, arrays, and other variables as they are created. Over time, some of these objects become unreachable because there are no references to them. Garbage collection is the process of identifying these unreachable objects and reclaiming their memory.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Reachability\"}),`\n`,(0,n.jsx)(e.p,{children:\"The primary concept in JavaScript garbage collection is reachability. An object is considered reachable if it can be accessed or reached in some way:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Global variables\"}),\": Objects referenced by global variables are always reachable.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Local variables and function parameters\"}),\": These objects are reachable as long as the function is executing.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Closure variables\"}),\": Objects referenced by closures are reachable if the closure is reachable.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"DOM and other system roots\"}),\": Objects referenced by the DOM or other host objects.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"If there is a chain of references from a root to an object, that object is considered reachable.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Garbage collection algorithms\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Mark-and-sweep\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Mark Phase\"}),\": The garbage collector starts from the root objects and marks all reachable objects.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Sweep Phase\"}),\": It then scans memory for objects that were not marked and reclaims their memory.\"]}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Reference counting\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"This algorithm keeps a count of references to each object. When an object's reference count drops to zero, it is considered unreachable and can be collected.\"}),`\n`,(0,n.jsx)(e.li,{children:\"A drawback of reference counting is that it cannot handle circular references well (e.g., two objects referencing each other but not referenced by any other object).\"}),`\n`]}),`\n`]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Generational garbage collection\"}),\":\",`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Memory is divided into generations: young and old.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Objects are initially allocated in the young generation.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Objects that survive multiple collections are promoted to the old generation.\"}),`\n`,(0,n.jsx)(e.li,{children:\"Young generation collections are more frequent and faster, while old generation collections are less frequent but cover more objects.\"}),`\n`]}),`\n`]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"JavaScript engine implementations\"}),`\n`,(0,n.jsx)(e.p,{children:\"Different JavaScript engines use variations of these algorithms:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"V8 (Google Chrome, Node.js)\"}),\": Uses a combination of generational, mark-and-sweep, and other optimizations for efficient garbage collection.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"SpiderMonkey (Mozilla Firefox)\"}),\": Uses incremental and generational garbage collection.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"JavaScriptCore (Safari)\"}),\": Uses a mark-and-sweep algorithm with generational collection.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Memory leaks\"}),`\n`,(0,n.jsx)(e.p,{children:\"Memory leaks in JavaScript occur when a program fails to release memory that it no longer needs, causing the program to consume more and more memory over time.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Memory leaks in JavaScript can occur due to various reasons, including:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Accidental global variables\"}),\": Unintentionally creating global variables that remain in memory even after they are no longer needed.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Closures\"}),\": Improper use of closures, where an inner function retains references to variables from an outer function's scope, preventing the outer function's scope from being garbage collected.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Event listeners\"}),\": Failing to remove event listeners or callbacks when they are no longer needed, causing the associated objects to remain in memory.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Caching\"}),\": Implementing caches without proper eviction logic, leading to unbounded memory growth over time.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Detached DOM node references\"}),\": Keeping references to detached DOM nodes, preventing them from being garbage collected.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Forgotten timers or callbacks\"}),\": Failing to clear timers or callbacks when they are no longer needed, causing their associated data to remain in memory.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"To avoid leaking memory:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Remove event listeners\"}),\": Always remove event listeners when they are no longer needed.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Clear references in closures\"}),\": Avoid holding unnecessary references in closures.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Manage DOM references\"}),\": Explicitly remove DOM nodes and their references when they are no longer needed.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Avoid global variables\"}),\": Minimize the use of global variables to reduce the risk of inadvertently keeping references alive.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Glossary/Garbage_collection\",children:\"Garbage collection - MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management\",children:\"Memory management\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.linkedin.com/pulse/understanding-memory-management-garbage-collection-aayush-patniya\",children:\"Understanding memory management and garbage collection in JavaScript\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.calibraint.com/blog/garbage-collection-in-javascript\",children:\"JavaScript memory management: A comprehensive guide to garbage collection in JavaScript\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/garbage-collection\",children:\"Garbage collection - javascript.info\"})}),`\n`]})]})}function j(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var k=j;return y(M);})();\n;return Component;"
}