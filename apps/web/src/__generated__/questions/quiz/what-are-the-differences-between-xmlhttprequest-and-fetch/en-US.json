{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-the-differences-between-xmlhttprequest-and-fetch",
    "importance": "medium",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 290,
    "similarQuestions": [],
    "slug": "what-are-the-differences-between-xmlhttprequest-and-fetch",
    "subtitle": null,
    "title": "What are the differences between `XMLHttpRequest` and `fetch()` in JavaScript and browsers?",
    "topics": [
      "javascript",
      "networking"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-the-differences-between-xmlhttprequest-and-fetch/en-US.mdx"
  },
  "solution": "var Component=(()=>{var a=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var m=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),b=(r,e)=>{for(var o in e)c(r,o,{get:e[o],enumerable:!0})},s=(r,e,o,d)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of u(e))!f.call(r,t)&&t!==o&&c(r,t,{get:()=>e[t],enumerable:!(d=p(e,t))||d.enumerable});return r};var y=(r,e,o)=>(o=r!=null?a(g(r)):{},s(e||!r||!r.__esModule?c(o,\"default\",{value:r,enumerable:!0}):o,r)),q=r=>s(c({},\"__esModule\",{value:!0}),r);var i=m((w,h)=>{h.exports=_jsx_runtime});var R={};b(R,{default:()=>j,frontmatter:()=>x});var n=y(i()),x={title:\"What are the differences between `XMLHttpRequest` and `fetch()` in JavaScript and browsers?\"};function l(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",hr:\"hr\",pre:\"pre\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" (XHR) and \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" API are both used for asynchronous HTTP requests in JavaScript (AJAX). \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" offers a cleaner syntax, promise-based approach, and more modern feature set compared to XHR. However, there are some differences:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" event callbacks, while \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" utilizes promise chaining.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"fetch()\"}),\" provides more flexibility in headers and request bodies.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"fetch()\"}),\" support cleaner error handling with \",(0,n.jsx)(e.code,{children:\"catch()\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Handling caching with \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" is difficult but caching is supported by \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" by default in the \",(0,n.jsx)(e.code,{children:\"options.cache\"}),\" object (\",(0,n.jsx)(e.code,{children:\"cache\"}),\" value of second parameter) to \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" or \",(0,n.jsx)(e.code,{children:\"Request()\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"fetch()\"}),\" requires an \",(0,n.jsx)(e.code,{children:\"AbortController\"}),\" for cancelation, while for \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\", it provides \",(0,n.jsx)(e.code,{children:\"abort()\"}),\" property.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" has good support for progress tracking, which \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" lacks.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" is only available in the browser and not natively supported in Node.js environments. On the other hand \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" is part of the JavaScript language and is supported on all modern JavaScript runtimes.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"These days \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" is preferred for its cleaner syntax and modern features.\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.h2,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" vs \",(0,n.jsx)(e.code,{children:\"fetch()\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" (XHR) and \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" are ways to make asynchronous HTTP requests in JavaScript. However, they differ significantly in syntax, promise handling, and feature set.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Syntax and usage\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" is event-driven and requires attaching event listeners to handle response/error states. The basic syntax for creating an \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" object and sending a request is as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/1', true);\nxhr.responseType = 'json';\nxhr.onload = function () {\n  if (xhr.status === 200) {\n    console.log(xhr.response);\n  }\n};\nxhr.send();\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"xhr\"}),\" is an instance of the \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" class. The \",(0,n.jsx)(e.code,{children:\"open\"}),\" method is used to specify the request method, URL, and whether the request should be asynchronous. The \",(0,n.jsx)(e.code,{children:\"onload\"}),\" event is used to handle the response, and the \",(0,n.jsx)(e.code,{children:\"send\"}),\" method is used to send the request.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"fetch()\"}),\" provides a more straightforward and intuitive way of making HTTP requests. It is \",(0,n.jsx)(e.code,{children:\"Promise\"}),\"-based and returns a promise that resolves with the response or rejects with an error. The basic syntax for making a GET request using \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" is as follows:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('https://jsonplaceholder.typicode.com/todos/1')\n  .then((response) => response.text())\n  .then((data) => console.log(data));\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Request headers\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" and \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" support setting request headers. However, \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" provides more flexibility in terms of setting headers, as it supports custom headers and allows for more complex header configurations.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" supports setting request headers using the \",(0,n.jsx)(e.code,{children:\"setRequestHeader\"}),\" method:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`xhr.setRequestHeader('Content-Type', 'application/json');\nxhr.setRequestHeader('Authorization', 'Bearer YOUR_TOKEN');\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\", headers are passed as an object in the second argument to \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('https://jsonplaceholder.typicode.com/todos/1', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    Authorization: 'Bearer YOUR_TOKEN',\n  },\n  body: JSON.stringify({\n    name: 'John Doe',\n    age: 30,\n  }),\n});\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Request body\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" and \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" support sending request bodies. However, \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" provides more flexibility in terms of sending request bodies, as it supports sending JSON data, form data, and more.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" supports sending request bodies using the \",(0,n.jsx)(e.code,{children:\"send\"}),\" method:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\nxhr.open('POST', 'https://jsonplaceholder.typicode.com/todos/1', true);\nxhr.send(\n  JSON.stringify({\n    name: 'John Doe',\n    age: 30,\n  }),\n);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"fetch()\"}),\" supports sending request bodies using the \",(0,n.jsx)(e.code,{children:\"body\"}),\" property in the second argument to \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('https://jsonplaceholder.typicode.com/todos/1', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n  },\n  body: JSON.stringify({\n    name: 'John Doe',\n    age: 30,\n  }),\n});\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Response handling\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" provides a \",(0,n.jsx)(e.code,{children:\"responseType\"}),\" property to set the response format that we are expecting. \",(0,n.jsx)(e.code,{children:\"responseType\"}),\" is \",(0,n.jsx)(e.code,{children:\"'text'\"}),\" by default but it support types likes \",(0,n.jsx)(e.code,{children:\"'text'\"}),\", \",(0,n.jsx)(e.code,{children:\"'arraybuffer'\"}),\", \",(0,n.jsx)(e.code,{children:\"'blob'\"}),\", \",(0,n.jsx)(e.code,{children:\"'document'\"}),\" and \",(0,n.jsx)(e.code,{children:\"'json'\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/1', true);\nxhr.responseType = 'json'; // or 'text', 'blob', 'arraybuffer'\nxhr.onload = function () {\n  if (xhr.status === 200) {\n    console.log(xhr.response);\n  }\n};\nxhr.send();\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"On the other hand, \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" provides a unified \",(0,n.jsx)(e.code,{children:\"Response\"}),\" object with \",(0,n.jsx)(e.code,{children:\"then\"}),\" method for accessing data.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// JSON data\nfetch('https://jsonplaceholder.typicode.com/todos/1')\n  .then((response) => response.json())\n  .then((data) => console.log(data));\n\n// Text data\nfetch('https://jsonplaceholder.typicode.com/todos/1')\n  .then((response) => response.text())\n  .then((data) => console.log(data));\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Error handling\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both support error handling but \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" provides more flexibility in terms of error handling, as it supports handling errors using the \",(0,n.jsx)(e.code,{children:\".catch()\"}),\" method.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" supports error handling using the \",(0,n.jsx)(e.code,{children:\"onerror\"}),\" event:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://jsonplaceholder.typicod.com/todos/1', true); // Typo in URL\nxhr.responseType = 'json';\nxhr.onload = function () {\n  if (xhr.status === 200) {\n    console.log(xhr.response);\n  }\n};\nxhr.onerror = function () {\n  console.error('Error occurred');\n};\nxhr.send();\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"fetch()\"}),\" supports error handling using the \",(0,n.jsx)(e.code,{children:\"catch()\"}),\" method on the returned \",(0,n.jsx)(e.code,{children:\"Promise\"}),\":\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`fetch('https://jsonplaceholder.typicod.com/todos/1') // Typo in URL\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error('Error occurred: ' + error));\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Caching control\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Handling caching with \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" is difficult, and you might need to add a random value to the query string in order to get around the browser cache. Caching is supported by \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" by default in the second parameter of the \",(0,n.jsx)(e.code,{children:\"options\"}),\" object:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const res = await fetch('https://jsonplaceholder.typicode.com/todos/1', {\n  method: 'GET',\n  cache: 'default',\n});\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Other values for the \",(0,n.jsxs)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\",children:[(0,n.jsx)(e.code,{children:\"cache\"}),\" option\"]}),\" include \",(0,n.jsx)(e.code,{children:\"default\"}),\", \",(0,n.jsx)(e.code,{children:\"no-store\"}),\", \",(0,n.jsx)(e.code,{children:\"reload\"}),\", \",(0,n.jsx)(e.code,{children:\"no-cache\"}),\", \",(0,n.jsx)(e.code,{children:\"force-cache\"}),\", and \",(0,n.jsx)(e.code,{children:\"only-if-cached\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Cancelation\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In-flight \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\"s can be canceled by running the \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\"'s \",(0,n.jsx)(e.code,{children:\"abort()\"}),\" method. An \",(0,n.jsx)(e.code,{children:\"abort\"}),\" handler can be attached by assigning to the \",(0,n.jsx)(e.code,{children:\".onabort\"}),\" property if necessary:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\nxhr.open('GET', 'https://jsonplaceholder.typicode.com/todos/1');\nxhr.send();\n// ...\nxhr.onabort = () => console.log('aborted');\nxhr.abort();\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Aborting a \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" requires creating an \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/AbortController\",children:(0,n.jsx)(e.code,{children:\"AbortController\"})}),\" object and passing it to as the \",(0,n.jsx)(e.code,{children:\"signal\"}),\" property of the \",(0,n.jsx)(e.code,{children:\"options\"}),\" object when calling \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const controller = new AbortController();\nconst signal = controller.signal;\n\nfetch('https://jsonplaceholder.typicode.com/todos/1', { signal })\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error('Error occurred: ' + error));\n\n// Abort request.\ncontroller.abort();\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Progress support\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" supports tracking the progress of requests by attaching a handler to the \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" object's progress event. This is especially useful when uploading large files such as videos to track the progress of the upload.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const xhr = new XMLHttpRequest();\n\n// The callback is passed a \\`ProgressEvent\\`.\nxhr.upload.onprogress = (event) => {\n  console.log(Math.round((event.loaded / event.total) * 100) + '%');\n};\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"The callback assigned to \",(0,n.jsx)(e.code,{children:\"onprogress\"}),\" is passed a \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/progress_event\",children:(0,n.jsx)(e.code,{children:\"ProgressEvent\"})}),\":\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"loaded\"}),\" field on the \",(0,n.jsx)(e.code,{children:\"ProgressEvent\"}),\" is a 64-bit integer indicating the amount of work already performed (bytes uploaded/downloaded) by the underlying process.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"The \",(0,n.jsx)(e.code,{children:\"total\"}),\" field on the \",(0,n.jsx)(e.code,{children:\"ProgressEvent\"}),\" is a 64-bit integer representing the total amount of work that the underlying process is in the progress of performing. When downloading resources, this is the \",(0,n.jsx)(e.code,{children:\"Content-Length\"}),\" value of the HTTP request.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"On the other hand, the \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" API does not offer any convenient way to track upload progress. It can be implemented by monitoring the \",(0,n.jsx)(e.code,{children:\"body\"}),\" of the \",(0,n.jsx)(e.code,{children:\"Response\"}),\" object as a fraction of the \",(0,n.jsx)(e.code,{children:\"Content-Length\"}),\" header, but it's quite complicated.\"]}),`\n`,(0,n.jsxs)(e.h2,{children:[\"Choosing between \",(0,n.jsx)(e.code,{children:\"XMLHttpRequest\"}),\" and \",(0,n.jsx)(e.code,{children:\"fetch()\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In modern development scenarios, \",(0,n.jsx)(e.code,{children:\"fetch()\"}),\" is the preferred choice due to its cleaner syntax, promise-based approach, and improved handling of features like error handling, headers, and CORS.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch\",children:\"Fetch API | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\",children:\"XMLHttpRequest | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Request/cache\",children:\"Request: cache property | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/xmlhttprequest\",children:\"XMLHttpRequest | Javascript.info\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://hacks.mozilla.org/2015/03/this-api-is-so-fetching/\",children:\"This API is so Fetching! - Mozilla Hacks\"})}),`\n`]})]})}function v(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(l,r)})):l(r)}var j=v;return q(R);})();\n;return Component;"
}