{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "What's a typical use case for anonymous functions in JavaScript?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/whats-a-typical-use-case-for-anonymous-functions/en-US.mdx"
  },
  "solution": "var Component=(()=>{var u=Object.create;var a=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var g=(o,n)=>()=>(n||o((n={exports:{}}).exports,n),n.exports),b=(o,n)=>{for(var t in n)a(o,t,{get:n[t],enumerable:!0})},c=(o,n,t,i)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let s of m(n))!p.call(o,s)&&s!==t&&a(o,s,{get:()=>n[s],enumerable:!(i=h(n,s))||i.enumerable});return o};var y=(o,n,t)=>(t=o!=null?u(f(o)):{},c(n||!o||!o.__esModule?a(t,\"default\",{value:o,enumerable:!0}):t,o)),w=o=>c(a({},\"__esModule\",{value:!0}),o);var l=g((A,r)=>{r.exports=_jsx_runtime});var I={};b(I,{default:()=>k,frontmatter:()=>v});var e=y(l()),v={title:\"What's a typical use case for anonymous functions in JavaScript?\"};function d(o){let n=Object.assign({h2:\"h2\",p:\"p\",pre:\"pre\",code:\"code\",hr:\"hr\",h3:\"h3\",ul:\"ul\",li:\"li\"},o.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h2,{children:\"TL;DR\"}),`\n`,(0,e.jsx)(n.p,{children:\"Anonymous function in Javascript is a function that does not have any name associated with it. They are typically used as arguments to other functions or assigned to variables.\"}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const arr = [-1, 0, 5, 6];\n\n// The filter method is passed an anonymous function.\narr.filter((x) => x > 1); // [5, 6]\n`})}),`\n`,(0,e.jsx)(n.p,{children:'They are often used as arguments to other functions, known as higher-order functions, which can take functions as input and return a function as output. Anonymous functions can access variables from the outer scope, a concept known as closures, allowing them to \"close over\" and remember the environment in which they were created.'}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// Encapsulating Code\n(function () {\n  // Some code here.\n})();\n\n// Callbacks\nsetTimeout(function () {\n  console.log('Hello world!');\n}, 1000);\n\n// Functional programming constructs\nconst arr = [1, 2, 3];\nconst double = arr.map(function (el) {\n  return el * 2;\n});\nconsole.log(double); // [2, 4, 6]\n`})}),`\n`,(0,e.jsx)(n.hr,{}),`\n`,(0,e.jsx)(n.h2,{children:\"Anonymous functions\"}),`\n`,(0,e.jsx)(n.p,{children:\"Anonymous functions provide a more concise way to define functions, especially for simple operations or callbacks. Besides that, they can also be used in the following scenarios\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Immediate execution\"}),`\n`,(0,e.jsx)(n.p,{children:\"Anonymous functions are commonly used in Immediately Invoked Function Expressions (IIFEs) to encapsulate code within a local scope. This prevents variables declared within the function from leaking to the global scope and polluting the global namespace.\"}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`// This is an IIFE\n(function () {\n  var x = 10;\n  console.log(x); // 10\n})();\n\n// x is not accessible here\nconsole.log(typeof x); // undefined\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"In the above example, the IIFE creates a local scope for the variable \",(0,e.jsx)(n.code,{children:\"x\"}),\". As a result, \",(0,e.jsx)(n.code,{children:\"x\"}),\" is not accessible outside the IIFE, thus preventing it from leaking into the global scope.\"]}),`\n`,(0,e.jsx)(n.h3,{children:\"Callbacks\"}),`\n`,(0,e.jsx)(n.p,{children:\"Anonymous functions can be used as callbacks that are used once and do not need to be used anywhere else. The code will seem more self-contained and readable when handlers are defined right inside the code calling them, rather than having to search elsewhere to find the function body.\"}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`setTimeout(() => {\n  console.log('Hello world!');\n}, 1000);\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Higher-order functions\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"It is used as arguments to functional programming constructs like Higher-order functions or Lodash (similar to callbacks). Higher-order functions take other functions as arguments or return them as results. Anonymous functions are often used with higher-order functions like \",(0,e.jsx)(n.code,{children:\"map()\"}),\", \",(0,e.jsx)(n.code,{children:\"filter()\"}),\", and \",(0,e.jsx)(n.code,{children:\"reduce()\"}),\".\"]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const arr = [1, 2, 3];\nconst double = arr.map((el) => {\n  return el * 2;\n});\nconsole.log(double); // [2, 4, 6]\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Event Handling\"}),`\n`,(0,e.jsx)(n.p,{children:\"In React, anonymous functions are widely used for defining callback functions inline for handling events and passing callbacks as props.\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-jsx\",children:`function App() {\n  return <button onClick={() => console.log('Clicked!')}>Click Me</button>;\n}\n`})}),`\n`,(0,e.jsx)(n.h2,{children:\"Follow-Up Questions\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:\"How do anonymous functions differ from named functions?\"}),`\n`,(0,e.jsx)(n.li,{children:\"Can you explain the difference between arrow functions and anonymous functions?\"}),`\n`]})]})}function x(o={}){let{wrapper:n}=o.components||{};return n?(0,e.jsx)(n,Object.assign({},o,{children:(0,e.jsx)(d,o)})):d(o)}var k=x;return w(I);})();\n;return Component;"
}