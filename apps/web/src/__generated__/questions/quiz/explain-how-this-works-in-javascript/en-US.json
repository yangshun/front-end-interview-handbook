{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [
      "linkedin"
    ],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/explain-how-this-works-in-javascript",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 60,
    "similarQuestions": [],
    "slug": "explain-how-this-works-in-javascript",
    "subtitle": null,
    "title": "Explain how `this` works in JavaScript",
    "topics": [
      "javascript",
      "oop"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/explain-how-this-works-in-javascript/en-US.mdx"
  },
  "solution": "var Component=(()=>{var a=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var m=(o,n)=>()=>(n||o((n={exports:{}}).exports,n),n.exports),g=(o,n)=>{for(var i in n)c(o,i,{get:n[i],enumerable:!0})},s=(o,n,i,h)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let t of p(n))!b.call(o,t)&&t!==i&&c(o,t,{get:()=>n[t],enumerable:!(h=u(n,t))||h.enumerable});return o};var w=(o,n,i)=>(i=o!=null?a(f(o)):{},s(n||!o||!o.__esModule?c(i,\"default\",{value:o,enumerable:!0}):i,o)),j=o=>s(c({},\"__esModule\",{value:!0}),o);var r=m((J,l)=>{l.exports=_jsx_runtime});var T={};g(T,{default:()=>x,frontmatter:()=>v});var e=w(r()),v={title:\"Explain how `this` works in JavaScript\"};function d(o){let n=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ol:\"ol\",li:\"li\",a:\"a\",hr:\"hr\",h3:\"h3\",pre:\"pre\",ul:\"ul\"},o.components);return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h2,{children:\"TL;DR\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"There's no simple explanation for \",(0,e.jsx)(n.code,{children:\"this\"}),\"; it is one of the most confusing concepts in JavaScript because it's behavior differs from many other programming languages. The one-liner explanation of the \",(0,e.jsx)(n.code,{children:\"this\"}),\" keyword is that it is a dynamic reference to the context in which a function is executed.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"A longer explanation follows is that \",(0,e.jsx)(n.code,{children:\"this\"}),\" follows these rules:\"]}),`\n`,(0,e.jsxs)(n.ol,{children:[`\n`,(0,e.jsxs)(n.li,{children:[\"If the \",(0,e.jsx)(n.code,{children:\"new\"}),\" keyword is used when calling the function, meaning the function was used as a function constructor, the \",(0,e.jsx)(n.code,{children:\"this\"}),\" inside the function is the newly-created object instance.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"If \",(0,e.jsx)(n.code,{children:\"this\"}),\" is used in a \",(0,e.jsx)(n.code,{children:\"class\"}),\" \",(0,e.jsx)(n.code,{children:\"constructor\"}),\", the \",(0,e.jsx)(n.code,{children:\"this\"}),\" inside the \",(0,e.jsx)(n.code,{children:\"constructor\"}),\" is the newly-created object instance.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"If \",(0,e.jsx)(n.code,{children:\"apply()\"}),\", \",(0,e.jsx)(n.code,{children:\"call()\"}),\", or \",(0,e.jsx)(n.code,{children:\"bind()\"}),\" is used to call/create a function, \",(0,e.jsx)(n.code,{children:\"this\"}),\" inside the function is the object that is passed in as the argument.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"If a function is called as a method (e.g. \",(0,e.jsx)(n.code,{children:\"obj.method()\"}),\")\\u200A\\u2014\\u200A\",(0,e.jsx)(n.code,{children:\"this\"}),\" is the object that the function is a property of.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"If a function is invoked as a free function invocation, meaning it was invoked without any of the conditions present above, \",(0,e.jsx)(n.code,{children:\"this\"}),\" is the global object. In the browser, the global object is the \",(0,e.jsx)(n.code,{children:\"window\"}),\" object. If in strict mode (\",(0,e.jsx)(n.code,{children:\"'use strict';\"}),\"), \",(0,e.jsx)(n.code,{children:\"this\"}),\" will be \",(0,e.jsx)(n.code,{children:\"undefined\"}),\" instead of the global object.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"If multiple of the above rules apply, the rule that is higher wins and will set the \",(0,e.jsx)(n.code,{children:\"this\"}),\" value.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[\"If the function is an ES2015 arrow function, it ignores all the rules above and receives the \",(0,e.jsx)(n.code,{children:\"this\"}),\" value of its surrounding scope at the time it is created.\"]}),`\n`]}),`\n`,(0,e.jsxs)(n.p,{children:[\"For an in-depth explanation, do check out \",(0,e.jsx)(n.a,{href:\"https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3\",children:\"Arnav Aggrawal's article on Medium\"}),\".\"]}),`\n`,(0,e.jsx)(n.hr,{}),`\n`,(0,e.jsxs)(n.h2,{children:[(0,e.jsx)(n.code,{children:\"this\"}),\" keyword\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"In JavaScript, \",(0,e.jsx)(n.code,{children:\"this\"}),\" is a keyword that refers to the current execution context of a function or script. It's a fundamental concept in JavaScript, and understanding how \",(0,e.jsx)(n.code,{children:\"this\"}),\" works is crucial for building robust and maintainable applications.\"]}),`\n`,(0,e.jsx)(n.h3,{children:\"Used globally\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"In the global scope, \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the global object, which is the \",(0,e.jsx)(n.code,{children:\"window\"}),\" object in a web browser or the \",(0,e.jsx)(n.code,{children:\"global\"}),\" object in a Node.js environment.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`console.log(this); // In a browser, this will log the window object (for non-strict mode).\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Within a regular function call\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"When a function is called in the global context or as a standalone function, \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the global object (in non-strict mode) or \",(0,e.jsx)(n.code,{children:\"undefined\"}),\" (in strict mode).\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`function showThis() {\n  console.log(this);\n}\n\nshowThis(); // In non-strict mode: Window (global object). In strict mode: undefined.\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Within a method call\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"When a function is called as a method of an object, \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the object that the method is called on.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const obj = {\n  name: 'John',\n  showThis: function () {\n    console.log(this);\n  },\n};\n\nobj.showThis(); // { name: 'John', showThis: \\u0192 }\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"Note that if you do the following, it is as good as a regular function call and not a method call. \",(0,e.jsx)(n.code,{children:\"this\"}),\" has lost its context and no longer points to \",(0,e.jsx)(n.code,{children:\"obj\"}),\".\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const obj = {\n  name: 'John',\n  showThis: function () {\n    console.log(this);\n  },\n};\n\nconst showThisStandalone = obj.showThis;\nshowThisStandalone(); // In non-strict mode: Window (global object). In strict mode: undefined.\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Within a function constructor\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"When a function is used as a constructor (called with the \",(0,e.jsx)(n.code,{children:\"new\"}),\" keyword), \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the newly-created instance. In the following example, \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the \",(0,e.jsx)(n.code,{children:\"Person\"}),\" object being created, and the \",(0,e.jsx)(n.code,{children:\"name\"}),\" property is set on that object.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`function Person(name) {\n  this.name = name;\n}\n\nconst person = new Person('John');\nconsole.log(person.name); // \"John\"\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Within class constructor and methods\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"In ES2015 classes, \",(0,e.jsx)(n.code,{children:\"this\"}),\" behaves as it does in object methods. It refers to the instance of the class.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`class Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  showThis() {\n    console.log(this);\n  }\n}\n\nconst person = new Person('John');\nperson.showThis(); // Person\\xA0{name: 'John'}\n\nconst showThisStandalone = person.showThis;\nshowThisStandalone(); // \\`undefined\\` because all parts of a class' body are strict mode.\n`})}),`\n`,(0,e.jsxs)(n.h3,{children:[\"Explicitly binding \",(0,e.jsx)(n.code,{children:\"this\"})]}),`\n`,(0,e.jsxs)(n.p,{children:[\"You can use \",(0,e.jsx)(n.code,{children:\"bind()\"}),\", \",(0,e.jsx)(n.code,{children:\"call()\"}),\", or \",(0,e.jsx)(n.code,{children:\"apply()\"}),\" to explicitly set the value of \",(0,e.jsx)(n.code,{children:\"this\"}),\" for a function.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"Using the \",(0,e.jsx)(n.code,{children:\"call()\"}),\" and \",(0,e.jsx)(n.code,{children:\"apply()\"}),\" methods allow you to explicitly set the value of \",(0,e.jsx)(n.code,{children:\"this\"}),\" when calling the function.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`function showThis() {\n  console.log(this);\n}\nconst obj = { name: 'John' };\n\nshowThis.call(obj); // { name: 'John' }\nshowThis.apply(obj); // { name: 'John' }\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"The \",(0,e.jsx)(n.code,{children:\"bind()\"}),\" method creates a new function with \",(0,e.jsx)(n.code,{children:\"this\"}),\" bound to the specified value.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`function showThis() {\n  console.log(this);\n}\nconst obj = { name: 'John' };\n\nconst boundFunc = showThis.bind(obj);\nboundFunc(); // { name: 'John' }\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Within arrow functions\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"Arrow functions do not have their own \",(0,e.jsx)(n.code,{children:\"this\"}),\" context. Instead, the \",(0,e.jsx)(n.code,{children:\"this\"}),\" is lexically scoped, which means it inherits the \",(0,e.jsx)(n.code,{children:\"this\"}),\" value from its surrounding scope at the time they are defined.\"]}),`\n`,(0,e.jsxs)(n.p,{children:[\"In this example, \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the global object (window or global), because the arrow function is not bound to the \",(0,e.jsx)(n.code,{children:\"person\"}),\" object.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const person = {\n  name: 'John',\n  sayHello: () => {\n    console.log(\\`Hello, my name is \\${this.name}!\\`);\n  },\n};\n\nperson.sayHello(); // \"Hello, my name is undefined!\"\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"In the following example, the \",(0,e.jsx)(n.code,{children:\"this\"}),\" in the arrow function will be the \",(0,e.jsx)(n.code,{children:\"this\"}),\" value of its enclosing context, so it depends on how \",(0,e.jsx)(n.code,{children:\"showThis()\"}),\" is called.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const obj = {\n  name: 'John',\n  showThis: function () {\n    const arrowFunc = () => {\n      console.log(this);\n    };\n    arrowFunc();\n  },\n};\n\nobj.showThis(); // { name: 'John', showThis: \\u0192 }\n\nconst showThisStandalone = obj.showThis;\nshowThisStandalone(); // In non-strict mode: Window (global object). In strict mode: undefined.\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"Therefore, the \",(0,e.jsx)(n.code,{children:\"this\"}),\" value in arrow functions cannot be set by \",(0,e.jsx)(n.code,{children:\"bind()\"}),\", \",(0,e.jsx)(n.code,{children:\"apply()\"}),\" or \",(0,e.jsx)(n.code,{children:\"call()\"}),\" methods, nor does it point to the current object in object methods.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`const obj = {\n  name: 'Alice',\n  regularFunction: function () {\n    console.log('Regular function:', this.name);\n  },\n  arrowFunction: () => {\n    console.log('Arrow function:', this.name);\n  },\n};\n\nconst anotherObj = {\n  name: 'Bob',\n};\n\n// Using call/apply/bind with a regular function\nobj.regularFunction.call(anotherObj); // Regular function: Bob\nobj.regularFunction.apply(anotherObj); // Regular function: Bob\nconst boundRegularFunction = obj.regularFunction.bind(anotherObj);\nboundRegularFunction(); // Regular function: Bob\n\n// Using call/apply/bind with an arrow function, \\`this\\` refers to the global scope and cannot be modified.\nobj.arrowFunction.call(anotherObj); // Arrow function: window/undefined (depending if strict mode)\nobj.arrowFunction.apply(anotherObj); // Arrow function: window/undefined (depending if strict mode)\nconst boundArrowFunction = obj.arrowFunction.bind(anotherObj);\nboundArrowFunction(); // Arrow function: window/undefined (depending if strict mode)\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Within event handlers\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"When a function is called as a DOM event handler, \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the element that triggered the event. In this example, \",(0,e.jsx)(n.code,{children:\"this\"}),\" refers to the \",(0,e.jsx)(n.code,{children:\"<button>\"}),\" element that was clicked.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-html\",children:`<button id=\"my-button\" onclick=\"console.log(this)\">Click me</button>\n<!-- Logs the button element -->\n`})}),`\n`,(0,e.jsx)(n.p,{children:\"When setting an event handler using JavaScript, this also refers to the element that received the event.\"}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`document.getElementById('my-button').addEventListener('click', function () {\n  console.log(this); // Logs the button element\n});\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"As mentioned above, ES2015 introduces \",(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\",children:\"arrow functions\"}),\" which uses the \",(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_separate_this\",children:\"enclosing lexical scope\"}),\". This is usually convenient, but does prevent the caller from defining the \",(0,e.jsx)(n.code,{children:\"this\"}),\" context via \",(0,e.jsx)(n.code,{children:\".call\"}),\"/\",(0,e.jsx)(n.code,{children:\".apply\"}),\"/\",(0,e.jsx)(n.code,{children:\".bind\"}),\". One of the consequences is that DOM event handlers will not properly bind \",(0,e.jsx)(n.code,{children:\"this\"}),\" in your event handler functions if you define the callback parameters to \",(0,e.jsx)(n.code,{children:\".addEventListener()\"}),\" using arrow functions.\"]}),`\n`,(0,e.jsx)(n.pre,{children:(0,e.jsx)(n.code,{className:\"language-js\",children:`document.getElementById('my-button').addEventListener('click', () => {\n  console.log(this); // Window / undefined (depending on whether strict mode) instead of the button element.\n});\n`})}),`\n`,(0,e.jsxs)(n.p,{children:[\"In summary, \",(0,e.jsx)(n.code,{children:\"this\"}),\" in JavaScript refers to the current execution context of a function or script, and its value can change depending on the context in which it is used. Understanding how \",(0,e.jsx)(n.code,{children:\"this\"}),\" works is essential for building robust and maintainable JavaScript applications.\"]}),`\n`,(0,e.jsx)(n.h2,{children:\"Further reading\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this\",children:\"this - JavaScript | MDN\"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsxs)(n.a,{href:\"https://medium.com/m/global-identity-2?redirectUrl=https%3A%2F%2Fcodeburst.io%2Fthe-simple-rules-to-this-in-javascript-35d97f31bde3\",children:[\"The Simple Rules to \",(0,e.jsx)(n.code,{children:\"this\"}),\" in Javascript\"]})}),`\n`]})]})}function y(o={}){let{wrapper:n}=o.components||{};return n?(0,e.jsx)(n,Object.assign({},o,{children:(0,e.jsx)(d,o)})):d(o)}var x=y;return j(T);})();\n;return Component;"
}