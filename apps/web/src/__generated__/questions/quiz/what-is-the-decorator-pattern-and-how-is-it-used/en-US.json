{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "easy",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-is-the-decorator-pattern-and-how-is-it-used",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 999,
    "similarQuestions": [],
    "slug": "what-is-the-decorator-pattern-and-how-is-it-used",
    "subtitle": null,
    "title": "What is the Decorator pattern and how is it used?",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-is-the-decorator-pattern-and-how-is-it-used/en-US.mdx"
  },
  "solution": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var v=(r,n)=>()=>(n||r((n={exports:{}}).exports,n),n.exports),y=(r,n)=>{for(var t in n)o(r,t,{get:n[t],enumerable:!0})},c=(r,n,t,a)=>{if(n&&typeof n==\"object\"||typeof n==\"function\")for(let i of p(n))!m.call(r,i)&&i!==t&&o(r,i,{get:()=>n[i],enumerable:!(a=g(n,i))||a.enumerable});return r};var D=(r,n,t)=>(t=r!=null?u(f(r)):{},c(n||!r||!r.__esModule?o(t,\"default\",{value:r,enumerable:!0}):t,r)),b=r=>c(o({},\"__esModule\",{value:!0}),r);var l=v((P,s)=>{s.exports=_jsx_runtime});var w={};y(w,{default:()=>h,frontmatter:()=>C});var e=D(l()),C={title:\"What is the Decorator pattern and how is it used?\"};function d(r){let n={a:\"a\",code:\"code\",h2:\"h2\",h3:\"h3\",h4:\"h4\",hr:\"hr\",li:\"li\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...r.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(n.h2,{children:\"TL;DR\"}),`\n`,(0,e.jsx)(n.p,{children:\"The Decorator pattern is a structural design pattern that allows behavior to be added to individual objects, dynamically, without affecting the behavior of other objects from the same class. It is used to extend the functionalities of objects by wrapping them with additional behavior. In JavaScript, this can be achieved using higher-order functions or classes.\"}),`\n`,(0,e.jsxs)(n.p,{children:[\"For example, if you have a \",(0,e.jsx)(n.code,{children:\"Car\"}),\" class and you want to add features like \",(0,e.jsx)(n.code,{children:\"GPS\"}),\" or \",(0,e.jsx)(n.code,{children:\"Sunroof\"}),\" without modifying the \",(0,e.jsx)(n.code,{children:\"Car\"}),\" class itself, you can create decorators for these features.\"]}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`class Car {\n  drive() {\n    return 'Driving';\n  }\n}\n\nclass CarDecorator {\n  constructor(car) {\n    this.car = car;\n  }\n\n  drive() {\n    return this.car.drive();\n  }\n}\n\nclass GPSDecorator extends CarDecorator {\n  drive() {\n    return \\`\\${super.drive()} with GPS\\`;\n  }\n}\n\nconst myCar = new Car();\nconst myCarWithGPS = new GPSDecorator(myCar);\nconsole.log(myCarWithGPS.drive()); // \"Driving with GPS\"\n`})}),`\n`,(0,e.jsx)(n.hr,{}),`\n`,(0,e.jsx)(n.h2,{children:\"What is the Decorator pattern and how is it used?\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Definition\"}),`\n`,(0,e.jsx)(n.p,{children:\"The Decorator pattern is a structural design pattern that allows you to dynamically add behavior and responsibilities to objects without modifying their code. This pattern creates a set of decorator classes that are used to wrap concrete components.\"}),`\n`,(0,e.jsx)(n.h3,{children:\"Use cases\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Adding functionalities\"}),\": When you need to add functionalities to objects without altering their structure.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Flexible and reusable code\"}),\": When you want to create flexible and reusable code by composing behaviors.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Single Responsibility Principle\"}),\": When you want to adhere to the Single Responsibility Principle by dividing functionalities into different classes.\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Implementation in JavaScript\"}),`\n`,(0,e.jsx)(n.h4,{children:\"Using classes\"}),`\n`,(0,e.jsx)(n.p,{children:\"In JavaScript, the Decorator pattern can be implemented using classes. Here is an example:\"}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`class Car {\n  drive() {\n    return 'Driving';\n  }\n}\n\nclass CarDecorator {\n  constructor(car) {\n    this.car = car;\n  }\n\n  drive() {\n    return this.car.drive();\n  }\n}\n\nclass GPSDecorator extends CarDecorator {\n  drive() {\n    return \\`\\${super.drive()} with GPS\\`;\n  }\n}\n\nclass SunroofDecorator extends CarDecorator {\n  drive() {\n    return \\`\\${super.drive()} with Sunroof\\`;\n  }\n}\n\nconst myCar = new Car();\nconst myCarWithGPS = new GPSDecorator(myCar);\nconst myCarWithGPSAndSunroof = new SunroofDecorator(myCarWithGPS);\n\nconsole.log(myCarWithGPSAndSunroof.drive()); // \"Driving with GPS with Sunroof\"\n`})}),`\n`,(0,e.jsx)(n.h4,{children:\"Using higher-order functions\"}),`\n`,(0,e.jsx)(n.p,{children:\"Another way to implement the Decorator pattern in JavaScript is by using higher-order functions:\"}),`\n`,(0,e.jsx)(n.pre,{live:!0,children:(0,e.jsx)(n.code,{className:\"language-js\",children:`function car() {\n  return {\n    drive: () => 'Driving',\n  };\n}\n\nfunction gpsDecorator(car) {\n  return {\n    drive: () => \\`\\${car.drive()} with GPS\\`,\n  };\n}\n\nfunction sunroofDecorator(car) {\n  return {\n    drive: () => \\`\\${car.drive()} with Sunroof\\`,\n  };\n}\n\nlet myCar = car();\nmyCar = gpsDecorator(myCar);\nmyCar = sunroofDecorator(myCar);\n\nconsole.log(myCar.drive()); // \"Driving with GPS with Sunroof\"\n`})}),`\n`,(0,e.jsx)(n.h3,{children:\"Advantages\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Open/Closed Principle\"}),\": Classes are open for extension but closed for modification.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Flexible\"}),\": Allows for the dynamic composition of behaviors.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Reusable\"}),\": Decorators can be reused across different objects.\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h3,{children:\"Disadvantages\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Complexity\"}),\": Can lead to a large number of small classes or functions.\"]}),`\n`,(0,e.jsxs)(n.li,{children:[(0,e.jsx)(n.strong,{children:\"Debugging\"}),\": Can be harder to debug due to the added layers of abstraction.\"]}),`\n`]}),`\n`,(0,e.jsx)(n.h2,{children:\"Further reading\"}),`\n`,(0,e.jsxs)(n.ul,{children:[`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://en.wikipedia.org/wiki/Decorator_pattern\",children:\"Decorator Pattern on Wikipedia\"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#class_decorators\",children:\"MDN Web Docs: Decorators\"})}),`\n`,(0,e.jsx)(n.li,{children:(0,e.jsx)(n.a,{href:\"https://refactoring.guru/design-patterns/decorator\",children:\"Refactoring Guru: Decorator Pattern\"})}),`\n`]})]})}function h(r={}){let{wrapper:n}=r.components||{};return n?(0,e.jsx)(n,{...r,children:(0,e.jsx)(d,{...r})}):d(r)}return b(w);})();\n;return Component;"
}