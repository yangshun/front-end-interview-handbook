{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [
      "linkedin",
      "google",
      "amazon",
      "bytedance",
      "atlassian"
    ],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-the-pros-and-cons-of-using-promises-instead-of-callbacks",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 260,
    "similarQuestions": [],
    "slug": "what-are-the-pros-and-cons-of-using-promises-instead-of-callbacks",
    "subtitle": null,
    "title": "What are the pros and cons of using Promises instead of callbacks in JavaScript?",
    "topics": [
      "async",
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-the-pros-and-cons-of-using-promises-instead-of-callbacks/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var b=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),D=(a,e)=>{for(var t in e)l(a,t,{get:e[t],enumerable:!0})},i=(a,e,t,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of m(e))!g.call(a,r)&&r!==t&&l(a,r,{get:()=>e[r],enumerable:!(o=u(e,r))||o.enumerable});return a};var v=(a,e,t)=>(t=a!=null?h(p(a)):{},i(e||!a||!a.__esModule?l(t,\"default\",{value:a,enumerable:!0}):t,a)),f=a=>i(l({},\"__esModule\",{value:!0}),a);var s=b((T,c)=>{c.exports=_jsx_runtime});var P={};D(P,{default:()=>k,frontmatter:()=>y});var n=v(s()),y={title:\"What are the pros and cons of using Promises instead of callbacks in JavaScript?\"};function d(a){let e=Object.assign({h2:\"h2\",p:\"p\",hr:\"hr\",h3:\"h3\",pre:\"pre\",code:\"code\",ul:\"ul\",li:\"li\",a:\"a\"},a.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:\"Promises offer a cleaner alternative to callbacks, helping to avoid callback hell and making asynchronous code more readable. They facilitate writing sequential and parallel asynchronous operations with ease. However, using promises may introduce slightly more complex code.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Pros\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Avoid callback hell which can be unreadable.\"}),`\n`,(0,n.jsx)(e.p,{children:`Callback hell, also known as the \"pyramid of doom,\" is a phenomenon that occurs when you have multiple nested callbacks in your code. This can lead to code that is difficult to read, maintain, and debug. Here's an example of callback hell:`}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function getFirstData(callback) {\n  setTimeout(() => {\n    callback({ id: 1, title: 'First Data' });\n  }, 1000);\n}\n\nfunction getSecondData(data, callback) {\n  setTimeout(() => {\n    callback({ id: data.id, title: data.title + ' Second Data' });\n  }, 1000);\n}\n\nfunction getThirdData(data, callback) {\n  setTimeout(() => {\n    callback({ id: data.id, title: data.title + ' Third Data' });\n  }, 1000);\n}\n\n// Callback hell\ngetFirstData((data) => {\n  getSecondData(data, (data) => {\n    getThirdData(data, (result) => {\n      console.log(result); // Output: {id: 1, title: \"First Data Second Data Third Data\"}\n    });\n  });\n});\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Promises address the problem of callback hell by providing a more linear and readable structure for your code.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Example of sequential asynchronous code using setTimeout and Promises\nfunction getFirstData() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ id: 1, title: 'First Data' });\n    }, 1000);\n  });\n}\n\nfunction getSecondData(data) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ id: data.id, title: data.title + ' Second Data' });\n    }, 1000);\n  });\n}\n\nfunction getThirdData(data) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ id: data.id, title: data.title + ' Third Data' });\n    }, 1000);\n  });\n}\n\ngetFirstData()\n  .then(getSecondData)\n  .then(getThirdData)\n  .then((data) => {\n    console.log(data); // Output: {id: 1, title: \"First Data Second Data Third Data\"}\n  })\n  .catch((error) => console.error('Error:', error));\n`})}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Makes it easy to write sequential asynchronous code that is readable with \",(0,n.jsx)(e.code,{children:\".then()\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the above code example, we use \",(0,n.jsx)(e.code,{children:\".then()\"}),\" method to chain these Promises together, allowing the code to execute sequentially. It provides a cleaner and more manageable way to handle asynchronous operations in JavaScript.\"]}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Makes it easy to write parallel asynchronous code with \",(0,n.jsx)(e.code,{children:\"Promise.all()\"}),\".\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\"Promise.all()\"}),\" and callbacks can be used to write parallel asynchronous code. However, \",(0,n.jsx)(e.code,{children:\"Promise.all()\"}),\" provides a more concise and readable way to handle multiple Promises, especially when dealing with complex asynchronous workflows.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function getData1() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ id: 1, title: 'Data 1' });\n    }, 1000);\n  });\n}\n\nfunction getData2() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ id: 2, title: 'Data 2' });\n    }, 1000);\n  });\n}\n\nfunction getData3() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve({ id: 3, title: 'Data 3' });\n    }, 1000);\n  });\n}\n\nPromise.all([getData1(), getData2(), getData3()])\n  .then((results) => {\n    console.log(results); // Output: [[{ id: 1, title: 'Data 1' }, { id: 2, title: 'Data 2' }, { id: 3, title: 'Data 3' }]\n  })\n  .catch((error) => {\n    console.error('Error:', error);\n  });\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"With promises, these scenarios which are present in callbacks-only coding, will not happen:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Call the callback too early\"}),`\n`,(0,n.jsx)(e.li,{children:\"Call the callback too late (or never)\"}),`\n`,(0,n.jsx)(e.li,{children:\"Call the callback too few or too many times\"}),`\n`,(0,n.jsx)(e.li,{children:\"Fail to pass along any necessary environment/parameters\"}),`\n`,(0,n.jsx)(e.li,{children:\"Swallow any errors/exceptions that may happen\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Cons\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Slightly more complex code (debatable).\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Practice\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Try implementing your own \",(0,n.jsxs)(e.a,{href:\"/questions/javascript/promise-resolve\",children:[(0,n.jsx)(e.code,{children:\"Promise.resolve()\"}),\" method\"]}),\", \",(0,n.jsxs)(e.a,{href:\"/questions/javascript/promise-reject\",children:[(0,n.jsx)(e.code,{children:\"Promise.reject()\"}),\" method\"]}),\" and \",(0,n.jsxs)(e.a,{href:\"/questions/javascript/promise-all\",children:[(0,n.jsx)(e.code,{children:\"Promise.all()\"}),\" method\"]}),\" on GreatFrontEnd.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\",children:\"Promise | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Glossary/Callback_function\",children:\"Callback function | MDN\"})}),`\n`]})]})}function w(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,Object.assign({},a,{children:(0,n.jsx)(d,a)})):d(a)}var k=w;return f(P);})();\n;return Component;"
}