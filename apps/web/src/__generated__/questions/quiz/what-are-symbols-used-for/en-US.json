{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "What are `Symbol`s used for in JavaScript?"
  },
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [
      "bytedance"
    ],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-symbols-used-for",
    "importance": "medium",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 430,
    "similarQuestions": [],
    "slug": "what-are-symbols-used-for",
    "subtitle": null,
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-symbols-used-for/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var b=Object.getOwnPropertyNames;var y=Object.getPrototypeOf,u=Object.prototype.hasOwnProperty;var p=(o,e)=>()=>(e||o((e={exports:{}}).exports,e),e.exports),g=(o,e)=>{for(var l in e)i(o,l,{get:e[l],enumerable:!0})},t=(o,e,l,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of b(e))!u.call(o,r)&&r!==l&&i(o,r,{get:()=>e[r],enumerable:!(c=m(e,r))||c.enumerable});return o};var S=(o,e,l)=>(l=o!=null?h(y(o)):{},t(e||!o||!o.__esModule?i(l,\"default\",{value:o,enumerable:!0}):l,o)),f=o=>t(i({},\"__esModule\",{value:!0}),o);var s=p((q,a)=>{a.exports=_jsx_runtime});var k={};g(k,{default:()=>w,frontmatter:()=>j});var n=S(s()),j={title:\"What are `Symbol`s used for in JavaScript?\"};function d(o){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\",strong:\"strong\",hr:\"hr\",ul:\"ul\",li:\"li\",blockquote:\"blockquote\",h3:\"h3\",a:\"a\"},o.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s in JavaScript are a new primitive data type introduced in ES6 (ECMAScript 2015). They are unique and immutable identifiers that is primarily for object property keys to avoid name collisions. These values can be created using \",(0,n.jsx)(e.code,{children:\"Symbol(...)\"}),\" function, and each \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\" value is guaranteed to be unique, even if they have the same key/description. \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\" properties are not enumerable in \",(0,n.jsx)(e.code,{children:\"for...in\"}),\" loops or \",(0,n.jsx)(e.code,{children:\"Object.keys()\"}),\", making them suitable for creating private/internal object state.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let sym1 = Symbol();\nlet sym2 = Symbol('myKey');\n\nconsole.log(typeof sym1); // \"symbol\"\nconsole.log(sym1 === sym2); // false, because each symbol is unique\n\nlet obj = {};\nlet sym = Symbol('uniqueKey');\n\nobj[sym] = 'value';\nconsole.log(obj[sym]); // \"value\"\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note\"}),\": The \",(0,n.jsx)(e.code,{children:\"Symbol()\"}),\" function must be called without the \",(0,n.jsx)(e.code,{children:\"new\"}),\" keyword. It is not exactly a constructor because it can only be called as a function instead of with \",(0,n.jsx)(e.code,{children:\"new Symbol()\"}),\".\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.h2,{children:[(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s in JavaScript\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Symbols in JavaScript are a unique and immutable data type used primarily for object property keys to avoid name collisions.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Key characteristics\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Uniqueness\"}),\": Each Symbol value is unique, even if they have the same description.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Immutability\"}),\": Symbol values are immutable, meaning their value cannot be changed.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Non-enumerable\"}),\": Symbol properties are not included in for...in loops or Object.keys().\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.h2,{children:[\"Creating \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s can be created using the \",(0,n.jsx)(e.code,{children:\"Symbol()\"}),\" function:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const sym1 = Symbol();\nconst sym2 = Symbol('uniqueKey');\n\nconsole.log(typeof sym1); // \"symbol\"\nconsole.log(sym1 === sym2); // false, because each symbol is unique\n`})}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"Symbol(..)\"}),\" function must be called without the \",(0,n.jsx)(e.code,{children:\"new\"}),\" keyword.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.h2,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s as \",(0,n.jsx)(e.code,{children:\"object\"}),\" property keys\"]}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s can be used to add properties to an object without risk of name collision:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const obj = {};\nconst sym = Symbol('uniqueKey');\n\nobj[sym] = 'value';\nconsole.log(obj[sym]); // \"value\"\n`})}),`\n`,(0,n.jsxs)(e.h2,{children:[(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s are not enumerable\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Symbol\"}),\" properties are not included in \",(0,n.jsx)(e.code,{children:\"for...in\"}),\" loops or\",(0,n.jsx)(e.code,{children:\" Object.keys()\"}),\".\"]}),`\n`,(0,n.jsx)(e.li,{children:\"This makes them suitable for creating private/internal object state.\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use\",(0,n.jsx)(e.code,{children:\" Object.getOwnPropertySymbols(obj)\"}),\" to get all symbol properties on an object.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const mySymbol = Symbol('privateProperty');\nconst obj = {\n  name: 'John',\n  [mySymbol]: 42,\n};\n\nconsole.log(Object.keys(obj)); // Output: ['name']\nconsole.log(obj[mySymbol]); // Output: 42\n`})}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Global \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\" registry\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"You can create global \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s using \",(0,n.jsx)(e.code,{children:\"Symbol.for('key')\"}),\", which creates a new \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\" in the global registry if it doesn't exist, or returns the existing one. This allows you to reuse \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s across different parts of your code base or even across different code bases.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const globalSym1 = Symbol.for('globalKey');\nconst globalSym2 = Symbol.for('globalKey');\n\nconsole.log(globalSym1 === globalSym2); // true\n\nconst key = Symbol.keyFor(globalSym1);\nconsole.log(key); // \"globalKey\"\n`})}),`\n`,(0,n.jsxs)(e.h2,{children:[\"Well-known \",(0,n.jsx)(e.code,{children:\"Symbol\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"JavaScript includes several built-in \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s, referred as well-known \",(0,n.jsx)(e.code,{children:\"Symbol\"}),\"s.\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.code,{children:\"Symbol.iterator\"})}),\": Defines the default \",(0,n.jsx)(e.code,{children:\"iterator\"}),\" for an object.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.code,{children:\"Symbol.toStringTag\"})}),\": Used to create a string description for an object.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:(0,n.jsx)(e.code,{children:\"Symbol.hasInstance\"})}),\": Used to determine if an object is an instance of a constructor.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"Symbol.iterator\"})}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let iterable = {\n  [Symbol.iterator]() {\n    let step = 0;\n    return {\n      next() {\n        step++;\n        if (step <= 5) {\n          return { value: step, done: false };\n        }\n        return { done: true };\n      },\n    };\n  },\n};\n\nfor (let value of iterable) {\n  console.log(value); // 1, 2, 3, 4, 5\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:(0,n.jsx)(e.code,{children:\"Symbol.toStringTag\"})}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let myObj = {\n  [Symbol.toStringTag]: 'MyCustomObject',\n};\n\nconsole.log(Object.prototype.toString.call(myObj)); // \"[object MyCustomObject]\"\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Summary\"}),`\n`,(0,n.jsx)(e.p,{children:\"Symbols are a powerful feature in JavaScript, especially useful for creating unique object properties and customizing object behavior. They provide a means to create hidden properties, preventing accidental access or modification, which is particularly beneficial in large-scale applications and libraries.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol\",children:\"Symbol - MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/symbol\",children:\"Symbol type\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.freecodecamp.org/news/how-did-i-miss-javascript-symbols-c1f1c0e1874a/\",children:\"A quick overview of JavaScript symbols\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/types-grammar/ch1.md#symbol-values\",children:\"Symbol Values - You Don't Know JS Yet\"})}),`\n`]})]})}function v(o={}){let{wrapper:e}=o.components||{};return e?(0,n.jsx)(e,Object.assign({},o,{children:(0,n.jsx)(d,o)})):d(o)}var w=v;return f(k);})();\n;return Component;"
}