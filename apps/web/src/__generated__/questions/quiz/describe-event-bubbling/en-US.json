{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/describe-event-bubbling",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 210,
    "similarQuestions": [],
    "slug": "describe-event-bubbling",
    "subtitle": null,
    "title": "Describe event bubbling in JavaScript and browsers",
    "topics": [
      "web-api",
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/describe-event-bubbling/en-US.mdx"
  },
  "solution": "var Component=(()=>{var u=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var v=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),f=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},r=(t,e,i,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let l of g(e))!b.call(t,l)&&l!==i&&o(t,l,{get:()=>e[l],enumerable:!(c=p(e,l))||c.enumerable});return t};var y=(t,e,i)=>(i=t!=null?u(m(t)):{},r(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),w=t=>r(o({},\"__esModule\",{value:!0}),t);var d=v((C,a)=>{a.exports=_jsx_runtime});var E={};f(E,{default:()=>s,frontmatter:()=>k});var n=y(d()),k={title:\"Describe event bubbling in JavaScript and browsers\"};function h(t){let e={a:\"a\",code:\"code\",h2:\"h2\",h3:\"h3\",hr:\"hr\",li:\"li\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...t.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:\"Event bubbling is a DOM event propagation mechanism where an event (e.g. a click), starts at the target element and bubbles up to the root of the document. This allows ancestor elements to also respond to the event.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Event bubbling is essential for event delegation, where a single event handler manages events for multiple child elements, enhancing performance and code simplicity. While convenient, failing to manage event propagation properly can lead to unintended behavior, such as multiple handlers firing for a single event.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"What is event bubbling?\"}),`\n`,(0,n.jsx)(e.p,{children:\"Event bubbling is a propagation mechanism in the DOM (Document Object Model) where an event, such as a click or a keyboard event, is first triggered on the target element that initiated the event and then propagates upward (bubbles) through the DOM tree to the root of the document.\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.strong,{children:\"Note\"}),\": even before the event bubbling phase happens is the \",(0,n.jsx)(e.a,{href:\"/questions/quiz/describe-event-capturing\",children:\"event capturing\"}),\" phase which is the opposite of bubbling where the event goes down from the document root to the target element.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Bubbling phase\"}),`\n`,(0,n.jsx)(e.p,{children:\"During the bubbling phase, the event starts at the target element and bubbles up through its ancestors in the DOM hierarchy. This means that the event handlers attached to the target element and its ancestors can all potentially receive and respond to the event.\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here's an example using modern ES6 syntax to demonstrate event bubbling:\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// HTML:\n// <div id=\"parent\">\n//   <button id=\"child\">Click me!</button>\n// </div>\nconst parentDiv = document.createElement('div');\nparentDiv.id = 'parent';\nconst button = document.createElement('button');\nbutton.id = 'child';\nparentDiv.appendChild(button);\ndocument.body.appendChild(parentDiv);\n\nconst parent = document.getElementById('parent');\nconst child = document.getElementById('child');\n\nparent.addEventListener('click', () => {\n  console.log('Parent element clicked');\n});\n\nchild.addEventListener('click', () => {\n  console.log('Child element clicked');\n});\n\n// Simulate clicking the button:\nchild.click();\n`})}),`\n`,(0,n.jsx)(e.p,{children:'When you click the \"Click me!\" button, both the child and parent event handlers will be triggered due to the event bubbling.'}),`\n`,(0,n.jsx)(e.h2,{children:\"Stopping the bubbling\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Event bubbling can be stopped during the bubbling phase using the \",(0,n.jsx)(e.code,{children:\"stopPropagation()\"}),\" method. If an event handler calls \",(0,n.jsx)(e.code,{children:\"stopPropagation()\"}),\", it prevents the event from further bubbling up the DOM tree, ensuring that only the handlers of the elements up to that point in the hierarchy are executed.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// HTML:\n// <div id=\"parent\">\n//   <button id=\"child\">Click me!</button>\n// </div>\nconst parentDiv = document.createElement('div');\nparentDiv.id = 'parent';\nconst button = document.createElement('button');\nbutton.id = 'child';\nparentDiv.appendChild(button);\ndocument.body.appendChild(parentDiv);\n\nconst parent = document.getElementById('parent');\nconst child = document.getElementById('child');\n\nparent.addEventListener('click', () => {\n  console.log('Parent element clicked');\n});\n\nchild.addEventListener('click', (event) => {\n  console.log('Child element clicked');\n  event.stopPropagation(); // Stops propagation to parent\n});\n\n// Simulate clicking the button:\nchild.click();\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Event delegation\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Event bubbling is the basis for a technique called \",(0,n.jsx)(e.a,{href:\"/questions/quiz/explain-event-delegation\",children:\"event delegation\"}),\", where you attach a single event handler to a common ancestor of multiple elements and use event delegation to handle events for those elements efficiently. This is particularly useful when you have a large number of similar elements, like a list of items, and you want to avoid attaching individual event handlers to each item.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`parent.addEventListener('click', (event) => {\n  if (event.target && event.target.id === 'child') {\n    console.log('Child element clicked');\n  }\n});\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Benefits\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Cleaner code:\"}),\" Reduced number of event listeners improves code readability and maintainability.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Efficient event handling:\"}),\" Minimizes performance overhead by attaching fewer listeners.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Flexibility:\"}),\" Allows handling events happening on child elements without directly attaching listeners to them.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Pitfalls\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Accidental event handling:\"}),\" Be mindful that parent elements might unintentionally capture events meant for children. Use \",(0,n.jsx)(e.code,{children:\"event.target\"}),\" to identify the specific element that triggered the event.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Event order:\"}),\" Events bubble up in a specific order. If multiple parents have event listeners, their order of execution depends on the DOM hierarchy.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Over-delegation:\"}),\" While delegating events to a common ancestor is efficient, attaching a listener too high in the DOM tree might capture unintended events.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Use cases\"}),`\n`,(0,n.jsx)(e.p,{children:\"Here are some practical ways to use event bubbling to write better code.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Reducing code with event delegation\"}),`\n`,(0,n.jsx)(e.p,{children:'Imagine you have a product list with numerous items, each with a \"Buy Now\" button. Traditionally, you might attach a separate click event listener to each button:'}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// HTML:\n// <ul id=\"product-list\">\n//   <li><button id=\"item1-buy\">Buy Now</button></li>\n//   <li><button id=\"item2-buy\">Buy Now</button></li>\n// </ul>\n\nconst item1Buy = document.getElementById('item1-buy');\nconst item2Buy = document.getElementById('item2-buy');\n\nitem1Buy.addEventListener('click', handleBuyClick);\nitem2Buy.addEventListener('click', handleBuyClick);\n\n// ... repeat for each item ...\n\nfunction handleBuyClick(event) {\n  console.log('Buy button clicked for item:', event.target.id);\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"This approach becomes cumbersome as the number of items grows. Here's how event bubbling can simplify things:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// HTML:\n// <ul id=\"product-list\">\n//   <li><button id=\"item1-buy\">Buy Now</button></li>\n//   <li><button id=\"item2-buy\">Buy Now</button></li>\n// </ul>\n\nconst productList = document.getElementById('product-list');\n\nproductList.addEventListener('click', handleBuyClick);\n\nfunction handleBuyClick(event) {\n  // Check if the clicked element is a button within the list\n  if (event.target.tagName.toLowerCase() === 'button') {\n    console.log('Buy button clicked for item:', event.target.id);\n  }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"By attaching the listener to the parent (\",(0,n.jsx)(e.code,{children:\"productList\"}),\") and checking the clicked element (\",(0,n.jsx)(e.code,{children:\"event.target\"}),\") within the handler, you achieve the same functionality with less code. This approach scales well when the items are dynamic as no new event handlers have to be added or removed when the list of items change.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Dropdown menus\"}),`\n`,(0,n.jsx)(e.p,{children:\"Consider a dropdown menu where clicking anywhere on the menu element (parent) should close it. With event bubbling, you can achieve this with a single listener:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// HTML:\n// <div id=\"dropdown\">\n//   <button>Open Menu</button>\n//   <ul>\n//     <li>Item 1</li>\n//     <li>Item 2</li>\n//   </ul>\n// </div>\n\nconst dropdown = document.getElementById('dropdown');\n\ndropdown.addEventListener('click', handleDropdownClick);\n\nfunction handleDropdownClick(event) {\n  // Close the dropdown if clicked outside the button\n  if (event.target !== dropdown.querySelector('button')) {\n    console.log('Dropdown closed');\n    // Your logic to hide the dropdown content\n  }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"Here, the click event bubbles up from the clicked element (button or list item) to the \",(0,n.jsx)(e.code,{children:\"dropdown\"}),\" element. The handler checks if the clicked element is not the \",(0,n.jsx)(e.code,{children:\"<button>\"}),\" and closes the menu accordingly.\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Accordion menus\"}),`\n`,(0,n.jsx)(e.p,{children:\"Imagine an accordion menu where clicking a section header (parent) expands or collapses the content section (child) below it. Event bubbling makes this straightforward:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// HTML:\n// <div class=\"accordion\">\n//   <div class=\"header\">Section 1</div>\n//   <div class=\"content\">Content for Section 1</div>\n//   <div class=\"header\">Section 2</div>\n//   <div class=\"content\">Content for Section 2</div>\n// </div>\n\nconst accordion = document.querySelector('.accordion');\n\naccordion.addEventListener('click', handleAccordionClick);\n\nfunction handleAccordionClick(event) {\n  // Check if clicked element is a header\n  if (event.target.classList.contains('header')) {\n    const content = event.target.nextElementSibling;\n    content.classList.toggle('active'); // Toggle display of content\n  }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"By attaching the listener to the \",(0,n.jsx)(e.code,{children:\"accordion\"}),\" element, clicking on any header triggers the event. The handler checks if the clicked element is a header and toggles the visibility of the corresponding content section.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#event_bubbling\",children:\"MDN Web Docs on Event Bubbling\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/bubbling-and-capturing\",children:\"JavaScript.info - Bubbling and Capturing\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\",children:\"W3C DOM Level 3 Events Specification\"})}),`\n`]})]})}function s(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(h,{...t})}):h(t)}return w(E);})();\n;return Component;"
}