{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "What is the difference between `==` and `===` in JavaScript?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-is-the-difference-between-double-equal-and-triple-equal/en-US.mdx"
  },
  "solution": "var Component=(()=>{var s=Object.create;var l=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),y=(r,e)=>{for(var o in e)l(r,o,{get:e[o],enumerable:!0})},i=(r,e,o,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let t of p(e))!m.call(r,t)&&t!==o&&l(r,t,{get:()=>e[t],enumerable:!(c=u(e,t))||c.enumerable});return r};var v=(r,e,o)=>(o=r!=null?s(f(r)):{},i(e||!r||!r.__esModule?l(o,\"default\",{value:r,enumerable:!0}):o,r)),b=r=>i(l({},\"__esModule\",{value:!0}),r);var d=g((x,a)=>{a.exports=_jsx_runtime});var S={};y(S,{default:()=>j,frontmatter:()=>w});var n=v(d()),w={title:\"What is the difference between `==` and `===` in JavaScript?\"};function h(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",hr:\"hr\",h3:\"h3\",pre:\"pre\",a:\"a\",ul:\"ul\",li:\"li\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"==\"}),\" is the abstract equality operator while \",(0,n.jsx)(e.code,{children:\"===\"}),\" is the strict equality operator. The \",(0,n.jsx)(e.code,{children:\"==\"}),\" operator will compare for equality after doing any necessary type conversions. The \",(0,n.jsx)(e.code,{children:\"===\"}),\" operator will not do type conversion, so if two values are not the same type \",(0,n.jsx)(e.code,{children:\"===\"}),\" will simply return \",(0,n.jsx)(e.code,{children:\"false\"}),\".\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Operator\"}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"==\"})}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"===\"})})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Name\"}),(0,n.jsx)(e.td,{children:\"(Loose) Equality operator\"}),(0,n.jsx)(e.td,{children:\"Strict equality operator\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Type coercion\"}),(0,n.jsx)(e.td,{children:\"Yes\"}),(0,n.jsx)(e.td,{children:\"No\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Compares value and type\"}),(0,n.jsx)(e.td,{children:\"No\"}),(0,n.jsx)(e.td,{children:\"Yes\"})]})]})]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Equality operator (\",(0,n.jsx)(e.code,{children:\"==\"}),\")\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"==\"}),\" operator checks for equality between two values but performs type coercion if the values are of different types. This means that JavaScript will attempt to convert the values to a common type before making the comparison.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`console.log(42 == '42'); // true\nconsole.log(0 == false); // true\nconsole.log(null == undefined); // true\nconsole.log([] == false); // true\nconsole.log('' == false); // true\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In these examples, JavaScript converts the operands to the same type before making the comparison. For example, \",(0,n.jsx)(e.code,{children:\"42 == '42'\"}),\" is true because the string \",(0,n.jsx)(e.code,{children:\"'42'\"}),\" is converted to the number \",(0,n.jsx)(e.code,{children:\"42\"}),\" before comparison.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"However, when using \",(0,n.jsx)(e.code,{children:\"==\"}),\", unintuitive results can happen:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`console.log(1 == [1]); // true\nconsole.log(0 == ''); // true\nconsole.log(0 == '0'); // true\nconsole.log('' == '0'); // false\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"As a general rule of thumb, never use the \",(0,n.jsx)(e.code,{children:\"==\"}),\" operator, except for convenience when comparing against \",(0,n.jsx)(e.code,{children:\"null\"}),\" or \",(0,n.jsx)(e.code,{children:\"undefined\"}),\", where \",(0,n.jsx)(e.code,{children:\"a == null\"}),\" will return \",(0,n.jsx)(e.code,{children:\"true\"}),\" if \",(0,n.jsx)(e.code,{children:\"a\"}),\" is \",(0,n.jsx)(e.code,{children:\"null\"}),\" or \",(0,n.jsx)(e.code,{children:\"undefined\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`var a = null;\nconsole.log(a == null); // true\nconsole.log(a == undefined); // true\n`})}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Strict equality operator (\",(0,n.jsx)(e.code,{children:\"===\"}),\")\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The \",(0,n.jsx)(e.code,{children:\"===\"}),\" operator, also known as the strict equality operator, checks for equality between two values without performing type coercion. This means that both the value and the type must be the same for the comparison to return true.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`console.log(42 === '42'); // false\nconsole.log(0 === false); // false\nconsole.log(null === undefined); // false\nconsole.log([] === false); // false\nconsole.log('' === false); // false\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"For these comparisons, no type conversion is performed, so the statement returns \",(0,n.jsx)(e.code,{children:\"false\"}),\" if the types are different. For instance, \",(0,n.jsx)(e.code,{children:\"42 === '42'\"}),\" is \",(0,n.jsx)(e.code,{children:\"false\"}),\" because the types (number and string) are different.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Comparison with type coercion (==)\nconsole.log(42 == '42'); // true\nconsole.log(0 == false); // true\nconsole.log(null == undefined); // true\n\n// Strict comparison without type coercion (===)\nconsole.log(42 === '42'); // false\nconsole.log(0 === false); // false\nconsole.log(null === undefined); // false\n`})}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Bonus: \",(0,n.jsx)(e.code,{children:\"Object.is()\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"There's one final value-comparison operation within JavaScript, that is the \",(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",children:(0,n.jsx)(e.code,{children:\"Object.is()\"})}),\" static method. The only difference between \",(0,n.jsx)(e.code,{children:\"Object.is()\"}),\" and \",(0,n.jsx)(e.code,{children:\"===\"}),\" is how they treat of signed zeros and \",(0,n.jsx)(e.code,{children:\"NaN\"}),\" values. The \",(0,n.jsx)(e.code,{children:\"===\"}),\" operator (and the \",(0,n.jsx)(e.code,{children:\"==\"}),\" operator) treats the number values \",(0,n.jsx)(e.code,{children:\"-0\"}),\" and \",(0,n.jsx)(e.code,{children:\"+0\"}),\" as equal, but treats \",(0,n.jsx)(e.code,{children:\"NaN\"}),\" as not equal to each other.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Conclusion\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Use \",(0,n.jsx)(e.code,{children:\"==\"}),\" when you want to compare values with type coercion (and understand the implications of it). Practically, the only valid use case for the equality operator is when against \",(0,n.jsx)(e.code,{children:\"null\"}),\" and \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" for convenience.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use \",(0,n.jsx)(e.code,{children:\"===\"}),\" when you want to ensure both the value and the type are the same, which is the safer and more predictable choice in most cases.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"===\"}),\" (strict equality) is generally recommended to avoid the pitfalls of type coercion, which can lead to unexpected behavior and bugs in your code. It makes the intent of your comparisons clearer and ensures that you are comparing both the value and the type.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"ESLint's \",(0,n.jsx)(e.a,{href:\"https://eslint.org/docs/latest/rules/eqeqeq\",children:(0,n.jsx)(e.code,{children:\"eqeqeq\"})}),\" rule enforces the use of strict equality operators \",(0,n.jsx)(e.code,{children:\"===\"}),\" and \",(0,n.jsx)(e.code,{children:\"!==\"}),\" and even provides an option to always enforce strict equality except when comparing with the \",(0,n.jsx)(e.code,{children:\"null\"}),\" literal.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Equality\",children:\"Equality (==) | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality\",children:\"Strict equality (===) | MDN\"})}),`\n`]})]})}function q(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var j=q;return b(S);})();\n;return Component;"
}