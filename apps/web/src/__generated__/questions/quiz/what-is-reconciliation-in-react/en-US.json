{
  "description": null,
  "format": "quiz",
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-is-reconciliation-in-react",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 480,
    "similarQuestions": [],
    "slug": "what-is-reconciliation-in-react",
    "subtitle": null,
    "title": "What is reconciliation in React?",
    "topics": [
      "react"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-reactjs-interview-questions/blob/main/questions/what-is-reconciliation-in-react/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var h=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var m=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),w=(n,e)=>{for(var i in e)h(n,i,{get:e[i],enumerable:!0})},c=(n,e,i,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of m(e))!f.call(n,a)&&a!==i&&h(n,a,{get:()=>e[a],enumerable:!(r=p(e,a))||r.enumerable});return n};var v=(n,e,i)=>(i=n!=null?d(u(n)):{},c(e||!n||!n.__esModule?h(i,\"default\",{value:n,enumerable:!0}):i,n)),R=n=>c(h({},\"__esModule\",{value:!0}),n);var s=g((j,o)=>{o.exports=_jsx_runtime});var y={};w(y,{default:()=>O,frontmatter:()=>M});var t=v(s()),M={title:\"What is reconciliation in React?\"};function l(n){let e=Object.assign({h2:\"h2\",p:\"p\",hr:\"hr\",h3:\"h3\",ol:\"ol\",li:\"li\",strong:\"strong\",pre:\"pre\",code:\"code\",ul:\"ul\",a:\"a\"},n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,t.jsx)(e.p,{children:`Reconciliation in React is the process through which React updates the DOM to match the virtual DOM. When a component's state or props change, React creates a new virtual DOM tree and compares it with the previous one. This comparison process is called \"diffing.\" React then updates only the parts of the actual DOM that have changed, making the updates efficient and fast.`}),`\n`,(0,t.jsx)(e.hr,{}),`\n`,(0,t.jsx)(e.h2,{children:\"What is reconciliation in React?\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Introduction\"}),`\n`,(0,t.jsx)(e.p,{children:\"Reconciliation is a key concept in React that deals with how React updates the DOM to match the virtual DOM. The virtual DOM is a lightweight copy of the actual DOM, and React uses it to determine the most efficient way to update the user interface.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"The virtual DOM\"}),`\n`,(0,t.jsx)(e.p,{children:\"React maintains a virtual DOM to optimize updates. When a component's state or props change, React creates a new virtual DOM tree. This new tree is then compared to the previous virtual DOM tree to identify what has changed.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"The diffing algorithm\"}),`\n`,(0,t.jsx)(e.p,{children:'The process of comparing the new virtual DOM tree with the previous one is called \"diffing.\" React uses a highly optimized diffing algorithm to perform this comparison. The algorithm works in the following way:'}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Element type comparison\"}),\": If the elements are of different types, React will replace the old element with the new one.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Key comparison\"}),\": If elements are of the same type but have different keys, React will treat them as different elements and replace the old one with the new one.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Props and state comparison\"}),\": If elements are of the same type and have the same keys, React will compare their props and state to determine what has changed.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"Updating the DOM\"}),`\n`,(0,t.jsx)(e.p,{children:\"Once the diffing algorithm has identified the changes, React updates only the parts of the actual DOM that have changed. This makes the updates efficient and fast, as React avoids re-rendering the entire DOM.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Example\"}),`\n`,(0,t.jsx)(e.p,{children:\"Here is a simple example to illustrate reconciliation:\"}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-jsx\",children:`class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n\n  increment = () => {\n    this.setState({ count: this.state.count + 1 });\n  };\n\n  render() {\n    return (\n      <div>\n        <p>{this.state.count}</p>\n        <button onClick={this.increment}>Increment</button>\n      </div>\n    );\n  }\n}\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"In this example, when the \",(0,t.jsx)(e.code,{children:\"increment\"}),\" method is called, the state changes, and React creates a new virtual DOM tree. The diffing algorithm compares the new tree with the previous one and updates only the \",(0,t.jsx)(e.code,{children:\"<p>\"}),\" element with the new count value.\"]}),`\n`,(0,t.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://reactjs.org/docs/reconciliation.html\",children:\"React documentation on reconciliation\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom\",children:\"Understanding the virtual DOM\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://reactjs.org/docs/reconciliation.html#the-diffing-algorithm\",children:\"React's diffing algorithm\"})}),`\n`]})]})}function D(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}var O=D;return R(y);})();\n;return Component;"
}