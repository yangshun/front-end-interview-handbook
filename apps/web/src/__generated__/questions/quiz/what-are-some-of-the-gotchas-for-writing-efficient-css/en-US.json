{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/what-are-some-of-the-gotchas-for-writing-efficient-css",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "what-are-some-of-the-gotchas-for-writing-efficient-css",
    "subtitle": null,
    "title": "What are some of the \"gotchas\" for writing efficient CSS?",
    "topics": [
      "css"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/front-end-interview-handbook/blob/main/packages/quiz/questions/what-are-some-of-the-gotchas-for-writing-efficient-css/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var s=Object.defineProperty;var f=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,w=Object.prototype.hasOwnProperty;var u=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var n in e)s(t,n,{get:e[n],enumerable:!0})},i=(t,e,n,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!w.call(t,o)&&o!==n&&s(t,o,{get:()=>e[o],enumerable:!(a=f(e,o))||a.enumerable});return t};var x=(t,e,n)=>(n=t!=null?d(p(t)):{},i(e||!t||!t.__esModule?s(n,\"default\",{value:t,enumerable:!0}):n,t)),b=t=>i(s({},\"__esModule\",{value:!0}),t);var c=u((M,h)=>{h.exports=_jsx_runtime});var v={};y(v,{default:()=>m,frontmatter:()=>k});var r=x(c()),k={title:'What are some of the \"gotchas\" for writing efficient CSS?'};function l(t){let e={a:\"a\",p:\"p\",...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.p,{children:\"Firstly, understand that browsers match selectors from rightmost (key selector) to left. Browsers filter out elements in the DOM according to the key selector and traverse up its parent elements to determine matches. The shorter the length of the selector chain, the faster the browser can determine if that element matches the selector. Hence avoid key selectors that are tag and universal selectors. They match a large number of elements and browsers will have to do more work in determining if the parents do match.\"}),`\n`,(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.a,{href:\"https://en.bem.info/\",children:\"BEM (Block Element Modifier)\"}),\" methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override.\"]}),`\n`,(0,r.jsxs)(e.p,{children:[\"Be aware of which CSS properties \",(0,r.jsx)(e.a,{href:\"https://csstriggers.com/\",children:\"trigger\"}),\" reflow, repaint, and compositing. Avoid writing styles that change the layout (trigger reflow) where possible.\"]})]})}function m(t={}){let{wrapper:e}=t.components||{};return e?(0,r.jsx)(e,{...t,children:(0,r.jsx)(l,{...t})}):l(t)}return b(v);})();\n;return Component;"
}