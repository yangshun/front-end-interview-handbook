{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/explain-the-difference-between-mutable-and-immutable-objects",
    "importance": "medium",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 390,
    "similarQuestions": [],
    "slug": "explain-the-difference-between-mutable-and-immutable-objects",
    "subtitle": null,
    "title": "Explique a diferença entre objetos mutáveis e imutáveis",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/explain-the-difference-between-mutable-and-immutable-objects/pt-BR.mdx"
  },
  "solution": "var Component=(()=>{var l=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,h=Object.prototype.hasOwnProperty;var j=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),v=(a,e)=>{for(var s in e)r(a,s,{get:e[s],enumerable:!0})},d=(a,e,s,n)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of p(e))!h.call(a,i)&&i!==s&&r(a,i,{get:()=>e[i],enumerable:!(n=u(e,i))||n.enumerable});return a};var f=(a,e,s)=>(s=a!=null?l(b(a)):{},d(e||!a||!a.__esModule?r(s,\"default\",{value:a,enumerable:!0}):s,a)),g=a=>d(r({},\"__esModule\",{value:!0}),a);var c=j((E,t)=>{t.exports=_jsx_runtime});var z={};v(z,{default:()=>O,frontmatter:()=>q});var o=f(c()),q={title:\"Explique a diferen\\xE7a entre objetos mut\\xE1veis e imut\\xE1veis\"};function m(a){let e=Object.assign({p:\"p\",h2:\"h2\",code:\"code\",h3:\"h3\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},a.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:\"A imutabilidade \\xE9 um princ\\xEDpio central na programa\\xE7\\xE3o funcional e tamb\\xE9m tem muito a oferecer para programas orientados para objetos. Um objeto mut\\xE1vel \\xE9 um objeto cujo estado pode ser modificado depois de criado. Um objeto mut\\xE1vel \\xE9 um objeto cujo estado pode ser modificado depois de criado.\"}),`\n`,(0,o.jsx)(e.h2,{children:\"O que \\xE9 um exemplo de um objeto imut\\xE1vel em JavaScript?\"}),`\n`,(0,o.jsx)(e.p,{children:\"Em JavaScript, alguns tipos internos (n\\xFAmeros, strings) s\\xE3o imut\\xE1veis, mas objetos personalizados geralmente s\\xE3o mut\\xE1veis.\"}),`\n`,(0,o.jsxs)(e.p,{children:[\"Alguns objetos JavaScript imut\\xE1veis integrados s\\xE3o \",(0,o.jsx)(e.code,{children:\"Math\"}),\", \",(0,o.jsx)(e.code,{children:\"Date\"}),\".\"]}),`\n`,(0,o.jsx)(e.p,{children:\"Aqui est\\xE3o algumas maneiras de adicionar/simular imutabilidade em objetos JavaScript simples.\"}),`\n`,(0,o.jsx)(e.h3,{children:\"Propriedades Constante de Objeto\"}),`\n`,(0,o.jsxs)(e.p,{children:[\"Ao combinar \",(0,o.jsx)(e.code,{children:\"grav\\xE1vel: falso\"}),\" e \",(0,o.jsx)(e.code,{children:\"configur\\xE1vel: falso\"}),\", voc\\xEA pode criar uma constante (n\\xE3o pode ser alterada, redefinida ou apagada) como uma propriedade do objeto, como:\"]}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`let myObject = {};\nObject.defineProperty(myObject, 'number', {\n  value: 42,\n  writable: false,\n  configurable: false,\n});\nconsole.log(myObject.number); // 42\nmyObject.number = 43;\nconsole.log(myObject.number); // 42\n`})}),`\n`,(0,o.jsx)(e.h3,{children:\"Evitar Extens\\xF5es\"}),`\n`,(0,o.jsxs)(e.p,{children:[\"Se voc\\xEA quiser evitar que um objeto tenha novas propriedades adicionadas, mas deixando o resto das propriedades do objeto sozinhas, chame \",(0,o.jsx)(e.code,{children:\"Object.preventExtensions(...)\"}),\":\"]}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`let myObject = {\n  a: 2,\n};\n\nObject.preventExtensions(myObject);\n\nmyObject.b = 3;\nmyObject.b; // undefined\n`})}),`\n`,(0,o.jsxs)(e.p,{children:[\"No modo n\\xE3o restrito, a cria\\xE7\\xE3o de \",(0,o.jsx)(e.code,{children:\"b\"}),\" falha silenciosamente. No modo estrito, ele lan\\xE7a um \",(0,o.jsx)(e.code,{children:\"TypeError\"}),\".\"]}),`\n`,(0,o.jsx)(e.h3,{children:\"Prote\\xE7\\xE3o\"}),`\n`,(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:\"Object.seal()\"}),' cria um objeto \"selado\", o que significa que recebe um objeto existente e basicamente chama ',(0,o.jsx)(e.code,{children:\"Object.preventExtensions()\"}),\" nele, mas tamb\\xE9m marca todas as suas propriedades existentes como \",(0,o.jsx)(e.code,{children:\"configurable: false\"}),\".\"]}),`\n`,(0,o.jsx)(e.p,{children:\"Ent\\xE3o, n\\xE3o s\\xF3 voc\\xEA n\\xE3o pode adicionar mais propriedades, mas voc\\xEA tamb\\xE9m n\\xE3o pode reconfigurar ou apagar quaisquer propriedades existentes (embora voc\\xEA ainda possa modificar seus valores).\"}),`\n`,(0,o.jsx)(e.h3,{children:\"Travamento\"}),`\n`,(0,o.jsxs)(e.p,{children:[(0,o.jsx)(e.code,{children:\"Object.freeze()\"}),\" cria um objeto congelado, o que significa que \\xE9 preciso um objeto existente e basicamente chama \",(0,o.jsx)(e.code,{children:\"objeto.seal()\"}),' nele, mas tamb\\xE9m marca todas as propriedades do tipo \"acesso a dados\" como writable:false, para que seus valores n\\xE3o possam ser alterados.']}),`\n`,(0,o.jsx)(e.p,{children:\"Essa abordagem \\xE9 o maior n\\xEDvel de imutabilidade que voc\\xEA pode alcan\\xE7ar para um objeto em si, pois impede quaisquer mudan\\xE7as no objeto ou em qualquer uma de suas propriedades diretas (embora, como mencionado acima, o conte\\xFAdo de quaisquer outros objetos referenciados n\\xE3o seja afetado).\"}),`\n`,(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:\"language-js\",children:`let immutableObject = Object.freeze({});\n`})}),`\n`,(0,o.jsxs)(e.p,{children:[\"Congelar um objeto n\\xE3o permite que novas propriedades sejam adicionadas a um objeto e impede que os usu\\xE1rios removam ou modifiquem as propriedades existentes. \",(0,o.jsx)(e.code,{children:\"Object.freeze()\"}),\" preserva a enumerabilidade, configurabilidade, gravabilidade e prot\\xF3tipo do objeto. Ele retorna o objeto passado e n\\xE3o cria uma c\\xF3pia congelada.\"]}),`\n`,(0,o.jsx)(e.h2,{children:\"Quais s\\xE3o os pr\\xF3s e os contras da imutabilidade?\"}),`\n`,(0,o.jsx)(e.h3,{children:\"Pr\\xF3s\"}),`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Detec\\xE7\\xE3o de mudan\\xE7as mais f\\xE1cil: A igualdade de objetos pode ser determinada de maneira eficiente e f\\xE1cil por meio da igualdade referencial. Isso \\xE9 \\xFAtil para comparar diferen\\xE7as de objetos no React e Redux.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Menos complicado: Programas com objetos imut\\xE1veis s\\xE3o menos complicados de se pensar, j\\xE1 que voc\\xEA n\\xE3o precisa se preocupar sobre como um objeto pode evoluir ao longo do tempo.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Compartilhamento f\\xE1cil por refer\\xEAncias: Uma c\\xF3pia de um objeto \\xE9 t\\xE3o boa quanto outra, ent\\xE3o voc\\xEA pode armazenar objetos em cache ou reutilizar o mesmo objeto v\\xE1rias vezes.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Seguro para threads: Objetos imut\\xE1veis podem ser usados com seguran\\xE7a entre threads em um ambiente multi-threaded, j\\xE1 que n\\xE3o h\\xE1 risco de serem modificados em outras threads que est\\xE3o sendo executadas simultaneamente.\"}),`\n`,(0,o.jsxs)(e.li,{children:[\"Menos necessidade de mem\\xF3ria: Usando bibliotecas como \",(0,o.jsx)(e.a,{href:\"https://immerjs.github.io/immer/\",children:\"Immer\"}),\" e \",(0,o.jsx)(e.a,{href:\"https://immutable-js.com/\",children:\"Immutable.js\"}),\", objetos s\\xE3o modificados usando compartilhamento estrutural e menos mem\\xF3ria \\xE9 necess\\xE1ria para ter v\\xE1rios objetos com estruturas semelhantes.\"]}),`\n`,(0,o.jsx)(e.li,{children:\"N\\xE3o h\\xE1 necessidade de c\\xF3pias defensivas: c\\xF3pias defensivas n\\xE3o s\\xE3o mais necess\\xE1rias quando objetos imut\\xE1veis s\\xE3o retornados ou passados para fun\\xE7\\xF5es, uma vez que n\\xE3o h\\xE1 possibilidade de um objeto imut\\xE1vel ser modificado por ela.\"}),`\n`]}),`\n`,(0,o.jsx)(e.h3,{children:\"Contras\"}),`\n`,(0,o.jsxs)(e.ul,{children:[`\n`,(0,o.jsx)(e.li,{children:\"Complexo para criar por si mesmo: Implementa\\xE7\\xF5es ing\\xEAnuas de estruturas de dados imut\\xE1veis e suas opera\\xE7\\xF5es podem resultar em desempenho extremamente pobre porque novos objetos s\\xE3o criados cada vez. \\xC9 recomendado o uso de bibliotecas para estruturas de dados imut\\xE1veis e opera\\xE7\\xF5es eficientes que utilizam compartilhamento estrutural.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Potencial impacto negativo na performance: Aloca\\xE7\\xE3o (e desaloca\\xE7\\xE3o) de muitos objetos pequenos ao inv\\xE9s de modificar objetos existentes pode causar um impacto na performance. A complexidade do alocador ou do coletor de lixo geralmente depende do n\\xFAmero de objetos no heap.\"}),`\n`,(0,o.jsx)(e.li,{children:\"Complexidade para estruturas de dados c\\xEDclicas: estruturas de dados c\\xEDclicas como grafos s\\xE3o dif\\xEDceis de construir. Se voc\\xEA tiver dois objetos que n\\xE3o podem ser modificados ap\\xF3s a inicializa\\xE7\\xE3o, como voc\\xEA pode fazer com que eles apontem um para o outro?\"}),`\n`]})]})}function x(a={}){let{wrapper:e}=a.components||{};return e?(0,o.jsx)(e,Object.assign({},a,{children:(0,o.jsx)(m,a)})):m(a)}var O=x;return g(z);})();\n;return Component;"
}