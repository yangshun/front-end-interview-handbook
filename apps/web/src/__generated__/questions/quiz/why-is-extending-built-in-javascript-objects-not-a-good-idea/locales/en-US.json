{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "Why is extending built-in JavaScript objects not a good idea?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/why-is-extending-built-in-javascript-objects-not-a-good-idea/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var r=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var m=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),f=(i,e)=>{for(var t in e)r(i,t,{get:e[t],enumerable:!0})},a=(i,e,t,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!g.call(i,o)&&o!==t&&r(i,o,{get:()=>e[o],enumerable:!(s=u(e,o))||s.enumerable});return i};var y=(i,e,t)=>(t=i!=null?h(b(i)):{},a(e||!i||!i.__esModule?r(t,\"default\",{value:i,enumerable:!0}):t,i)),v=i=>a(r({},\"__esModule\",{value:!0}),i);var c=m((I,l)=>{l.exports=_jsx_runtime});var S={};f(S,{default:()=>w,frontmatter:()=>x});var n=y(c()),x={title:\"Why is extending built-in JavaScript objects not a good idea?\"};function d(i){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",hr:\"hr\",pre:\"pre\",ol:\"ol\",li:\"li\",strong:\"strong\",a:\"a\",ul:\"ul\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Extending a built-in/native JavaScript object means adding properties/functions to its \",(0,n.jsx)(e.code,{children:\"prototype\"}),\". While this may seem like a good idea at first, it is dangerous in practice. Imagine your code uses a few libraries that both extend the \",(0,n.jsx)(e.code,{children:\"Array.prototype\"}),\" by adding the same \",(0,n.jsx)(e.code,{children:\"contains\"}),\" method, the implementations will overwrite each other and your code will have unpredictable behavior if these two methods do not work the same way.\"]}),`\n`,(0,n.jsx)(e.p,{children:\"The only time you may want to extend a native object is when you want to create a polyfill, essentially providing your own implementation for a method that is part of the JavaScript specification but might not exist in the user's browser due to it being an older browser.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Extending JavaScript\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In JavaScript it's very easy to extend a built-in/native object. You can simply extend a built-in object by adding properties and functions to its \",(0,n.jsx)(e.code,{children:\"prototype\"}),\".\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`String.prototype.reverseString = function () {\n  return this.split('').reverse().join('');\n};\n\nconsole.log('hello world'.reverseString()); // Outputs 'dlrow olleh'\n\n// Instead of extending the built-in object, write a pure utility function to do it.\n\nfunction reverseString(str) {\n  return str.split('').reverse().join('');\n}\n\nconsole.log(reverseString('hello world')); // Outputs 'dlrow olleh'\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Disadvantages\"}),`\n`,(0,n.jsx)(e.p,{children:\"Extending built-in JavaScript objects is essentially modifying the global scope and it's not a good idea because:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Future-proofing\"}),\": If a browser decides to implement its own version of a method, your custom extension might get overridden silently, leading to unexpected behavior or conflicts.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Collisions\"}),\": Adding custom methods to built-in objects can lead to collisions with future browser implementations or other libraries, causing unexpected behavior or errors.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Maintenance and debugging\"}),\": When extending built-in objects, it can be difficult for other developers to understand the changes made, making maintenance and debugging more challenging.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Performance\"}),\": Extending built-in objects can potentially impact performance, especially if the extensions are not optimized for the specific use case.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Security\"}),\": In some cases, extending built-in objects can introduce security vulnerabilities if not done correctly, such as adding enumerable properties that can be exploited by malicious code.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Compatibility\"}),\": Custom extensions to built-in objects may not be compatible with all browsers or environments, leading to issues with cross-browser compatibility.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Namespace clashes\"}),\": Extending built-in objects can lead to namespace clashes if multiple libraries or scripts extend the same object in different ways, causing conflicts and unexpected behavior.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"We dive deeper into \",(0,n.jsx)(e.a,{href:\"/questions/quiz/why-is-it-in-general-a-good-idea-to-leave-the-global-scope-of-a-website-as-is-and-never-touch-it\",children:\"why it is a bad idea to modify the global scope\"}),\".\"]}),`\n`,(0,n.jsx)(e.p,{children:\"It is not recommended to extend built-in objects due to these potential issues and instead suggest using composition or creating custom classes and utility functions to achieve the desired functionality.\"}),`\n`,(0,n.jsx)(e.h2,{children:\"Alternatives to extending built-in objects\"}),`\n`,(0,n.jsx)(e.p,{children:\"Instead of extending built-in objects, do the following instead:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Create custom utility functions\"}),\": For simple tasks, creating small utility functions specific to your needs can be a cleaner and more maintainable solution.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Use libraries and frameworks\"}),\": Many libraries and frameworks provide their own helper methods and extensions, eliminating the need to modify built-in objects directly.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Polyfilling as a valid reason\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"One valid reason to extend built-in objects is to implement polyfills for the latest ECMAScript standard and proposals. \",(0,n.jsx)(e.a,{href:\"https://github.com/zloirock/core-js\",children:(0,n.jsx)(e.code,{children:\"core-js\"})}),\" is a popular library that is present on most popular websites. It not only polyfills missing features but also fixes incorrect or non-compliant implementations of JavaScript features in various browsers and runtimes.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`import 'core-js/actual/array/flat-map'; // With this, Array.prototype.flatMap is available to be used.\n\n[1, 2].flatMap((it) => [it, it]); // => [1, 1, 2, 2]\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://lucybain.com/blog/2014/js-extending-built-in-objects/\",children:\"JS: don't extend JS objects\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/extend-natives\",children:\"Extending built-in classes\"})}),`\n`]})]})}function j(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(d,i)})):d(i)}var w=j;return v(S);})();\n;return Component;"
}