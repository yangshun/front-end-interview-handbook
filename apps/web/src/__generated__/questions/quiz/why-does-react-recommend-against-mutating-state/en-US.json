{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "hard",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": "react",
    "frameworks": [
      {
        "framework": "react",
        "href": "/questions/quiz/why-does-react-recommend-against-mutating-state"
      }
    ],
    "href": "/questions/quiz/why-does-react-recommend-against-mutating-state",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 230,
    "similarQuestions": [],
    "slug": "why-does-react-recommend-against-mutating-state",
    "subtitle": null,
    "title": "Why does React recommend against mutating state?",
    "topics": [
      "react"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-reactjs-interview-questions/blob/main/questions/why-does-react-recommend-against-mutating-state/en-US.mdx"
  },
  "solution": "var Component=(()=>{var m=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,y=Object.prototype.hasOwnProperty;var f=(n,e)=>()=>(e||n((e={exports:{}}).exports,e),e.exports),w=(n,e)=>{for(var a in e)c(n,a,{get:e[a],enumerable:!0})},s=(n,e,a,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let i of g(e))!y.call(n,i)&&i!==a&&c(n,i,{get:()=>e[i],enumerable:!(r=u(e,i))||r.enumerable});return n};var b=(n,e,a)=>(a=n!=null?m(p(n)):{},s(e||!n||!n.__esModule?c(a,\"default\",{value:n,enumerable:!0}):a,n)),v=n=>s(c({},\"__esModule\",{value:!0}),n);var l=f((j,o)=>{o.exports=_jsx_runtime});var x={};w(x,{default:()=>h,frontmatter:()=>R});var t=b(l()),R={title:\"Why does React recommend against mutating state?\"};function d(n){let e={a:\"a\",code:\"code\",h2:\"h2\",h3:\"h3\",hr:\"hr\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",strong:\"strong\",ul:\"ul\",...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"React recommends against mutating state because it can lead to unexpected behavior and bugs. React relies on state immutability to efficiently determine when to re-render components. When state is mutated directly, React may not detect the changes, leading to stale or incorrect UI updates. Instead, always create a new state object using methods like \",(0,t.jsx)(e.code,{children:\"setState\"}),\" or the \",(0,t.jsx)(e.code,{children:\"useState\"}),\" hook.\"]}),`\n`,(0,t.jsx)(e.hr,{}),`\n`,(0,t.jsx)(e.h2,{children:\"Why does React recommend against mutating state?\"}),`\n`,(0,t.jsx)(e.h3,{children:\"React's rendering mechanism\"}),`\n`,(0,t.jsx)(e.p,{children:\"React uses a virtual DOM to optimize rendering. When state changes, React compares the new virtual DOM with the previous one to determine the minimal set of changes needed to update the actual DOM. This process is called reconciliation.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Immutability and state comparison\"}),`\n`,(0,t.jsx)(e.p,{children:\"React relies on immutability to efficiently detect changes. When state is immutable, React can quickly determine if a component needs to re-render by comparing references. If the references are different, React knows that the state has changed.\"}),`\n`,(0,t.jsx)(e.h3,{children:\"Problems with mutating state\"}),`\n`,(0,t.jsxs)(e.ol,{children:[`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Stale UI updates\"}),\": Directly mutating state can lead to React not detecting changes, resulting in the UI not updating as expected.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Debugging difficulties\"}),\": Mutating state directly can make it harder to track state changes and debug issues.\"]}),`\n`,(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:\"Unexpected behavior\"}),\": Mutating state can lead to unpredictable behavior, especially when multiple components depend on the same state.\"]}),`\n`]}),`\n`,(0,t.jsx)(e.h3,{children:\"How to update state correctly\"}),`\n`,(0,t.jsxs)(e.p,{children:[\"Instead of mutating state directly, always create a new state object. For example, when using the \",(0,t.jsx)(e.code,{children:\"useState\"}),\" hook:\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-javascript\",children:`const [state, setState] = useState(initialState);\n\n// Incorrect: Directly mutating state\nstate.value = newValue;\n\n// Correct: Creating a new state object\nsetState({ ...state, value: newValue });\n`})}),`\n`,(0,t.jsxs)(e.p,{children:[\"When using class components and \",(0,t.jsx)(e.code,{children:\"setState\"}),\":\"]}),`\n`,(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:\"language-javascript\",children:`this.setState((prevState) => ({\n  ...prevState,\n  value: newValue,\n}));\n`})}),`\n`,(0,t.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,t.jsxs)(e.ul,{children:[`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://react.dev/learn/state-a-components-memory\",children:\"React documentation on state\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://react.dev/learn/preserving-and-resetting-state\",children:\"React documentation on reconciliation\"})}),`\n`,(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:\"https://daveceddia.com/why-not-modify-react-state-directly/\",children:\"Why not to mutate state in React\"})}),`\n`]})]})}function h(n={}){let{wrapper:e}=n.components||{};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}return v(x);})();\n;return Component;"
}