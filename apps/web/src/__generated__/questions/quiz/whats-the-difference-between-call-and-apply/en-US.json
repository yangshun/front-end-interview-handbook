{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [
      "atlassian"
    ],
    "created": 1630800000,
    "difficulty": "easy",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/whats-the-difference-between-call-and-apply",
    "importance": "high",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 100,
    "similarQuestions": [],
    "slug": "whats-the-difference-between-call-and-apply",
    "subtitle": null,
    "title": "What's the difference between `.call` and `.apply` in JavaScript?",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/whats-the-difference-between-call-and-apply/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(l,e)=>()=>(e||l((e={exports:{}}).exports,e),e.exports),f=(l,e)=>{for(var r in e)c(l,r,{get:e[r],enumerable:!0})},i=(l,e,r,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!g.call(l,a)&&a!==r&&c(l,a,{get:()=>e[a],enumerable:!(o=p(e,a))||o.enumerable});return l};var b=(l,e,r)=>(r=l!=null?h(m(l)):{},i(e||!l||!l.__esModule?c(r,\"default\",{value:l,enumerable:!0}):r,l)),v=l=>i(c({},\"__esModule\",{value:!0}),l);var d=y((k,t)=>{t.exports=_jsx_runtime});var A={};f(A,{default:()=>x,frontmatter:()=>w});var n=b(d()),w={title:\"What's the difference between `.call` and `.apply` in JavaScript?\"};function s(l){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",ul:\"ul\",li:\"li\",pre:\"pre\",hr:\"hr\",h3:\"h3\",ol:\"ol\",a:\"a\"},l.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\".call\"}),\" and \",(0,n.jsx)(e.code,{children:\".apply\"}),\" are both used to invoke functions with a specific \",(0,n.jsx)(e.code,{children:\"this\"}),\" context and arguments. The primary difference lies in how they accept arguments:\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\".call(thisArg, arg1, arg2, ...)\"}),\": Takes arguments individually.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\".apply(thisArg, [argsArray])\"}),\": Takes arguments as an array.\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Assuming we have a function \",(0,n.jsx)(e.code,{children:\"add\"}),\", the function can be invoked using \",(0,n.jsx)(e.code,{children:\".call\"}),\" and \",(0,n.jsx)(e.code,{children:\".apply\"}),\" in the following manner:\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add.call(null, 1, 2)); // 3\nconsole.log(add.apply(null, [1, 2])); // 3\n`})}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Call vs Apply\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\".call\"}),\" and \",(0,n.jsx)(e.code,{children:\".apply\"}),\" are used to invoke functions and the first parameter will be used as the value of \",(0,n.jsx)(e.code,{children:\"this\"}),\" within the function. However, \",(0,n.jsx)(e.code,{children:\".call\"}),\" takes in comma-separated arguments as the next arguments while \",(0,n.jsx)(e.code,{children:\".apply\"}),\" takes in an array of arguments as the next argument.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"An easy way to remember this is C for \",(0,n.jsx)(e.code,{children:\"call\"}),\" and comma-separated and A for \",(0,n.jsx)(e.code,{children:\"apply\"}),\" and an array of arguments.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add.call(null, 1, 2)); // 3\nconsole.log(add.apply(null, [1, 2])); // 3\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"With ES6 syntax, we can invoke \",(0,n.jsx)(e.code,{children:\"call\"}),\" using an array along with the spread operator for the arguments.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function add(a, b) {\n  return a + b;\n}\n\nconsole.log(add.call(null, ...[1, 2])); // 3\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Use cases\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Context management\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\".call\"}),\" and \",(0,n.jsx)(e.code,{children:\".apply\"}),\" can set the \",(0,n.jsx)(e.code,{children:\"this\"}),\" context explicitly when invoking methods on different objects.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const person = {\n  name: 'John',\n  greet() {\n    console.log(\\`Hello, my name is \\${this.name}\\`);\n  },\n};\n\nconst anotherPerson = { name: 'Alice' };\n\nperson.greet.call(anotherPerson); // Hello, my name is Alice\nperson.greet.apply(anotherPerson); // Hello, my name is Alice\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Function borrowing\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Both \",(0,n.jsx)(e.code,{children:\".call\"}),\" and \",(0,n.jsx)(e.code,{children:\".apply\"}),\" allow borrowing methods from one object and using them in the context of another. This is useful when passing functions as arguments (callbacks) and the original \",(0,n.jsx)(e.code,{children:\"this\"}),\" context is lost. \",(0,n.jsx)(e.code,{children:\".call\"}),\" and \",(0,n.jsx)(e.code,{children:\".apply\"}),\" allow the function to be invoked with the intended \",(0,n.jsx)(e.code,{children:\"this\"}),\" value.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function greet() {\n  console.log(\\`Hello, my name is \\${this.name}\\`);\n}\n\nconst person1 = { name: 'John' };\nconst person2 = { name: 'Alice' };\n\ngreet.call(person1); // Hello, my name is John\ngreet.call(person2); // Hello, my name is Alice\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Alternative syntax to call methods on objects\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\".apply\"}),\" can be used with object methods by passing the object as the first argument followed by the usual parameters.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`const arr1 = [1, 2, 3];\nconst arr2 = [4, 5, 6];\n\nArray.prototype.push.apply(arr1, arr2); // Same as arr1.push(4, 5, 6)\n\nconsole.log(arr1); // [1, 2, 3, 4, 5, 6]\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"Deconstructing the above:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"The first object, \",(0,n.jsx)(e.code,{children:\"arr1\"}),\" will be used as the \",(0,n.jsx)(e.code,{children:\"this\"}),\" value.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\".push()\"}),\" is called on \",(0,n.jsx)(e.code,{children:\"arr1\"}),\" using \",(0,n.jsx)(e.code,{children:\"arr2\"}),\" as arguments as an array because it's using \",(0,n.jsx)(e.code,{children:\".apply()\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"Array.prototype.push.apply(arr1, arr2)\"}),\" is equivalent to \",(0,n.jsx)(e.code,{children:\"arr1.push(...arr2)\"}),\".\"]}),`\n`]}),`\n`,(0,n.jsxs)(e.p,{children:[\"It may not be obvious, but \",(0,n.jsx)(e.code,{children:\"Array.prototype.push.apply(arr1, arr2)\"}),\" causes modifications to \",(0,n.jsx)(e.code,{children:\"arr1\"}),\". It's clearer to call methods using the OOP-centric way instead where possible.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Follow-Up Questions\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"How do \",(0,n.jsx)(e.code,{children:\".call\"}),\" and \",(0,n.jsx)(e.code,{children:\".apply\"}),\" differ from \",(0,n.jsx)(e.code,{children:\"Function.prototype.bind\"}),\"?\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Practice\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Practice implementing your own \",(0,n.jsxs)(e.a,{href:\"/questions/javascript/function-call\",children:[(0,n.jsx)(e.code,{children:\"Function.prototype.call\"}),\" method\"]}),\" and \",(0,n.jsxs)(e.a,{href:\"/questions/javascript/function-apply\",children:[(0,n.jsx)(e.code,{children:\"Function.prototype.apply\"}),\" method\"]}),\" on GreatFrontEnd.\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further Reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call\",children:\"Function.prototype.call | MDN\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\",children:\"Function.prototype.apply | MDN\"})}),`\n`]})]})}function j(l={}){let{wrapper:e}=l.components||{};return e?(0,n.jsx)(e,Object.assign({},l,{children:(0,n.jsx)(s,l)})):s(l)}var x=j;return v(A);})();\n;return Component;"
}