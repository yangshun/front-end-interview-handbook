{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "How do you handle asynchronous data loading in React applications?",
    "gitHubEditUrl": "https://github.com/yangshun/top-reactjs-interview-questions/blob/main/questions/how-do-you-handle-asynchronous-data-loading-in-react-applications/en-US.mdx"
  },
  "solution": "var Component=(()=>{var h=Object.create;var c=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var p=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var m=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var a in e)c(t,a,{get:e[a],enumerable:!0})},s=(t,e,a,o)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of f(e))!g.call(t,r)&&r!==a&&c(t,r,{get:()=>e[r],enumerable:!(o=u(e,r))||o.enumerable});return t};var v=(t,e,a)=>(a=t!=null?h(p(t)):{},s(e||!t||!t.__esModule?c(a,\"default\",{value:t,enumerable:!0}):a,t)),D=t=>s(c({},\"__esModule\",{value:!0}),t);var d=m((F,i)=>{i.exports=_jsx_runtime});var j={};y(j,{default:()=>S,frontmatter:()=>E});var n=v(d()),E={title:\"How do you handle asynchronous data loading in React applications?\"};function l(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",pre:\"pre\",hr:\"hr\",h3:\"h3\",ol:\"ol\",li:\"li\",strong:\"strong\",ul:\"ul\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In React applications, asynchronous data loading is typically handled using \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" and \",(0,n.jsx)(e.code,{children:\"useState\"}),\" hooks. You initiate the data fetch inside \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" and update the state with the fetched data. This ensures that the component re-renders with the new data. Here's a simple example:\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import React, { useState, useEffect } from 'react';\n\nfunction DataFetchingComponent() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    async function fetchData() {\n      const response = await fetch('https://api.example.com/data');\n      const result = await response.json();\n      setData(result);\n      setLoading(false);\n    }\n\n    fetchData();\n  }, []);\n\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n\n  return <div>{JSON.stringify(data)}</div>;\n}\n`})}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Handling asynchronous data loading in React applications\"}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Using \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" and \",(0,n.jsx)(e.code,{children:\"useState\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The most common way to handle asynchronous data loading in React is by using the \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" and \",(0,n.jsx)(e.code,{children:\"useState\"}),\" hooks. \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" allows you to perform side effects, such as data fetching, and \",(0,n.jsx)(e.code,{children:\"useState\"}),\" helps manage the component's state.\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Initialize state\"}),\": Use \",(0,n.jsx)(e.code,{children:\"useState\"}),\" to create state variables for storing the fetched data and loading status.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Fetch data\"}),\": Use \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" to perform the data fetching when the component mounts.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.strong,{children:\"Update state\"}),\": Once the data is fetched, update the state to trigger a re-render.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Here's a detailed example:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import React, { useState, useEffect } from 'react';\n\nfunction DataFetchingComponent() {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    async function fetchData() {\n      try {\n        const response = await fetch('https://api.example.com/data');\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        console.error('Error fetching data:', error);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchData();\n  }, []);\n\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n\n  return <div>{JSON.stringify(data)}</div>;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Handling errors\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"It's important to handle errors that may occur during data fetching. You can use a \",(0,n.jsx)(e.code,{children:\"try-catch\"}),\" block within the \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" to catch and handle errors.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`useEffect(() => {\n  async function fetchData() {\n    try {\n      const response = await fetch('https://api.example.com/data');\n      const result = await response.json();\n      setData(result);\n    } catch (error) {\n      console.error('Error fetching data:', error);\n    } finally {\n      setLoading(false);\n    }\n  }\n\n  fetchData();\n}, []);\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Using custom hooks\"}),`\n`,(0,n.jsx)(e.p,{children:\"For better code reusability, you can create custom hooks to handle data fetching. This allows you to encapsulate the data fetching logic and reuse it across multiple components.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import { useState, useEffect } from 'react';\n\nfunction useFetch(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    async function fetchData() {\n      try {\n        const response = await fetch(url);\n        const result = await response.json();\n        setData(result);\n      } catch (error) {\n        setError(error);\n      } finally {\n        setLoading(false);\n      }\n    }\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}\n\nexport default useFetch;\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"You can then use this custom hook in your components:\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-javascript\",children:`import React from 'react';\nimport useFetch from './useFetch';\n\nfunction DataFetchingComponent() {\n  const { data, loading, error } = useFetch('https://api.example.com/data');\n\n  if (loading) {\n    return <div>Loading...</div>;\n  }\n\n  if (error) {\n    return <div>Error: {error.message}</div>;\n  }\n\n  return <div>{JSON.stringify(data)}</div>;\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://react.dev/reference/react/hooks\",children:\"React documentation on hooks\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://react.dev/reference/react/useEffect\",children:\"React useEffect Hook\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\",children:\"Fetch API\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/async-await#error-handling\",children:\"Handling errors in async functions\"})}),`\n`]})]})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(l,t)})):l(t)}var S=w;return D(j);})();\n;return Component;"
}