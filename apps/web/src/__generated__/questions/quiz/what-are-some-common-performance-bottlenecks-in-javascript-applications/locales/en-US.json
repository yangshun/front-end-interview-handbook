{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "What are some common performance bottlenecks in JavaScript applications?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-some-common-performance-bottlenecks-in-javascript-applications/en-US.mdx"
  },
  "solution": "var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,p=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)o(t,i,{get:e[i],enumerable:!0})},c=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of u(e))!p.call(t,r)&&r!==i&&o(t,r,{get:()=>e[r],enumerable:!(a=m(e,r))||a.enumerable});return t};var v=(t,e,i)=>(i=t!=null?d(f(t)):{},c(e||!t||!t.__esModule?o(i,\"default\",{value:t,enumerable:!0}):i,t)),y=t=>c(o({},\"__esModule\",{value:!0}),t);var l=g((x,s)=>{s.exports=_jsx_runtime});var D={};b(D,{default:()=>w,frontmatter:()=>j});var n=v(l()),j={title:\"What are some common performance bottlenecks in JavaScript applications?\"};function h(t){let e=Object.assign({h2:\"h2\",p:\"p\",hr:\"hr\",h3:\"h3\",pre:\"pre\",code:\"code\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:\"Common performance bottlenecks in JavaScript applications include inefficient DOM manipulation, excessive use of global variables, blocking the main thread with heavy computations, memory leaks, and improper use of asynchronous operations. To mitigate these issues, you can use techniques like debouncing and throttling, optimizing DOM updates, and leveraging web workers for heavy computations.\"}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Inefficient DOM manipulation\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Frequent DOM updates\"}),`\n`,(0,n.jsx)(e.p,{children:\"Frequent DOM updates can be costly because the browser has to re-render the page each time the DOM changes. Batch DOM updates together to minimize reflows and repaints.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Inefficient\nfor (let i = 0; i < 1000; i++) {\n  const div = document.createElement('div');\n  div.textContent = i;\n  document.body.appendChild(div);\n}\n\n// Efficient\nconst fragment = document.createDocumentFragment();\nfor (let i = 0; i < 1000; i++) {\n  const div = document.createElement('div');\n  div.textContent = i;\n  fragment.appendChild(div);\n}\ndocument.body.appendChild(fragment);\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Layout thrashing\"}),`\n`,(0,n.jsx)(e.p,{children:\"Layout thrashing occurs when you read and write to the DOM repeatedly, causing multiple reflows and repaints. Minimize layout thrashing by batching reads and writes separately.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Inefficient\nfor (let i = 0; i < 1000; i++) {\n  const height = element.clientHeight;\n  element.style.height = \\`\\${height + 10}px\\`;\n}\n\n// Efficient\nconst height = element.clientHeight;\nfor (let i = 0; i < 1000; i++) {\n  element.style.height = \\`\\${height + 10}px\\`;\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Excessive use of global variables\"}),`\n`,(0,n.jsx)(e.p,{children:\"Global variables can lead to memory leaks and make the code harder to maintain. Use local variables and closures to limit the scope of variables.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Inefficient\nvar globalVar = 'I am global';\n\n// Efficient\nfunction myFunction() {\n  let localVar = 'I am local';\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Blocking the main thread\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Heavy computations\"}),`\n`,(0,n.jsx)(e.p,{children:\"Heavy computations can block the main thread, making the UI unresponsive. Use web workers to offload heavy computations to a background thread.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Main thread\nconst worker = new Worker('worker.js');\nworker.postMessage('start');\n\n// worker.js\nself.onmessage = function (e) {\n  if (e.data === 'start') {\n    // Perform heavy computation\n    self.postMessage('done');\n  }\n};\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Synchronous operations\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Avoid synchronous operations like \",(0,n.jsx)(e.code,{children:\"alert\"}),\", \",(0,n.jsx)(e.code,{children:\"prompt\"}),\", and synchronous XHR requests, as they block the main thread.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Inefficient\nalert('This blocks the main thread');\n\n// Efficient\nconsole.log('This does not block the main thread');\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Memory leaks\"}),`\n`,(0,n.jsx)(e.p,{children:\"Memory leaks occur when memory that is no longer needed is not released. Common causes include circular references and unremoved event listeners.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Circular references\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Inefficient\nfunction createCircularReference() {\n  const obj1 = {};\n  const obj2 = {};\n  obj1.ref = obj2;\n  obj2.ref = obj1;\n}\n\n// Efficient\nfunction createNonCircularReference() {\n  const obj1 = {};\n  const obj2 = {};\n  obj1.ref = obj2;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Unremoved event listeners\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Inefficient\nelement.addEventListener('click', handleClick);\n\n// Efficient\nelement.removeEventListener('click', handleClick);\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Improper use of asynchronous operations\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Unoptimized promises\"}),`\n`,(0,n.jsx)(e.p,{children:\"Chain promises properly to avoid blocking the main thread.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Inefficient\nfetch('url')\n  .then((response) => response.json())\n  .then((data) => {\n    // Process data\n  });\n\n// Efficient\nasync function fetchData() {\n  const response = await fetch('url');\n  const data = await response.json();\n  // Process data\n}\nfetchData();\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Debouncing and throttling\"}),`\n`,(0,n.jsx)(e.p,{children:\"Use debouncing and throttling to limit the rate of function execution, especially for event handlers.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// Debouncing\nfunction debounce(func, wait) {\n  let timeout;\n  return function (...args) {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => func.apply(this, args), wait);\n  };\n}\n\n// Throttling\nfunction throttle(func, limit) {\n  let inThrottle;\n  return function (...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => (inThrottle = false), limit);\n    }\n  };\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/Performance\",children:\"MDN Web Docs: Performance\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developers.google.com/web/fundamentals/performance\",children:\"Google Developers: Web Performance Optimization\"})}),`\n`]})]})}function k(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var w=k;return y(D);})();\n;return Component;"
}