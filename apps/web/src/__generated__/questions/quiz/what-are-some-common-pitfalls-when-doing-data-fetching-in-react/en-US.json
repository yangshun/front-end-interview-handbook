{
  "description": null,
  "format": "quiz",
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "medium",
    "duration": 5,
    "excerpt": null,
    "featured": true,
    "format": "quiz",
    "frameworkDefault": "react",
    "frameworks": [
      {
        "framework": "react",
        "href": "/questions/quiz/what-are-some-common-pitfalls-when-doing-data-fetching-in-react/react"
      }
    ],
    "href": "/questions/quiz/what-are-some-common-pitfalls-when-doing-data-fetching-in-react",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 400,
    "similarQuestions": [],
    "slug": "what-are-some-common-pitfalls-when-doing-data-fetching-in-react",
    "subtitle": null,
    "title": "What are some common pitfalls when doing data fetching in React?",
    "topics": [
      "react"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-reactjs-interview-questions/blob/main/questions/what-are-some-common-pitfalls-when-doing-data-fetching-in-react/en-US.mdx"
  },
  "solution": "var Component=(()=>{var l=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var f=Object.getPrototypeOf,m=Object.prototype.hasOwnProperty;var g=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),y=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},c=(t,e,r,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of u(e))!m.call(t,a)&&a!==r&&o(t,a,{get:()=>e[a],enumerable:!(s=p(e,a))||s.enumerable});return t};var x=(t,e,r)=>(r=t!=null?l(f(t)):{},c(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),j=t=>c(o({},\"__esModule\",{value:!0}),t);var d=g((D,i)=>{i.exports=_jsx_runtime});var k={};y(k,{default:()=>C,frontmatter:()=>E});var n=x(d()),E={title:\"What are some common pitfalls when doing data fetching in React?\"};function h(t){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",hr:\"hr\",h3:\"h3\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Common pitfalls when doing data fetching in React include not handling loading and error states, causing memory leaks by not cleaning up subscriptions, and not using the right lifecycle methods or hooks. Always ensure you handle these states properly, clean up after your components, and use \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" for side effects in functional components.\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Common pitfalls when doing data fetching in React\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Not handling loading and error states\"}),`\n`,(0,n.jsx)(e.p,{children:\"When fetching data, it's crucial to manage the different states of the request: loading, success, and error. Failing to do so can lead to a poor user experience.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`const [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(null);\n\nuseEffect(() => {\n  fetch('https://api.example.com/data')\n    .then(response => response.json())\n    .then(data => {\n      setData(data);\n      setLoading(false);\n    })\n    .catch(error => {\n      setError(error);\n      setLoading(false);\n    });\n}, []);\n\nif (loading) return <div>Loading...</div>;\nif (error) return <div>Error: {error.message}</div>;\nreturn <div>{JSON.stringify(data)}</div>;\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Causing memory leaks by not cleaning up subscriptions\"}),`\n`,(0,n.jsx)(e.p,{children:\"When a component unmounts before a fetch request completes, it can cause memory leaks. To prevent this, you should clean up any ongoing requests.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`useEffect(() => {\n  let isMounted = true;\n\n  fetch('https://api.example.com/data')\n    .then(response => response.json())\n    .then(data => {\n      if (isMounted) {\n        setData(data);\n        setLoading(false);\n      }\n    })\n    .catch(error => {\n      if (isMounted) {\n        setError(error);\n        setLoading(false);\n      }\n    });\n\n  return () => {\n    isMounted = false;\n  };\n}, []);\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Not using the right lifecycle methods or hooks\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In class components, data fetching should be done in \",(0,n.jsx)(e.code,{children:\"componentDidMount\"}),\". In functional components, use the \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" hook.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`// Class component\nclass MyComponent extends React.Component {\n  componentDidMount() {\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => this.setState({ data, loading: false }))\n      .catch(error => this.setState({ error, loading: false }));\n  }\n}\n\n// Functional component\nconst MyComponent = () => {\n  useEffect(() => {\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => setData(data))\n      .catch(error => setError(error));\n  }, []);\n};\n`})}),`\n`,(0,n.jsxs)(e.h3,{children:[\"Ignoring dependency arrays in \",(0,n.jsx)(e.code,{children:\"useEffect\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"The dependency array in \",(0,n.jsx)(e.code,{children:\"useEffect\"}),\" determines when the effect runs. Ignoring it can lead to unnecessary re-renders or missed updates.\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`useEffect(() => {\n  fetch('https://api.example.com/data')\n    .then(response => response.json())\n    .then(data => setData(data))\n    .catch(error => setError(error));\n}, []); // Empty array means this effect runs once after the initial render\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Fetching data in the render method\"}),`\n`,(0,n.jsx)(e.p,{children:\"Fetching data directly in the render method can cause infinite loops and performance issues. Always use lifecycle methods or hooks.\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`// Incorrect\nconst MyComponent = () => {\n  const data = fetch('https://api.example.com/data').then(response => response.json());\n  return <div>{JSON.stringify(data)}</div>;\n};\n\n// Correct\nconst MyComponent = () => {\n  useEffect(() => {\n    fetch('https://api.example.com/data')\n      .then(response => response.json())\n      .then(data => setData(data))\n      .catch(error => setError(error));\n  }, []);\n};\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://reactjs.org/docs/hooks-intro.html\",children:\"React documentation on hooks\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsxs)(e.a,{href:\"https://reactjs.org/docs/hooks-effect.html\",children:[\"React documentation on \",(0,n.jsx)(e.code,{children:\"useEffect\"})]})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://www.robinwieruch.de/react-hooks-fetch-data\",children:\"Handling async requests in React\"})}),`\n`]})]})}function M(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(h,t)})):h(t)}var C=M;return j(k);})();\n;return Component;"
}