{
  "description": null,
  "info": {
    "excerpt": null,
    "title": "What are the differences between JavaScript variables created using `let`, `var` or `const`?",
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/what-are-the-differences-between-variables-created-using-let-var-or-const/en-US.mdx"
  },
  "solution": "var Component=(()=>{var s=Object.create;var o=Object.defineProperty;var b=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,v=Object.prototype.hasOwnProperty;var g=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),p=(r,e)=>{for(var i in e)o(r,i,{get:e[i],enumerable:!0})},d=(r,e,i,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let c of f(e))!v.call(r,c)&&c!==i&&o(r,c,{get:()=>e[c],enumerable:!(l=b(e,c))||l.enumerable});return r};var m=(r,e,i)=>(i=r!=null?s(u(r)):{},d(e||!r||!r.__esModule?o(i,\"default\",{value:r,enumerable:!0}):i,r)),y=r=>d(o({},\"__esModule\",{value:!0}),r);var t=g((k,a)=>{a.exports=_jsx_runtime});var R={};p(R,{default:()=>x,frontmatter:()=>z});var n=m(t()),z={title:\"What are the differences between JavaScript variables created using `let`, `var` or `const`?\"};function h(r){let e=Object.assign({h2:\"h2\",p:\"p\",code:\"code\",table:\"table\",thead:\"thead\",tr:\"tr\",th:\"th\",tbody:\"tbody\",td:\"td\",hr:\"hr\",h3:\"h3\",em:\"em\",pre:\"pre\",ul:\"ul\",li:\"li\",a:\"a\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"In JavaScript, \",(0,n.jsx)(e.code,{children:\"let\"}),\", \",(0,n.jsx)(e.code,{children:\"var\"}),\", and \",(0,n.jsx)(e.code,{children:\"const\"}),\" are all keywords used to declare variables, but they differ significantly in terms of scope, initialization rules, whether they can be redeclared or reassigned and the behavior when they are accessed before declaration:\"]}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Behavior\"}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"var\"})}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"let\"})}),(0,n.jsx)(e.th,{children:(0,n.jsx)(e.code,{children:\"const\"})})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Scope\"}),(0,n.jsx)(e.td,{children:\"Function or Global\"}),(0,n.jsx)(e.td,{children:\"Block\"}),(0,n.jsx)(e.td,{children:\"Block\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Initialization\"}),(0,n.jsx)(e.td,{children:\"Optional\"}),(0,n.jsx)(e.td,{children:\"Optional\"}),(0,n.jsx)(e.td,{children:\"Required\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Redeclaration\"}),(0,n.jsx)(e.td,{children:\"Yes\"}),(0,n.jsx)(e.td,{children:\"No\"}),(0,n.jsx)(e.td,{children:\"No\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Reassignment\"}),(0,n.jsx)(e.td,{children:\"Yes\"}),(0,n.jsx)(e.td,{children:\"Yes\"}),(0,n.jsx)(e.td,{children:\"No\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:\"Accessing before declaration\"}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"undefined\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"ReferenceError\"})}),(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"ReferenceError\"})})]})]})]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Differences in behavior\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Let's look at the difference in behavior between \",(0,n.jsx)(e.code,{children:\"var\"}),\", \",(0,n.jsx)(e.code,{children:\"let\"}),\", and \",(0,n.jsx)(e.code,{children:\"const\"}),\".\"]}),`\n`,(0,n.jsx)(e.h3,{children:\"Scope\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Variables declared using the \",(0,n.jsx)(e.code,{children:\"var\"}),\" keyword are scoped to the function in which they are created, or if created outside of any function, to the global object. \",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" are \",(0,n.jsx)(e.em,{children:\"block scoped\"}),\", meaning they are only accessible within the nearest set of curly braces (function, if-else block, or for-loop).\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function foo() {\n  // All variables are accessible within functions.\n  var bar = 1;\n  let baz = 2;\n  const qux = 3;\n\n  console.log(bar); // 1\n  console.log(baz); // 2\n  console.log(qux); // 3\n}\n\nfoo(); // Prints each variable successfully\nconsole.log(bar); // ReferenceError: bar is not defined\nconsole.log(baz); // ReferenceError: baz is not defined\nconsole.log(qux); // ReferenceError: qux is not defined\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In the following example, \",(0,n.jsx)(e.code,{children:\"bar\"}),\" is accessible outside of the \",(0,n.jsx)(e.code,{children:\"if\"}),\" block but \",(0,n.jsx)(e.code,{children:\"baz\"}),\" and \",(0,n.jsx)(e.code,{children:\"quz\"}),\" are not.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`if (true) {\n  var bar = 1;\n  let baz = 2;\n  const qux = 3;\n}\n\n// var variables are accessible anywhere in the function scope.\nconsole.log(bar); // 1\n// let and const variables are not accessible outside of the block they were defined in.\nconsole.log(baz); // ReferenceError: baz is not defined\nconsole.log(qux); // ReferenceError: qux is not defined\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Initialization\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"var\"}),\" and \",(0,n.jsx)(e.code,{children:\"let\"}),\" variables can be initialized without a value but \",(0,n.jsx)(e.code,{children:\"const\"}),\" declarations must be initialized.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`var foo; // Ok\nlet bar; // Ok\nconst baz; // SyntaxError: Missing initializer in const declaration\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Redeclaration\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"Redeclaring a variable with \",(0,n.jsx)(e.code,{children:\"var\"}),\" will not throw an error, but \",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" will.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`var foo = 1;\nvar foo = 2; // Ok\nconsole.log(foo); // Should print 2, but SyntaxError from baz prevents the code executing.\n\nlet baz = 3;\nlet baz = 4; // Uncaught SyntaxError: Identifier 'baz' has already been declared\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Reassignment\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" differ in that \",(0,n.jsx)(e.code,{children:\"var\"}),\" and \",(0,n.jsx)(e.code,{children:\"let\"}),\" allow reassigning the variable's value while \",(0,n.jsx)(e.code,{children:\"const\"}),\" does not.\"]}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`var foo = 1;\nfoo = 2; // This is fine.\n\nlet bar = 3;\nbar = 4; // This is fine.\n\nconst baz = 5;\nbaz = 6; // Uncaught TypeError: Assignment to constant variable.\n`})}),`\n`,(0,n.jsx)(e.h3,{children:\"Accessing before declaration\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"var\"}),\" ,\",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" declared variables are all hoisted. \",(0,n.jsx)(e.code,{children:\"var\"}),\" declared variables are auto-initialized with an \",(0,n.jsx)(e.code,{children:\"undefined\"}),\" value. However, \",(0,n.jsx)(e.code,{children:\"let\"}),\" and \",(0,n.jsx)(e.code,{children:\"const\"}),\" variables are not initialized and accessing them before the declaration will result in a \",(0,n.jsx)(e.code,{children:\"ReferenceError\"}),' exception because they are in a \"temporal dead zone\" from the start of the block until the declaration is processed.']}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`console.log(foo); // undefined\nvar foo = 'foo';\n\nconsole.log(baz); // ReferenceError: Cannot access 'baz' before initialization\nlet baz = 'baz';\n\nconsole.log(bar); // ReferenceError: Cannot access 'baz' before initialization\nconst bar = 'bar';\n`})}),`\n`,(0,n.jsx)(e.h2,{children:\"Notes\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[\"In modern JavaScript, it's generally recommended to use \",(0,n.jsx)(e.code,{children:\"const\"}),\" by default for variables that don't need to be reassigned. This promotes immutability and prevents accidental changes.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Use \",(0,n.jsx)(e.code,{children:\"let\"}),\" when you need to reassign a variable within its scope.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"Avoid using \",(0,n.jsx)(e.code,{children:\"var\"}),\" due to its potential for scoping issues and hoisting behavior.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"If you need to target older browsers, write your code using \",(0,n.jsx)(e.code,{children:\"let\"}),\"/\",(0,n.jsx)(e.code,{children:\"const\"}),\", and use a transpiler like Babel compile your code to older syntax.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://medium.com/swlh/the-difference-of-var-vs-let-vs-const-in-javascript-abe37e214d66\",children:'The Difference of \"var\" vs \"let\" vs \"const\" in Javascript'})}),`\n`]})]})}function w(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(h,r)})):h(r)}var x=w;return y(R);})();\n;return Component;"
}