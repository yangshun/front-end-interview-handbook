{
  "description": null,
  "metadata": {
    "access": "free",
    "author": null,
    "companies": [],
    "created": 1630800000,
    "difficulty": "easy",
    "duration": 5,
    "excerpt": null,
    "featured": false,
    "format": "quiz",
    "frameworkDefault": null,
    "frameworks": [],
    "href": "/questions/quiz/explain-the-concept-of-lexical-scoping",
    "importance": "low",
    "languages": [],
    "nextQuestions": [],
    "published": true,
    "ranking": 999,
    "similarQuestions": [],
    "slug": "explain-the-concept-of-lexical-scoping",
    "subtitle": null,
    "title": "Explain the concept of lexical scoping",
    "topics": [
      "javascript"
    ],
    "gitHubEditUrl": "https://github.com/yangshun/top-javascript-interview-questions/blob/main/questions/explain-the-concept-of-lexical-scoping/en-US.mdx"
  },
  "solution": "var Component=(()=>{var u=Object.create;var t=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var g=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),x=(i,e)=>{for(var c in e)t(i,c,{get:e[c],enumerable:!0})},l=(i,e,c,r)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!f.call(i,o)&&o!==c&&t(i,o,{get:()=>e[o],enumerable:!(r=h(e,o))||r.enumerable});return i};var b=(i,e,c)=>(c=i!=null?u(m(i)):{},l(e||!i||!i.__esModule?t(c,\"default\",{value:i,enumerable:!0}):c,i)),F=i=>l(t({},\"__esModule\",{value:!0}),i);var s=g((V,a)=>{a.exports=_jsx_runtime});var w={};x(w,{default:()=>j,frontmatter:()=>v});var n=b(s()),v={title:\"Explain the concept of lexical scoping\"};function d(i){let e=Object.assign({h2:\"h2\",p:\"p\",pre:\"pre\",code:\"code\",hr:\"hr\",h3:\"h3\",ul:\"ul\",li:\"li\",a:\"a\"},i.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h2,{children:\"TL;DR\"}),`\n`,(0,n.jsx)(e.p,{children:\"Lexical scoping means that the scope of a variable is determined by its location within the source code, and nested functions have access to variables declared in their outer scope. For example:\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function outerFunction() {\n  let outerVariable = 'I am outside!';\n\n  function innerFunction() {\n    console.log(outerVariable); // 'I am outside!'\n  }\n\n  innerFunction();\n}\n\nouterFunction();\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"In this example, \",(0,n.jsx)(e.code,{children:\"innerFunction\"}),\" can access \",(0,n.jsx)(e.code,{children:\"outerVariable\"}),\" because of lexical scoping.\"]}),`\n`,(0,n.jsx)(e.hr,{}),`\n`,(0,n.jsx)(e.h2,{children:\"Lexical scoping\"}),`\n`,(0,n.jsx)(e.p,{children:\"Lexical scoping is a fundamental concept in JavaScript and many other programming languages. It determines how variable names are resolved in nested functions. The scope of a variable is defined by its position in the source code, and nested functions have access to variables declared in their outer scope.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"How lexical scoping works\"}),`\n`,(0,n.jsx)(e.p,{children:\"When a function is defined, it captures the scope in which it was created. This means that the function has access to variables in its own scope as well as variables in any containing (outer) scopes.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Example\"}),`\n`,(0,n.jsx)(e.p,{children:\"Consider the following example:\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function outerFunction() {\n  let outerVariable = 'I am outside!';\n\n  function innerFunction() {\n    console.log(outerVariable); // 'I am outside!'\n  }\n\n  innerFunction();\n}\n\nouterFunction();\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In this example:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"outerFunction\"}),\" declares a variable \",(0,n.jsx)(e.code,{children:\"outerVariable\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"innerFunction\"}),\" is nested inside \",(0,n.jsx)(e.code,{children:\"outerFunction\"}),\" and logs \",(0,n.jsx)(e.code,{children:\"outerVariable\"}),\" to the console.\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"When \",(0,n.jsx)(e.code,{children:\"innerFunction\"}),\" is called, it has access to \",(0,n.jsx)(e.code,{children:\"outerVariable\"}),\" because of lexical scoping.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h3,{children:\"Nested functions and closures\"}),`\n`,(0,n.jsx)(e.p,{children:\"Lexical scoping is closely related to closures. A closure is created when a function retains access to its lexical scope, even when the function is executed outside that scope.\"}),`\n`,(0,n.jsx)(e.pre,{live:!0,children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function outerFunction() {\n  let outerVariable = 'I am outside!';\n\n  function innerFunction() {\n    console.log(outerVariable);\n  }\n\n  return innerFunction;\n}\n\nconst myInnerFunction = outerFunction();\nmyInnerFunction(); // 'I am outside!'\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"In this example:\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"outerFunction\"}),\" returns \",(0,n.jsx)(e.code,{children:\"innerFunction\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"myInnerFunction\"}),\" is assigned the returned \",(0,n.jsx)(e.code,{children:\"innerFunction\"}),\".\"]}),`\n`,(0,n.jsxs)(e.li,{children:[\"When \",(0,n.jsx)(e.code,{children:\"myInnerFunction\"}),\" is called, it still has access to \",(0,n.jsx)(e.code,{children:\"outerVariable\"}),\" because of the closure created by lexical scoping.\"]}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{children:\"Further reading\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures\",children:\"MDN Web Docs: Closures\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://javascript.info/closure#lexical-environment\",children:\"JavaScript.info: Lexical environment\"})}),`\n`,(0,n.jsx)(e.li,{children:(0,n.jsx)(e.a,{href:\"https://eloquentjavascript.net/03_functions.html#h_jxlm8r9e2g\",children:\"Eloquent JavaScript: Functions and closures\"})}),`\n`]})]})}function I(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,Object.assign({},i,{children:(0,n.jsx)(d,i)})):d(i)}var j=I;return F(w);})();\n;return Component;"
}