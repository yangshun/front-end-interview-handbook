---
title: Você pode oferecer um caso de uso para a nova sintaxe de função => arrow?
subtitle: Como essa nova sintaxe difere de outras funções?
---

## TL;DR

As funções arrow fornecem uma sintaxe concisa para escrever funções em JavaScript. Elas são particularmente úteis para manter o contexto de `this` dentro de métodos e callbacks. Por exemplo, em um manipulador de eventos ou método de array como `map`, as funções arrow podem simplificar o código e evitar problemas com a vinculação de `this`.

```js live
const numbers = [1, 2, 3];
const doubled = numbers.map((n) => n * 2);
console.log(doubled); // [2, 4, 6]
```

---

## Caso de uso para a nova sintaxe de função => arrow

### Simplificando a sintaxe

As funções arrow fornecem uma maneira mais concisa de escrever funções. Isso é especialmente útil para funções curtas ou callbacks.

```js live
// Função tradicional
const add = function (a, b) {
  return a + b;
};

// Função de seta
const anotherAdd = (a, b) => a + b;

console.log(add(2, 3)); // Saída: 5
console.log(anotherAdd(2, 3)); // Saída: 5
```

### Ligação lexical de `this`

Funções de seta não têm seu próprio contexto `this`. Em vez disso, elas herdam `this` do escopo circundante. Isso é particularmente útil em métodos e callbacks onde o contexto `this` pode ser complicado.

```js live
function Timer() {
  this.seconds = 0;
  this.increment = () => {
    this.seconds++; // 'this.seconds' é herdado do escopo externo
    console.log(this.seconds);
  };
}

const timer = new Timer();
timer.increment(); // 1
timer.increment(); // 2
```

No exemplo acima, usar uma função tradicional dentro de `setInterval` exigiria etapas adicionais para manter o contexto correto de `this`.

### Usando funções de seta em métodos de array

As funções de seta são frequentemente usadas em métodos de array como `map`, `filter` e `reduce` para um código mais limpo e legível.

```js live
const numbers = [1, 2, 3, 4, 5];

// Função tradicional
const doubledTraditional = numbers.map(function (n) {
  return n * 2;
});

// Função de seta
const doubled = numbers.map((n) => n * 2);

console.log(doubled); // [2, 4, 6, 8, 10]
```

### Manipuladores de eventos

Funções de seta podem ser usadas em manipuladores de eventos para manter o contexto `this` da classe ou objeto.

```js live
class Button {
  constructor() {
    this.count = 0;
    this.button = document.createElement('button');
    this.button.innerText = 'Clique em mim';
    this.button.addEventListener('click', () => {
      this.count++;
      console.log('count:', this.count);
    });
    document.body.appendChild(this.button);
  }
}

const myButton = new Button();
myButton.button.click(); // count: 1
myButton.button.click(); // count: 2
```

## Leitura adicional

- [MDN Web Docs: Funções de seta](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
- [JavaScript.info: Funções de seta revisitadas](https://javascript.info/arrow-functions)
- [Eloquent JavaScript: Funções](https://eloquentjavascript.net/03_functions.html)
