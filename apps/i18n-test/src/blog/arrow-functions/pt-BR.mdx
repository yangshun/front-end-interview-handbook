---
title: Você pode oferecer um caso de uso para a nova sintaxe de função => arrow?
subtitle: Como essa nova sintaxe difere de outras funções?
---

## TL;DR

Funções de seta fornecem uma sintaxe concisa para escrever funções em JavaScript. Elas são particularmente úteis para manter o contexto `this` dentro de métodos e callbacks. Por exemplo, em um manipulador de eventos ou método de array como `map`, funções de seta podem simplificar o código e evitar problemas com a ligação de `this`.

```js live
const numbers = [1, 2, 3];
const doubled = numbers.map((n) => n * 2);
console.log(doubled); // [2, 4, 6]
```

***

## Caso de uso para a nova sintaxe de função de seta =>

### Simplificando a sintaxe

Funções de seta fornecem uma maneira mais concisa de escrever funções. Isso é especialmente útil para funções curtas ou callbacks.

```js live
// Função tradicional
const add = function (a, b) {
  return a + b;
};

// Função de seta
const anotherAdd = (a, b) => a + b;

console.log(add(2, 3)); // Output: 5
console.log(anotherAdd(2, 3)); // Output: 5
```

### Ligação léxica `this`

Funções de seta não têm seu próprio contexto `this`. Em vez disso, elas herdam `this` do escopo circundante. Isso é particularmente útil em métodos e callbacks onde o contexto `this` pode ser complicado.

```js live
function Timer() {
  this.seconds = 0;
  this.increment = () => {
    this.seconds++; // 'this.seconds' is inherited from the outer scope
    console.log(this.seconds);
  };
}

const timer = new Timer();
timer.increment(); // 1
timer.increment(); // 2
```

No exemplo acima, usar uma função tradicional dentro de `setInterval` exigiria etapas adicionais para manter o contexto `this` correto.

### Usando funções de seta em métodos de array

Funções de seta são frequentemente usadas em métodos de array como `map`, `filter` e `reduce` para um código mais limpo e legível.

```js live
const numbers = [1, 2, 3, 4, 5];

// Função tradicional
const doubledTraditional = numbers.map(function (n) {
  return n * 2;
});

// Função de seta
const doubled = numbers.map((n) => n * 2);

console.log(doubled); // [2, 4, 6, 8, 10]
```

### Manipuladores de eventos

Funções de seta podem ser usadas em manipuladores de eventos para manter o contexto `this` da classe ou objeto.

```js live
class Button {
  constructor() {
    this.count = 0;
    this.button = document.createElement('button');
    this.button.innerText = 'Click me';
    this.button.addEventListener('click', () => {
      this.count++;
      console.log('count:', this.count);
    });
    document.body.appendChild(this.button);
  }
}

const myButton = new Button();
myButton.button.click(); // count: 1
myButton.button.click(); // count: 2
```

`<Component />` é um componente React que pode ser usado para renderizar o conteúdo da página. É um espaço reservado para qualquer componente que você queira usar.

Se `<br>` não for renderizado, ele será substituído por uma quebra de linha. Tente `console.log("Hello")` para ver se o JavaScript está habilitado.

Se `<hr/>` não for renderizado, tente `<hr>` em vez disso.

Para detectar se o JavaScript está desabilitado em uma página, você pode usar a tag HTML `<noscript>`. Essa tag permite que você exiba conteúdo ou mensagens para usuários que desabilitaram o JavaScript em seus navegadores. Por exemplo, você pode incluir uma mensagem dentro da tag `<noscript>` para informar aos usuários que o JavaScript é necessário para a funcionalidade completa da página.

## Leitura adicional

* [MDN Web Docs: Funções de seta](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Functions/Arrow_functions)
* [JavaScript.info: Funções de seta revisadas](https://javascript.info/arrow-functions)
* [JavaScript Eloquente: Funções](https://eloquentjavascript.net/03_functions.html)
