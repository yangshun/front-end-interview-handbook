import MDXCodeBlock from 'MDXCodeBlock';

import heapJs from '../setup/src/heap.js';
import heapTs from '../setup/src/heap.ts';

## 解决方案

堆是一种特殊的基于树的数据结构，它满足堆属性，其中在最大堆中，每个父节点都大于或等于其子节点的值。此属性使堆成为实现优先级队列的理想选择，在优先级队列中，需要快速访问最高（或最低）优先级元素。

### 操作

* `heapify(array)`：从无序数组构造堆。这是通过对数组的后半部分执行一系列插入操作来完成的，以就地构建堆。
* `insert(value)`：向堆中添加一个新元素。这涉及将元素附加到数组的末尾（表示堆），然后向上移动新添加的元素，直到恢复堆属性（如果它被违反）。

![Insert](/img/questions/heap/insert.png)

* `delete()`：删除堆的根元素，即最大堆中的最大值。堆的最后一个元素替换根，然后慢慢向下移动，直到恢复堆属性。

![Delete](/img/questions/heap/delete.png)

* `findMax()`：返回堆的根元素，而不删除它，从而提供对最大值的恒定时间访问。

由于操作 `insert` 和 `delete` 可能涉及在堆的高度上移动元素，因此它们的时间复杂度为 O(log n)，其中 n 是堆中元素的数量。`findMax` 是一个恒定时间操作，O(1)，因为它返回第一个元素。`Heapify` 的时间复杂度为 O(n log(n))，因为它遍历每个元素并逐个缓慢地插入它们。

## 边缘情况

* 插入到空堆中。
* 从空堆中删除。
* 在空堆上调用 `findMax`。

## 技术

* 面向对象编程。
* 数组操作以模拟二叉树。
* 了解对数时间复杂度以及操作如何影响它。

此堆实现侧重于高效的数据操作，利用二叉树的属性来确保快速访问高优先级项目，同时保持以对数时间进行调整的能力。

<MDXCodeBlock languages={{ jsx: heapJs, tsx: heapTs }} />
