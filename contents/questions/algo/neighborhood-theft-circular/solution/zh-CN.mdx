import MDXCodeBlock from 'MDXCodeBlock';

import neighborhoodTheftCircular from '../setup/src/neighborhood-theft-circular.ts';
import neighborhoodTheftCircularTopDownApproach from '../setup/src/neighborhood-theft-circular-top-down.ts';

## 1. 自顶向下动态规划

此解决方案将邻里盗窃问题扩展到房屋的环形排列。在这种情况下，第一个和最后一个房屋是相邻的，因此它们不能同时被抢劫。该解决方案使用分治法，将循环问题分解为两个线性子问题：

1. 排除第一个房屋并计算其余房屋的最大金额。
2. 排除最后一个房屋并计算其余房屋的最大金额。

这些子问题使用自顶向下的动态规划方法和记忆化来解决。辅助函数 `robWithMemo` 通过递归地探索每个房屋的两个选项来计算可以从给定范围的房屋中抢劫的最大金额：

* 抢劫当前房屋并跳过下一个房屋。
* 跳过当前房屋并移至下一个房屋。

记忆化确保缓存中间结果，避免冗余计算并提高效率。最终结果是两个子问题的最大值，代表循环排列的最优解。

### 算法

1. 处理特殊情况：
   * 如果没有房屋，则返回 `0`。
   * 如果只有一个房屋，则返回其值。
2. 定义一个辅助函数 `robWithMemo` 来计算可以从给定范围的房屋中抢劫的最大金额：
   1. 初始化一个 `memo` 数组来存储中间结果，用 `-1` 填充以指示未计算的值。
   2. 定义一个递归函数 `dp(i)`：
      * 如果 `i` 超过范围的末尾，则返回 `0`，因为没有房屋可以抢劫。
      * 如果已计算，则返回 `memo[i]` 中的缓存值。
      * 通过选择以下选项来计算当前房屋的最大金额：
        * 抢劫当前房屋并添加跳过下一个房屋的结果 (`numbers[i] + dp(i + 2)`)。
        * 跳过当前房屋并移至下一个房屋 (`dp(i + 1)`)。
      * 将结果缓存在 `memo[i]` 中并返回。
   3. 从给定范围的起始索引开始递归，并返回结果。
3. 计算两个子问题：
   * 排除第一个房屋的最大金额 (`robWithMemo(numbers, 1, numbers.length - 1)`)。
   * 排除最后一个房屋的最大金额 (`robWithMemo(numbers, 0, numbers.length - 2)`)。
4. 返回两个结果的最大值。

<MDXCodeBlock>
  {neighborhoodTheftCircularTopDownApproach}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个子问题在其范围内处理所有房屋一次，从而产生线性时间复杂度。
* **空间复杂度：O(n)**。记忆化数组需要与范围内的房屋数量成比例的空间。

## 2. 自底向上动态规划

循环邻里盗窃问题需要处理第一个和最后一个房屋是邻居的附加约束。当同时考虑抢劫这两个房屋时，这会产生冲突，因为同时抢劫它们会违反问题的约束。为了解决这个问题，将问题分为两个独立的场景：

1. 从第二个房屋抢劫到最后一个房屋，不包括第一个房屋。
2. 从第一个房屋抢劫到倒数第二个房屋，不包括最后一个房屋。

通过独立地解决这两个线性子问题，可以有效地处理循环约束。然后比较这两种情况的结果，以确定可以抢劫的最大金额。

这些子问题中的每一个都使用空间优化的动态规划方法来解决。不是维护一个完整的 `dp` 数组来存储所有房屋的最大金额，而是使用两个变量来跟踪当前房屋和前一个房屋的结果。这降低了空间复杂度，同时确保有效地计算每个子问题的最优解。

核心思想是使用一个观察结果，即在线性房屋排列中，抢劫或跳过每个房屋的决定仅取决于可以从前两个房屋抢劫的最大金额。这里采用了这一原则，通过解决两个单独的线性情况并结合它们的结果来处理循环排列。

### 算法

1. 检查 `numbers` 数组是否为空。如果是，则返回 `0`，因为没有房屋可以抢劫。
2. 检查 `numbers` 数组是否只有一个房屋。如果是，则返回该房屋的值。
3. 解决两个线性子问题：
   * 使用从索引 `0` 到 `n - 2`（不包括最后一个房屋）的范围调用 `robSimple`。
   * 使用从索引 `1` 到 `n - 1`（不包括第一个房屋）的范围调用 `robSimple`。
4. 返回两个结果的最大值。
5. 定义辅助函数 `robSimple` 来解决线性抢劫问题：
   1. 将两个变量 `t1` 和 `t2` 初始化为 `0`。这些变量表示可以抢劫到当前房屋和前一个房屋的最大金额。
   2. 遍历从 `start` 到 `end` 的房屋范围：
      * 将当前房屋可以抢劫的最大金额计算为以下各项的最大值：
        * 抢劫当前房屋并添加 `t2`（表示抢劫到两个房屋之前的最大金额）。
        * 跳过当前房屋并使用 `t1`（表示抢劫到前一个房屋的最大金额）。
      * 将 `t2` 更新为 `t1` 的值。
      * 将 `t1` 更新为计算出的最大值。
   3. 循环结束后，返回 `t1`，其中包含在该范围内可以抢劫的最大金额。

<MDXCodeBlock>
  {neighborhoodTheftCircular}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。在辅助函数的两次线性迭代中，每个房屋只处理一次。
* **空间复杂度：O(1)**。仅使用两个变量 `t1` 和 `t2` 来跟踪中间结果。
