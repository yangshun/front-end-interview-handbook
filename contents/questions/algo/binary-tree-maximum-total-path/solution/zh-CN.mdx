import MDXCodeBlock from 'MDXCodeBlock';

import binaryTreeMaximumPathSum from '../setup/src/binary-tree-maximum-total-path.ts';

## 1. 使用后序遍历DFS

二叉树中的最大路径和是任何路径中节点值的最大总和。路径可以从树中的任何节点开始和结束，但它必须遵循父子连接。该策略使用后序深度优先搜索（DFS）来探索每个子树，并计算每个节点左右子树的最大增益。对于每个节点，潜在的最大路径和计算为其值与左右子树的最大增益之和。忽略来自子树的负增益，以确保仅包含具有正贡献的路径。通过遍历整个树，确定全局最大路径和。

### 算法

1. 对树执行后序遍历，仅在处理完其左右子树后才处理每个节点。
2. 对于每个节点，计算其左右子树的最大增益。如果子树贡献负增益，则将其忽略，视为 0。
3. 计算当前节点的路径和，即其值与其左右子树的最大增益之和。
4. 如果当前节点的计算路径和更大，则更新全局最大路径和。
5. 返回可以传递给父节点的最大增益，其中包括节点的值以及来自其左子树或右子树的较大增益。

<MDXCodeBlock>
  {binaryTreeMaximumPathSum}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。在遍历期间，每个节点都会被访问一次。
* **空间复杂度：O(h)**。递归堆栈所需的空间与树的高度成正比，其中 `h` 是树的高度。
