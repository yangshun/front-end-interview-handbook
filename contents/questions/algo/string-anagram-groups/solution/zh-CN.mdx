import MDXCodeBlock from 'MDXCodeBlock';

import anagramGroups from '../setup/src/string-anagram-groups.ts';
import groupAnagramsUsingFreqCount from '../setup/src/string-anagram-groups-freq-count.ts';

## 1. 使用排序

一种朴素的方法可能涉及检查所有可能的字符串对，这将是低效的。然而，这种优化的解决方案使用每个字符串的排序版本作为分组的唯一键。排序确保所有字谜产生相同的键，简化了组的识别。对每个字符串进行排序将问题简化为键生成，使用 `Map` 处理起来很简单。

### 算法

1. 初始化一个空的 `Map` 来存储字谜组。
   * 键表示字符串的排序版本，值是原始字符串的数组。
2. 遍历字符串的输入数组。
   * 对于每个字符串，将其转换为字符数组并按字母顺序排序。
   * 连接排序后的字符以创建键。
3. 检查键是否已存在于 `Map` 中。
   * 如果键不存在，则使用一个空数组对其进行初始化。
   * 将原始字符串附加到与键对应的数组中。
4. 将 `Map` 的值转换为数组的数组并返回。

<MDXCodeBlock>
  {anagramGroups}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n.m log m)**。对长度为 `m` 的每个字符串进行排序需要 O(m log m)，并且有 `n` 个字符串。
* **空间复杂度：O(n.m)**。`Map` 存储所有字符串，键和值所需的空间取决于输入中的总字符数。

## 2. 使用频率计数

与对字符串进行排序以生成键（如之前的解决方案）不同，使用固定大小的频率数组（对于英文字母为 26）来计算每个字符的出现次数。此解决方案通过使用其字符频率计数来表示每个字符串，从而优化了该过程。这消除了对排序的需要，而排序是基于排序的方法中的瓶颈。

每个组的键是从频率计数派生的，格式化为包含所有字符计数的连接字符串。这确保所有字谜都映射到相同的键，同时避免了排序开销，提高了解决方案的效率。

### 算法

1. 检查输入数组是否为空。
   * 如果数组为空，则返回一个空数组。
2. 初始化一个空对象来存储字谜组。
   * 键表示字符计数模式，值是与该模式匹配的字符串数组。
3. 遍历输入数组中的每个字符串。
   * 初始化一个大小为 26 的计数数组来表示字符频率。
   * 对于字符串中的每个字符，递增计数数组中对应的索引。
4. 从计数数组生成一个键字符串。
   * 连接 `#` 和每个字符的计数以形成键。
5. 检查该键是否存在于对象中。
   * 如果该键不存在，则使用一个空数组对其进行初始化。
   * 将字符串附加到与该键对应的数组中。
6. 将对象的值作为字谜组的数组返回。

<MDXCodeBlock>
  {groupAnagramsUsingFreqCount}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n.m)**。计算每个长度为 `m` 的字符串的字符需要 O(m)，并且有 `n` 个字符串。
* **空间复杂度：O(n.m)**。对象存储所有字符串，并为字符计数和键使用额外的空间。
