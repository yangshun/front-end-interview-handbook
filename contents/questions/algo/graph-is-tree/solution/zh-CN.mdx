import MDXCodeBlock from 'MDXCodeBlock';

import graphIsTree from '../setup/src/graph-is-tree.ts';
import graphIsTreeUsingUnion from '../setup/src/graph-is-tree-using-union.ts';

## 1. 图论和 DFS

问题是确定给定的无向图是否为有效树。 树定义为无环的连通图，对于 `n` 个节点，恰好有 `n - 1` 条边。

该解决方案背后的直觉是验证两个关键属性：

1. 图应该是连通的，这意味着从任何节点开始都必须可以到达所有节点。
2. 图中不应该有环。

深度优先搜索 (DFS) 用于遍历图，同时检测环。 遍历从单个节点开始，将节点标记为已访问在 `Set` 中。 在遍历期间，如果重新访问一个节点（不包括遍历中的父节点），则检测到一个环。 此外，检查边的数量以确保它恰好是 `n - 1`，因为这是有效树的必要条件。

这种方法通过在单个 DFS 遍历中结合环检测和连通性验证来避免冗余检查。

### 算法

1. 检查边的数量是否不等于 `num - 1`。 如果是，则返回 `false`，因为该图不能是树。
2. 创建一个邻接表来表示该图：
   * 初始化一个 `Map`，其中每个节点指向一个空数组。
   * 通过将每条边的两个端点添加到彼此的邻居列表中来填充邻接表。
3. 初始化一个名为 `seen` 的空 `Set`，用于在遍历期间跟踪已访问的节点。
4. 定义一个递归的 `dfs` 函数：
   * 如果当前节点已经在 `seen` 中，则返回 `false`，因为这表示一个环。
   * 将当前节点添加到 `seen`。
   * 对于当前节点的每个邻居：
     * 跳过父节点以避免误报环检测。
     * 递归地对邻居调用 `dfs`。 如果任何递归调用检测到环，则返回 `false`。
   * 在处理完所有邻居后返回 `true`。
5. 从节点 `0` 开始调用 `dfs`，并将 `-1` 作为父节点。
6. 通过检查 `seen` 的大小是否等于 `num` 来验证该图是否已连接。
7. 如果未检测到环并且该图已连接，则返回 `true`。

<MDXCodeBlock>
  {graphIsTree}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(v + e)**。 在 DFS 遍历期间，每个节点 (`v`) 和边 (`e`) 都会被访问一次。
* **空间复杂度：O(v)**。 `seen` 集合和邻接表所需的空间与节点数成正比。

## 2. 图论和并查集

问题是确定给定的无向图是否为有效树。 树是一个连通图，没有环，对于 `n` 个节点，恰好有 `n - 1` 条边。

并查集数据结构用于有效地跟踪连通分量并检测环。 最初，每个节点都被视为其自己的分量。 当一条边连接两个节点时，`union` 操作会合并分量，而 `find` 操作使用路径压缩确保对节点分量的有效查找。 如果一条边连接了已经在同一分量中的两个节点，则检测到一个环。 此外，该图必须恰好有 `n - 1` 条边才能成为单个连通分量。

这种方法通过使用高效的并查集操作直接管理分量之间的关系，消除了对节点和边的冗余遍历。

### 算法

1. 检查边的数量是否不等于 `num - 1`。 如果是，则返回 `false`，因为该图不能是树。
2. 初始化并查集数据结构：
   * 创建一个 `parent` 数组，其中每个节点最初都是它自己的父节点。
   * 创建一个 `size` 数组来跟踪每个分量的大小，将所有大小初始化为 `1`。
3. 定义 `find` 函数：
   * 向上遍历父指针，直到到达分量的根。
   * 通过使路径上的所有节点直接指向根来应用路径压缩。
4. 定义 `union` 函数：
   * 使用 `find` 函数确定两个节点的根分量。
   * 如果根相同，则检测到一个环。 返回 `false`。
   * 否则，将较小的分量合并到较大的分量中并更新大小。
5. 遍历边列表：
   * 使用 `union` 函数合并由每条边连接的节点。
   * 如果在此过程中检测到环，则返回 `false`。
6. 如果未检测到环，并且该图有 `n - 1` 条边，则返回 `true`。

<MDXCodeBlock>
  {graphIsTreeUsingUnion}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(e.α(v))**。 由于路径压缩和按大小合并，`union` 和 `find` 操作几乎是恒定时间，其中 α(v) 是反阿克曼函数。
* **空间复杂度：O(v)**。 `parent` 和 `size` 数组所需的空间与节点数 (`v`) 成正比。
