import MDXCodeBlock from 'MDXCodeBlock';

import binaryTreeEqual from '../setup/src/binary-tree-equal.ts';
import binaryTreeEqualIterative from '../setup/src/binary-tree-equal-stack.ts';

## 1. 递归

检查两个二叉树是否相同的问题涉及逐个比较两个树的结构和值。递归方法通过将其分解为左右子树的较小子问题来简化此过程。

该方法首先检查基本情况：如果两个节点都为 null，则树在该点上相同，但如果一个节点为 null 而另一个节点不为 null，或者它们的值不同，则树不相同。然后它执行递归检查，比较两棵树的左子树和两棵树的右子树。仅当左右子树都相同时，才认为树相同。一旦所有对应的节点都已比较或发现不匹配，递归就会终止。

这种方法确保检查每个节点的结构和值。

### 算法

1. 检查基本情况：
   1. 如果 `a` 和 `b` 都为 `null`，则返回 `true`，因为树在该点上相同。
   2. 如果 `a` 或 `b` 其中之一为 `null`，则返回 `false`，因为树的结构不同。
   3. 如果 `a` 和 `b` 的值不相等，则返回 `false`，因为树的值不同。
2. 递归检查左右子树：
   * 对 `a` 和 `b` 的右子树调用 `binaryTreeEqual`。
   * 对 `a` 和 `b` 的左子树调用 `binaryTreeEqual`。
3. 如果左右子树的比较都返回 `true`，则返回 `true`。

<MDXCodeBlock>
  {binaryTreeEqual}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。 两个树中的每个节点都会被访问一次。
* **空间复杂度：O(h)**。 递归堆栈需要与树的高度成比例的空间，其中 `h` 是两棵树的最大高度。

## 2. 迭代

用于确定两个二叉树是否相同的迭代方法使用广度优先遍历策略。 这种方法不依赖于递归，而是使用队列来管理来自两棵树的节点对，从而确保结构和值的等价性。

该算法首先初始化一个队列，其中包含两棵树的根节点作为一对。 每一对节点都会出列，并检查它们的等价性。 如果两个节点都为 `null`，则该对在该点上被认为是相同的。 如果一个节点为 `null` 而另一个节点不为 `null`，或者它们的值不同，则树不相同。 对于非 `null` 节点，将两个节点的左右子节点作为新对入队。 该过程一直持续到队列为空，这表明两棵树中所有对应的节点在结构和值上都是相同的。

### 算法

1. 定义一个辅助函数 `check`，该函数：
   * 如果两个节点都为 `null`，则返回 `true`。
   * 如果一个节点为 `null` 而另一个节点不为 `null`，则返回 `false`。
   * 比较两个非 `null` 节点的值，如果它们相等，则返回 `true`。
2. 使用两棵树的根节点作为一对来初始化队列。
3. 当队列不为空时：
   * 出队第一对节点，并使用 `check` 函数验证它们。
   * 如果节点有效，则将它们的左右子节点作为新对入队以进行进一步比较。
4. 如果在遍历过程中未发现违规行为，则返回 `true`。

<MDXCodeBlock>
  {binaryTreeEqualIterative}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。 两个树中的每个节点都会被处理一次。
* **空间复杂度：O(n)**。 队列最多存储 `n` 对节点，具体取决于树的大小。
