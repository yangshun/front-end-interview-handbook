import MDXCodeBlock from 'MDXCodeBlock';

import insertionSortJs from '../setup/src/insertion-sort.js';
import insertionSortTs from '../setup/src/insertion-sort.ts';

插入排序是一种稳定的、原地的、基于比较的算法，适用于中小型数组以及部分排序的数组。

它只需要少量的工作就可以对已经部分排序的数组进行排序。

## 澄清问题

如果未指定：

* 数据应该按升序还是降序排序？
* 数据应该就地排序还是可以使用其他数据结构？
* 我们需要处理什么样的输入？
  * 它只是一个整数数组，还是我们应该处理其他数据类型？
  * 是否存在大量重复元素？
  * 应该如何处理负数？

## 解决方案

注意：此问题针对升序输出的就地排序。请参阅下面的“注释”部分，了解如何处理其他情况。

<MDXCodeBlock languages={{ jsx: insertionSortJs, tsx: insertionSortTs }} />

## 边缘情况

* 非整数元素输入：如果输入数组包含不同数据类型的元素，您可能需要返回一个错误，尽力进行排序，例如，仅对输入数据的子集进行排序，甚至为非整数定义自定义比较函数。
* 单个元素/空输入：返回原始数据结构、引发错误或阐明所需处理方式。
* 大输入：您可能需要考虑使用其他优化，如二分查找，以加快插入速度。
* 已排序的输入：您可能需要检测排序并保持输入不变。
* 无效输入：如果输入不是数组，请考虑抛出错误。

## 笔记

* 如果要求按降序排序：只需将比较更改为 `<` 而不是 `>`，如下所示：

```js
while (j >= 0 && arr[j] < currentValue)
```

* 如果要求使用其他数据结构或编写纯函数而不是就地排序数据，请使用扩展运算符或 `Array.prototype.slice()` 克隆输入数组，并在克隆的数组上进行排序。

## Big-O 分析

让我们分析一下算法的时间和空间复杂度。

### 时间复杂度

对于插入排序，最佳时间复杂度为 O(n)，最坏时间复杂度为 O(n<sup>2</sup>)，平均时间复杂度也为 O(n<sup>2</sup>)。

由于插入排序需要嵌套循环结构，其中外循环遍历数组，内循环遍历已排序的数组以找到插入当前元素的正确位置，因此时间复杂度通常为O(n<sup>2</sup>)，如果两个循环都完全迭代。不同情况之间的差异受到原始输入排序程度的影响，这会影响我们是否需要对特定元素运行内循环。

* **最坏情况时间复杂度**：当输入以完全相反的顺序排列时，输出必须是（例如，当我们需要降序时升序）。我们需要对每个元素完全遍历外循环和内循环，时间复杂度为O(n<sup>2</sup>)。
* **最佳情况时间复杂度**：当输入已经排序或接近排序时。这意味着内循环不需要迭代太多。在最好的情况下，输入数组已经完全排序，我们只运行外循环，复杂度为O(n)。
* **平均情况时间复杂度**：考虑到输入数组随机排列的情况，算法的内循环仍然必须遍历数组的已排序部分，以便找到插入当前元素的正确位置。

### 空间复杂度

插入排序的空间复杂度为O(1)，因为它进行原地排序，不需要与输入大小成比例的额外存储。
