import MDXCodeBlock from 'MDXCodeBlock';

import kthSmallestElementInABst from '../setup/src/binary-search-tree-kth-smallest.ts';
import kthSmallestElementInABstIteration from '../setup/src/binary-search-tree-kth-smallest-iteration.ts';

## 1. 使用递归

在二叉搜索树 (BST) 中查找第 `k` 个最小元素的这个问题使用了中序遍历的属性。BST 的中序遍历按照节点值的升序访问节点。利用此属性，该算法按排序顺序收集节点值并直接检索第 `k` 个最小值。

中序遍历确保 BST 的值按升序访问。通过遍历左子树，然后是当前节点，最后是右子树，该算法系统地收集排序后的值。

该算法递归地遍历 BST，在此过程中将节点值附加到数组中。此数组包含所有按升序排列的节点值。

由于数组已排序，第 `k` 个最小元素对应于索引 `k-1` 处的元素，因为索引是从零开始的。这使得检索效率很高。

### 算法

1. 定义一个辅助函数 `inorderTraversal`，该函数：
   1. 接受一个节点 `root` 和一个数组 `arr` 作为输入。
   2. 检查当前节点是否为 `null`。如果为真，则返回数组。
   3. 通过在 `root.left` 上调用 `inorderTraversal` 来递归遍历左子树。
   4. 将当前节点的值附加到数组中。
   5. 通过在 `root.right` 上调用 `inorderTraversal` 来递归遍历右子树。
   6. 返回按排序顺序收集的值的数组。
2. 在 BST 的根节点上调用 `inorderTraversal`，并使用一个空数组来获取所有按排序顺序排列的节点值。
3. 通过访问排序数组的 `(k-1)`-th 索引来检索第 `k` 个最小元素。
4. 将此值作为结果返回。

<MDXCodeBlock>
  {kthSmallestElementInABst}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。中序遍历正好访问每个节点一次。
* **空间复杂度：O(n)**。数组存储所有节点值，递归堆栈也可能使用高达 O(h) 的空间，其中 `h` 是 BST 的高度。

## 2. 使用迭代

用于在二叉搜索树 (BST) 中查找第 `k` 个最小元素的迭代方法使用中序遍历，该遍历按升序访问节点。与递归方法不同，此方法使用堆栈来管理遍历，避免递归并减少调用堆栈的使用。

中序遍历按升序处理 BST 的节点。通过遍历左子树，访问根节点，然后遍历右子树，节点按排序顺序依次访问。

该算法没有遍历整个树，而是跟踪已访问的节点数 (`k`)，并在找到第 `k` 个最小节点后停止。这种优化确保了效率。

迭代方法避免了递归的开销，并使用堆栈来管理遍历，堆栈大小与树的高度成正比。

### 算法

1. 初始化一个空堆栈以在遍历期间存储节点。
2. 当 `true`（无限循环）时：
   1. 遍历到最左边的节点：
      * 将当前 `root` 节点推入堆栈。
      * 移动到左子节点 (`root = root.left`)。
   2. 弹出堆栈顶部的节点：
      * 将弹出的节点分配给 `root`。
   3. 递减 `k`。如果 `k` 变为 `0`，则返回当前节点的值 (`root.val`)。
   4. 移动到右子树 (`root = root.right`)。

<MDXCodeBlock>
  {kthSmallestElementInABstIteration}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(h + k)**。该算法最多访问 `k` 个节点，并在最左边的遍历中探索最大深度 `h`（树的高度）。
* **空间复杂度：O(h)**。堆栈存储沿通往最左边节点的路径的节点，这与树的高度成正比。
