import MDXCodeBlock from 'MDXCodeBlock';

import findWordInGrid from '../setup/src/grid-find-word.ts';

## 1. 使用回溯法

该问题要求判断给定的 `target` 单词是否存在于字符的二维网格中。该单词可以由网格中连续相邻的单元格构成，可以上下左右移动。一个单元格不能在同一个单词构造中重复使用。

该方法使用回溯法和深度优先搜索（DFS）来探索从网格中每个单元格开始的所有可能路径。在每一步，算法检查当前单元格是否与 `target` 的下一个字符匹配。如果发生不匹配或单元格超出边界，则放弃该路径。为了确保不重复访问单元格，在 DFS 探索期间，它被临时标记为已访问。在探索完所有方向后，单元格的值被恢复以使其他路径可以使用它。

这种方法系统地探索所有可能的路径，同时尽早修剪无效路径，优化搜索过程。

### 算法

1. 检索网格中的行数和列数。
2. 定义一个递归的 `backtrack` 函数：
   * 如果 `suffix` 为空，则返回 `true`，因为整个单词已匹配。
   * 检查当前单元格是否超出边界，或者它是否与 `suffix` 的第一个字符不匹配。如果是，则返回 `false`。
   * 通过暂时将其值更改为 `'#'` 来标记当前单元格为已访问。
   * 定义四个可能要探索的方向：右、下、左和上。
   * 遍历这些方向，并使用剩余的 `suffix` 递归调用相邻单元格的 `backtrack` 函数。
   * 在探索完所有方向后，恢复单元格的原始值。
   * 如果任何方向导致成功匹配，则返回 `true`；否则，返回 `false`。
3. 遍历网格中的每个单元格：
   * 从当前单元格开始，使用完整的 `target` 字符串调用 `backtrack` 函数。
   * 如果该函数返回 `true`，则该单词存在于网格中。
4. 如果没有起始单元格导致匹配，则返回 `false`。

<MDXCodeBlock>
  {findWordInGrid}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n.3<sup>l</sup>)**。网格中的每个单元格 (`m.n`) 都可以启动搜索，并且对于单词中的每个字符 (`l`)，最多探索 3 个方向（因为我们不会回到我们来的地方）。
* **空间复杂度：O(l)**。递归堆栈深度与单词的长度 (`l`) 成正比。
