import MDXCodeBlock from 'MDXCodeBlock';

import sumWithoutAddition from '../setup/src/sum-without-addition.ts';

## 1. 使用位运算

给定的解决方案使用位运算来计算两个数字的和，而不使用加法运算符。 关键思想依赖于理解二进制加法的原理：

* XOR 运算 (`^`) 执行加法，但不产生进位。 例如，在二进制中 `1 ^ 1 = 0` 且 `0 ^ 1 = 1`。
* AND 运算 (`&`) 确定产生进位位的位置。 例如，在二进制中 `1 & 1 = 1` 且 `0 & 1 = 0`。
* 左移运算 (`<<`) 将进位位移动到下一个更高的位置，以便在后续迭代中进行加法。

通过迭代地应用这些操作，算法处理进位位，直到没有进位，从而得到总和。

### 算法

1. 初始化 `carry` 变量以保存每次迭代中产生的进位位。
2. 只要 `b` 中有要处理的位或有进位位，就继续循环。
3. 使用 `a & b` 运算提取进位位并将结果存储在 `carry` 中。
4. 使用 XOR 运算 (`a ^ b`) 计算和，不带进位位，并更新 `a`。
5. 将 `carry` 左移一位 (`carry << 1`) 以使其与下一个更高的位对齐，并将结果分配给 `b`。
6. 重复步骤 3–5，直到 `b` 和 `carry` 都为零。
7. 返回 `a`，它保存最终的和。

<MDXCodeBlock>
  {sumWithoutAddition}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(1)**。 每个整数包含 32 位。
* **空间复杂度：O(1)**。 算法使用恒定空间，因为它直接对输入变量进行操作。
