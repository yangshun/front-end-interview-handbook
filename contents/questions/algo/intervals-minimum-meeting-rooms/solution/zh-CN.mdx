import MDXCodeBlock from 'MDXCodeBlock';

import minMeetingRoomsNeeded from '../setup/src/intervals-minimum-meeting-rooms.ts';
import minMeetingRoomsPQ from '../setup/src/intervals-minimum-meeting-rooms-pq.ts';

## 1. 使用双指针方法

这种方法通过分离并排序区间的开始和结束时间来确定所需的最少会议室数量。通过使用两个指针，一个用于`start`时间，一个用于`end`时间，该算法有效地跟踪并发会议的数量。

直觉是，当会议结束时，会议室就会空闲，这由`endPointer`表示。对于每个会议开始时间（`startPointer`），算法会检查会议是否可以重复使用一个可用的房间（通过将开始时间与最早的结束时间进行比较）。如果房间空闲，则将`endPointer`向前移动以标记该房间可用。否则，将分配一个新房间。

此方法避免了直接比较所有区间对，使用排序数组和两个指针来实现最佳效率。

### 算法

1. 处理基本情况，如果`intervals`数组为空，则返回`0`。
2. 创建两个数组`start`和`end`，以存储每个区间的开始和结束时间。
3. 通过遍历`intervals`数组来填充`start`和`end`数组。
4. 按升序对`start`和`end`数组进行排序。
5. 初始化两个指针`startPointer`和`endPointer`，分别遍历`start`和`end`数组。此外，初始化一个变量`usedRooms`以跟踪当前正在使用的房间数。
6. 遍历`start`数组：
   1. 如果当前会议的开始时间大于或等于最早的结束时间（由`end[endPointer]`指示），则通过递减`usedRooms`并将`endPointer`向前移动来释放一个房间。
   2. 为当前会议分配一个房间，方法是递增`usedRooms`。
   3. 移动`startPointer`以处理下一个会议。
7. 返回`usedRooms`的值，该值表示在任何时候所需的最大房间数。

<MDXCodeBlock>
  {minMeetingRoomsNeeded}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。对`start`和`end`数组进行排序占据了运行时的大部分，而处理区间的线性扫描需要 O(n)。
* **空间复杂度：O(n)**。使用两个额外的数组`start`和`end`来存储区间的开始和结束时间。

## 2. 使用优先级队列（最小堆）

该方法使用最小堆来有效地跟踪正在进行的会议的结束时间，确保最早结束的会议始终首先被处理。这允许确定当新会议开始时房间是否空闲。按开始时间对区间进行排序可确保会议按时间顺序处理。

使用最小堆是因为它支持高效地插入和提取最小元素。在任何时候，堆都包含所有活动会议的结束时间。当会议开始时，将其开始时间与堆中最小的结束时间（最早结束的会议）进行比较。如果新会议可以重复使用房间（其开始时间大于或等于最小结束时间），则从堆中删除结束时间。否则，将分配一个新房间，并将会议的结束时间添加到堆中。

### 算法

1. 处理基本情况，如果`intervals`数组为空，则返回`0`。
2. 按会议的开始时间对`intervals`数组进行升序排序。
3. 初始化一个最小堆（`allocator`）以存储当前占用房间的会议的结束时间。
4. 将第一个会议的结束时间添加到堆中。
5. 遍历剩余的区间：
   1. 如果当前会议的开始时间大于或等于堆中最小的结束时间，则从堆中删除最小的结束时间（表示一个房间已释放）。
   2. 将当前会议的结束时间添加到堆中，为其分配一个房间。
6. 处理完所有区间后，堆的大小表示所需的最小房间数，因为堆中的每个元素对应于当前活动的会议。
7. 返回堆的大小。

<MDXCodeBlock>
  {minMeetingRoomsPQ}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。对区间进行排序需要 O(n log n)，并且堆中的每个插入和删除操作都需要 O(log n)，导致所有区间的堆操作为 O(n log n)。
* **空间复杂度：O(n)**。最小堆在最坏情况下最多可以包含`n`个元素。
