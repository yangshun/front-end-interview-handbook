import MDXCodeBlock from 'MDXCodeBlock';

import tripletSum from '../setup/src/triplet-sum.ts';
import tripletSumBruteForce from '../setup/src/triplet-sum-brute-force.ts';

## 1. 暴力解法

目标是在一个数组中找到所有和为零的唯一三元组。 这种方法是使用三个嵌套循环来探索三个数字的每一种组合。 检查每个组合是否总和为零。 使用 `Set` 通过将它们转换为字符串来存储唯一的三元组，确保避免重复。 对三元组进行排序有助于保持顺序，并确保在添加到 `Set` 时正确检测到重复项。

### 算法

1. 初始化一个 `Set` 来存储唯一的三元组。
2. 使用三个嵌套循环遍历数组：
   1. 最外层循环固定三元组的第一个数字。
   2. 第二个循环固定三元组的第二个数字。
   3. 最内层循环选择三元组的第三个数字。
3. 对于每一种三个数字的组合，检查它们的总和是否等于零。
4. 如果总和为零，对三元组进行排序以保持顺序，并将其转换为字符串以存储在 `Set` 中。
5. 完成迭代后，通过解析存储的字符串将 `Set` 转换回数组。
6. 对生成的三元组数组进行排序，以满足有序结果的要求。
7. 返回已排序的三元组数组。

<MDXCodeBlock>
  {tripletSumBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>3</sup>)**。 三个嵌套循环遍历数组中所有可能的三个数字的组合。
* **空间复杂度：O(k)**。 用于存储唯一三元组的 `Set` 和生成的数组所需的空间与唯一三元组的数量成正比，即 `k`。

## 2. 双指针

双指针方法通过减少不必要的计算来改进暴力解法。 对数组进行排序可以通过使用两个指针（`j` 和 `k`）根据当前总和相互移动来有效地搜索总和为零的三元组。 这消除了对第三个嵌套循环的需求，并通过跳过重复项来避免冗余检查。 通过专注于补充固定起始元素（`i`）的数字对，该解决方案显着降低了时间复杂度。

### 算法

1. 对输入数组进行升序排序，以允许有效的双指针遍历。
2. 初始化一个空数组 `ans` 来存储三元组。
3. 使用索引 `i` 遍历排序后的数组：
   1. 跳过重复元素，以确保每个起始元素都是唯一的。
   2. 设置两个指针：`j` 在 `i` 之后的索引处，`k` 在数组的最后一个索引处。
4. 当 `j` 小于 `k` 时：
   1. 计算 `numbers[i]`、`numbers[j]` 和 `numbers[k]` 的总和。
   2. 如果总和等于零：
      * 将三元组 `[numbers[i], numbers[j], numbers[k]]` 添加到 `ans`。
      * 移动 `j` 向前，移动 `k` 向后，跳过重复元素。
   3. 如果总和小于零，则递增 `j` 以增加总和。
   4. 如果总和大于零，则递减 `k` 以减少总和。
5. 返回包含所有唯一三元组的 `ans` 数组。

<MDXCodeBlock>
  {tripletSum}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。 对数组进行排序需要 O(n log n)，并且对每个元素进行双指针遍历需要 O(n)，结果为 O(n<sup>2</sup>)。
* **空间复杂度：O(1)**。 除了输出数组之外，该解决方案使用恒定量的额外空间。
