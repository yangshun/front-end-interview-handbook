import MDXCodeBlock from 'MDXCodeBlock';

import courseDependency from '../setup/src/course-dependency.ts';
import courseDependencyUsingDFS from '../setup/src/course-dependency-dfs.ts';

## 1. Kahn's Topological Sort

该问题涉及确定是否可以在给定一组先决条件的情况下完成所有课程。这是一个经典的有向图循环检测问题。如果存在循环，则无法完成所有课程。Kahn 算法是一种拓扑排序方法，用于通过系统地删除没有传入边的节点来解决该问题。

关键思想是：

* 使用邻接表构建图。
* 跟踪每门课程的先决条件（入度）的数量。
* 从没有先决条件的课程开始。
* 处理每门课程，减少其邻居的入度。如果邻居的入度变为 0，则将其添加到处理队列中。
* 如果所有课程都已处理完毕，而没有任何未访问的节点，则表示没有循环。

### 算法

1. 初始化一个 `indegree` 数组，以计算每门课程的先决条件数量。
2. 初始化一个邻接表 (`adj`) 来表示有向图。
3. 通过迭代先决条件来填充邻接表和 `indegree` 数组：
   * 对于每对 `[a, b]`，在 `adj` 中将 `a` 添加为 `b` 的邻居。
   * 增加 `a` 的入度。
4. 初始化一个队列，并将所有 `indegree` 为 0 的课程添加到队列中。
5. 初始化一个计数器 `nodesVisited` 来跟踪已处理的课程数量。
6. 执行 BFS：
   * 从队列中删除一门课程并增加 `nodesVisited`。
   * 对于当前课程的每个邻居，减少其入度。
   * 如果邻居的入度变为 0，则将其添加到队列中。
7. 处理完所有节点后，检查 `nodesVisited` 是否等于课程总数：
   * 如果为真，则返回 `true`（所有课程都可以完成）。
   * 否则，返回 `false`（存在循环）。

<MDXCodeBlock>
  {courseDependency}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(v + e)**。图在 O(e) 中构建，其中 `e` 是先决条件的数量。BFS 遍历每个课程和边一次，需要 O(v + e)，其中 `v` 是课程的数量。
* **空间复杂度：O(v + e)**。邻接表和队列需要 O(v + e) 空间。

## 2. 使用 DFS

该问题涉及确定是否可以在给定一组先决条件的情况下完成所有课程。这是一个有向图中的图循环检测问题。如果存在循环，则并非所有课程都可以完成，因为至少有一门课程直接或间接依赖于自身。

该算法使用深度优先搜索 (DFS) 来检测循环：

* 每门课程都表示为图中的一个节点。
* 先决条件表示为节点之间的有向边。
* 在 DFS 期间，节点被标记为已访问并添加到递归堆栈 (`inStack`) 中以检测循环。如果在递归堆栈中重新访问一个节点，则检测到循环。
* 如果在访问所有节点后未找到循环，则可以完成所有课程。

### 算法

1. 初始化一个邻接表 `adj` 来表示图。
2. 通过迭代 `prerequisites` 数组来构建图：
   * 对于每对 `[a, b]`，在 `adj` 中将 `a` 添加为 `b` 的邻居。
3. 初始化两个数组：
   * `visit` 用于跟踪节点是否已被访问。
   * `inStack` 用于跟踪节点是否在当前的递归堆栈中。
4. 定义一个 `dfs` 函数来执行以下操作：
   * 如果当前节点在递归堆栈 (`inStack`) 中，则返回 `true`（检测到循环）。
   * 如果当前节点已被访问，则返回 `false`。
   * 将当前节点标记为已访问并将其添加到递归堆栈中。
   * 对于当前节点的每个邻居，递归调用 `dfs`。如果任何调用检测到循环，则返回 `true`。
   * 从递归堆栈中删除当前节点并返回 `false`（未检测到循环）。
5. 对每个节点执行 DFS：
   * 如果检测到循环，则返回 `false`。
6. 如果在未检测到循环的情况下处理了所有节点，则返回 `true`。

<MDXCodeBlock>
  {courseDependencyUsingDFS}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(v + e)**。构建图需要 O(e)，其中 `e` 是先决条件的数量。DFS 访问每个节点和边一次，需要 O(v + e)，其中 `v` 是课程的数量。
* **空间复杂度：O(v + e)**。邻接表需要 O(e) 空间，而 `visit` 和 `inStack` 数组需要 O(v) 空间。
