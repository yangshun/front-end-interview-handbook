import MDXCodeBlock from 'MDXCodeBlock';

import bitCounting from '../setup/src/bit-counting.ts';
import bitCountingDpMSB from '../setup/src/bit-counting-dp-msb.ts';
import bitCountingPopulationCount from '../setup/src/bit-counting-pop-count.ts';

## 1. 使用人口计数

这种方法使用简单的位操作技术来计算每个数字中 `1` 的数量。 关键的直觉是，一个数字的二进制表示可以通过逐位处理来检查其最低有效位，然后右移该数字以检查下一位。 这个过程一直持续到数字变为 `0`。

这种方法遍历从 `0` 到 `n` 的所有数字，并在 O(k) 时间内处理每个数字，其中 `k` 是数字中的位数。

### 算法

1. 初始化一个空数组 `ans` 来存储结果。
2. 遍历从 `0` 到 `n` 的所有数字：
   * 将变量 `count` 设置为 `0` 以跟踪当前数字中 `1` 的数量。
   * 将当前数字分配给临时变量 `num`。
   * 使用 `while` 循环处理该数字：
     * 将最低有效位 (`num & 1`) 添加到 `count`。
     * 使用 `num >>= 1` 将该数字右移一位。
   * 将 `count` 附加到 `ans` 数组。
3. 返回数组 `ans`。

<MDXCodeBlock>
  {bitCountingPopulationCount}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n.k)**。 该算法处理从 `0` 到 `n` 的每个数字，其中 `k` 是该数字的二进制表示中的位数。
* **空间复杂度：O(n)**。 数组 `ans` 存储从 `0` 到 `n` 的所有数字的结果。

## 2. 使用动态规划和 MSB

具有最高有效位的动态规划方法通过使用先前计算的结果来提高效率。 关键的直觉是，一个数字的二进制表示中 `1` 的数量可以通过将 `1` 添加到较小范围内的数字中 `1` 的计数来确定。 具体来说，如果 `b` 是 2 的幂，则范围 `[b, 2b)` 中的任何数字都与 `[0, b)` 中的数字具有相同的位模式，并设置了额外的最高有效位 `1`。

这种方法消除了像朴素解法那样重复处理每个数字的每一位的需要。 相反，它通过加倍范围和重用先前计算的计数来动态构建结果，从而减少了冗余工作。

### 算法

1. 初始化一个大小为 `n + 1` 的数组 `ans`，并将所有值设置为 `0`。
2. 将 `x` 设置为 `0`，将 `b` 设置为 `1`，其中 `b` 表示当前的 2 的幂范围。
3. 使用 `while` 循环处理范围：
   * 当 `b` 小于或等于 `n` 时：
     * 遍历范围 `[b, 2b)` 中的数字：
       * 对于范围内每个数字 `x + b`，计算 `1` 的计数为 `ans[x] + 1`。
       * 递增 `x`。
     * 将 `x` 重置为 `0` 并将 `b` 加倍以处理下一个范围。
4. 返回数组 `ans`。

<MDXCodeBlock>
  {bitCountingDpMSB}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。 由于范围递增加倍，因此每个数字只处理一次。
* **空间复杂度：O(n)**。 `ans` 数组需要的空间与输入大小 `n` 成正比。

## 3. 使用动态规划和 LSB

另一种解决方案使用最低有效位与动态规划方法相结合来计算从 `0` 到 `n` 的整数的二进制表示中 `1` 的数量。 关键的直觉是，数字 `i` 中 `1` 的数量可以从 `i / 2`（`i` 的右移值）和 `i` 的最低有效位推导出来。 最低有效位可以使用 `i & 1` 确定。

### 算法

1. 初始化一个大小为 `n + 1` 的数组 `counts`，并将所有值设置为 `0`。
2. 遍历从 `1` 到 `n` 的数字：
   * 使用 `i & 1` 计算当前数字的最低有效位。
   * 使用动态规划公式 `counts[i] = counts[Math.floor(i / 2)] + least significant bit` 计算 `1` 的计数。
3. 返回数组 `counts`。

<MDXCodeBlock>
  {bitCounting}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。从 `1` 到 `n` 的每个数字都只处理一次，并且每个数字的操作都是恒定时间。
* **空间复杂度：O(n)**。数组 `counts` 需要与输入大小 `n` 成比例的空间。
