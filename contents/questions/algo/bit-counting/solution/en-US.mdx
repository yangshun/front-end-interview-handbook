import MDXCodeBlock from 'MDXCodeBlock';

import bitCounting from '../setup/src/bit-counting.ts';
import bitCountingDpMSB from '../setup/src/bit-counting-dp-msb.ts';
import bitCountingPopulationCount from '../setup/src/bit-counting-pop-count.ts';

## 1. Using Population Count

This approach uses a simple bitwise manipulation technique to compute the count of `1`s for each number. The key intuition is that the binary representation of a number can be processed bit by bit by examining its least significant bit and then right-shifting the number to examine the next bit. This process continues until the number becomes `0`.

This approach iterates through all numbers from `0` to `n` and processes each number in O(k) time, where `k` is the number of bits in the number.

### Algorithm

1. Initialize an empty array `ans` to store the results.
2. Iterate through all numbers from `0` to `n`:
   - Set a variable `count` to `0` to track the number of `1`s for the current number.
   - Assign the current number to a temporary variable `num`.
   - Use a `while` loop to process the number:
     - Add the least significant bit (`num & 1`) to `count`.
     - Right-shift the number by one position using `num >>= 1`.
   - Append `count` to the `ans` array.
3. Return the array `ans`.

<MDXCodeBlock>{bitCountingPopulationCount}</MDXCodeBlock>

### Big-O analysis

- **Time complexity: O(n.k)**. The algorithm processes each number from `0` to `n`, where `k` is the number of bits in the binary representation of the number.
- **Space complexity: O(n)**. The array `ans` stores the results for all numbers from `0` to `n`.

## 2. Using Dynamic Programming and MSB

The dynamic programming approach with the most significant bit improves efficiency by using previously computed results. The key intuition is that the number of `1`s in the binary representation of a number can be determined by adding `1` to the count of `1`s in a number from a smaller range. Specifically, if `b` is a power of 2, then any number in the range `[b, 2b)` has the same bit pattern as a number in `[0, b)` with an additional most significant bit set to `1`.

This approach removes the need to repeatedly process each bit of every number, as in the naive solution. Instead, it dynamically builds the result by doubling the range and reusing previously computed counts, reducing redundant work.

### Algorithm

1. Initialize an array `ans` of size `n + 1` with all values set to `0`.
2. Set `x` to `0` and `b` to `1`, where `b` represents the current power of 2 range.
3. Use a `while` loop to process ranges:
   - While `b` is less than or equal to `n`:
     - Iterate through numbers in the range `[b, 2b)`:
       - For each number `x + b` within bounds, calculate the count of `1`s as `ans[x] + 1`.
       - Increment `x`.
     - Reset `x` to `0` and double `b` to process the next range.
4. Return the array `ans`.

<MDXCodeBlock>{bitCountingDpMSB}</MDXCodeBlock>

### Big-O analysis

- **Time complexity: O(n)**. Each number is processed once as the range doubles incrementally.
- **Space complexity: O(n)**. The `ans` array requires space proportional to the input size `n`.

## 3. Using Dynamic Programming and LSB

Another solution uses least significant bit combined with dynamic programming approach to calculate the number of `1`s in the binary representation of integers from `0` to `n`. The key intuition is that the number of `1`s in a number `i` can be derived from the number of `1`s in `i / 2` (right-shifted value of `i`) and the least significant bit of `i`. The least significant bit can be determined using `i & 1`.

### Algorithm

1. Initialize an array `counts` of size `n + 1` with all values set to `0`.
2. Iterate through numbers from `1` to `n`:
   - Compute the least significant bit of the current number using `i & 1`.
   - Use the dynamic programming formula `counts[i] = counts[Math.floor(i / 2)] + least significant bit` to compute the count of `1`s.
3. Return the array `counts`.

<MDXCodeBlock>{bitCounting}</MDXCodeBlock>

### Big-O analysis

- **Time complexity: O(n)**. Each number from `1` to `n` is processed exactly once, and the operations for each number are constant time.
- **Space complexity: O(n)**. The array `counts` requires space proportional to the input size `n`.
