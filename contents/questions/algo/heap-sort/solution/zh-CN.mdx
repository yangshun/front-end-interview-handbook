import MDXCodeBlock from 'MDXCodeBlock';

import heapSortJs from '../setup/src/heap-sort.js';
import heapSortTs from '../setup/src/heap-sort.ts';
import heapifyMin from '../setup/src/heapifyMin';

堆排序是一种原地、基于比较的算法，对于大型数组效果很好，因为它具有 O(nlog(n)) 的时间复杂度。

它也不需要任何额外的内存空间来对数据进行排序，因为它是一种原地排序算法。但是，它不是一种稳定的排序，这意味着具有相同值的元素的顺序可能不会被保留。

## 澄清问题

如果未指定：

* 数据应该按升序还是降序排序？
* 应该对数据进行原地排序，还是可以使用额外的数据结构？
* 我们需要处理什么样的输入？
  * 它只是一个整数数组，还是我们应该处理其他数据类型？
  * 是否存在大量重复元素？
  * 应该如何处理负数？

## 解决方案

注意：此问题处理的是原地排序，用于升序输出。请参阅下面的“注释”部分，了解如何处理其他情况。

<MDXCodeBlock languages={{ jsx: heapSortJs, tsx: heapSortTs }} />

## 边缘情况

* 非整数元素输入：如果输入数组包含不同数据类型的元素，您可能需要返回一个错误，尽力进行排序，例如，仅对输入数据的子集进行排序，甚至为非整数定义自定义比较函数。
* 单个元素/空输入：返回原始数据结构、引发错误或阐明所需处理方式。
* 已排序的输入：您可能需要检测排序并原样返回输入。
* 无效输入：如果输入不是数组，请考虑抛出错误。

## 注释

* 如果要求按降序排序：更改 `heapify()` 函数中的比较运算符，以便构建最小堆而不是最大堆，然后在 `heapSort` 中照常使用它：

<MDXCodeBlock>
  {heapifyMin}
</MDXCodeBlock>

* 如果要求使用额外的数据结构或编写纯函数而不是对数据进行原地排序，请创建数组的副本并返回已排序数组的浅层副本：

```js
function heapSort(arr) {
  const result = arr.slice(0);
  const size = arr.length;
  for (let i = Math.floor(size / 2 - 1); i >= 0; i--) {
    heapify(result, size, i);
  }
  for (let i = size - 1; i >= 0; i--) {
    [result[0], result[i]] = [result[i], result[0]];
    heapify(result, i, 0);
  }
  return result;
}
```

* 如果您想知道为什么 `Math.floor(size / 2 - 1)` 能够计算最后一个父节点的索引，那是因为在完全二叉树中，父节点的数量等于 Math.floor(size / 2)。末尾的 -1 是必需的，因为数组中的索引从 0 开始，而不是 1。

## Big-O 分析

让我们分析一下算法的时间和空间复杂度。

### 时间复杂度

堆排序的最佳、平均和最坏情况下的时间复杂度为 O(nlog n)。 无论元素是否已排序，该算法都将始终需要 O(nlog(n)) 时间才能完成。 除非您检测到已排序的数组并立即返回它们以获得最佳情况下的 O(n) 时间复杂度（对于完全排序的数组），否则这是准确的。

要理解堆排序的时间复杂度，理解 `heapify()` 的时间复杂度至关重要。 在 `heapify()` 中，我们从上到下遍历树，这意味着时间复杂度与二叉树的高度成正比，对于大小为 n 的树，高度最多为 O(log(n))。 因此，`heapify()` 函数的时间复杂度为 O(log(n))。

堆排序的时间复杂度为 O(nlog(n))，因为该算法有 2 个步骤：构建堆，然后对数据进行排序。

1. 构建堆的时间复杂度为 O(n)，因为 `heapify()` 方法是从最后一个节点开始，以树根结束，向后为每个父节点调用。 平均而言，这可以在 O(n) 时最佳地完成。
2. 对数据进行排序时，我们调用 `heapify()` 方法 n-1 次以维护数组未排序部分的堆属性。 因此，总的时间复杂度为 O(nlog(n))。

堆排序的总时间复杂度是每个步骤的时间复杂度的总和，即 O(n) + O(nlog(n)) = O(nlog(n))。

### 空间复杂度

堆排序的空间复杂度为 O(1)，因为它进行原地排序，不需要与输入大小成比例的额外存储空间。

但是，如果使用递归函数调用来实现该算法，则空间复杂度将为 O(n)，这需要额外的内存空间来存储函数调用堆栈。
