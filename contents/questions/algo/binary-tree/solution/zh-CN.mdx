import MDXCodeBlock from 'MDXCodeBlock';

import binaryTreeJs from '../setup/src/binary-tree.js';
import binaryTreeTs from '../setup/src/binary-tree.ts';

二叉树是一种分层数据结构，其中每个节点最多有两个子节点：`left`子节点和`right`子节点。该结构由存储`value`和对其子节点的引用的节点组成。最顶层的节点称为`root`。

此实现将二叉树结构（`BinaryTree`）与其各个节点（`BinaryTreeNode`）分开。每个节点包含一个`value`，以及指向其`left`和`right`子节点的指针。

核心操作可以使用递归方法实现，这对于二叉树来说是自然且高效的，因为每个子树本身就是一棵二叉树：

* **遍历方法**（`inOrder`、`preOrder`、`postOrder`）使用简单的深度优先递归以正确的顺序访问节点，并将其值收集到一个数组中。
* `size()`和`height()`通过访问每个节点一次来递归计算，结合左右子节点的结果。
* `isBalanced()`使用递归方法从底部向上遍历树，检查每个子树是否平衡。在执行此操作时，它还会计算每个节点的高度。如果它发现一个子树的高度差 > 1，它会立即返回 -1，这会冒泡并停止进一步的检查，使时间复杂度保持在 O(n)。
* `isComplete()`使用层序遍历（BFS）来确保所有层都已完全填充，并且最后一层从左到右填充，没有间隙。

<MDXCodeBlock languages={{ jsx: binaryTreeJs, tsx: binaryTreeTs }} />

### 算法

1. `new BinaryTree(value)`:
   * 初始化一棵树。如果传递了`value`，则将根设置为具有该值的新的`BinaryTreeNode`。如果没有，则根为`null`。
2. `size()`:
   * 基本情况：如果`node`为`null`，则返回 0。
   * 递归情况：1 + 左子树的大小 + 右子树的大小。
3. `height()`:
   * 基本情况：如果`node`为`null`，则返回 -1。
   * 递归情况：1 + max(左子树的高度，右子树的高度)。
   * 对于空树，`height()`返回 0。
4. 遍历方法（`inOrder()`、`preOrder()`、`postOrder()`):
   * 这些方法根据不同的遍历顺序返回节点值的数组：
     * 中序遍历（左 → 根 → 右）
     * 前序遍历（根 → 左 → 右）
     * 后序遍历（左 → 右 → 根）
   * 每种方法都使用一个递归助手，该助手使用 DFS 从根遍历树，并按指定的顺序访问子节点。
   * 在递归调用期间构建一个临时数组，以按正确的顺序收集值。
5. `isBalanced()`:
   * 递归助手返回高度（如果子树平衡），或者如果未平衡则返回 -1。
   * 主方法检查结果是否不为 -1。
6. `isComplete()`:
   * 使用 BFS（层序遍历）与队列。
   * 当节点出队时，如果找到`null`，则所有后续节点也必须为`null`，才能认为树是完整的。如果在 null 之后出现任何非 null 节点，则树不完整。

### Big-O 分析

设`n`为节点的数量，`h`为树的高度。

* **时间复杂度**：
  * `size()`、`height()`、`inOrder()`、`preOrder()`、`postOrder()`、`isBalanced()`、`isComplete()`：O(n)。每个节点访问一次。
* **空间复杂度**：
  * 递归方法（`size()`、`height()`、遍历、`isBalanced()`）：O(h) 由于调用堆栈。在最坏的情况下（倾斜树），h = O(n)。在平衡树中，h = O(log n)。
  * `isComplete()`：在最坏的情况下为 O(n)，因为 BFS 队列在完整树的最后一层最多可以容纳 n/2 个节点。

## 边缘情况

* **空树**：
  * `size()`为 0
  * `height()`为 0
  * 遍历返回`[]`
  * 树既平衡又完整
* **单节点树**：
  * `size()`为 1
  * `height()`为 0
  * 树既平衡又完整
