import MDXCodeBlock from 'MDXCodeBlock';

import findDuplicates from '../setup/src/array-find-duplicate.ts';
import findDuplicateSorting from '../setup/src/array-find-duplicate-sorting.ts';
import findDuplicateBruteForce from '../setup/src/array-find-duplicate-brute-force.ts';

## 1. 暴力解法

该问题涉及查找数组中是否存在重复元素。暴力方法检查数组中每对可能的元素，以确定它们是否相等。这是通过两个嵌套循环实现的，其中比较每一对。虽然这种方法很简单，但由于其 O(n<sup>2</sup>) 的时间复杂度，对于大型数组来说效率低下。

### 算法

1. 确定输入数组 `numbers` 的长度，并将其存储在变量 `n` 中。
2. 使用索引 `i` 的循环遍历数组中的每个元素。
3. 对于每个 `i`，使用另一个从 `i + 1` 开始的索引 `j` 的循环来检查数组中的每个后续元素。
4. 比较索引 `i` 和 `j` 处的元素：
   * 如果它们相等，则返回 `true` 以指示找到重复项。
5. 如果在检查所有对后未找到重复项，则返回 `false`。

<MDXCodeBlock>
  {findDuplicateBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。外层循环迭代 `n` 次，内层循环最多迭代 `n - i - 1` 次，导致二次时间复杂度。
* **空间复杂度：O(1)**。该算法使用恒定量的额外空间，因为它不依赖于任何辅助数据结构。

## 2. 使用排序

之前的暴力解法有不必要的检查所有对的工作。为了消除冗余的比较，这个优化的解决方案将数组按升序排序，这确保了重复的元素连续出现。一旦数组排序完成，只需一次遍历即可检查是否有任何两个连续的元素相等。

### 算法

1. 使用内置的 `sort` 函数按升序对输入数组 `numbers` 进行排序。
2. 使用循环从索引 `0` 到 `numbers.length - 1` 遍历排序后的数组。
   * 对于每个元素，将其与数组中的下一个元素进行比较。
   * 如果这两个元素相等，则返回 `true` 以指示已找到重复项。
3. 如果在循环完成之后未找到重复项，则返回 `false`。

<MDXCodeBlock>
  {findDuplicateSorting}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。排序操作以 O(n log n) 占据了运行时的大部分。随后对排序数组的线性遍历的复杂度为 O(n)，与排序步骤相比，可以忽略不计。
* **空间复杂度：O(1)**。排序是就地执行的，并且该算法不使用任何其他数据结构，从而导致恒定的空间使用。

## 3. 使用 Set

之前的解决方案使用排序，由于排序步骤（O(n log n)），其时间复杂度存在瓶颈。排序确保重复项连续出现，但对于较大的输入数组需要大量时间。

当前的解决方案通过使用 `Set` 来跟踪到目前为止看到的元素来改进这一点。`Set` 允许以恒定时间进行操作，以检查存在性和添加元素。这消除了对排序的需求，将时间复杂度降低到线性 O(n)。它还保留了原始数组，因为没有进行就地更改。

### 算法

1. 创建一个空的 `Set` 来存储唯一元素。
2. 遍历输入数组中的每个元素：
   * 检查当前元素是否存在于 `Set` 中。
   * 如果该元素存在，则返回 `true`，表示已找到重复项。
   * 否则，将当前元素添加到 `Set` 中。
3. 如果在未找到重复项的情况下完成迭代，则返回 `false`。

<MDXCodeBlock>
  {findDuplicates}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。该算法遍历数组一次，对 `Set` 中的添加和检查元素执行恒定时间的操作。
* **空间复杂度：O(n)**。在所有元素都唯一的最坏情况下，`Set` 需要额外的空间来存储多达 `n` 个元素。
