import MDXCodeBlock from 'MDXCodeBlock';

import binaryTreeFlip from '../setup/src/binary-tree-flip.ts';
import binaryTreeFlipIteration from '../setup/src/binary-tree-flip-iteration.ts';

## 1. 使用递归

翻转二叉树涉及交换树中每个节点的左右子树。递归方法通过将问题分解为每个子树的较小问题来简化此操作。

它从一个基本情况开始：如果当前节点为 `null`，则无需翻转，因此返回 `null`。对于每个非 `null` 节点，递归翻转左右子树，并将结果存储在临时变量中。递归后，交换当前节点的左右子节点。这确保了树的所有层都被正确翻转，并且结构完全颠倒。

### 算法

1. 检查基本情况：如果节点为 `null`，则返回 `null`。
2. 递归调用右子树上的函数并存储结果。
3. 递归调用左子树上的函数并存储结果。
4. 交换当前节点的左右子节点。
5. 将当前节点作为翻转树的根节点返回。

<MDXCodeBlock>
  {binaryTreeFlip}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个节点只访问一次。
* **空间复杂度：O(h)**。递归堆栈使用的空间与树的高度成正比，其中 `h` 是树的高度。

## 2. 使用迭代

翻转二叉树涉及交换每个节点的左右子树。迭代方法使用队列逐层遍历树，确保处理所有节点。此方法避免了递归，使其成为处理深度树以防止堆栈溢出的一个很好的替代方案。

迭代方法从一个基本情况开始，其中空树（`null` 根）直接返回 `null`。使用根节点初始化一个队列，并执行广度优先遍历。在每个步骤中，交换当前节点的左右子节点。如果交换的子节点不为 `null`，则将它们添加到队列中以进行后续处理。该过程一直持续到队列为空，确保树中的所有节点都被翻转。

### 算法

1. 通过在根为 `null` 时返回 `null` 来处理基本情况。
2. 初始化一个队列并添加根节点。
3. 当队列不为空时：
   * 出队一个节点并交换其左右子节点。
   * 如果左子节点存在，则将其入队。
   * 如果右子节点存在，则将其入队。
4. 返回反转树的根。

<MDXCodeBlock>
  {binaryTreeFlipIteration}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。树中的每个节点只处理一次。
* **空间复杂度：O(n)**。在最坏的情况下，队列最多可以存储 `n` 个节点，这与树在其最宽层上的广度成正比。
