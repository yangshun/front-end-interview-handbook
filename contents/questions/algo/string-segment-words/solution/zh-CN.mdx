import MDXCodeBlock from 'MDXCodeBlock';

import segmentWords from '../setup/src/string-segment-words.ts';
import segmentWordsBFS from '../setup/src/string-segment-words-bfs.js';

## 1. 使用动态规划

动态规划方法通过将字符串分割成更小的子问题来解决将字符串分割成给定字典中的单词的问题。 关键的直觉是，如果字符串的前缀可以被分割，并且剩余的子字符串存在于字典中，那么整个字符串就可以被分割。 使用 `dp` 数组来存储以每个位置结尾的子字符串是否可以被分割。

`dp[i]` 表示子字符串 `str[0...i-1]` 是否可以被分割成字典中的有效单词。 这种方法确保了重叠的子问题只被解决一次，避免了冗余的计算。

### 算法

1. 将单词字典转换为 `Set` 以便快速查找单词。
2. 创建一个大小为 `str.length + 1` 的 `dp` 数组，并初始化为 `false`。
   * 将 `dp[0]` 设置为 `true`，因为空字符串总是可以被分割。
3. 遍历字符串以检查以每个位置 `end` 结尾的子字符串：
   * 对于每个 `end`，遍历子字符串的可能起始位置 `start`。
   * 检查子字符串 `str[start...end-1]` 是否存在于字典中，以及 `dp[start]` 是否为 `true`。
   * 如果两个条件都满足，则将 `dp[end]` 设置为 `true` 并跳出内循环。
4. 返回 `dp[str.length]` 的值，该值指示整个字符串是否可以被分割。

<MDXCodeBlock>
  {segmentWords}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n.m.k)**。 检查子字符串是否存在于字典中的成本为 O(m.k)，其中 `m` 是字典的大小，`k` 是平均单词长度。 由于有 O(n) 个状态需要计算，因此总的时间复杂度为 O(n.m.k)。
* **空间复杂度：O(n)**。 `dp` 数组需要 O(n) 空间。

## 2. 使用 BFS

广度优先搜索 (BFS) 方法通过将所有可能的分割作为图中的层来解决字符串分割问题。 关键的直觉是，该问题可以表示为从字符串的开头到结尾的导航，其中每个有效的子字符串对应于连接两个节点（索引）的边。 使用队列执行 BFS，从索引 `0` 开始，并探索字典中存在的所有可能的子字符串。

BFS 的使用确保了解决方案系统地检查所有有效路径。 为了防止冗余计算，使用 `seen` 集合来跟踪已访问的索引。

### 算法

1. 将字典 `dict` 转换为 `Set`，以实现 O(1) 平均时间复杂度查找。
2. 检查字符串为空的基本情况。 如果字符串为空，则返回 `true`。
3. 使用起始索引 `0` 和 `seen` 集合初始化一个队列，以跟踪已访问的索引。
4. 执行 BFS：
   * 出队队列的前一个元素，表示当前的起始索引。
   * 如果起始索引等于字符串的长度，则返回 `true`，因为字符串可以被分割。
   * 遍历从 `start + 1` 到 `str.length` 的所有可能的结束索引：
     * 跳过已经在 `seen` 集合中的索引。
     * 如果从 `start` 到 `end` 的子字符串存在于字典中：
       * 将 `end` 索引添加到队列中。
       * 将 `end` 索引标记为在 `seen` 集合中已访问。
5. 如果队列已耗尽且未找到有效的分割，则返回 `false`。

<MDXCodeBlock>
  {segmentWordsBFS}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>3</sup> + m⋅k)**。 有 O(n) 个节点，并且由于 `seen` 集合，每个节点最多访问一次。 在每个节点，算法遍历当前节点之前的节点 (O(n)) 并创建子字符串 (O(n))，从而导致每个节点 O(n<sup>2</sup>)。 因此，BFS 的成本为 O(n<sup>3</sup>)。 此外，从字典创建 `words` 集合的成本为 O(m⋅k)，其中 `m` 是字典的大小，`k` 是平均单词长度。
* **空间复杂度：O(n + m⋅k)**。 `queue` 和 `seen` 集合需要 O(n) 空间，而 `words` 集合需要 O(m⋅k) 空间。
