import MDXCodeBlock from 'MDXCodeBlock';

import balancedBrackets from '../setup/src/array-balanced-brackets.ts';

## 1. 使用堆栈

平衡括号问题涉及确定包含括号的字符串是否有效。如果满足以下条件，则字符串有效：

1. 每个开括号都有一个对应的、正确排序的闭括号。
2. 括号嵌套正确。

堆栈数据结构非常适合解决这个问题，因为它具有 LIFO（后进先出）的特性。当遍历字符串时：

1. 开括号被压入堆栈。
2. 闭括号与堆栈的顶部元素匹配，如果匹配，则弹出顶部元素。

朴素方法中的瓶颈可能涉及反复扫描整个字符串以查找匹配的括号，从而导致 O(n<sup>2</sup>) 的复杂度。基于堆栈的方法通过维护单个遍历并使用用于 push 和 pop 的恒定时间操作来消除不必要的工作。

### 算法

1. 定义一个映射对象 `mappings`，其中每个闭括号映射到其对应的开括号。
2. 初始化一个空堆栈，用于在遍历期间存储开括号。
3. 遍历输入字符串中的每个字符：
   * 如果该字符是闭括号：
     * 从堆栈中弹出顶部元素（如果堆栈为空，则使用占位符）。
     * 检查弹出的元素是否与当前闭括号对应的开括号匹配：
       * 如果不匹配，则返回 `false`。
   * 如果该字符是开括号，则将其压入堆栈。
4. 处理完所有字符后，检查堆栈是否为空。如果堆栈不为空，则返回 `false`；否则，返回 `true`。

<MDXCodeBlock>
  {balancedBrackets}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。该算法仅处理输入字符串中的每个字符一次，其中 `n` 是字符串的长度。
* **空间复杂度：O(n)**。在最坏的情况下，所有开括号都存储在堆栈中，导致 O(n) 的空间使用。
