import MDXCodeBlock from 'MDXCodeBlock';

import decodeMessage from '../setup/src/string-decode-message.ts';
import decodeMessageTopDown from '../setup/src/string-decode-message-top-down.ts';
import decodeMessageBottomUpConstantSpace from '../setup/src/string-decode-message-bottom-up-constant-space.ts';

## 1. 自顶向下动态规划

将字符串解码成可能的字母组合的问题可以被可视化为导航决策树。字符串中的每一步都提供两种选择：解码单个字符或解码两个字符（如果它们构成 `10` 到 `26` 之间的有效数字）。目标是计算从字符串开头到结尾的所有有效解码路径。

使用蛮力递归方法会导致冗余计算，因为同一个子问题（例如，解码从特定索引开始的子字符串）会被多次解决。这种冗余可以通过将先前计算的子问题的结果存储在备忘录映射中来避免。备忘录解决方案以最佳方式导航决策树，确保每个子问题只解决一次，从而显着提高效率。

### 算法

1. 定义一个递归函数 `recursiveWithMemo`，它:
   * 接受当前索引、输入字符串和备忘录映射作为参数。
   * 检查当前索引的结果是否存在于 `memo` 中，如果找到则返回它。
   * 如果索引到达字符串的末尾（有效解码），则返回 `1`。
   * 如果当前字符是 `'0'`（无效解码），则返回 `0`。
   * 如果当前索引指向最后一个字符（有效解码），则返回 `1`。
2. 使用 `recursiveWithMemo` 以 `index + 1` 调用，初始化一个变量 `ans`，结果是解码当前索引处的单个字符。
3. 检查接下来的两个字符是否构成 `10` 到 `26` 之间的有效数字:
   * 如果有效，通过使用 `index + 2` 调用 `recursiveWithMemo` 来添加解码两个字符的结果。
4. 将当前索引的计算结果存储在 `memo` 映射中。
5. 返回存储在 `memo` 中当前索引的值。
6. 实现一个包装函数 `decodeMessage`，它:
   * 初始化一个空的 `Map` 用于备忘录。
   * 使用初始索引 `0` 和输入字符串调用 `recursiveWithMemo`。

<MDXCodeBlock>
  {decodeMessageTopDown}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。由于备忘录，每个索引只处理一次。
* **空间复杂度：O(n)**。`Map` 最多存储 `n` 个条目，并且递归堆栈在最坏情况下需要 O(n) 空间。

## 2. 自底向上动态规划

这种方法不是递归地解决子问题，而是通过使用较小子字符串的结果来迭代地计算解码字符串的方式的数量。直觉是维护一个 `dp` 数组，其中每个条目表示解码到该索引的子字符串的方式的数量。

这种方法通过在单次传递中迭代地填充 `dp` 数组来避免递归和备忘录的开销。迭代性质确保每个子问题只解决一次，从而显着优化时间和空间。

### 算法

1. 使用所有值设置为 `0` 初始化大小为 `str.length + 1` 的 `dp` 数组。
   * 将 `dp[0]` 设置为 `1`，因为有一种方法可以解码一个空字符串。
   * 如果第一个字符不是 `'0'`，则将 `dp[1]` 设置为 `1`，否则将其设置为 `0`。
2. 从索引 `2` 迭代到 `str.length`:
   * 如果当前字符不是 `'0'`，则将 `dp[i - 1]` 添加到 `dp[i]` 以进行单数字解码。
   * 提取最后两个字符作为两位数。如果它在 `10` 和 `26` 之间，则将 `dp[i - 2]` 添加到 `dp[i]` 以进行两位数解码。
3. 返回 `dp[str.length]` 中的值，它表示解码整个字符串的方式的数量。

<MDXCodeBlock>
  {decodeMessage}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。该算法遍历字符串一次。
* **空间复杂度：O(n)**。`dp` 数组存储字符串每个索引的中间结果。

## 3. 具有恒定空间的自底向上动态规划

此解决方案通过将空间复杂度降低到 O(1) 来改进自底向上的动态规划方法。此方法不是维护一个 `dp` 数组来存储所有索引的结果，而是仅跟踪最后两个结果 (`dp[i-2]` 和 `dp[i-1]`)。这种优化是可能的，因为在任何位置解码字符串的方式都仅取决于前两个位置的结果。

之前的自底向上解决方案使用了一个需要 O(n) 空间的数组。通过用两个变量替换数组，此解决方案减少了空间使用，而不会影响正确性或时间复杂度。当处理大型字符串时，此改进特别有用。

### 算法

1. 通过返回 `0` 来处理字符串为空的边缘情况。
2. 初始化两个变量:
   * `prev` 表示 `dp[i-2]`，对于空字符串的基本情况，设置为 `1`。
   * `curr` 表示 `dp[i-1]`，如果第一个字符不是 `'0'`，则设置为 `1`，否则设置为 `0`。
3. 从索引 `2` 迭代到 `str.length`:
   * 初始化一个临时变量 `temp` 来存储当前结果。
   * 如果当前字符不是 `'0'`，则将 `curr` 添加到 `temp` 以进行单数字解码。
   * 提取最后两个字符作为两位数。如果它在 `10` 和 `26` 之间，则将 `prev` 添加到 `temp` 以进行两位数解码。
   * 将 `prev` 更新为 `curr`，将 `curr` 更新为 `temp` 以进行下一次迭代。
4. 返回 `curr` 的值，其中包含解码整个字符串的方式的数量。

<MDXCodeBlock> {decodeMessageBottomUpConstantSpace} </MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。该解决方案遍历字符串一次。
* **空间复杂度：O(1)**。仅使用两个变量来存储中间结果。
