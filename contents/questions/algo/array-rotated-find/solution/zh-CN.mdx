import MDXCodeBlock from 'MDXCodeBlock';

import findInRotatedArray from '../setup/src/array-rotated-find.ts';
import findInRotatedArrayPivotBinarySearch from '../setup/src/array-rotated-find-pivot-binary-search.ts';

## 1. 使用枢轴索引和二分查找

该解决方案通过结合两种有效技术来解决在旋转排序数组中查找目标的问题：识别枢轴索引和执行二分查找。 在朴素方法中，线性扫描整个数组是主要的瓶颈，因为它导致时间复杂度为 O(n)。 该解决方案通过使用数组已排序但已旋转的事实来消除不必要的工作。

第一步是找到枢轴索引，它是数组中最小的元素。 该索引也表示排序数组被分成两个子数组的旋转点。 知道这个枢轴索引有助于确定要搜索目标的数组部分。

确定枢轴索引后，使用二分查找来有效地搜索目标。 搜索空间根据目标相对于枢轴的值进行划分。 这允许仅关注数组的相关一半。 使用二分查找将总运行时间从 O(n) 减少到 O(log n)，使解决方案达到最佳。

### 算法

1. 定义一个辅助函数 `findPivotIndex` 来定位数组旋转的枢轴点。

   * 分别在数组的开头和结尾初始化两个指针 `low` 和 `high`。
   * 使用循环调整指针：
     * 计算中间索引 `mid`。
     * 如果 `numbers[mid]` 大于 `numbers[high]`，则枢轴在右侧。 将 `low` 更新为 `mid + 1`。
     * 否则，枢轴在左侧或在 `mid` 处。 将 `high` 更新为 `mid`。
   * 当循环结束时，`low` 指向枢轴索引。

2. 定义一个辅助函数 `binarySearch` 以在排序的子数组中搜索目标。

   * 将 `low` 和 `high` 指针初始化为子数组的开头和结尾。
   * 使用循环执行二分查找：
     * 计算中间索引 `mid`。
     * 如果 `numbers[mid]` 与目标匹配，则返回 `mid`。
     * 如果 `numbers[mid]` 小于目标，则将 `low` 调整为 `mid + 1`。
     * 否则，将 `high` 调整为 `mid - 1`。
   * 如果循环结束时未找到目标，则返回 `-1`。

3. 使用 `findPivotIndex` 找到枢轴索引。

4. 根据目标决定搜索数组的哪一部分。

   * 如果目标位于旋转部分的范围内（从 `pivot` 到数组的末尾），则对该部分执行二分查找。
   * 否则，对非旋转部分（从数组的开头到 `pivot - 1`）执行二分查找。

5. 返回二分查找的结果。

<MDXCodeBlock>
  {findInRotatedArrayPivotBinarySearch}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(log n)**。 枢轴查找操作和二分查找都花费 O(log n) 时间，导致总时间复杂度为 O(log n)。
* **空间复杂度：O(1)**。 该算法在恒定空间中运行，仅使用几个变量进行指针操作。

## 2. 使用修改后的二分查找

给定的解决方案通过消除显式的枢轴索引计算来改进之前的方案。 该方法没有将数组分成两部分并执行两个单独的二分查找，而是使用一个二分查找，并添加了额外的逻辑来处理旋转排序数组。

关键的见解是，在旋转排序数组中，数组的至少一半（左侧或右侧）始终已排序。 通过在每一步检查哪一半已排序，该算法确定目标是否位于已排序的范围内。 如果是，则调整搜索范围以排除未排序的一半。 否则，搜索将继续在未排序的一半中进行。 这种方法避免了显式查找枢轴索引的开销，直接缩小了搜索空间。

### 算法

1. 分别将两个指针 `low` 和 `high` 初始化为数组的开头和结尾。
2. 使用循环执行二分查找，当 `low` 小于或等于 `high` 时：
   * 将中间索引 `mid` 计算为 `low` 和 `high` 的平均值的下限。
   * 如果 `numbers[mid]` 等于目标，则返回 `mid`。
   * 通过比较 `numbers[low]` 和 `numbers[mid]` 来确定数组的左半部分是否已排序。
     * 如果左半部分已排序，请检查目标是否位于此范围内。 如果是，则将 `high` 调整为 `mid - 1`。 否则，将 `low` 调整为 `mid + 1`。
     * 如果左半部分未排序，则右半部分必须已排序。 检查目标是否位于此范围内。 如果是，则将 `low` 调整为 `mid + 1`。 否则，将 `high` 调整为 `mid - 1`。
3. 如果循环结束时未找到目标，则返回 `-1` 以指示目标不存在于数组中。

<MDXCodeBlock>
  {findInRotatedArray}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(log n)**。 二分查找在每一步将搜索空间减半，从而产生对数时间复杂度。
* **空间复杂度：O(1)**。 该算法使用恒定量的额外空间用于变量，因为它直接对输入数组进行操作。
