import MDXCodeBlock from 'MDXCodeBlock';

import breadthFirstSearchJs from '../setup/src/breadth-first-search.js';
import breadthFirstSearchTs from '../setup/src/breadth-first-search.ts';
import breadthFirstSearchRecursive from '../setup/src/breadthFirstSearchRecursive';

## Clarification questions

If unspecified:

- Order of traversal: Should we use a standard pre-order traversal or other orders of traversal?
- Input format: What is the format of the input data? Can we assume the input will be an adjacency list in the form of a JavaScript Object where keys are nodes and values are child nodes?
- Output format: How should the output be formatted? Are there specific requirements or can we return an array with elements in the order of traversal?
- Disconnected graphs: Do we have to consider or handle the case for disconnected graphs where there are multiple subgraphs that are not connected to each other?

## Iterative solution

The solution implements the algorithm outlined in the description.

<MDXCodeBlock
  languages={{ jsx: breadthFirstSearchJs, tsx: breadthFirstSearchTs }}
/>

## Recursive solution

We can also perform BFS recursively, which is can be more intuitive in certain cases. The recursion call stack is an implicit stack to track which nodes to visit next.

<MDXCodeBlock>{breadthFirstSearchRecursive}</MDXCodeBlock>

## Edge cases

- **Empty graphs**: Return an empty array without crashing.
- **Graphs with only one-two nodes**: Traverse without crashing.
- **Cyclic graphs**: Make sure not to traverse visited nodes again.
- **Disjoint graphs**: Doesn't require special handling but good to be aware of.

## Big-O analysis

Let's analyze the algorithm's time and space complexity.

### Time complexity

In the worst case, BFS visits every vertex and every edge of the graph once. Therefore, the time complexity of BFS is O(V + E), where V is the number of vertices in the graph and E is the number of edges. This is because BFS has to explore all vertices and edges to ensure that it covers the entire graph.

Take note that you should not use `Array.shift()` as it takes O(n) time to dequeue, where n is the number of elements in the array.

### Space complexity

BFS uses a queue to keep track of the nodes to be visited. At any given time, the queue contains the nodes that are at the current level of the graph being explored. Therefore, the space complexity of BFS is O(maximum number of nodes in any level of the graph).
