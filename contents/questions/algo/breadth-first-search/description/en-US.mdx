---
title: Breadth-first Search
excerpt: Implement a breadth-first search algorithm that traverses a directed graph in a breadth-first manner
---

Write a function that implements the breadth-first search (BFS) algorithm on a directed graph (in adjacency list format), given a starting node.

BFS is an algorithm used for traversing a graph or a tree, starting from the root node and exploring all the neighbors at the current depth before moving on to nodes at the next depth level. The output from BFS is an array of the graph's nodes in the order they were traversed. Visiting neighboring nodes in any order is a valid BFS, but for this question, please visit each node's neighbors from left to right.

## Examples

```js
const graph1 = {
  A: ['B', 'C', 'D'],
  B: ['E', 'F'],
  C: ['G', 'H'],
  D: ['I', 'J'],
  E: ['D'],
  F: [],
  G: [],
  H: [],
  I: [],
  J: [],
};

breadthFirstSearch(graph1, 'A'); // ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']
```

<center>
  <img
    src="/img/questions/breadth-first-search/graph1a.png"
    alt="Illustration of graph1 from node 'A' "
    style={{ width: '50%' }}
  />
</center>

```js
breadthFirstSearch(graph1, 'B'); // ['B', 'E', 'F', 'D', 'I', 'J']
```

<center>
  <img
    src="/img/questions/breadth-first-search/graph1b.png"
    alt="Illustration of graph1 from node 'B' "
    style={{ width: '30%' }}
  />
</center>

```js
const graph2 = {
  A: ['B', 'C'],
  B: ['D', 'E'],
  C: ['F', 'G'],
  D: [],
  E: [],
  F: [],
  G: [],
};

breadthFirstSearch(graph2, 'A'); // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
```

<center>
  <img
    src="/img/questions/breadth-first-search/graph2a.png"
    alt="Illustration of graph2 from node 'A' "
    style={{ width: '50%' }}
  />
</center>

```js
breadthFirstSearch(graph2, 'E'); // ['E']
```

A `Queue` data structure is also provided for you at the bottom of the skeleton code.

## Recap (Hint)

Breadth-first search (BFS) is an algorithm used for traversing a graph or a tree. Here is an overview of how BFS works to traverse a graph, using the standard implementation that takes in an adjacency list (we use an array instead) and the root node:

1. Initialize a queue to store nodes to be visited. Enqueue the root node.
1. Initialize a set to track visited nodes.
1. Enter a loop that continues until the queue is empty. In each iteration of the loop:
   1. Dequeue from the queue and mark it as visited.
   1. Retrieve the neighbors of the node from the input graph.
   1. For each neighbor, check if it has been visited. If it has not been visited, enqueue the node.
1. Return the set of visited nodes.

Breadth-first search is useful for the same purposes as [Depth-first search](/questions/javascript/depth-first-search), and it is especially useful for finding the shortest path between two nodes.
