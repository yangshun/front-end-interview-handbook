---
title: 广度优先搜索
excerpt: 实现一个广度优先搜索算法，该算法以广度优先的方式遍历有向图
---

编写一个函数`breadthFirstSearch(graph, source)`，该函数在有向图（邻接表格式）上实现广度优先搜索（BFS）算法，给定一个起始节点（`source`）。

BFS 是一种用于遍历图或树的算法，从根节点开始，在移动到下一深度级别上的节点之前，先探索当前深度的所有邻居。BFS 的输出是一个数组，其中包含图的节点，按照它们被遍历的顺序排列。以任何顺序访问相邻节点都是有效的 BFS，但对于这个问题，请从左到右访问每个节点的邻居。

## 示例

```js
const graph1 = {
  A: ['B', 'C', 'D'],
  B: ['E', 'F'],
  C: ['G', 'H'],
  D: ['I', 'J'],
  E: ['D'],
  F: [],
  G: [],
  H: [],
  I: [],
  J: [],
};

breadthFirstSearch(graph1, 'A'); // ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']
```

<center>
  <img src="/img/questions/breadth-first-search/graph1a.png" alt="Illustration of graph1 from node 'A' " style={{ width: '50%' }} />
</center>

```js
breadthFirstSearch(graph1, 'B'); // ['B', 'E', 'F', 'D', 'I', 'J']
```

<center>
  <img src="/img/questions/breadth-first-search/graph1b.png" alt="Illustration of graph1 from node 'B' " style={{ width: '30%' }} />
</center>

```js
const graph2 = {
  A: ['B', 'C'],
  B: ['D', 'E'],
  C: ['F', 'G'],
  D: [],
  E: [],
  F: [],
  G: [],
};

breadthFirstSearch(graph2, 'A'); // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
```

<center>
  <img src="/img/questions/breadth-first-search/graph2a.png" alt="Illustration of graph2 from node 'A' " style={{ width: '50%' }} />
</center>

```js
breadthFirstSearch(graph2, 'E'); // ['E']
breadthFirstSearch({}, ''); // []
```

**注意：**

* 如果图为空，则返回一个空数组。
* 如果提供了`source`节点，则保证它存在于`graph`中。

在骨架代码的底部也为您提供了一个`Queue`数据结构。

## 回顾（提示）

广度优先搜索（BFS）是一种用于遍历图或树的算法。以下是 BFS 如何遍历图的概述，使用接受邻接表（我们使用数组代替）和根节点的标准实现：

1. 初始化一个队列来存储要访问的节点。将根节点入队。
2. 初始化一个集合来跟踪已访问的节点。
3. 进入一个循环，该循环将持续到队列为空。在循环的每次迭代中：
   1. 从队列中出队并将其标记为已访问。
   2. 从输入图中检索节点的邻居。
   3. 对于每个邻居，检查它是否已被访问。如果尚未访问，则将节点入队。
4. 返回已访问节点的集合。

广度优先搜索与[深度优先搜索](/questions/javascript/depth-first-search)的用途相同，并且特别适用于查找两个节点之间的最短路径。
