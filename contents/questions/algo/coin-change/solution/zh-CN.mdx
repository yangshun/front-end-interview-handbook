import MDXCodeBlock from 'MDXCodeBlock';

import minimumCoinsForChange from '../setup/src/coin-change.ts';
import minimumCoinsForChangeBruteForce from '../setup/src/coin-change-bruteforce-recursive.ts';

## 1. 使用递归的蛮力方法

目标是确定使用可用的硬币面额组成给定目标金额所需的最少硬币数量。蛮力方法递归地尝试每一种可能的硬币组合，以找到硬币最少的解决方案。递归探索减少目标金额到零的所有有效方法，并跟踪所需的最少硬币数量。

### 算法

1. 定义一个辅助函数`minimumCoinsForChangeHelper`，该函数接受硬币数组和剩余的目标金额作为参数。
2. 如果目标金额为`0`，则返回`0`，因为不需要硬币。
3. 将变量`minCoins`初始化为`Infinity`，以跟踪所需的最少硬币数量。
4. 遍历硬币数组：
   1. 检查当前硬币面额是否小于或等于剩余的目标金额。
   2. 递归调用辅助函数，传入剩余金额（`target - coin`）。
   3. 如果找到有效的解决方案并且使用的硬币数量小于`minCoins`，则更新`minCoins`。
5. 遍历所有硬币后，如果没有找到有效的解决方案，则返回`-1`；否则，返回`minCoins`的值。
6. 主函数`minimumCoinsForChange`通过使用完整的目标金额调用辅助函数来初始化递归。

<MDXCodeBlock>
  {minimumCoinsForChangeBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(c<sup>t</sup>)**。 递归探索目标金额`t`的所有`c`硬币组合，导致指数时间复杂度。
* **空间复杂度：O(t)**。 递归调用栈与目标金额`t`成正比增长。

## 2. 使用动态规划

动态规划方法通过避免对相同子问题的重复计算来改进蛮力解决方案。该方法没有递归地解决每一种可能的硬币组合，而是使用`dp`数组来存储组成从`0`到目标金额所需的最少硬币数量。通过建立在先前计算的值之上，迭代地计算每个值，确保每个子问题只解决一次。这消除了冗余工作，并显着降低了时间复杂度。

### 算法

1. 初始化一个大小为`target + 1`的`dp`数组，所有值都设置为`Number.MAX_VALUE`，以表示不可达状态。
2. 将`dp[0]`设置为`0`，因为不需要硬币来组成金额`0`。
3. 迭代金额从`1`到`target`：
   1. 对于每个金额，遍历硬币列表。
   2. 如果当前硬币可以贡献到该金额（`i - coin >= 0`），则使用其当前值或`dp[i - coin] + 1`的最小值来更新`dp[i]`。
4. 填充`dp`数组后，检查`dp[target]`处的值：
   * 如果它仍然是`Number.MAX_VALUE`，则返回`-1`，因为目标金额无法实现。
   * 否则，返回`dp[target]`作为所需的最少硬币数量。

<MDXCodeBlock>
  {minimumCoinsForChange}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n.t)**。 遍历`target`金额并检查每个`n`硬币，结果为O(n.t)。
* **空间复杂度：O(t)**。 `dp`数组所需的空间与目标金额`t`成正比。
