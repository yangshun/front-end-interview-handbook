import MDXCodeBlock from 'MDXCodeBlock';

import findWordsInGrid from '../setup/src/grid-find-words.ts';

## 1. 使用回溯和字典树

该任务是从给定的列表 (`words`) 中找到存在于 2D 网格中的所有单词。单词可以通过上下左右移动的相邻单元格顺序形成。每个单元格每个单词只能使用一次。

此解决方案使用字典树（前缀树）结合回溯来实现高效的单词查找和验证。字典树允许快速前缀匹配，使算法能够尽早放弃无效路径。列表中的每个单词都存储在字典树中，每条路径代表一个可能的单词。在回溯期间，算法从每个网格单元格开始探索所有可能的路径，并对照字典树进行检查以验证有效前缀。当字典树中匹配到完整的单词时，就会记录单词。

这种方法最大限度地减少了冗余检查，并有效地修剪了无效路径，与蛮力方法相比，显著提高了性能。

### 算法

1. 构建一个字典树来存储给定的 `words`:
   * 使用根节点初始化字典树。
   * 对于 `words` 中的每个单词，遍历字典树，如果不存在，则为每个字符添加一个新节点。
   * 通过将单词存储在相应的节点中来标记字典树中每个单词的结尾。
2. 定义一个 `backtracking` 函数来探索网格中的路径:
   * 检查字典树中的当前节点是否代表一个完整的单词。如果是，将该单词添加到结果列表中，并将其标记为已使用以避免重复。
   * 暂时将当前网格单元格标记为已访问，方法是更改其值。
   * 探索所有相邻单元格（上、下、左、右），如果字典树中存在相应的字符，则递归调用 `backtracking` 函数。
   * 在探索完所有邻居后，恢复网格单元格的值。
   * 如果没有进一步的路径，则从字典树中删除叶节点以进行优化。
3. 遍历网格中的每个单元格:
   * 如果单元格的字符作为字典树中根节点的子节点存在，则从该单元格启动回溯搜索。
4. 返回匹配的单词列表。

<MDXCodeBlock>
  {findWordsInGrid}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n.4.3<sup>l-1</sup>)**。该算法遍历所有 `m.n` 个单元格，在最坏的情况下，每个单元格最多探索 4.3<sup>l-1</sup> 条路径。当所有路径都有效时，就会发生这种情况，例如一个由相同字母填充的棋盘和一个包含单个长单词的字典。像从字典树中删除匹配节点这样的优化可以在找到所有单词后减少回溯成本。
* **空间复杂度：O(l)**，其中 `l` 是字典中字母的总数。字典树使用 `l` 空间，如果单词也被存储，则使用 `2.l` 空间。在最坏的情况下，由于没有共享前缀，每个字母都有自己的节点。
