import MDXCodeBlock from 'MDXCodeBlock';

import binarySearchJs from '../setup/src/binary-search.js';
import binarySearchTs from '../setup/src/binary-search.ts';
import binarySearchRecursive from '../setup/src/binarySearchRecursive';

二分查找是一种高效的搜索算法，它在每一步都将搜索空间减半，这意味着它可以在 O(log(n)) 时间内找到目标元素，其中 n 是输入数组的大小。这使得它比线性搜索快得多，线性搜索的时间复杂度为 O(n)。

## 澄清问题

如果未指定：

* 排序顺序：是升序还是降序？
* 我们需要处理什么样的输入？
  * 它只是一个整数数组，还是我们应该处理其他数据类型？
  * 是否有重复的元素？
  * 应该如何处理负数？

## 解决方案

注意：这个问题处理的是一个标准的二分查找，它使用迭代方法，并假设数组已经排序。有关其他替代方案，请参阅“注释”部分。

<MDXCodeBlock languages={{ jsx: binarySearchJs, tsx: binarySearchTs }} />

如果面试官要求使用递归方法：

<MDXCodeBlock>
  {binarySearchRecursive}
</MDXCodeBlock>

## 边缘情况

* 非整数元素输入：如果输入数组包含不同数据类型的元素，您可能需要返回一个错误，以尽力而为的方式进行排序，例如，仅对输入数据的子集进行排序，甚至为非整数定义自定义比较函数。

## Big-O 分析

让我们分析一下算法的时间和空间复杂度。

### 时间复杂度

二分查找在平均和最坏情况下的时间复杂度为 O(log(n))，因为它每一步都将搜索空间减半。即使在目标元素不在数组中的最坏情况下，它仍然将搜索空间减半，因此在对数时间内完成搜索。

在最佳情况下，二分查找的时间复杂度为 O(1)。当目标元素恰好位于输入数组的中间索引时，就会发生这种情况。

但是，二分查找假设输入数组已排序。如果需要排序，则需要额外的时间复杂度，具体取决于所选的排序算法。

### 空间复杂度

二分查找在所有情况下，迭代方法的时间复杂度为 O(1)，因为它使用恒定的额外内存来存储变量。除了输入之外，我们不保留额外的内存。

但是，如果使用递归方法，空间复杂度取决于递归调用堆栈所需的空间。由于递归树的高度是 log(n) + 1，并且在每一层只有一个递归调用，我们预计空间复杂度为 O(log(n))。
