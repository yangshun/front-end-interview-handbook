import MDXCodeBlock from 'MDXCodeBlock';

import serializeAndDeserializeBinaryTree from '../setup/src/binary-tree-serialization-deserialization.ts';

## 1. 使用 DFS

二叉树的序列化和反序列化分别涉及将树结构转换为字符串表示形式，以及从字符串重建树。该解决方案使用深度优先遍历 (DFS) 方法来实现此目的。

#### 序列化

* 每个节点的值附加到字符串中，然后递归地序列化其左子树和右子树。
* 如果节点为 `null`，则表示为字符串 `"null"` 以保留树的结构。

#### 反序列化

* 序列化字符串被拆分成一个节点值的列表以进行遍历。
* `null` 值表示分支的结尾，而其他值用于创建树节点。
* 递归地，反序列化左子树和右子树以重建树。

### 算法

#### 序列化

1. 检查当前节点是否为 `null`。如果是，则将 `"null,"` 附加到字符串并返回。
2. 将当前节点的值附加到字符串，后跟一个逗号。
3. 递归地序列化左子树并将其附加到字符串。
4. 递归地序列化右子树并将其附加到字符串。
5. 返回序列化后的字符串。

#### 反序列化

1. 按逗号分割序列化字符串，形成节点值的列表。
2. 检查列表中第一个元素是否为 `"null"`。如果是，则将其从列表中删除并返回 `null`。
3. 使用列表的第一个元素创建一个 `TreeNode`，将其转换为数字。
4. 从列表中删除第一个元素。
5. 递归地反序列化左子树并将其分配给节点的左子节点。
6. 递归地反序列化右子树并将其分配给节点的右子节点。
7. 返回重建的树节点。

<MDXCodeBlock>
  {serializeAndDeserializeBinaryTree}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。序列化和反序列化都遍历二叉树的所有 `n` 个节点一次。
* **空间复杂度：O(n)**。DFS 的递归堆栈以及存储序列化字符串或列表所需的空间随树的大小而扩展。
