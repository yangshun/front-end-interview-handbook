import MDXCodeBlock from 'MDXCodeBlock';

import linkedListCombineKSorted from '../setup/src/linked-list-combine-k-sorted.ts';
import linkedListCombineKSortedBruteForce from '../setup/src/linked-list-combine-k-sorted-bruteforce.ts';

## 1. 暴力解法

一种朴素的方法是将所有`k`个链表中的所有值提取到一个数组中，对它们进行排序，然后从排序后的数组中重建一个新的排序链表。

### 算法

1. 创建一个空数组`nodes`，用于存储链表中所有节点的值。
2. 创建一个虚拟节点，作为构建新链表的起点。
3. 遍历`lists`数组中的每个链表。
   1. 遍历当前链表。
   2. 将每个节点的值追加到`nodes`数组中。
4. 按升序对`nodes`数组进行排序。
5. 遍历排序后的`nodes`数组。
   1. 为每个值创建一个新节点，并将其链接到组合链表中。
   2. 将指针移动到新添加的节点。
6. 返回组合链表，跳过虚拟节点。

<MDXCodeBlock>
  {linkedListCombineKSortedBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。提取值需要 O(n)，其中`n`是所有`k`个链表中节点的总数。对数组进行排序需要 O(n log n)。
* **空间复杂度：O(n)**。使用额外的空间来存储大小为`n`的`nodes`数组和新的链表。

## 2. 分治法

分治法不是尝试一步合并所有`k`个列表，而是将问题分解成更小的部分。相邻的列表成对合并，在每一轮中将列表的数量减少一半。

这个过程可以被可视化为构建一个二叉树。在底层，`k`个列表中的每一个都被视为一个单独的节点。在下一层，相邻的列表对被合并以形成`k/2`个合并列表。这种配对和合并一直持续到只剩下一个列表，形成树的根。

每次成对合并操作都会处理被合并的两个列表中的所有节点。这确保了不会进行额外的比较，从而利用了列表的排序顺序。

合并过程中的层数对应于二叉树的高度，该高度与`log k`成正比。与暴力解法相比，这种分层减少显著减少了比较次数。

### 算法

1. 将`amount`初始化为要合并的链表数量。
2. 将`interval`设置为 1，表示成对合并的距离。
3. 当`interval`小于`amount`时：
   1. 遍历`lists`数组，合并相隔`interval`的链表对。
   2. 将每对中的第一个列表替换为合并结果。
   3. 将`interval`加倍。
4. 如果`amount`大于 0，则返回`lists`数组中的第一个列表；否则，返回`null`。

辅助函数`merge2Lists`执行两个已排序链表的合并：

1. 初始化一个虚拟节点和一个指针来构建新的组合列表。
2. 遍历两个输入列表：
   1. 比较两个列表的当前节点，并将较小的节点附加到组合列表中。
   2. 移动到较小节点所在的列表中的下一个节点。
3. 将非空列表中剩余的任何节点附加到组合列表中。
4. 返回组合列表，跳过虚拟节点。

<MDXCodeBlock>
  {linkedListCombineKSorted}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log k)**。两个列表的每次合并操作为 O(n)，其中`n`是两个列表中节点的总数。合并层数为 O(log k)，其中`k`是列表的数量。
* **空间复杂度：O(1)**。合并过程是就地执行的，不需要额外的空间。
