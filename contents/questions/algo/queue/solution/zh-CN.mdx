import MDXCodeBlock from 'MDXCodeBlock';

import queueJs from '../setup/src/queue.js';
import queueTs from '../setup/src/queue.ts';

## 解决方案

队列应该用链表来实现，链表本质上是一系列连接的节点。为了简化空队列的链表操作，我们使用双向链表（节点同时具有 `prev` 和 `next` 指针）和虚拟/哨兵头/尾节点。通过使用虚拟节点，链表将永远不会是“空的”，我们不必单独处理入队到空队列和出队只有一个项目的队列的情况。

![Empty Queue](/img/questions/queue/empty-queue.png)

`enqueue()` 涉及创建一个新的 `Node` 并在 `_dummyTail` 节点和 `_dummyTail.next`（在空队列的情况下是 `_dummyHead`）之间添加它。

![Enqueue one item](/img/questions/queue/enqueue-a.png)

![Enqueue second item](/img/questions/queue/enqueue-b.png)

`dequeue()` 涉及删除 `_dummyHead` 节点和 `_dummyHead.prev` 之间的节点。如果队列为空，则这应该是一个 no-op，否则 `_dummyTail` 将被出队。

![Dequeue](/img/questions/queue/dequeue.png)

由于 `length()` 的时间复杂度必须是 O(1)，并且计算链表中项目的数量将需要 O(n)，因此我们需要使用 `_length` 实例属性单独跟踪列表中项目的数量，并在 `enqueue()` 和 `dequeue()` 方法中更新它。

请注意，自动评分器不会检查你的 `enqueue()` 和 `dequeue()` 操作的时间复杂度是否为 O(1)，但如果你只使用单个 JavaScript 数组来解决这个问题，那么它几乎肯定无法实现这两个操作的 O(1) 时间复杂度。

<MDXCodeBlock languages={{ jsx: queueJs, tsx: queueTs }} />

## 边缘情况

* 在空栈上调用 `dequeue()`。
* 在空栈上调用 `front()`。
* 在空栈上调用 `back()`。

## 技术

* 面向对象编程。
* 链表操作。
