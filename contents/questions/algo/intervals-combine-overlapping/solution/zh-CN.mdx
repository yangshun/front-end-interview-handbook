import MDXCodeBlock from 'MDXCodeBlock';

import mergeIntervals from '../setup/src/intervals-combine-overlapping.ts';
import mergeIntervalsUsingConnectedComponents from '../setup/src/intervals-combine-overlapping-connected-components.js';

## 1. 使用排序

该问题涉及将重叠的区间合并成一个单一的区间，针对每个重叠组。该方法使用排序来确保区间按其开始时间的升序处理。通过迭代排序后的区间，可以有效地检测和合并重叠部分。

按开始时间对区间进行排序，确保所有潜在的重叠部分连续出现，从而减少不必要的比较。如果不进行排序，暴力方法将涉及将每个区间与所有其他区间进行比较，导致重复工作和效率低下。暴力方法的瓶颈在于这些冗余的比较，而排序消除了这些比较。排序后，只需遍历一次区间即可通过将当前区间与最后一个合并的区间进行比较来合并重叠部分。

### 算法

1. 按每个区间的起始点对 `intervals` 数组进行升序排序。
2. 初始化一个空数组 `merged` 以存储合并后的区间。
3. 遍历排序后的数组中的每个区间：
   1. 如果 `merged` 数组为空，或者当前区间与 `merged` 中的最后一个区间不重叠，则将当前区间追加到 `merged`。
   2. 如果存在重叠，则将 `merged` 中最后一个区间的结束时间更新为其当前结束时间和当前区间的结束时间的最大值。
4. 返回包含所有合并区间的 `merged` 数组。

<MDXCodeBlock>
  {mergeIntervals}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。对区间进行排序需要 O(n log n)，后续遍历区间需要 O(n)。
* **空间复杂度：O(n)**。如果没有任何区间重叠，`merged` 数组最多可以容纳所有区间。

## 2. 使用连通分量

可以使用图论中的连通分量的概念来解决合并重叠区间的问题。每个区间被视为图中的一个节点，如果两个节点对应的区间重叠，则在它们之间创建一条边。目标是识别该图中的所有连通分量，其中每个分量代表一组重叠的区间。然后可以将每个分量合并成一个单一的区间。

通过构建连接区间的图并使用深度优先搜索 (DFS) 来识别连通分量，该过程变得结构化并避免了不必要的比较。一旦识别出这些分量，合并它们就变得很简单，因为它涉及找到分量中所有区间的最小开始时间和最大结束时间。

### 算法

1. 定义一个辅助函数 `overlap`，通过比较两个区间的起始点和结束点来检查它们是否重叠。
2. 使用 `buildGraph` 函数构建一个图：
   1. 遍历所有区间对。
   2. 如果两个区间重叠，则在图中的相应节点之间添加一条边。
3. 定义一个 `mergeNodes` 函数，通过找到连通分量中所有区间的最小开始点和最大结束点来合并它们。
4. 实现 `markComponentDFS` 函数以执行 DFS：
   1. 从一个节点开始，将所有连接的节点标记为同一分量的一部分。
   2. 使用堆栈递归地探索所有邻居。
5. 在主函数中：
   1. 使用 `buildGraph` 构建区间图。
   2. 使用 DFS 识别所有连通分量，并将区间分组成分量。
   3. 使用 `mergeNodes` 将每个分量合并成一个单一的区间。
6. 返回合并后的区间。

<MDXCodeBlock>
  {mergeIntervalsUsingConnectedComponents}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。构建图需要比较每对区间，导致 O(n<sup>2</sup>) 次操作。

* **空间复杂度：O(n<sup>2</sup>)**。在最坏的情况下，该图最多可以有 O(n<sup>2</sup>) 条边，并且 `visited` 集合和 `nodesInComp` 存储会随着区间数量的增加而扩展。
