import MDXCodeBlock from 'MDXCodeBlock';

import combinationTargetSum from '../setup/src/combinations-target-sum.ts';
import combinationTargetSumTopDownApproach from '../setup/src/combinations-target-sum-top-down.ts';

## 1. 自底向上动态规划

解决组合目标和问题的动态规划方法通过将问题分解为更小的子问题来工作。关键的直觉是，实现特定和的方法的数量可以从实现更小和的方法的数量推导出来。通过从最小的子问题（和为 0）到目标和迭代地构建解决方案，该算法确保了所有中间结果都被重用。

对于从 1 到目标值的每个可能的和，都会考虑输入数组中的每个数字。如果该数字可以从当前和中减去而不会导致负值，则将剩余和的组合添加到当前和的组合中。这确保了所有对当前和的有效贡献都被考虑在内。基本情况是，形成和为 0 的方法恰好有一种（不使用任何元素），这确保了该过程正确开始。

这种方法避免了蛮力解决方案的低效率，蛮力解决方案会生成并检查数组的所有可能子集。相反，它通过使用先前计算的结果来迭代地构建解决方案，从而消除了冗余计算并显着降低了运行时复杂度。

<MDXCodeBlock>
  {combinationTargetSum}
</MDXCodeBlock>

### 算法

1. 初始化一个大小为 `target + 1` 的 `dp` 数组，并用 `0` 填充。此数组将存储从 `0` 到 `target` 的每个和的组合数。
2. 设置 `dp[0] = 1` 以表示基本情况，其中实现和为 `0` 的方法恰好有一种（不使用任何元素）。
3. 迭代所有可能的和 (`combSum`)，从 `1` 到 `target`：
   1. 对于每个和，迭代输入数组 `numbers` 的元素。
   2. 检查当前数字是否可以从 `combSum` 中减去而不会导致负值。这确保只考虑有效的组合。
   3. 如果有效，通过添加 `dp[combSum - num]` 的值来更新 `dp[combSum]`。这会将实现剩余和 (`combSum - num`) 的方法数添加到当前和的计数中。
4. 返回 `dp[target]`，它保存实现目标和的不同组合的数量。

### Big-O 分析

* **时间复杂度：O(n.t)**。该算法迭代从 `1` 到 `target` 的所有和（外循环），并处理 `numbers` 数组中的每个元素（内循环）。
* **空间复杂度：O(t)**。`dp` 数组需要的空间与目标值成正比。

## 2. 自顶向下动态规划

自顶向下动态规划方法使用带有记忆的递归。关键思想是通过考虑从数组中减去每个数字后剩余的目标，将问题分解为更小的子问题。对于给定的目标，组合的数量是可以通过减去每个数字形成的较小目标的组合的总和。

这种方法避免了重新计算重叠子问题的低效率，这是蛮力递归解决方案中常见的瓶颈。记忆化将先前解决的子问题的结果存储在映射中，允许在后续计算中进行恒定时间检索。与朴素的递归方法相比，这减少了冗余计算并提高了效率。

### 算法

1. 初始化一个 `memo` 映射，以存储每个剩余目标的组合数。
2. 定义一个递归辅助函数 `combs(remain)`：
   1. 检查 `remain` 是否等于 0。如果是，则返回 1，因为存在一个有效的组合（不使用其他数字）。
   2. 如果 `memo` 映射包含 `remain` 的结果，则返回存储的值以避免冗余计算。
   3. 初始化一个变量 `result` 为 0，以存储当前 `remain` 的组合数。
   4. 迭代 `numbers` 数组中的每个数字：
      1. 如果 `remain - num` 为非负数，则递归调用 `combs(remain - num)` 并将结果添加到 `result`。
   5. 将计算出的 `result` 存储在 `memo` 映射中以供将来参考。
3. 返回调用 `combs(target)` 的结果，作为给定目标的总组合数。

<MDXCodeBlock>
  {combinationTargetSumTopDownApproach}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n.t)**。每个目标值的子问题只解决一次，解决每个问题都涉及迭代 `numbers`。
* **空间复杂度：O(t)**。`memo` 映射存储了多达 `target` 个不同值的结果，并且递归堆栈在最坏的情况下可以深入到 `target`。
