import MDXCodeBlock from 'MDXCodeBlock';

import binaryTreeMaximumDepth from '../setup/src/binary-tree-maximum-depth.ts';
import binaryTreeMaximumDepthIteration from '../setup/src/binary-tree-maximum-depth-iteration.ts';

## 1. 使用递归

二叉树的最大深度是通过找到从根节点到叶节点的最长路径来确定的。递归方法非常适合这个问题，因为节点的深度是其左子树和右子树的最大深度加 1。从根节点开始，算法探索左子树和右子树，计算它们的深度，并选择较大的值，有效地以分治方式遍历所有节点。

### 算法

1. 从根节点开始。
2. 如果当前节点为 `null`，则返回深度 0，因为其下没有节点。
3. 递归计算左子树的深度。
4. 递归计算右子树的深度。
5. 通过将 1（对于当前节点本身）添加到其左子树和右子树的深度的最大值来计算当前节点的深度。
6. 继续此过程，直到所有节点都被访问。

<MDXCodeBlock>
  {binaryTreeMaximumDepth}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。树中的每个节点只访问一次以计算其深度。
* **空间复杂度：O(h)**。递归堆栈大小取决于树的高度，其中 `h` 是树的高度。

## 2. 使用迭代

迭代方法查找二叉树的最大深度，使用堆栈来模拟深度优先遍历。每个堆栈条目包含一个节点及其当前深度。这避免了递归，并使用堆栈显式管理遍历。从深度为 1 的根节点开始，算法遍历树中的所有节点，在处理每个节点时更新最大深度。节点以其深度增加 1 的方式添加到堆栈中，表示树的下一层。这种方法确保考虑从根到叶的每条路径，并记录最大深度。

### 算法

1. 使用根节点及其初始深度设置为 1 来初始化堆栈。
2. 使用一个变量来跟踪遍历期间遇到的最大深度。
3. 当堆栈不为空时：
   * 弹出顶部节点及其关联的深度。
   * 如果当前深度更大，则更新最大深度。
   * 将节点的左子节点和右子节点推入堆栈，其深度增加 1。
4. 继续，直到所有节点都被处理。

<MDXCodeBlock>
  {binaryTreeMaximumDepthIteration}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。树中的每个节点在遍历期间只访问一次。
* **空间复杂度：O(h)**。堆栈大小取决于树的高度，其中 `h` 是树的高度。
