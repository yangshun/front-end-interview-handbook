import MDXCodeBlock from 'MDXCodeBlock';

import neighborhoodTheft from '../setup/src/neighborhood-theft.ts';
import neighborhoodTheftTopDownApproach from '../setup/src/neighborhood-theft-top-down.ts';
import neighborhoodTheftBottomUpSpaceOptimized from '../setup/src/neighborhood-theft-bottom-up-space-optimized.ts';

## 1. 自顶向下动态规划

此解决方案使用自顶向下的动态规划方法和记忆化来解决“邻居盗窃”问题。该问题涉及在确保不抢劫相邻房屋的情况下，最大化从房屋中偷走的金额。

该算法从第一所房子开始，并递归地探索两个选项：

1. 跳过当前房屋并移至下一所房屋。
2. 抢劫当前房屋并移至下一所房屋之后的房屋。

记忆化用于存储已计算的子问题的结果。这避免了冗余计算，并显着降低了运行时复杂度。通过缓存每个房屋的结果，该解决方案仅计算每个子问题一次，与纯递归方法相比，优化了性能。

### 算法

1. 初始化一个大小与输入数组相同的 `memo` 数组，并用 `-1` 填充，以指示未计算的值。
2. 定义一个辅助函数 `robFrom`，该函数递归地计算从第 `i` 个房屋开始可以抢劫的最大金额。
   1. 检查基本情况，其中 `i` 超过数组的边界，返回 `0`，因为没有房屋可以抢劫。
   2. 如果房屋 `i` 的结果已计算并存储在 `memo[i]` 中，则返回缓存值。
   3. 计算以下两者之间的最大值：
      * 跳过当前房屋，调用 `robFrom(i + 1, numbers)`。
      * 抢劫当前房屋，并将其值添加到 `robFrom(i + 2, numbers)` 的结果中。
   4. 将计算结果存储在 `memo[i]` 中以备将来使用。
3. 通过调用 `robFrom(0, numbers)` 来处理所有房屋，开始计算。
4. 返回计算结果，该结果表示在不触发警报的情况下可以抢劫的最大金额。

<MDXCodeBlock>
  {neighborhoodTheftTopDownApproach}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个房屋最多处理一次，结果存储在 `memo` 数组中，避免了冗余的递归调用。
* **空间复杂度：O(n)**。`memo` 数组所需的空间与房屋数量成正比，并且递归堆栈在最坏的情况下可能达到 `n` 的深度。

## 2. 自底向上动态规划

这种方法通过迭代地从最后一个房屋到第一个房屋构建 `dp` 表（或数组）来消除递归，确保所有子问题都按顺序解决。

`dp` 数组 `maxRobbedAmount` 存储了可以抢劫的最大金额，考虑从当前索引到最后一个房屋的房屋。对于每个房屋，考虑两个选项：

1. 跳过当前房屋并获取为下一所房屋存储的结果 (`maxRobbedAmount[i + 1]`)。
2. 抢劫当前房屋并将其值添加到为跳过下一所房屋存储的结果 (`maxRobbedAmount[i + 2] + numbers[i]`)。

每个房屋的决策是通过选择提供最大金额的选项来做出的。这避免了冗余计算，并确保了有效的解决方案。

### 算法

1. 处理输入数组为空的基本情况。如果没有房屋，则返回 `0`。
2. 初始化大小为 `N + 1` 的 `dp` 数组 `maxRobbedAmount`，并用 `0` 填充。此数组将存储从每个房屋开始可以抢劫的最大金额。
3. 设置最后两所房屋的基本情况：
   * `maxRobbedAmount[N]` 为 `0`，表示没有房屋可以抢劫。
   * `maxRobbedAmount[N - 1]` 设置为最后一个房屋的值 (`numbers[N - 1]`)，因为对于最后一个房屋没有其他选项。
4. 从倒数第二个房屋 (`N - 2`) 向后迭代到第一个房屋 (`0`)：
   * 对于每个房屋 `i`，通过在以下两者之间进行选择来计算可以抢劫的最大金额：
     1. 跳过当前房屋：`maxRobbedAmount[i + 1]`。
     2. 抢劫当前房屋并跳过下一所房屋：`maxRobbedAmount[i + 2] + numbers[i]`。
   * 将最大值存储在 `maxRobbedAmount[i]` 中。
5. 返回 `maxRobbedAmount[0]`，它表示从第一个房屋开始可以抢劫的最大金额。

<MDXCodeBlock>
  {neighborhoodTheft}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。该算法在向后迭代中恰好处理每个房屋一次。
* **空间复杂度：O(n)**。`dp` 数组 `maxRobbedAmount` 所需的空间与房屋数量成正比。

## 3. 自底向上动态规划，优化空间

此解决方案基于前一个问题中使用的自底向上动态规划方法，但将空间复杂度从 O(n) 优化到 O(1)。在之前的解决方案中，使用 `dp` 数组来存储从每个房屋开始可以抢劫的最大金额，这需要额外的空间，与房屋数量成正比。但是，在任何给定时间，只需要该数组的最后两个值来计算当前结果。

为了消除不必要的存储，此解决方案用两个变量 `prev1` 和 `prev2` 替换了 `dp` 数组，这两个变量存储了下一个房屋（`i + 1`）和之后房屋（`i + 2`）的最大金额。这确保了算法仍然计算相同的结果，但大大减少了空间使用。

该算法向后遍历数组，在每一步更新这两个变量。使用两个变量而不是整个数组消除了空间开销，同时保留了先前方法的时间效率。当处理大量房屋时，这种改进尤其有益。

### 算法

1. 处理特殊情况：
   1. 如果没有房屋，则返回 `0`。
   2. 如果只有一个房屋，则返回其值，因为不存在其他选项。
2. 初始化两个变量：
   * `prev1` 为 `0`，表示从下一个房屋（`i + 1`）开始可以抢劫的最大金额。
   * `prev2` 为 `0`，表示从下一个房屋（`i + 2`）之后的房屋开始可以抢劫的最大金额。
3. 向后遍历房屋：
   1. 计算可以从当前房屋抢劫的最大金额，即以下两者的最大值：
      * 跳过当前房屋（`prev1`）。
      * 抢劫当前房屋并加上 `prev2` 的值。
   2. 将 `prev2` 更新为 `prev1` 的当前值，并将 `prev1` 更新为新计算的最大值。
4. 循环结束后，`prev1` 包含从第一个房屋开始可以抢劫的最大金额。返回此值。

<MDXCodeBlock>
  {neighborhoodTheftBottomUpSpaceOptimized}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个房屋在向后迭代中只处理一次。
* **空间复杂度：O(1)**。仅使用两个变量来跟踪中间结果，无需额外的数组。
