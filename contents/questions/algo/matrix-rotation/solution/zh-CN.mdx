import MDXCodeBlock from 'MDXCodeBlock';

import matrixRotation from '../setup/src/matrix-rotation.ts';
import matrixRotationUsingTranspose from '../setup/src/matrix-rotation-transpose.ts';

## 1. 旋转四组单元格

该任务涉及将一个正方形矩阵顺时针旋转 90 度。这意味着变换不能使用额外的内存来存储另一个矩阵。该解决方案使用分组旋转方法来移动矩阵每一层中的值。

直觉是，对于 90 度顺时针旋转：

* 左上角的元素移动到右上角。
* 右上角的元素移动到右下角。
* 右下角的元素移动到左下角。
* 左下角的元素移动到左上角。

这种变换可以通过逐层遍历矩阵来实现。每一层代表一组嵌套的正方形，从最外层开始，向中心移动。对于每一层，元素以四组为单位进行交换，有效地执行旋转，而无需额外的内存使用。

### 算法

1. 获取矩阵的大小 `n`。
2. 逐层遍历矩阵：
   * 外循环处理从外到中心的每一层。层数为 `Math.floor((n + 1) / 2)`。
   * 内循环处理层内的元素。每层中的元素数量由 `Math.floor(n / 2)` 决定。
3. 对于当前层中的每组四个单元格：
   * 临时存储左上角元素。
   * 将左下角元素移动到左上角位置。
   * 将右下角元素移动到左下角位置。
   * 将右上角元素移动到右下角位置。
   * 将存储的左上角值分配给右上角位置。
4. 对所有层重复此过程。

<MDXCodeBlock>
  {matrixRotation}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。在逐层遍历期间，矩阵中的每个元素都会被访问一次。
* **空间复杂度：O(1)**。旋转是在原地执行的，没有使用额外的内存。

## 2. 使用矩阵转置

该任务涉及将一个正方形矩阵顺时针旋转 90 度。这种变换可以通过两个步骤实现：转置矩阵，然后水平反射它。

1. **转置**：转置操作通过将位置 `(i, j)` 处的元素与 `(j, i)` 处的元素交换来交换行和列。此步骤将原始矩阵的行转换为结果矩阵的列。

2. **水平反射**：转置后，水平反射矩阵会交换每一行中的元素，将最左边的元素与最右边的元素交换。这完成了 90 度顺时针旋转。

这种方法有效地在原地操作矩阵，而无需为另一个矩阵分配额外的空间。

### 算法

1. 检索矩阵的大小 `n`。
2. 执行转置操作：
   * 遍历矩阵的每一行 `i`。
   * 对于每一行，遍历列 `j`，其中 `j > i` 以避免冗余交换。
   * 交换 `(i, j)` 和 `(j, i)` 处的元素。
3. 执行水平反射：
   * 遍历矩阵的每一行 `i`。
   * 对于每一行，遍历前一半的列 `j`。
   * 交换 `(i, j)` 和 `(i, n-1-j)` 处的元素。
4. 现在矩阵顺时针旋转 90 度。

<MDXCodeBlock>
  {matrixRotationUsingTranspose}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。转置和反射操作都涉及访问矩阵的每个元素一次。
* **空间复杂度：O(1)**。旋转是在原地执行的，没有使用额外的内存。
