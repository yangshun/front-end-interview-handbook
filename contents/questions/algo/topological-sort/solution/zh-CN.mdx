import MDXCodeBlock from 'MDXCodeBlock';

import topologicalSortJs from '../setup/src/topological-sort.js';
import topologicalSortTs from '../setup/src/topological-sort.ts';

拓扑排序是一种算法，它产生有向无环图（DAG）的顶点的线性排序，使得对于每个有向边（u，v），顶点u在排序中位于顶点v之前。使用Kahn算法实现的拓扑排序具有线性时间复杂度，这使得它对于大型图相对有效。

## 澄清问题

如果未指定：

* 输入和输出格式：
  * 输入图应该表示为邻接矩阵、邻接表还是其他数据结构？
  * 输出应该是拓扑顺序的节点列表还是表示节点拓扑顺序的整数数组？

## 解决方案

<MDXCodeBlock languages={{jsx:topologicalSortJs,tsx:topologicalSortTs}}/>

## 边缘情况

* 没有边的图：返回一个空数组或适当的错误消息。
* 带有循环的图：返回错误或空数组。

## Big-O 分析

让我们分析一下算法的时间和空间复杂度。

### 时间复杂度

使用Kahn算法实现的拓扑排序始终以O(V + E)的时间复杂度运行，其中V是图中顶点的数量（或节点），E是图中边的数量。

* 初始化`Map`对象以存储每个节点的传入和传出边的循环的时间复杂度为O(V)，因为它访问了图的所有顶点（节点）一次。
* 遍历输入图中的所有键，并且对于每个节点，将其邻居节点的`in`属性增加1的循环的时间复杂度为O(E)，因为它访问了图的所有边一次。
* 遍历节点，将所有`in: 0`的节点添加到队列中的循环的时间复杂度也为O(V)，因为它访问了图的所有顶点一次。
* while循环迭代直到队列不为空，其最大时间复杂度为O(V + E)，因为它正在处理图的所有顶点和边。

总的来说，Kahn算法实现的的时间复杂度为O(V + E)。

### 空间复杂度

使用Kahn算法实现的拓扑排序的空间复杂度为O(V)，其中V是图中顶点的数量（或节点）。

* Map数据结构“nodes”存储每个节点的属性，并占用O(V)空间。
* 输出数组“order”占用O(V)空间，因为它存储所有节点的拓扑顺序。
* 队列数据结构“queue”存储入度等于0的节点，这需要与输入数据成线性关系的空间，因此占用O(V)空间。

因此，该算法的空间复杂度为O(V)。
