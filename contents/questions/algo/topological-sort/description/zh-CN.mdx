---
title: 拓扑排序
excerpt: 实现一个执行拓扑排序的函数
---

实现一个对有向图（邻接表格式）执行拓扑排序的函数，其中键表示节点，值是具有指向当前节点的传出边的节点数组。

## 例子

```js
const graph1 = {
  A: ['B', 'C'],
  B: ['C', 'D', 'E'],
  C: ['F'],
  D: [],
  E: ['F'],
  F: [],
};
topologicalSort(graph1); // ['A', 'B', 'C', 'D', 'E', 'F']

const graph2 = {
  A: ['B', 'C'],
  B: ['C', 'D'],
  C: ['D'],
  D: ['E'],
  E: ['F'],
  F: [],
};
topologicalSort(graph2); // ['A', 'B', 'C', 'D', 'E', 'F']

const graph3 = {
  A: [],
  B: ['A'],
  C: ['B'],
  D: ['C'],
  E: ['D'],
  F: ['E'],
};
topologicalSort(graph3); // ['F', 'E', 'D', 'C', 'B', 'A']
```

请注意，对于有向图，可以有多个有效的拓扑排序，但对于我们的测试用例，只有一个有效的解决方案。

在骨架代码的底部也为您提供了一个 `Queue` 数据结构。

## 回顾

拓扑排序是一种算法，用于以线性顺序对有向无环图 (DAG) 的元素进行排序，使得顺序遵循图中边定义的顺序。

理解这一点的一种简单方法是将图的节点视为任务，从节点 A 到节点 B 的边表示节点 B 依赖于节点 A。拓扑排序所做的是从图中生成一个节点数组，使得数组中节点的顺序遵循图中定义的所有依赖关系。

为什么拓扑排序只适用于 DAG 而不是任何图？这是因为图必须具有有向边才能表示依赖关系，并且是无环的（无环），因为任何环都将表示节点之间无法解析的依赖关系。

拓扑排序通常用于调度问题，例如调度具有依赖关系的作业，或在编译中，编译顺序由模块之间的依赖关系决定。

有很多方法可以实现拓扑排序，但一种简单直观的方法是使用 Kahn 算法，其工作原理如下：

1. 初始化一个队列和一个列表来存储排序后的节点。
2. 对于图中的每个节点，如果它没有入边，则将其添加到队列中。
3. 当队列不为空时：
4. 从队列的前面取出一个节点。
5. 将此节点添加到已排序节点的列表中。
6. 对于此节点的每个子节点，将其入度（入边的数量）减 1。
7. 如果子节点的入度变为 0，则将其添加到队列中。
8. 如果排序列表的长度小于图中的节点数，这意味着图中存在一个循环，并且无法进行拓扑排序。

### 笔记

* 严格来说，我们也可以使用一个集合而不是一个队列。
