import MDXCodeBlock from 'MDXCodeBlock';

import selectionSortJs from '../setup/src/selection-sort.js';
import selectionSortTs from '../setup/src/selection-sort.ts';

选择排序是一种排序算法，非常适用于小型数组或已经基本排序的数组。

它的时间复杂度为 O(n<sup>2</sup>)，这意味着不建议使用它来对大型数组进行排序。它通常不用于实践中。

## 澄清问题

如果未指定：

* 数据应该按升序还是降序排序？
* 数据应该就地排序还是可以使用其他数据结构？
* 我们需要处理什么样的输入？
  * 它只是一个整数数组，还是我们应该处理其他数据类型？
  * 是否存在大量重复元素？
  * 应该如何处理负数？

## 解决方案

注意：此问题处理的是按升序输出的排序。请参阅下面的“注释”部分，了解如何处理其他情况。

<MDXCodeBlock languages={{ jsx: selectionSortJs, tsx: selectionSortTs }} />

## 边缘情况

* 非整数元素输入：如果输入数组包含不同数据类型的元素，您可能需要返回一个错误，尝试进行最佳排序，例如，仅对输入数据的子集进行排序，甚至为非整数定义自定义比较函数。
* 单个元素/空输入：返回原始数据结构、引发错误或澄清所需处理。
* 已经排序的输入：您可能需要检测排序并原样返回输入。
* 重复元素：特别是如果数组有大量重复元素，您可能需要进一步优化您的实现以避免不必要的比较。
* 无效输入：如果输入不是数组，请考虑抛出错误。

## 笔记

* 如果要求按降序排序，请更改比较以找到 `maxIndex` 而不是 `minIndex`，方法是在相关比较中使用 `>=` 而不是 `<`，如下所示：

```js
if (arr[j] >= arr[maxIndex]) {
  maxIndex = j;
}
```

* 如果要求使用其他数据结构或编写纯函数而不是就地排序数据，请使用扩展运算符在应用排序之前创建一个新数组。

## Big-O 分析

让我们分析一下算法的时间和空间复杂度。

### 时间复杂度

选择排序的时间复杂度为 O(n<sup>2</sup>) - 在所有情况下都相同。这可以通过观察循环次数来推导。有 2 个循环，因此复杂度为 O(n<sup>2</sup>)。

### 空间复杂度

选择排序的空间复杂度为 O(1)，当它在原位执行时，因为它只需要常量大小的额外空间来存储变量。

但是，如果排序算法不是在原位执行的，那么空间复杂度将是 O(n)，因为需要额外的内存来存储已排序的元素。
