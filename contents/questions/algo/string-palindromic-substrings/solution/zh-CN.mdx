import MDXCodeBlock from 'MDXCodeBlock';

import palindromicSubstrings from '../setup/src/string-palindromic-substrings.ts';
import palindromicSubstringsUsingDP from '../setup/src/string-palindromic-substrings-dp.ts';
import palindromicSubstringsUsingBruteForce from '../setup/src/string-palindromic-substrings-bruteforce.ts';

## 1. 使用暴力方法

暴力方法会检查每个可能的子串，以确定它是否是回文。这是通过遍历所有可能的子串的起始和结束索引，并使用辅助函数来验证子串是否是回文来实现的。如果子串正向和反向读取相同，则该子串是回文。

### 算法

1. 定义一个辅助函数 `isPalindrome`：
   * 接受字符串 `str`、起始索引 `low` 和结束索引 `high`。
   * 使用 `while` 循环比较 `low` 和 `high` 处的字符。
   * 如果字符不匹配，则返回 `false`。
   * 递增 `low` 并递减 `high` 以向中心移动。
   * 如果所有字符都匹配，则返回 `true`。
2. 初始化一个变量 `ans` 来存储回文子串的计数。
3. 使用嵌套循环：
   * 外循环遍历子串的所有可能的起始索引 `low`。
   * 内循环遍历当前起始索引的所有可能的结束索引 `high`。
   * 对于每一对索引，使用 `isPalindrome` 函数检查子串是否是回文。
   * 如果子串是回文，则将 `ans` 增加 `1`。
4. 将 `ans` 的值作为回文子串的总数返回。

<MDXCodeBlock>
  {palindromicSubstringsUsingBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>3</sup>)**。有 O(n<sup>2</sup>) 个子串，并且检查每个子串是否为回文需要 O(n) 时间。
* **空间复杂度：O(1)**。除了输入字符串和循环变量外，该算法使用恒定空间。

## 2. 使用动态规划

动态规划方法通过避免重复检查重叠的子串来改进朴素的暴力方法。关键的直觉是，如果一个子串的两个最外面的字符相同，并且内部子串（不包括外部字符）也是回文，则该子串是回文。使用动态规划表可以有效地捕获此递归属性。

`dp` 表存储了以索引 `i` 开头并以索引 `j` 结尾的子串是否是回文。这通过从较小的子串开始并使用它们的结果来求解较大的子串，从而消除了冗余的重新计算。

### 算法

1. 通过返回 `0` 来处理空字符串的基本情况。
2. 初始化一个大小为 `n x n` 的二维数组 `dp`，并将所有值设置为 `false`。
3. 遍历长度为 `1` 的子串的字符串：
   * 对于所有索引 `i`，将 `dp[i][i]` 设置为 `true`，因为单字符子串始终是回文。
   * 增加每个单字符回文的计数 `ans`。
4. 遍历长度为 `2` 的子串的字符串：
   * 如果索引 `i` 和 `i + 1` 处的两个字符相等，则将 `dp[i][i + 1]` 设置为 `true`。
   * 增加每个双字符回文的计数 `ans`。
5. 使用嵌套循环来评估长度为 `3` 或更大的子串：
   * 对于以索引 `i` 开头并以索引 `j` 结尾的每个子串，如果满足以下条件，则将 `dp[i][j]` 设置为 `true`：
     * `i` 和 `j` 处的字符相同。
     * `i` 和 `j` 之间的子串 (`dp[i + 1][j - 1]`) 也是回文。
   * 增加找到的每个回文的计数 `ans`。
6. 将 `ans` 作为回文子串的总数返回。

<MDXCodeBlock>
  {palindromicSubstringsUsingDP}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。外循环遍历子串长度，内循环遍历子串的所有起始索引。
* **空间复杂度：O(n<sup>2</sup>)**。`dp` 表需要 O(n<sup>2</sup>) 空间来存储所有子串的结果。

## 3. 使用回文的中心

从中心扩展方法通过关注回文的潜在中心来优化查找所有回文子串的过程。关键的直觉是，每个回文都可以从其中心向外扩展。中心可以是单个字符（对于奇数长度的回文）或一对连续字符（对于偶数长度的回文）。通过从每个中心迭代地扩展，这种方法避免了冗余计算，并且不需要使用额外的空间来存储动态规划表。

此方法通过减少空间使用来改进先前动态规划方法。它没有预先计算所有可能长度的回文子串，而是在扩展过程中直接计算回文。

### 算法

1. 初始化一个变量 `ans` 来存储回文子串的总数。
2. 遍历字符串中的每个字符：
   * 将当前索引处的字符视为奇数长度回文的中心，并使用相同的起始和结束索引调用辅助函数 `countPalindromesAroundCenter`。
   * 将当前字符和下一个字符视为偶数长度回文的中心，并使用连续索引作为起始和结束点调用辅助函数 `countPalindromesAroundCenter`。
3. 将 `ans` 作为回文子串的总数返回。

#### 辅助函数：`countPalindromesAroundCenter`

1. 接受字符串`str`、起始索引`low`和结束索引`high`作为输入。
2. 初始化一个变量`ans`，用于存储扩展过程中找到的回文串的计数。
3. 使用`while`循环向外扩展，只要：
   * 索引`low`和`high`在字符串的范围内。
   * `low`和`high`处的字符匹配。
4. 对于每个有效回文串，递增`ans`。
5. 递减`low`并递增`high`以继续扩展。
6. 返回计数`ans`。

<MDXCodeBlock> {palindromicSubstrings} </MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。对于每个字符，扩展在最坏的情况下可以跨越整个字符串，导致O(n)个中心有O(n)次扩展。
* **空间复杂度：O(1)**。该算法使用常量额外空间用于变量，不需要额外的数据结构。
