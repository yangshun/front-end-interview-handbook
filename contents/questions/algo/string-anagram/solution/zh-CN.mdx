import MDXCodeBlock from 'MDXCodeBlock';

import isStringAnagram from '../setup/src/string-anagram.ts';
import isStringAnagramUsingFrequency from '../setup/src/string-anagram-frequency-check.ts';

## 1. 使用排序

问题是确定两个字符串是否互为字谜。如果两个字符串包含相同字符，且每个字符的出现频率也相同，但顺序可以不同，则它们互为字谜。这种方法的核心在于，对两个字符串进行排序后，如果它们是字谜，则会按照相同的顺序重新排列字符。排序后，简单地比较两个已排序的数组就可以确定这些字符串是否互为字谜。

排序提供了一种直接的方式来对齐两个字符串中的字符，从而便于检查是否相等。

### 算法

1. 检查 `str1` 和 `str2` 的长度是否不同。如果不同，则返回 `false`，因为长度不同的字符串不可能互为字谜。
2. 使用 `split` 方法将 `str1` 和 `str2` 分割成字符数组。
3. 使用 `sort` 方法对字符数组进行排序。
4. 遍历已排序的数组，并比较每个索引处的字符。
   * 如果两个数组中的任何字符不匹配，则返回 `false`。
5. 如果所有字符都匹配，则返回 `true`。

<MDXCodeBlock>
  {isStringAnagram}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。对字符数组进行排序是最昂贵的操作，并且在运行时占据主导地位。
* **空间复杂度：O(n)**。需要空间来存储从输入字符串创建的字符数组。

## 2. 使用频率计数

此解决方案通过使用频率计数方法来优化字谜检查过程。该解决方案没有对字符串进行排序（需要 O(n log n) 时间），而是使用固定大小的数组（对于英文字母，大小为 26）来计算字符的出现次数。对于每个字符串，都会更新频率表：一个字符串递增，另一个字符串递减。如果最后所有字符的计数都为零，则这些字符串互为字谜。

这种方法避免了不必要的排序，并直接针对前一个解决方案中的排序瓶颈，从而将时间复杂度从 O(n log n) 降低到 O(n)。

### 算法

1. 检查两个字符串的长度是否不同。
   * 如果不同，则返回 `false`，因为这些字符串不可能互为字谜。
2. 初始化一个大小为 26 的数组，并将所有元素设置为 0，以充当频率表。
3. 遍历第一个字符串。
   * 对于每个字符，递增其在频率表中的相应位置。
4. 遍历第二个字符串。
   * 对于每个字符，递减其在频率表中的相应位置。
   * 如果表中任何计数变为负数，则返回 `false`。
5. 在两次迭代之后，如果没有计数为负数，则返回 `true`，因为这些字符串互为字谜。

<MDXCodeBlock>
  {isStringAnagramUsingFrequency}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。该解决方案恰好遍历两个字符串一次。
* **空间复杂度：O(1)**。频率表的大小是固定的（26），与输入大小无关。
