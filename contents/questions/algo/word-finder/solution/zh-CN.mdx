import MDXCodeBlock from 'MDXCodeBlock';

import designAddAndSearchWordsDataStructure from '../setup/src/word-finder.ts';

## 1. 使用Trie

使用Trie（前缀树）构建`WordFinder`，以高效地存储和搜索单词。`TrieNode`结构由一个`Map`组成，用于存储子节点，以及一个布尔标志，指示该节点是否代表单词的结尾。这种设计对于解决涉及使用`.`进行精确匹配或通配符模式的单词搜索问题特别有效。

主要思想是逐个节点地将单词添加到Trie中，其中每个字符代表Trie中的一个路径。搜索是递归完成的，对`.`字符进行特殊处理，它充当通配符。`.`可以匹配任何字符，并递归地探索所有可能的子节点以找到匹配项。

### 算法

1. **添加单词**:

   * 从根节点开始。
   * 对于单词中的每个字符，检查它是否存在于当前节点的`children`映射中。
   * 如果不存在，创建一个新的`TrieNode`并将其添加到映射中。
   * 移动到下一个节点并重复，直到完全添加单词。
   * 通过将`word`标志设置为`true`，将最终节点标记为单词的结尾。

2. **搜索**:
   * 使用辅助函数`searchInNode`递归遍历Trie。
   * 对于每个字符:
     * 如果它存在于当前节点的`children`中，则移动到子节点。
     * 如果字符是`.`，则迭代所有子节点并递归搜索剩余的子字符串。
     * 如果字符不存在且不是`.`，则返回`false`。
   * 在单词的末尾，如果当前节点标记单词的结尾，则返回`true`。

<MDXCodeBlock>
  {designAddAndSearchWordsDataStructure}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度**: O(m)，对于没有点的明确定义的单词，其中`m`是单词的长度。对于“未定义”的单词，时间复杂度为O(n.26<sup>m</sup>)，其中n是键的数量，m是未定义单词的长度。这表示搜索未定义单词的最坏情况，其中包含m个递归调用，因为该单词比所有插入的键长一个字符。
* **空间复杂度**: O(1) 用于搜索没有点的“定义明确”的单词。对于“未定义”的单词，空间复杂度可以增加到O(m)以适应递归堆栈。
