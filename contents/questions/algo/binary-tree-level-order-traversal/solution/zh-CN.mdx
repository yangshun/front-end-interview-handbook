import MDXCodeBlock from 'MDXCodeBlock';

import binaryTreeLevelOrderTraversal from '../setup/src/binary-tree-level-order-traversal.ts';
import binaryTreeLevelOrderTraversalIteration from '../setup/src/binary-tree-level-order-traversal-iteration.ts';

## 1. 使用递归

递归方法通过其深度级别对二叉树中的节点进行分组。每个级别都表示为一个数组，并且将同一深度的所有节点存储在一起。遍历从根节点开始，逐级进行，确保保留树的层次结构。每当到达一个新级别时，都会初始化一个新组以容纳该深度处的节点。这确保了节点被有效地分组，从而保持了树的级别之间的清晰区分。

### 算法

1. 从根节点开始遍历树，跟踪当前的深度级别。
2. 对于第一次遇到的每个级别，初始化一个新组来存储节点值。
3. 将每个节点的值添加到其对应的组中，具体取决于其深度级别。
4. 递归处理左子节点和右子节点，在遍历深入树时增加级别。
5. 继续，直到所有节点都被处理并按级别分组。

<MDXCodeBlock>
  {binaryTreeLevelOrderTraversal}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。树中的每个节点只访问一次。
* **空间复杂度：O(h)**。递归堆栈使用的空间与树的高度 `h` 成正比，并且使用额外的空间来存储级别组。

## 2. 使用迭代

迭代方法使用队列通过其深度级别对二叉树中的节点进行分组。遍历从根节点开始，并分别处理每个级别。在每个级别，所有节点都会出队，它们的值存储在对应于当前级别的组中，并且它们的子节点会排队等待下一次迭代。这确保了在移动到下一级别之前，同一深度的所有节点都被一起处理。该方法以广度优先的方式有效地处理所有节点，从而保持了树的层次结构。

### 算法

1. 使用根节点初始化一个队列以迭代处理级别。
2. 使用循环逐级处理节点，直到队列为空。
3. 在每个级别，跟踪要处理的节点数，并初始化一个新组以存储它们的值。
4. 移除当前级别的每个节点，将其值添加到组中，并将其左子节点和右子节点排队（如果存在）。
5. 将值组附加到结果中，然后继续到下一级别。
6. 继续，直到所有节点都被处理并按深度分组。

<MDXCodeBlock>
  {binaryTreeLevelOrderTraversalIteration}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个节点只访问一次。
* **空间复杂度：O(m)**。队列保存当前级别的节点，其中 `m` 是任何级别上的最大节点数（等于树的宽度）。
