import MDXCodeBlock from 'MDXCodeBlock';

import findMissingNumberInSequence from '../setup/src/array-find-missing-number-in-sequence.ts';
import findMissingNumberInSequenceSorting from '../setup/src/array-find-missing-number-in-sequence-sorting.ts';
import findMissingNumberInSequenceBruteForce from '../setup/src/array-find-missing-number-in-sequence-brute-force.ts';

## 1. 暴力解法

该问题需要从 0 到 `n` 的序列中识别缺失的数字。暴力解法遍历期望的数字范围，并检查数组中是否存在每个数字。对于每个数字，将对数组进行另一次迭代以检查其是否存在。这种方法涉及嵌套循环，导致时间复杂度为 O(n<sup>2</sup>)。这种方法虽然简单，但由于重复检查，对于较大的数组效率低下。

### 算法

1. 计算期望的范围数 `n`。
2. 遍历从 0 到 `n` 的数字范围：
   * 对于每个数字，遍历数组以检查当前数字是否存在。
   * 如果找到该数字，停止搜索并移至下一个数字。
   * 如果未找到该数字，则将其作为缺失数字返回。
3. 如果未找到缺失数字，则返回 -1。

<MDXCodeBlock>
  {findMissingNumberInSequenceBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。对于范围 0 到 `n` 中的每个数字，都会对数组进行完全遍历以检查其是否存在。
* **空间复杂度：O(1)**。除了用于存储中间结果的几个变量外，没有使用额外的空间。

## 2. 使用排序

为了消除暴力解法中的冗余检查，这种优化方法对输入数组进行排序，通过确保数字按升序排列，从而更容易识别序列中缺失的数字。排序后，该解决方案检查边界情况（序列中第一个或最后一个数字是否缺失）。如果未检测到边界情况，则该解决方案遍历排序后的数组以检查每个索引处是否存在期望值。

### 算法

1. 按升序对输入数组进行排序。
2. 检查最后一个数字是否等于数组长度：
   * 如果不是，则返回数组长度作为缺失数字。
3. 检查第一个数字是否为 0：
   * 如果不是，则返回 0 作为缺失数字。
4. 遍历排序后的数组：
   * 对于每个数字，将期望的下一个数字计算为当前数字加一。
   * 如果下一个数字与期望值不匹配，则返回期望值作为缺失数字。
5. 如果未找到缺失数字，则返回 -1，这在使用有效输入时不会发生。

<MDXCodeBlock>
  {findMissingNumberInSequenceSorting}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。对数组进行排序占据了运行时的大部分时间，需要 O(n log n) 时间。随后对数组的迭代是 O(n)。
* **空间复杂度：O(1)**。排序是就地执行的，除了几个变量外，没有使用额外的空间。

## 3. 使用数学性质计算从 0 到 n 的数字之和

排序可能是不必要的，因为可以通过使用从 0 到 `n` 的整数之和的数学性质来确定缺失的数字。数学性质消除了迭代和比较元素的需要。相反，它计算总的期望和，并减去实际和以找到缺失的数字。这种优化消除了排序的瓶颈，并将总的时间复杂度降低到 O(n)。

### 算法

1. 将 `expectedSum` 初始化为 0。这将保存从 0 到 `n` 的所有整数的和。
2. 使用循环计算从 0 到 `n` 的整数的总期望和，并将结果存储在 `expectedSum` 中。
3. 将 `actualSum` 初始化为 0。这将保存给定数组中元素的总和。
4. 遍历数组并计算所有元素的总和，将其存储在 `actualSum` 中。
5. 从 `expectedSum` 中减去 `actualSum` 以确定缺失的数字。
6. 返回结果。

<MDXCodeBlock>
  {findMissingNumberInSequence}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。计算期望和并遍历数组都需要 O(n) 时间。
* **空间复杂度：O(1)**。该解决方案使用常量数量的变量空间。
