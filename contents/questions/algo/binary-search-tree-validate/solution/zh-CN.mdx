import MDXCodeBlock from 'MDXCodeBlock';

import binarySearchTreeValidate from '../setup/src/binary-search-tree-validate.ts';
import binarySearchTreeValidateIteration from '../setup/src/binary-search-tree-validate-iteration.ts';

## 1. 使用递归

验证二叉搜索树（BST）的问题确保了对于每个节点，左子树中所有节点的值都较小，而右子树中所有节点的值都较大。这种递归方法利用范围检查来验证 BST 属性。

对于每个节点，都会维护一个范围：

* 节点的值必须位于其祖先定义的范围内。
* 对于左子节点，范围更新为 `[minAllowed, node.val)`。
* 对于右子节点，范围更新为 `(node.val, maxAllowed]`。

该算法递归地检查每个节点，确保它位于其允许的范围内。如果任何节点违反范围约束，则该树不是有效的 BST。

该算法正好遍历每个节点一次，并通过递归调用传播范围约束来确保正确性。

### 算法

1. 定义一个辅助函数 `checkNodeInRange`，它：
   * 接受 `node`、`minAllowed` 和 `maxAllowed` 作为参数。
   * 如果节点及其子树满足 BST 属性，则返回 `true`。
2. 对于每个节点：
   1. 如果 `node` 为 `null`，则返回 `true`（递归的基本情况）。
   2. 检查 `node.val` 是否在 `minAllowed` 和 `maxAllowed` 定义的范围之外。如果为真，则返回 `false`。
   3. 递归地使用范围 `[minAllowed, node.val)` 验证左子树。
   4. 递归地使用范围 `(node.val, maxAllowed]` 验证右子树。
   5. 仅当左右子树都有效时才返回 `true`。
3. 从根节点开始验证，范围为 `[-Infinity, Infinity]`。
4. 返回辅助函数的结果。

<MDXCodeBlock>
  {binarySearchTreeValidate}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个节点只访问一次。
* **空间复杂度：O(h)**。递归堆栈需要的空间与树的高度成正比，其中 `h` 是 BST 的高度。

## 2. 使用迭代

用于验证二叉搜索树（BST）的迭代方法确保所有节点都符合 BST 属性：左子树中的所有值都小于根，右子树中的所有值都大于根。此解决方案使用堆栈来管理节点及其在遍历期间对应的有效值范围。

每个节点都与一个范围（`low` 和 `high`）相关联，该范围表示基于其祖先的允许值。

* 对于左子节点，范围更新为 `[low, node.val)`。
* 对于右子节点，范围更新为 `(node.val, high]`。

堆栈用于维护尚未验证的节点及其有效范围。迭代过程避免了递归，并确保所有节点都按照 BST 规则进行验证。

对于每个节点，将其值与其分配的范围进行比较。如果该值违反了范围约束，则该树无效。

该算法正好处理每个节点一次，并使用堆栈来管理遍历，使其具有时间和空间效率。

### 算法

1. 初始化三个栈：
   * `stack` 用于存储节点。
   * `lowerLimits` 用于存储每个节点的下限范围。
   * `upperLimits` 用于存储每个节点的上限范围。
2. 定义一个辅助函数 `update`，该函数将：
   * 将一个节点及其更新后的范围 (`low`, `high`) 推入各自的栈中。
3. 将根节点推入栈中，初始限制为 `null`（无约束）。
4. 当 `stack` 不为空时：
   1. 弹出顶部节点及其对应的范围 (`low`, `high`)。
   2. 如果节点为 `null`，则跳过。
   3. 验证节点的值：
      * 检查该值是否小于或等于 `low` 或大于或等于 `high`。
      * 如果违反任何条件，则返回 `false`。
   4. 将右子节点推入栈中，更新限制为 `[node.val, high]`。
   5. 将左子节点推入栈中，更新限制为 `[low, node.val]`。
5. 如果未发现违规行为，则返回 `true`。

<MDXCodeBlock> {binarySearchTreeValidateIteration} </MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个节点只处理一次。
* **空间复杂度：O(h)**。栈最多同时容纳 `h` 个节点，其中 `h` 是树的高度。
