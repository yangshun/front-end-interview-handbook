import MDXCodeBlock from 'MDXCodeBlock';

import meetingCalendar from '../setup/src/intervals-meeting-calendar.ts';
import meetingCalendarBruteForce from '../setup/src/intervals-meeting-calendar-bruteforce.ts';

## 1. 暴力方法

朴素的方法是通过验证一组间隔是否可以通过检查没有两个间隔重叠来形成有效的会议日历。 关键思想是遍历所有间隔对并比较它们的开始和结束时间。 对于每一对，重叠是通过检查一个间隔是否在另一个间隔结束之前开始以及反之亦然来确定的。 如果检测到任何重叠，则日历被认为无效。

### 算法

1. 定义一个辅助函数 `overlap`，它将两个间隔作为输入，并通过比较它们的开始和结束时间来检查它们是否重叠。
2. 使用嵌套循环遍历所有间隔对：
   1. 对于每一对间隔，调用 `overlap` 函数。
   2. 如果函数返回 `true`，则立即返回 `false`，因为这些间隔无效。
3. 如果在所有比较之后未找到重叠的间隔，则返回 `true`。

<MDXCodeBlock>
  {meetingCalendarBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。 该算法遍历所有间隔对，导致 n(n - 1)/2 次比较，即 O(n<sup>2</sup>)。
* **空间复杂度：O(1)**。 该算法使用恒定空间，因为它不需要任何额外的数据结构。

## 2. 使用排序

这种方法依赖于按其开始时间对间隔进行排序，以保证重叠的间隔彼此相邻出现。 排序确保间隔按其开始时间按时间顺序排列。 如果两个间隔重叠，则较早间隔的结束时间将延伸到下一个间隔的开始时间范围内。 通过按其开始时间的升序排列间隔，只需将每个间隔与排序列表中的下一个间隔进行比较即可检测重叠。

此方法消除了蛮力方法中存在的不必要的比较。 无需比较每对间隔，只需检查排序顺序中相邻的间隔，因为在排序后，任何重叠的间隔都保证是连续的。

### 算法

1. 使用 `sort` 方法按其开始时间按升序对间隔进行排序。
2. 遍历排序后的间隔：
   1. 对于每个间隔，检查其结束时间是否大于下一个间隔的开始时间。
   2. 如果检测到重叠，则返回 `false`，因为日历无效。
3. 如果循环在未检测到任何重叠的情况下完成，则返回 `true`。

<MDXCodeBlock>
  {meetingCalendar}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。 排序间隔占据了运行时，需要 O(n log n)，而线性扫描间隔需要 O(n)，总共得到 O(n log n)。
* **空间复杂度：O(1)**。 该算法使用恒定空间，因为它就地修改间隔数组，并且不需要额外的数据结构。
