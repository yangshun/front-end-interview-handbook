import MDXCodeBlock from 'MDXCodeBlock';

import matrixZeroing from '../setup/src/matrix-zeroing.ts';
import matrixZeroingUsingExtraSpace from '../setup/src/matrix-zeroing-extra-space.ts';

## 1. 使用额外空间

该问题需要修改矩阵，使得如果任何单元格包含 `0`，则同一行和列中的所有单元格都设置为 `0`。此解决方案使用额外的集合来跟踪需要清零的行和列。

该方法涉及对矩阵进行两次遍历：

1. 在第一次遍历中，识别包含至少一个 `0` 的所有行和列，并将它们存储在单独的集合中。这避免了立即修改矩阵，这可能会干扰后续检查。
2. 在第二次遍历中，根据存储在集合中的信息，通过将已识别的行和列中的所有单元格设置为 `0` 来更新矩阵。

这种识别和修改的分离确保了正确性，并避免了过早地将可能影响后续计算的元素清零。

### 算法

1. 初始化两个集合：
   * `rows` 用于跟踪包含至少一个 `0` 的行索引。
   * `cols` 用于跟踪包含至少一个 `0` 的列索引。
2. 对矩阵进行第一次遍历：
   * 对于每个单元格 `(i, j)`，如果单元格包含 `0`，则将 `i` 添加到 `rows`，将 `j` 添加到 `cols`。
3. 对矩阵进行第二次遍历：
   * 对于每个单元格 `(i, j)`，检查 `i` 是否在 `rows` 中或 `j` 是否在 `cols` 中。
   * 如果任一条件为真，则将 `matrix[i][j]` 设置为 `0`。
4. 现在，矩阵已更新，所有相关的行和列都已清零。

<MDXCodeBlock>
  {matrixZeroingUsingExtraSpace}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n)**。该算法涉及对矩阵进行两次遍历，每次访问所有 `m.n` 个元素。
* **空间复杂度：O(m + n)**。额外的集合 `rows` 和 `cols` 最多存储 `m` 个行索引和 `n` 个列索引。

## 2. 空间高效的解决方案

该任务需要修改矩阵，使得如果任何单元格包含 `0`，则同一行和列中的所有单元格都设置为 `0`。此解决方案通过使用矩阵的第一行和第一列作为标记而不是分配额外的空间，以空间高效的方式实现了目标。

该方法涉及三个主要步骤：

1. 遍历矩阵并使用第一行和第一列来标记需要清零的行和列。使用一个单独的标志来确定是否需要将第一列清零。
2. 再次遍历矩阵，排除第一行和第一列，并根据标记更新元素。
3. 如果需要，根据标记和单独的标志更新第一行和第一列。

此方法确保不需要输入矩阵之外的额外空间，使其具有空间效率。

### 算法

1. 将标志 `isCol` 初始化为 `false`，以跟踪是否需要将第一列清零。
2. 对矩阵进行第一次遍历：
   * 对于每个单元格 `(i, j)`：
     * 如果单元格在第一列中并包含 `0`，则将 `isCol` 设置为 `true`。
     * 如果单元格不在第一列中并包含 `0`，则将相应的第一个行和第一个列标记设置为 `0`。
3. 对矩阵进行第二次遍历：
   * 对于每个单元格 `(i, j)`，其中 `i > 0` 且 `j > 0`：
     * 如果第一行或第一列中的相应标记为 `0`，则将 `matrix[i][j]` 设置为 `0`。
4. 如果矩阵的第一个单元格 (`matrix[0][0]`) 为 `0`，则将整个第一行设置为 `0`。
5. 如果 `isCol` 为 `true`，则将整个第一列设置为 `0`。

<MDXCodeBlock>
  {matrixZeroing}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n)**。该算法涉及对矩阵进行两次遍历，每次访问所有 `m.n` 个元素。
* **空间复杂度：O(1)**。除了输入矩阵和单个标志外，没有使用额外的空间。
