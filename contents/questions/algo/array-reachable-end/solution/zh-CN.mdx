import MDXCodeBlock from 'MDXCodeBlock';

import arrayReachableEnd from '../setup/src/array-reachable-end.ts';
import arrayReachableEndTopDown from '../setup/src/array-reachable-end-top-down.ts';
import arrayReachableEndBottomUp from '../setup/src/array-reachable-end-bottom-up.ts';

## 1. 自底向上动态规划

一个朴素的解决方案将涉及递归地探索从第一个位置开始的所有可能路径，以检查是否可以到达最后一个位置。这种方法存在冗余计算和指数时间复杂度的缺点，因为它多次探索重叠的子问题。

自底向上动态规划方法通过从倒数第二个位置迭代到第一个位置来优化这一点，同时维护一个 `memo` 数组，该数组记录每个位置是 `GOOD`、`BAD` 还是 `UNKNOWN`。如果一个位置可以到达最后一个位置或已经标记为 `GOOD` 的位置，则该位置为 `GOOD`。优化通过使用 `memo` 数组中先前计算的结果来消除冗余检查。

### 算法

1. 定义一个枚举 `Index`，其状态为 `GOOD`、`BAD` 和 `UNKNOWN`，以表示每个索引的状态。
2. 初始化一个与输入数组长度相同的 `memo` 数组，所有值都设置为 `Index.UNKNOWN`。
3. 将 `memo` 数组中的最后一个位置设置为 `Index.GOOD`，因为最后一个位置可以很容易地到达它自己。
4. 从倒数第二个位置到第一个位置向后遍历输入数组：
   * 使用 `i + numbers[i]` 和最后一个索引的最小值来计算从当前索引可以到达的最远位置。
   * 检查当前索引和最远可到达位置之间的所有位置：
     * 如果这些位置中的任何一个在 `memo` 中被标记为 `Index.GOOD`，则将当前位置标记为 `Index.GOOD` 并中断内循环。
5. 如果第一个位置在 `memo` 中被标记为 `Index.GOOD`，则返回 `true`，表示可以到达最后一个位置。否则，返回 `false`。

<MDXCodeBlock>
  {arrayReachableEndBottomUp}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。对于每个位置，内循环检查最多 `numbers[i]` 个位置，导致最坏情况下的二次方复杂度。
* **空间复杂度：O(n)**。大小为 `n` 的 `memo` 数组用于动态规划存储。

## 2. 自顶向下动态规划

还有另一种自顶向下的动态规划方法，该方法从第一个位置开始，并使用递归来确定后续可到达的位置是否可以到达最后一个位置。备忘录数组确保重用先前计算的结果，避免了冗余计算并提高了效率。

### 算法

1. 初始化一个与输入数组长度相同的 `memo` 数组，所有值都设置为 `'UNKNOWN'`。
2. 将 `memo` 数组中的最后一个位置设置为 `'GOOD'`，因为它本身可以轻松到达。
3. 定义一个辅助函数 `canReachLastPosition`，它将当前位置和输入数组作为参数：
   * 如果当前位置已经在 `memo` 中标记，则返回相应的结果。
   * 如果当前位置的值为 `0`，则将其标记为 `'BAD'` 并返回 `false`，因为它无法继续前进。
   * 计算从当前位置可以到达的最远位置，即 `position + numbers[position]` 和最后一个索引的最小值。
   * 从当前位置向后遍历所有可到达的位置：
     * 如果任何可到达的位置是 `'GOOD'`，则将当前位置标记为 `'GOOD'` 并返回 `true`。
   * 如果没有任何可到达的位置是 `'GOOD'`，则将当前位置标记为 `'BAD'` 并返回 `false`。
4. 使用辅助函数从第一个位置开始递归。
5. 如果第一个位置是 `'GOOD'`，则返回 `true`，表示可以到达最后一个位置。否则，返回 `false`。

<MDXCodeBlock>
  {arrayReachableEndTopDown}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。最坏的情况涉及检查每个索引的所有可到达位置，导致二次方复杂度。
* **空间复杂度：O(n)**。大小为 `n` 的 `memo` 数组用于存储中间结果，并且递归堆栈可能达到 `n` 次调用。

## 3. 贪心算法

在贪心算法中，算法从最后一个位置开始并向后迭代。对于每个位置，它检查当前位置是否可以到达最远的可到达位置。如果可以，则将最远的可到达位置更新为当前位置。如果在处理完整个数组后，最远的可到达位置变为第一个索引，则表示可以到达最后一个位置。

### 算法

1. 将变量 `farthestReachable` 初始化为数组的最后一个索引 (`numbers.length - 1`)。
2. 从最后一个索引开始向后遍历数组：
   * 对于每个位置，检查 `currentPosition + numbers[currentPosition]` 是否大于或等于 `farthestReachable`。
   * 如果为真，则将 `farthestReachable` 更新为 `currentPosition`。
3. 迭代后，检查 `farthestReachable` 是否等于 `0`：
   * 如果 `farthestReachable` 为 `0`，则返回 `true`，表示可以从第一个位置到达最后一个位置。
   * 否则，返回 `false`。

<MDXCodeBlock>
  {arrayReachableEnd}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。该算法以相反的顺序遍历数组一次。
* **空间复杂度：O(1)**。除了常量数量的变量外，没有使用额外的空间。
