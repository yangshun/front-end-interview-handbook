import MDXCodeBlock from 'MDXCodeBlock';

import optimalStockTrading from '../setup/src/optimal-stock-trading.ts';
import optimalStockTradingBruteForce from '../setup/src/optimal-stock-trading-brute-force.ts';

## 1. 暴力破解方法

此解决方案使用暴力破解方法计算通过在不同日期买卖股票可以获得的最大利润。 想法是评估所有可能的日期对，并计算每对的利润。 最大利润通过比较所有计算出的利润来确定。

对于每一天，该算法假设它是买入日，并遍历所有后续日期以检查可能的卖出日。 每对的利润计算为卖出价和买入价之间的差额。 在这些比较期间遇到的最大利润被存储并作为结果返回。

### 算法

1. 将变量 `maxProfit` 初始化为 `0`，以存储遇到的最大利润。
2. 使用嵌套循环遍历所有可能的日期对：
   1. 外循环代表买入日 (`i`)，从第一天迭代到倒数第二天。
   2. 内循环代表卖出日 (`j`)，从 `i` 之后的一天迭代到最后一天。
3. 对于每一对日期：
   1. 计算利润，即卖出日 (`prices[j]`) 的价格与买入日 (`prices[i]`) 的价格之差。
   2. 如果计算出的利润大于 `maxProfit`，则使用新的利润值更新 `maxProfit`。
4. 在所有迭代之后，返回 `maxProfit` 作为可以实现的最大利润。

<MDXCodeBlock>
  {optimalStockTradingBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。嵌套循环遍历所有日对，导致二次方时间复杂度。
* **空间复杂度：O(1)**。没有使用额外的数据结构；仅需要几个变量进行计算。

## 2. 贪心方法

此解决方案使用贪心方法计算通过在不同日期买卖股票可以获得的最大利润。 该算法侧重于通过跟踪到目前为止遇到的最低价格并在迭代过程中动态计算利润来最大限度地减少不必要的计算。

关键思想是维护两个变量：

1. `lowestPrice`，它跟踪到目前为止在数组中遇到的最低价格。
2. `maxProfit`，它跟踪基于当前的 `lowestPrice` 和当前价格可能获得的最大利润。

对于数组中的每个价格，如果当前价格较低，则算法会更新 `lowestPrice`。 然后，它通过从当前价格中减去 `lowestPrice` 来计算潜在利润，如果计算出的利润更大，则更新 `maxProfit`。 与暴力破解方法相比，这种方法消除了比较所有价格对的需要，从而显着降低了时间复杂度。

### 算法

1. 将 `maxProfit` 初始化为 `0`，以存储遇到的最大利润。
2. 将 `lowestPrice` 初始化为一个非常大的值 (`Number.MAX_SAFE_INTEGER`)，以跟踪到目前为止遇到的最小价格。
3. 遍历 `prices` 数组中的每个价格：
   1. 使用 `lowestPrice` 和当前价格中较小的值更新 `lowestPrice`。
   2. 计算潜在利润，即当前价格与 `lowestPrice` 之间的差额。
   3. 使用 `maxProfit` 和潜在利润中较大的值更新 `maxProfit`。
4. 完成迭代后，返回 `maxProfit` 作为可以实现的最大利润。

<MDXCodeBlock>
  {optimalStockTrading}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。该算法遍历价格列表一次，为每个价格以恒定时间更新 `lowestPrice` 并计算 `maxProfit`。
* **空间复杂度：O(1)**。仅使用两个变量 `lowestPrice` 和 `maxProfit` 来跟踪中间结果。
