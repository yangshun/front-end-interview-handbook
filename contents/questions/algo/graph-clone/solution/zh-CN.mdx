import MDXCodeBlock from 'MDXCodeBlock';

import graphClone from '../setup/src/graph-clone.ts';
import graphCloneBFS from '../setup/src/graph-clone-bfs.ts';

## 1. 使用 DFS

任务是创建一个图的深拷贝。一个图由节点组成，每个节点都有一个值和邻居列表。挑战在于确保新图中的每个节点都是一个完全独立的副本，并且节点之间的所有连接都得到准确复制。

其基本原理是基于对图的深度优先搜索（DFS）遍历。从一个节点开始，算法递归地访问其所有邻居，并在遇到未访问的节点时创建新的克隆节点。为了避免重复工作并确保节点不会被多次克隆，使用 `Map` 来存储原始节点与其克隆对应物之间的关系。这确保了当一个节点被重新访问（由于循环或共享邻居）时，算法会重用 `Map` 中的现有克隆，而不是创建一个新的克隆。

这种方法反映了图的自然连接方式，在处理每个节点及其连接时逐步构建克隆图。通过递归处理邻居并利用 `Map` 来提高效率，该解决方案避免了不必要的工作重复，并保证了克隆图结构的正确性。

### 算法

1. 检查输入节点是否为 `null`。如果是，则返回 `null`，因为没有要克隆的图。
2. 初始化一个 `Map` 来存储原始节点与其克隆对应物之间的映射。
3. 定义一个递归的 `dfs` 函数：
   * 如果当前节点已被访问，则从 `Map` 返回相应的克隆节点。
   * 创建一个具有当前节点的值和空邻居列表的新 `GraphNode`。
   * 将当前节点及其克隆添加到 `Map`。
   * 对于当前节点的每个邻居，使用 `dfs` 函数递归地克隆邻居，并将其添加到克隆节点的邻居列表中。
4. 通过在输入节点上调用 `dfs` 来启动克隆过程。
5. 返回克隆图的根节点。

<MDXCodeBlock>
  {graphClone}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(v + e)**。在 DFS 遍历期间，图中的每个节点 (`v`) 和边 (`e`) 都只被访问一次。
* **空间复杂度：O(v)**。`Map` 存储每个节点的映射，并且递归堆栈最多可以增长到图中节点的数量。

## 2. 使用 BFS

这种方法使用广度优先搜索（BFS）遍历来系统地访问所有节点并克隆它们。BFS 确保节点逐层访问，并且每个节点只处理一次。`Map` 用于存储原始节点与其克隆之间的关系。这可以防止冗余克隆并有效地处理图中的循环。随着遍历的进行，每个节点的邻居都会被克隆并添加到相应克隆的邻居列表中。这确保了克隆图保持与原始图相同的结构。

此方法通过逐层处理节点，在遇到节点及其连接时克隆它们，并通过使用 `Map` 来避免重复，从而直观地工作。

### 算法

1. 检查输入节点是否为 `null`。如果是，则返回 `null`，因为没有要克隆的图。
2. 初始化一个 `Map` 来存储原始节点与其克隆对应物之间的映射。
3. 创建一个队列并将输入节点添加到其中以进行 BFS 遍历。
4. 克隆输入节点并将其存储在 `Map` 中。
5. 当队列不为空时：
   * 从队列的前面删除一个节点。
   * 遍历当前节点的邻居。
     * 如果邻居尚未被克隆：
       * 克隆邻居并将其添加到 `Map`。
       * 将邻居添加到队列中以进行进一步处理。
     * 将邻居的克隆添加到当前节点的克隆的邻居列表中。
6. 从 `Map` 返回输入节点的克隆。

<MDXCodeBlock>
  {graphCloneBFS}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(v + e)**。在 BFS 遍历期间，图中的每个节点 (`v`) 和边 (`e`) 都只被访问一次。
* **空间复杂度：O(v)**。`Map` 存储每个节点的映射，并且队列在最坏的情况下最多包含 `v` 个节点。
