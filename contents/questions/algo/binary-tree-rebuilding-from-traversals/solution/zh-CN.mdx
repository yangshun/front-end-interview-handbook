import MDXCodeBlock from 'MDXCodeBlock';

import binaryTreeRebuildingFromTraversals from '../setup/src/binary-tree-rebuilding-from-traversals.ts';

## 1. 使用递归

目标是从其先序遍历和中序遍历重建二叉树。在先序遍历中，第一个元素始终是树的根。中序遍历根据根的位置将树分成其左子树和右子树。通过结合这两个遍历，可以识别根并递归地重建左子树和右子树。

为了优化此过程，创建一个映射来存储中序遍历中元素的索引，从而允许 O(1) 查找根在中序数组中的位置。使用此映射，该算法避免了在中序遍历中重复搜索元素，否则会导致更高的时间复杂度。

### 算法

1. 创建一个映射，用于存储中序数组中每个值的索引，以便快速查找。
2. 定义一个递归函数，用于在给定的中序数组范围内构造树。
3. 在递归函数中：
   * 选择先序数组中的当前元素作为根，并递增先序索引。
   * 使用中序映射来定位根在中序数组中的位置。
   * 使用中序数组中根左侧的元素递归地构建左子树。
   * 使用中序数组中根右侧的元素递归地构建右子树。
4. 在处理完先序数组中的所有元素后，返回构造的树。

<MDXCodeBlock>
  {binaryTreeRebuildingFromTraversals}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个节点只处理一次，并且该映射允许在中序数组中进行 O(1) 索引查找。
* **空间复杂度：O(n)**。空间用于递归堆栈和存储中序数组中元素索引的映射。
