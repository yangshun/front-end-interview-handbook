import MDXCodeBlock from 'MDXCodeBlock';

import countGridIslands from '../setup/src/grid-count-islands.ts';
import countGridIsLandsBFS from '../setup/src/grid-count-islands-bfs.ts';

## 1. 使用 DFS

该问题需要计算二维网格中岛屿的数量，其中每个单元格是陆地（`1`）或水域（`0`）。岛屿定义为水平或垂直连接的一组相邻陆地单元格。任务是计算网格中所有不同的岛屿。

该方法使用深度优先搜索（DFS）来遍历和标记岛屿的所有单元格，从陆地单元格开始。网格被就地修改，将已访问的单元格标记为水域（`0`），以避免重复访问它们。每次遇到未访问的陆地单元格时，它表示一个新的岛屿，并启动 DFS 以探索所有连接的陆地单元格。这确保了每个岛屿只被计算一次。

此方法消除了对已访问单元格的不必要检查，并通过直接修改网格来避免冗余处理。

### 算法

1. 从网格维度中检索行数和列数。
2. 初始化计数器 `numIslands` 为 `0`，以存储岛屿的总数。
3. 遍历网格中的每个单元格：
   * 如果单元格值为 `1`（陆地），则增加 `numIslands` 计数器。
   * 从当前单元格执行 DFS，以探索整个岛屿并将所有连接的陆地单元格标记为已访问，方法是将其值设置为 `0`。
4. 定义一个递归的 `dfs` 函数：
   * 将当前单元格标记为已访问，方法是将其值设置为 `0`。
   * 递归地检查并访问所有相邻单元格（上、下、左、右），如果它们在范围内且其值为 `1`。
5. 处理完网格中的所有单元格后，返回 `numIslands` 计数器。

<MDXCodeBlock>
  {countGridIslands}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n)**。网格中的每个单元格都会被访问一次，无论是在主迭代期间还是在 DFS 遍历期间。
* **空间复杂度：O(m.n)**。当网格包含一个大的连接岛屿时，递归堆栈可能会增长到网格的大小。

## 2. 使用 BFS

此方法使用广度优先搜索（BFS）来遍历网格。该方法从任何未访问的陆地单元格开始，这标志着一个新岛屿的开始。执行 BFS 遍历以访问所有连接的陆地单元格，将它们标记为已访问，方法是将其值设置为 `0`。这确保了每个岛屿只被计算一次。网格被就地修改，以节省用于跟踪已访问单元格的额外空间。

这种方法系统地探索每个岛屿，同时避免冗余检查，使其对大型网格高效。

### 算法

1. 从网格维度中检索行数和列数。
2. 初始化计数器 `numIslands` 为 `0`，以跟踪岛屿的数量。
3. 遍历网格中的每个单元格：
   * 如果单元格值为 `1`（陆地），则增加 `numIslands` 计数器。
   * 将单元格值设置为 `0` 以将其标记为已访问。
   * 初始化一个用于 BFS 遍历的队列，并将当前单元格添加到队列中。
4. 使用队列执行 BFS：
   * 从队列中出队一个单元格。
   * 对于它的每个邻居（上、下、左、右）：
     * 如果邻居在范围内且其值为 `1`，则将其入队并将其标记为已访问，方法是将其值设置为 `0`。
5. 处理完网格中的所有单元格后，返回 `numIslands` 计数器。

<MDXCodeBlock>
  {countGridIsLandsBFS}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n)**。网格中的每个单元格都会被访问一次，无论是在 BFS 遍历期间还是在主循环期间。
* **空间复杂度：O(min(m, n))**。在最坏的情况下，BFS 队列可以增长到较小维度的尺寸，例如当网格只有一行或一列陆地时。
