import MDXCodeBlock from 'MDXCodeBlock';

import maximumWaterBetweenWalls from '../setup/src/maximum-water-between-walls.ts';
import maximumWaterBetweenWallsBruteForce from '../setup/src/maximum-water-between-walls-brute-force.ts';

## 1. 暴力解法

暴力解法是找到两个墙之间可以截留的最大水量。 想法是评估输入数组中每对可能的墙，并计算它们之间可以容纳的水量。 容纳的水量由该对中较短的墙和两个墙之间的距离决定。

暴力解法确保考虑了所有墙对。 该算法使用嵌套循环遍历每对可能的墙，并计算每对墙的面积。 在此过程中找到的最大面积作为结果返回。

### 算法

1. 将变量 `maxArea` 初始化为 `0`，以跟踪找到的最大水域面积。
2. 使用嵌套循环遍历所有墙对：
   1. 外循环代表左墙，从第一堵墙迭代到倒数第二堵墙。
   2. 内循环代表右墙，从左墙之后的一堵墙迭代到最后一堵墙。
3. 对于每对墙，计算墙之间的宽度为 `right - left`。
4. 使用较短的墙通过调用 `Math.min(walls[left], walls[right])` 来确定容器的高度。
5. 通过将高度和宽度相乘来计算可以容纳的水域面积。
6. 使用当前 `maxArea` 和新计算的面积之间的较大值更新 `maxArea`。
7. 完成嵌套循环后，返回 `maxArea` 作为结果。

<MDXCodeBlock>
  {maximumWaterBetweenWallsBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。 嵌套循环遍历所有墙对，导致二次时间复杂度。
* **空间复杂度：O(1)**。 除了用于跟踪最大面积和计算值的一些变量外，没有使用额外的空间。

## 2. 使用双指针

此解决方案使用双指针技术来优化查找两个墙之间可以截留的最大水量的过程。 想法是使用两个指针，一个从最左边的墙开始，另一个从最右边的墙开始，并计算它们之间的面积。 面积由较短的墙决定，因为它限制了高度，以及两个墙之间的宽度。

与暴力解法一样，不是评估每对可能的墙，双指针技术通过移动指针消除了不必要的比较。 通过始终将较短墙的指针向内移动，该算法确保宽度减小，同时尝试找到可能增加面积的较高墙。 这种方法避免了不必要或重复的工作，将时间复杂度从 O(n<sup>2</sup>) 降低到 O(n)。

### 算法

1. 将两个指针初始化，`left` 在数组的开头，`right` 在数组的结尾。
2. 初始化一个变量 `maxWaterArea` 来存储找到的最大水域面积。
3. 使用 `while` 循环进行迭代，只要 `left` 小于 `right`：
   1. 计算由 `left` 和 `right` 指向的墙之间的面积。 高度是两堵墙中较小的一堵，宽度是指针之间的距离 (`right - left`)。
   2. 使用当前 `maxWaterArea` 和新计算的面积之间的较大值更新 `maxWaterArea`。
   3. 将较短墙的指针向内移动：
      * 如果 `walls[left]` 较小，则递增 `left` 以找到更高的墙。
      * 否则，递减 `right` 以在右侧找到更高的墙。
4. 返回 `maxWaterArea` 作为找到的最大水域面积。

<MDXCodeBlock>
  {maximumWaterBetweenWalls}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。 每个指针最多移动 `n` 步，导致线性运行时。
* **空间复杂度：O(1)**。 除了用于跟踪指针和面积计算的几个变量外，不需要额外的空间。
