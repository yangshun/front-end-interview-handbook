import MDXCodeBlock from 'MDXCodeBlock';

import linkedListReversal from '../setup/src/linked-list-reversal.ts';
import linkedListReversalUsingRecursion from '../setup/src/linked-list-reversal-using-recursion.ts';

## 1. 使用迭代方法

反转链表涉及翻转所有节点的 `next` 指针，使其指向前一个节点而不是下一个节点。迭代方法使用两个指针 `prev` 和 `curr` 分别跟踪前一个节点和当前节点。这确保了列表在原地反转，而无需额外的内存。

每个节点的 `next` 指针被反转以指向前一个节点。此操作对列表中的所有节点进行迭代。

`curr` 指针从头到尾遍历列表，而 `prev` 指针滞后，逐步构建列表的反转部分。

通过仅使用几个指针 (`prev`、`curr` 和一个用于下一个节点的临时指针)，该算法实现了反转，而无需为新列表分配额外的空间。

当 `curr` 指针变为 `null` 时，该过程结束，这表明所有节点都已被反转。此时，`prev` 指针指向反转列表的新头部。

这种方法在线性时间内有效地反转列表，同时保持恒定的空间复杂度。

### 算法

1. 初始化两个指针：
   * `prev` 初始化为 `null`，表示前一个节点。
   * `curr` 初始化为 `head`，表示当前节点。
2. 当 `curr` 不为 `null` 时，遍历列表：
   1. 将下一个节点存储在临时变量 `nextTemp` (`curr.next`) 中。
   2. 反转当前节点的 `next` 指针 (`curr.next = prev`)。
   3. 将 `prev` 指针移动到当前节点 (`prev = curr`)。
   4. 将 `curr` 指针移动到下一个节点 (`curr = nextTemp`)。
3. 循环结束后，`prev` 指针将指向反转列表的新头部。
4. 返回 `prev` 作为新头部。

<MDXCodeBlock>
  {linkedListReversal}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。列表中的每个节点都会被访问一次。
* **空间复杂度：O(1)**。该算法使用恒定量的额外空间。

## 2. 使用递归方法

递归地反转链表涉及将问题分解为更小的子问题，首先反转列表的尾部，并在递归调用时调整指针。关键是在递归沿调用堆栈向上传播时，一次一步地反转节点的 `next` 指针。

该问题被分解为反转从第二个节点开始的子列表 (`head.next`)。基本情况发生在列表为空或只有一个节点时，在这种情况下，反转完成。

在每次递归调用期间，后续节点的 `next` 指针被更新以指回当前节点 (`head`)。这会反转每个节点的 `next` 指针的方向。

递归调用返回反转子列表的新头部，该头部传播回顶层调用者。这确保了返回反转列表的最终头部。

该算法直接在列表的节点上运行，而无需为新列表或辅助数据结构分配额外的空间。

### 算法

1. 检查基本情况：
   * 如果 `head` 为 `null` 或 `head.next` 为 `null`，则返回 `head` 作为反转后的列表。
2. 递归调用 `reverseLinkedList`，使用 `head.next` 反转列表的其余部分。
   * 将结果存储在变量 `p` 中，它表示反转列表的新头。
3. 调整指针：
   * 将 `head.next.next` 设置为 `head`，反转当前节点的 `next` 指针。
   * 将 `head.next` 设置为 `null`，以断开当前节点与原始列表结构的连接。
4. 返回 `p` 作为反转列表的新头。

<MDXCodeBlock> {linkedListReversalUsingRecursion} </MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。在递归期间，每个节点只访问一次。
* **空间复杂度：O(n)**。递归深度与列表的大小成正比，需要额外的堆栈空间。
