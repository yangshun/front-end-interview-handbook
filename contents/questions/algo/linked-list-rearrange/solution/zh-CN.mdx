import MDXCodeBlock from 'MDXCodeBlock';

import rearrangeLinkedList from '../setup/src/linked-list-rearrange.ts';

## 1. 合并列表与反向子列表

该问题涉及重新排列链表，使得节点在列表的前半部分和后半部分之间交替。这种方法使用三个关键步骤的组合：定位列表的中间位置，反转列表的后半部分，以及合并这两个部分。

链表的中间位置使用双指针技术确定。`slow`指针一次移动一步，而`fast`指针移动两步。当`fast`指针到达末尾时，`slow`指针位于中间位置。这会将列表分成两半。

列表的后半部分就地反转。这会将链表转换为两部分：前半部分按原始顺序排列，后半部分按反向顺序排列。反转是为了方便交替合并。

通过交替选择来自前半部分和反向后半部分的节点来合并这两半。这会以所需的交替模式重新排列列表。

这种方法在线性时间内有效地解决了问题，并使用恒定空间来重新排序节点。

### 算法

1. 检查`head`是否为`null`。如果为真，则立即返回，因为没有什么可重新排列的。
2. 初始化两个指针`slow`和`fast`，都设置为链表的`head`。
3. 定位列表的中间位置：
   1. 每次移动`slow`一步，`fast`两步。
   2. 当`fast`为`null`或`fast.next`为`null`时停止。`slow`指针现在将指向中间节点。
4. 反转列表的后半部分：
   1. 将`prev`初始化为`null`，将`curr`初始化为`slow`。
   2. 从`slow`遍历列表到末尾：
      * 将下一个节点存储在临时变量`tmp`中。
      * 将`curr.next`更新为指向`prev`。
      * 将`prev`移动到`curr`，将`curr`移动到`tmp`。
5. 合并列表的两半：
   1. 将`first`初始化为列表的`head`，将`second`初始化为`prev`（反向后半部分的头）。
   2. 交替链接来自`first`和`second`的节点：
      * 将`first`的下一个节点存储在`tmp1`中，将`second`的下一个节点存储在`tmp2`中。
      * 将`first.next`更新为指向`second`，将`second.next`更新为指向`tmp1`。
      * 将`first`移动到`tmp1`，将`second`移动到`tmp2`。

<MDXCodeBlock> {rearrangeLinkedList} </MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。在三个步骤中，每个节点都会被访问一次：找到中间位置、反转后半部分和合并。
* **空间复杂度：O(1)**。该算法使用恒定量的额外空间。
