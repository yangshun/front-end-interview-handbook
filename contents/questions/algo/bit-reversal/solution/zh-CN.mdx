import MDXCodeBlock from 'MDXCodeBlock';

import reverseBits from '../setup/src/bit-reversal.ts';
import reverseBitsMaskAndShift from '../setup/src/bit-reversal-mask-shift.ts';

## 1. 使用掩码和移位方法

用于位反转的掩码和移位方法使用位运算来有效地反转 32 位无符号整数的位。 关键直觉是，反转可以通过分层执行，方法是交换越来越小的位组。 从大组开始，例如 16 位的一半，该算法继续交换较小的组（字节、4 位半字节、成对的位，最后是单个位），直到所有位都处于其反转位置。

使用位掩码可确保在每个步骤中仅操作相关位，并且移位（`>>>` 用于无符号右移，`<<` 用于左移）将交换的位重新定位到它们正确的位置。 这种方法消除了单独处理每个位的需要，从而使算法非常高效。

### 算法

1. 交换左右 16 位的一半：
   * 使用 `n >>> 16` 将右半部分移到最左边的位置。
   * 使用 `n << 16` 将左半部分移到最右边的位置。
   * 使用按位 OR 运算 (`|`) 组合结果。
2. 交换连续的字节（8 位）：
   * 使用掩码 `0xff00ff00` 隔离最左边和最右边的字节，并将它们右移 8 位。
   * 使用掩码 `0x00ff00ff` 隔离内部字节，并将它们左移 8 位。
   * 使用按位 OR 运算组合结果。
3. 交换连续的 4 位组（半字节）：
   * 使用掩码 `0xf0f0f0f0` 隔离 4 位组，并将它们右移 4 位。
   * 使用掩码 `0x0f0f0f0f` 隔离其他组，并将它们左移 4 位。
   * 使用按位 OR 运算组合结果。
4. 交换连续的位对：
   * 使用掩码 `0xcccccccc` 隔离位对，并将它们右移 2 位。
   * 使用掩码 `0x33333333` 隔离其他对，并将它们左移 2 位。
   * 使用按位 OR 运算组合结果。
5. 交换单个位：
   * 使用掩码 `0xaaaaaaaa` 隔离交替位，并将它们右移 1 位。
   * 使用掩码 `0x55555555` 隔离其他交替位，并将它们左移 1 位。
   * 使用按位 OR 运算组合结果。
6. 使用 `>>> 0` 将最终结果作为无符号 32 位整数返回。

<MDXCodeBlock>
  {reverseBitsMaskAndShift}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(1)**。 无论输入值如何，该算法都会执行固定数量的位运算。
* **空间复杂度：O(1)**。 除了存储中间结果的几个变量之外，不需要额外的空间。

## 2. 使用位运算

用于位反转的位运算方法依赖于遍历给定整数的所有 32 位，并在新变量中重建反转的位序列。 关键思想是提取输入数字的最低有效位 (LSB)，将其移到反转数字中的新位置，然后通过右移输入数字移到下一位。 此过程将一直持续到所有位都被反转。

反转的位通过左移反转的数字并在每个步骤中附加提取的位来逐步构建。 该方法通过直接操作单个位来确保正确性和效率。

### 算法

1. 将变量 `reversed` 初始化为 `0` 以存储反转的位序列。
2. 循环 32 次以处理输入数字的每一位：
   * 使用 `n & 1` 提取数字的最低有效位 (LSB)。
   * 将 `reversed` 左移一位，并使用按位 OR 运算 (`|`) 附加 LSB。
   * 将输入数字 (`n`) 右移一位以处理下一位。
3. 使用 `>>> 0` 将 `reversed` 值作为无符号 32 位整数返回。

<MDXCodeBlock>
  {reverseBits}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(1)**。 该算法处理固定数量的 32 位，因此运行时不依赖于输入大小。
* **空间复杂度：O(1)**。 除了存储中间结果的几个变量之外，没有使用额外的空间。
