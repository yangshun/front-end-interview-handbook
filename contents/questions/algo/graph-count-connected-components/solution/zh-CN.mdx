import MDXCodeBlock from 'MDXCodeBlock';

import graphCountConnectedComponents from '../setup/src/graph-count-connected-components.ts';
import graphCountConnectedComponentsUsingDSU from '../setup/src/graph-count-connected-components-using-DSU.ts';

## 1. 使用 DFS

该问题需要计算无向图中的连通分量数量。连通分量是一个子图，其中任意两个节点都可以相互到达，并且子图中的任何节点都不会连接到它之外的任何节点。

该方法使用深度优先搜索 (DFS) 来探索图。其思路是将图视为节点和边的集合，由邻接表表示。通过从一个未访问的节点开始，DFS 遍历将探索同一连通分量中的所有节点。每次遇到一个新的未访问节点时，它表示一个新的连通分量的开始。这确保了所有节点都被处理，并且不会遗漏任何组件。`visited` 数组用于跟踪已探索的节点，避免冗余遍历。

此方法消除了对已知连通分量中已存在的节点的非必要遍历，使其高效且系统化。

### 算法

1. 处理节点数 (`num`) 为 `0` 的边缘情况，立即返回 `0`。
2. 初始化：
   * 计数器 `components` 用于跟踪连通分量的数量。
   * 一个大小为 `num` 的数组 `visited`，所有元素都设置为 `0`，以标记未访问的节点。
   * 一个邻接表 `adjList` 来表示图，初始化为一个空数组的数组。
3. 通过将每条边添加到两个连接节点的列表中，从给定的 `edges` 构建邻接表。
4. 遍历所有节点：
   * 如果一个节点未被访问，则增加 `components` 计数器。
   * 从该节点开始执行 DFS，将当前连通分量中所有可到达的节点标记为已访问。
5. 返回 `components` 的值。

<MDXCodeBlock>
  {graphCountConnectedComponents}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(v + e)**。在 DFS 遍历期间，每个节点 (`v`) 和边 (`e`) 都只被处理一次。
* **空间复杂度：O(v + e)**。邻接表需要 O(v + e) 空间来存储图，`visited` 数组需要 O(v) 空间。

## 2. 不相交集合并

其思路是最初将每个节点视为其自己的组件。当处理边时，如果节点已连接，则将它们合并到同一组件中。并查集数据结构通过为每个集合维护一个代表并使用“按大小合并”策略来最小化树高，从而有效地跟踪组件。路径压缩通过在查找期间展平树结构来进一步优化 `find` 操作。

这种方法通过直接管理组件之间的关系来避免对图的冗余遍历，使用高效的操作，非常适合用于计算连通分量。

### 算法

1. 初始化两个数组：
   * `representative` 用于跟踪每个节点的代表。最初，每个节点都是它自己的代表。
   * `size` 用于存储每个组件的大小。所有节点都初始化为大小 `1`。
2. 将连通分量的初始计数设置为节点数 (`num`)。
3. 定义一个 `find` 函数来确定节点的代表：
   * 如果一个节点是它自己的代表，则返回该节点。
   * 否则，递归查找其父节点的代表，应用路径压缩以展平树结构。
4. 定义一个 `combine` 函数来合并两个集合：
   * 找到两个集合的根代表。
   * 如果代表相同，则节点已在同一集合中。返回 `0`。
   * 否则，执行按大小合并：
     * 将较小的集合附加到较大的集合并更新大小。
     * 返回 `1` 以指示发生了合并。
5. 遍历边列表。对于每条边，调用 `combine` 函数以合并连接的节点并减少连通分量的计数。
6. 返回连通分量的最终计数。

<MDXCodeBlock>
  {graphCountConnectedComponentsUsingDSU}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(e.α(v))**。由于路径压缩和按大小合并，并查集操作 `find` 和 `union` 几乎是恒定时间，其中 α(v) 是反阿克曼函数。
* **空间复杂度：O(v)**。`representative` 和 `size` 数组所需的空间与节点数 (`v`) 成正比。
