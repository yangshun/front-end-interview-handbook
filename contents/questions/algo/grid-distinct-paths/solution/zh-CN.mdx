import MDXCodeBlock from 'MDXCodeBlock';

import gridDistinctPaths from '../setup/src/grid-distinct-paths.ts';
import gridDistinctPathsTopDown from '../setup/src/grid-distinct-paths-top-down.ts';

## 1. 自底向上动态规划

该问题要求找到一个 `m x n` 维网格从左上角到右下角的不同的路径数量。在任何时候，移动都仅限于向下或向右。

该方法使用自底向上的动态规划来高效地解决问题。其直觉是，到达网格中特定单元格的路径数量是到达其正上方单元格的路径数量与其左侧单元格的路径数量之和。这是因为到达当前单元格的唯一有效移动是从上方或从左侧。使用一个二维表来存储到达每个单元格的路径数量，避免了冗余计算。

这种方法通过迭代地在表中构建解决方案，消除了不必要的递归和重叠的子问题。

### 算法

1. 初始化一个大小为 `m x n` 的二维数组 `d`，所有单元格都设置为 `1`。这表示到达第一行或第一列的任何单元格只有一种方法。
2. 从第二行和第二列开始遍历网格：
   * 对于每个单元格 `(col, row)`，将到达该单元格的路径数量计算为到达其上方单元格 (`d[col-1][row]`) 的路径数量与到达其左侧单元格 (`d[col][row-1]`) 的路径数量之和。
3. 继续此过程，直到所有单元格都被填充。
4. 返回右下角单元格 `d[m-1][n-1]` 的值，该值表示从左上角到右下角的唯一路径总数。

<MDXCodeBlock>
  {gridDistinctPaths}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n)**。网格中的每个单元格都会被处理一次。
* **空间复杂度：O(m.n)**。使用一个大小为 `m x n` 的二维数组来存储每个单元格的唯一路径数量。

## 2. 自顶向下动态规划

这种方法使用带备忘录的自顶向下动态规划来避免冗余计算。递归函数通过将直接下方单元格和直接右侧单元格的路径相加来计算从给定单元格到目的地的路径数量。备忘录表存储先前计算的单元格的结果，确保每个子问题只解决一次。这消除了不必要的重复工作，优化了解决方案。

这种方法有效地将问题分解为重叠的子问题，同时存储中间结果以减少总计算时间。

### 算法

1. 创建一个大小为 `m x n` 的备忘录表 `memo`，并将其初始化为 `null`，以存储子问题的结果。
2. 定义一个递归辅助函数 `helper(row, col)`：
   * 如果当前单元格是右下角 (`row === m-1` 且 `col === n-1`)，则返回 `1`，因为到达目的地只有一条路径。
   * 如果当前单元格在网格之外 (`row >= m` 或 `col >= n`)，则返回 `0`，因为不可能有路径。
   * 如果当前单元格的结果已存储在 `memo[row][col]` 中，则返回存储的值以避免冗余计算。
   * 将路径数量计算为来自下方单元格 (`helper(row+1, col)`) 和右侧单元格 (`helper(row, col+1)`) 的路径之和。
   * 将计算结果存储在 `memo[row][col]` 中。
3. 通过为左上角调用 `helper(0, 0)` 来开始计算。
4. 从递归调用中返回结果，该结果表示从左上角到右下角的路径总数。

<MDXCodeBlock>
  {gridDistinctPathsTopDown}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n)**。由于备忘录，每个单元格最多计算一次，总共有 `m.n` 个子问题。
* **空间复杂度：O(m.n)**。备忘录表需要 `m.n` 的空间，并且递归堆栈在最坏的情况下可以增长到 `m + n` 层。
