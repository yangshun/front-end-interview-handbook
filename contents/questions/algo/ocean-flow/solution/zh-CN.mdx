import MDXCodeBlock from 'MDXCodeBlock';

import oceanFlow from '../setup/src/ocean-flow.ts';
import oceanFlowUsingBFS from '../setup/src/ocean-flow-bfs.ts';

## 1. 使用深度优先搜索

该问题涉及在矩阵中找到水可以流到太平洋（顶部和左侧边缘）和大西洋（底部和右侧边缘）的单元格。 解决方案使用深度优先搜索 (DFS) 来探索从每个海洋的边界开始的可到达单元格。

这种方法的直觉是将问题视为一个连通性图：

* 如果水可以流到该海洋，则一个单元格“连接”到该海洋。
* 如果一个单元格流向的所有相邻单元格的高度大于或等于其自身，则认为该单元格是可到达的。

该算法使用两个布尔矩阵来跟踪太平洋和大西洋的可达性。 从各自的海洋边界开始 DFS 可确保仅探索有效路径。 处理后，两个可达性矩阵的交集给出了所需的单元格。

### 算法

1. 定义 `DIRECTIONS` 数组以表示四种可能的移动（上、下、左、右）。
2. 初始化两个二维布尔矩阵：`oceanTopLeftReachable` 和 `oceanBottomRightReachable`，以分别标记从太平洋和大西洋可到达的单元格。
3. 定义 `dfs` 函数：
   * 将当前单元格标记为在给定的布尔矩阵中可到达。
   * 探索所有有效的相邻单元格：
     * 在范围内。
     * 尚未访问。
     * 高度大于或等于当前单元格。
4. 从太平洋的边界开始 DFS：
   * 遍历矩阵的顶行和左列。
5. 从大西洋的边界开始 DFS：
   * 遍历矩阵的底行和右列。
6. 遍历矩阵中的所有单元格：
   * 如果一个单元格在 `oceanTopLeftReachable` 和 `oceanBottomRightReachable` 中都被标记为可到达，则将其添加到结果中。
7. 返回可以流到两个海洋的单元格列表。

<MDXCodeBlock>
  {oceanFlow}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n)**。 在 DFS 期间，每个单元格最多访问一次，并且矩阵有 `m.n` 个单元格。
* **空间复杂度：O(m.n)**。 使用两个大小为 `m.n` 的布尔矩阵来跟踪可达性，并且 DFS 的调用堆栈在最坏的情况下可以达到 `m.n`。

## 2. 使用广度优先搜索

该问题涉及识别矩阵中水可以流到太平洋（顶部和左侧边缘）和大西洋（底部和右侧边缘）的单元格。 使用广度优先搜索 (BFS) 可确保在探索所有有效单元格时满足流量约束。 每个单元格的高度必须大于或等于其相邻单元格，水才能反向流动。

此解决方案使用两个 BFS 遍历：

* 一个从太平洋的边界开始。
* 另一个从大西洋的边界开始。

从两个 BFS 遍历都可到达的单元格是所需的结果。

### 算法

1. 定义 `DIRECTIONS` 数组以表示四种可能的移动（上、下、左、右）。
2. 实现 `bfs` 函数：
   * 初始化一个 `reachable` 布尔矩阵来跟踪遍历期间可访问的单元格。
   * 使用队列迭代处理单元格。
   * 对于每个单元格：
     * 将其标记为可到达。
     * 将所有有效的相邻单元格排队：
       * 确保邻居在范围内。
       * 确保邻居尚未被访问。
       * 确保邻居的高度大于或等于当前单元格。
   * 返回 `reachable` 矩阵。
3. 为 BFS 准备队列：
   * 太平洋队列从顶行和左列开始。
   * 大西洋队列从底行和右列开始。
4. 使用 `bfs` 函数对两个海洋执行 BFS。
5. 遍历矩阵中的所有单元格：
   * 如果单元格可以从太平洋和大西洋到达，则将其添加到结果中。
6. 返回公共单元格的列表。

<MDXCodeBlock>
  {oceanFlowUsingBFS}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(m.n)**。 在 BFS 期间，每个单元格最多处理一次。
* **空间复杂度：O(m.n)**。 使用两个布尔矩阵来跟踪可达性，并且 BFS 使用一个可能增长到矩阵大小的队列。
