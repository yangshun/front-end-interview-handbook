import MDXCodeBlock from 'MDXCodeBlock';

import mergeSortJs from '../setup/src/merge-sort.js';
import mergeSortTs from '../setup/src/merge-sort.ts';

归并排序是一种基于比较的稳定算法，在所有情况下，其时间复杂度均为 O(nlog(n))。它通常在实践中用作对各种大小的数组进行排序的通用算法。

## 澄清问题

如果未指定：

* 数据应该按升序还是降序排序？
* 数据应该就地排序还是可以使用其他数据结构？
* 我们需要处理什么样的输入？
  * 它只是一个整数数组，还是我们应该处理其他数据类型？
  * 是否存在大量重复元素？
  * 应该如何处理负数？

## 解决方案

注意：这个问题处理的是标准的归并排序，它是递归的，并且对于升序输出不是“就地”的。

<MDXCodeBlock languages={{jsx:mergeSortJs,tsx:mergeSortTs}} />

## 边缘情况

* 非整数元素输入：如果输入数组包含不同数据类型的元素，您可能需要返回一个错误，尝试进行最佳排序，例如，仅对输入数据的子集进行排序，甚至为非整数定义自定义比较函数。
* 单个元素/空输入：返回原始数据结构、引发错误或澄清所需处理。
* 已排序的输入：您可能需要检测排序并原样返回输入。
* 无效输入：如果输入不是数组，请考虑抛出错误。

## Big-O 分析

让我们分析一下算法的时间和空间复杂度。

### 时间复杂度

对于归并排序，最佳、平均和最坏情况下的时间复杂度均为 O(nlog(n))。这意味着排序所需的时间与数组大小和数组大小的对数的乘积成正比。

划分步骤的时间复杂度与由于输入数组被反复对半分而创建的二叉树的高度成正比，并且步数最多为 log(n) + 1。找到任何子数组的中间值是一个单步操作，成本为 O(1)。因此，我们预计它的时间复杂度为 O(log(n))。

合并步骤需要 O(n) 时间，用于由划分创建的每个子数组，因为它需要将 n 个元素组合成一个已排序的列表。

总的来说，归并排序的时间复杂度为 n(log(n) + 1) = O(nlog(n))。

### 空间复杂度

在空间复杂度方面，对于递归且非就地的标准归并排序，它是 O(n)。合并步骤需要创建一个新数组来存储 2 个部分的合并结果。在最后一个合并步骤中，我们希望数组与输入数组一样大。因此，空间需求是线性的。
