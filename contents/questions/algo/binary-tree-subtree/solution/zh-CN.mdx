import MDXCodeBlock from 'MDXCodeBlock';

import binaryTreeSubtree from '../setup/src/binary-tree-subtree.ts';
import binaryTreeSubtreeHashing from '../setup/src/binary-tree-subtree-hashing.ts';

## 1. 使用递归

该问题需要确定一个二叉树是否是另一个二叉树的子树。子树必须在结构和节点值上与较大树的一部分完全匹配。 挑战在于有效地比较子树，同时避免冗余检查。

一种蛮力解决方案涉及将较大树中的每个可能的子树与较小的树进行比较，但这种方法会导致大量不必要的工作。 为了优化，该解决方案使用递归方法直接验证当前子树是否与给定的较小树匹配。

其直觉基于将问题简化为更小的子问题：如果当前子树不匹配，则解决方案检查当前节点的左子树和右子树。 为了确定两棵树是否相同，一个辅助函数验证它们的根值并递归地比较它们的左子树和右子树。 这消除了不必要的重复比较，并确保了有效的子树匹配。

### 算法

1. 检查 `root` 是否为 `null`。 如果是，则返回 `false`，因为找不到子树。
2. 使用辅助函数验证当前子树是否与 `subRoot` 相同。
   * 如果相同，则返回 `true`。
3. 递归地检查当前节点的左子树和右子树。
4. 如果任何递归调用找到匹配项，则返回 `true`；否则，返回 `false`。

<MDXCodeBlock>
  {binaryTreeSubtree}
</MDXCodeBlock>

#### `isIdentical` 辅助函数：

1. 如果任一树为空，则仅当两者都为空时才返回 `true`。
2. 如果两棵树都非空：
   * 比较每棵树根节点的值。
   * 递归检查左子树是否相同。
   * 递归检查右子树是否相同。
3. 仅当值和结构完全匹配时才返回 `true`。

### Big-O 分析

* **时间复杂度：O(m.n)**。 对于较大树中的每个节点 (O(m))，子树与较小的树 (O(n)) 进行比较。
* **空间复杂度：O(h)**。 由于递归调用，使用的空间与较大树的高度成正比。

## 2. 使用哈希

该问题涉及确定一个二叉树是否是另一个二叉树的子树。 该方法没有重复地直接比较节点和结构，而是使用哈希来将子树表示为紧凑的哈希值。 这通过使用哈希函数的属性来有效地检测子树匹配，从而消除了冗余的结构比较。

直觉是为较大树中的每个子树计算唯一的哈希值，并将它们与较小树的哈希值进行比较。 子树哈希取决于节点值及其左右子节点的哈希值，确保不同子树结构的唯一性。 通过将所有子树哈希存储在集合中，可以在每次哈希比较中以恒定的时间检查较小树是否存在作为子树。 这避免了重复的结构检查并提高了效率。

### 算法

1. 定义一个辅助函数 `hashSubtreeAtNode`，用于计算以给定节点为根的子树的哈希值：
   * 对于 `null` 节点，返回预定义的基哈希值。
   * 递归计算左子树和右子树的哈希值。
   * 使用当前节点的值及其子节点的哈希值计算当前节点的哈希值，应用模运算以防止溢出。
   * 如果需要，将哈希值存储在全局集合中。
2. 初始化一个空集合 `memo` 以存储较大树中所有子树的哈希值。
3. 计算整个较大树的哈希值，将每个子树的哈希值存储在 `memo` 中。
4. 计算较小树的哈希值，而不将其添加到集合中。
5. 检查较小树的计算哈希值是否存在于 `memo` 集合中。 如果找到，则返回 `true`；否则，返回 `false`。

<MDXCodeBlock>
  {binaryTreeSubtreeHashing}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n + m)**。 较大树有 `n` 个节点，较小树有 `m` 个节点，在哈希期间分别遍历一次，导致总的时间复杂度为 O(n + m)。
* **空间复杂度：O(n)**。 较大树中所有 `n` 个节点的哈希值都存储在 `memo` 集合中。
