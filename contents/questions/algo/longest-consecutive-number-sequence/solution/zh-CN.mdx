import MDXCodeBlock from 'MDXCodeBlock';

import longestConsecutiveNumberSequence from '../setup/src/longest-consecutive-number-sequence.ts';
import longestConsecutiveNumberSequenceUsingSorting from '../setup/src/longest-consecutive-number-sequence-sorting.ts';
import longestConsecutiveNumberSequenceBruteForce from '../setup/src/longest-consecutive-number-sequence-brute-force.ts';

## 1. 蛮力法

目标是找到数组中最长连续整数序列的长度。这种蛮力方法遍历每个元素，并通过重复搜索数组来检查连续的数字。

该逻辑首先假设当前数字是潜在序列的开始，并使用`includes`方法检查下一个连续数字是否存在。该过程持续进行，直到序列中没有更多连续数字。然后，将此序列的长度与到目前为止找到的最长序列进行比较，以更新结果。

<MDXCodeBlock>
  {longestConsecutiveNumberSequenceBruteForce}
</MDXCodeBlock>

### 算法

1. 检查数组是否为空。如果是，则返回`0`，因为没有数字。
2. 初始化一个变量`longestStreak`来跟踪到目前为止找到的最长连续序列。
3. 使用`for`循环遍历数组中的每个数字：
   1. 将`currentNum`设置为当前数字，并将`currentStreak`初始化为`1`。
   2. 使用`while`循环检查下一个连续数字（`currentNum + 1`）是否存在于数组中：
      * 如果存在，则递增`currentNum`并将`currentStreak`增加`1`。
   3. 将`longestStreak`更新为`longestStreak`和`currentStreak`之间的最大值。
4. 循环结束之后，返回`longestStreak`的值。

### Big-O 分析

* **时间复杂度：O(n<sup>2</sup>)**。`includes`方法执行线性搜索，这使得这种方法是二次的，因为它嵌套在循环中，循环遍历所有`n`个元素。
* **空间复杂度：O(1)**。没有使用额外的数据结构；只分配了几个变量。

## 2. 使用排序

此解决方案通过对输入数组进行排序来改进蛮力方法，以简化查找连续数字的过程。排序将所有元素按升序排列，这使得连续数字彼此相邻出现。这消除了重复搜索序列中下一个数字的需要，从而显着减少了冗余操作。

该算法遍历排序后的数组，并跟踪当前连续数字序列的长度。每当序列中断时（一个数字与前一个数字不连续），将当前条纹的长度与到目前为止找到的最长条纹进行比较，并更新最大值。

### 算法

1. 检查数组是否为空。如果是，则返回`0`。
2. 使用`sort`方法按升序对数组进行排序。
3. 初始化两个变量：`longestStreak`为`1`，用于跟踪最长序列，`currentStreak`为`1`，用于当前连续序列长度。
4. 从第二个元素开始遍历排序后的数组：
   1. 如果当前数字等于前一个数字，则跳过它以避免重复。
   2. 如果当前数字正好比前一个数字大 1，则递增`currentStreak`。
   3. 如果当前数字既不等于前一个数字，也不与前一个数字连续：
      * 使用`longestStreak`和`currentStreak`之间的最大值更新`longestStreak`。
      * 将`currentStreak`重置为`1`。
5. 循环结束后，最后一次将`longestStreak`与`currentStreak`进行比较，并返回最大值。

<MDXCodeBlock>
  {longestConsecutiveNumberSequenceUsingSorting}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。对数组进行排序主导了运行时，需要 O(n log n)。随后对数组的单次遍历是 O(n)，使总复杂度为 O(n log n)。
* **空间复杂度：O(1)**。排序是就地执行的，并且仅使用几个变量来跟踪条纹。

## 3. 使用哈希

此解决方案通过使用`Set`存储输入数字来改进运行时复杂度。`Set`为查找提供了 O(1) 的平均时间复杂度，这消除了重复搜索数组的需要。该方法通过检查当前数字在集合中是否没有前一个数字（`num - 1`）来标识潜在序列的开始。一旦确定了序列的开始，它就会计算连续的数字，直到序列结束。

### 算法

1. 从输入数组创建一个`Set`，以删除重复项并允许 O(1) 查找。
2. 将`longestStreak`初始化为`0`，以跟踪最长序列长度。
3. 遍历`Set`中的每个数字：
   1. 通过验证`num - 1`不在`Set`中来检查当前数字是否为序列的开始。
   2. 如果是开始，则将`currentNum`初始化为当前数字，将`currentStreak`初始化为`1`。
   3. 使用`while`循环检查下一个数字（`currentNum + 1`）是否存在于`Set`中：
      * 如果存在，则递增`currentNum`和`currentStreak`。
   4. 将`longestStreak`更新为`longestStreak`和`currentStreak`之间的最大值。
4. 将`longestStreak`作为最长连续序列的长度返回。

<MDXCodeBlock>
  {longestConsecutiveNumberSequence}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个数字最多处理两次：一次是检查它是否是序列的开始，另一次是在`while`循环中扩展序列。
* **空间复杂度：O(n)**。`Set`需要与输入数组中唯一元素的数量成比例的空间。
