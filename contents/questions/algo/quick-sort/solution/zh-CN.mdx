import MDXCodeBlock from 'MDXCodeBlock';

import quickSortJs from '../setup/src/quick-sort.js';
import quickSortTs from '../setup/src/quick-sort.ts';

快速排序通常被认为是任何数组大小最有效的通用排序算法，平均速度比合并排序快。快速排序的标准形式通常是**递归**和**就地**完成的。然而，它是一种不稳定的排序，因此在稳定性很重要的情况下，可能更喜欢合并排序。

## 澄清问题

如果未指定：

* 数据应该按升序还是降序排序？
* 数据应该就地排序还是可以使用其他数据结构？
* 我们需要处理什么样的输入？
  * 它只是一个整数数组，还是我们应该处理其他数据类型？
  * 是否存在大量重复元素？
  * 应该如何处理负数？

## 解决方案

注意：这个问题处理的是一个标准的快速排序，它对升序输出是递归和就地的。

<MDXCodeBlock languages={{jsx:quickSortJs,tsx:quickSortTs}} />

## 边缘情况

* 非整数元素输入：如果输入数组包含不同数据类型的元素，您可能需要返回一个错误，满足于尽力排序，例如，仅对输入数据的子集进行排序，甚至为非整数定义自定义比较函数。
* 单个元素/空输入：返回原始数据结构、引发错误或澄清所需处理。
* 已经排序的输入：您可能需要检测排序并原样返回输入。
* 无效输入：如果输入不是数组，请考虑抛出错误。

## Big-O 分析

让我们分析一下算法的时间和空间复杂度。

### 时间复杂度

对于快速排序，最佳和平均情况下的时间复杂度为 O(nlog(n))，而最坏情况下的时间复杂度为 O(n<sup>2</sup>)。尽管如此，快速排序通常比合并排序更快，因为最坏或最佳情况时间复杂度的条件使其极其罕见。

快速排序的时间复杂度取决于每次递归调用时枢轴元素的选择。枢轴越接近数组或子数组的中位数，算法就越快。这是因为它会影响每次递归调用的分区时间，指的是扫描每个子数组并将其放置在较小或较大子数组中的时间。

在最坏的情况下，对于每次递归调用，我们恰好选择了离中位数最远的枢轴元素——即数组或子数组中最大或最小的元素。这意味着分区时间对于第一次递归调用是*c(n)*（c为某个常数），对于第二次递归调用是*c(n-1)*（在选择1个枢轴元素之后），依此类推。当我们加总n次递归调用的分区时间时，它大约为O(n<sup>2</sup>)的运行时间。

在最佳情况下，每次递归调用的枢轴元素非常接近中位数，因此分区始终尽可能均匀地平衡。在这种情况下，我们希望每次将每个子数组均匀地减半，这意味着我们只需要*2 \* (n/2)*分区时间用于每次递归调用（其中n指的是要分区的子数组的大小）。鉴于还需要进行log(n) + 1次递归调用，我们预计总共有cn(log(n) + 1)的运行时间，用大O表示法表示为O(nlog(n))。

正如我们从上面看到的，最佳和最坏情况需要非常具体的条件才能发生。

同时，平均情况更有可能发生在快速排序中。平均情况源于以下事实：任何恒定比例的分割都会产生深度为O(log(n))的递归树，其中每个递归级别的分区成本为O(log(n))。因此，时间复杂度往往为O(nlog(n))。

使用一个例子，我们假设部分不平衡的分割比例为 (9:1):

1. 递归的左子树将以 1/10 的因子递减，这使得它的深度为 log<sub>10</sub>(n)。
2. 递归的右子树将以 9/10 的因子递减，这使得它的深度为 log<sub>10/9</sub>(n) = O(log(n))。
3. 在递归的每一层进行分区的成本大约为 *c(n)*。

综上所述，我们看到成本大约为 O(nlog(n))。

### 空间复杂度

在空间复杂度方面，尽管快速排序是一种原地算法，但作为递归函数，它仍然使用调用栈。因此，空间复杂度将取决于递归调用栈的大小，也就是递归树的高度。

在最坏的情况下，每次递归调用中枢轴的选择都很糟糕，因此在递归的每一层只有 1 个调用。这导致递归树的高度为 O(n)。

在最好的情况下，空间复杂度往往是 O(log(n))，在每个递归级别都有 2 个递归调用。当枢轴始终是中位数或接近中位数时，就会发生这种情况，这样递归树是平衡的。

为了避免最坏情况下的时间和空间复杂度，我们可以使用更好的枢轴选择策略。这种策略的一个例子是随机枢轴选择策略。通过随机选择枢轴元素，我们可以确保枢轴并不总是在数组中最小或最大的元素，这降低了最坏情况时间复杂度发生的可能性。

```js
// 随机选择一个枢轴元素
const pivotIndex = Math.floor(Math.random() * arr.length);
const pivot = arr[pivotIndex];
```
