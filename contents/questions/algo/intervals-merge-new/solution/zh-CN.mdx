import MDXCodeBlock from 'MDXCodeBlock';

import mergeNewInterval from '../setup/src/intervals-merge-new.ts';
import mergeNewIntervalUsingBinarySearch from '../setup/src/intervals-merge-new-using-binarysearch.ts';

## 1. 使用线性搜索

该方法通过执行一次线性扫描，将一个新区间合并到一组非重叠区间中。区间根据其与新区间之间的关系分为三个不同的阶段进行处理：完全在新区间之前的区间、重叠的区间和完全在新区间之后的区间。由于输入区间已经排序，因此不需要排序。

不与新区间重叠的区间将原样添加到结果中。与新区间重叠的区间通过更新新区间的开始和结束以覆盖组合范围来进行合并。合并所有重叠区间后，将新区间添加到结果中，然后添加剩余的区间。这种方法确保每个区间只处理一次。

### 算法

1. 初始化一个空的结果数组 `res`，并将指针 `i` 设置为 `0`。
2. 处理新区间之前的区间：
   1. 当当前区间的结束小于新区间的开始时，将该区间添加到 `res`。
   2. 为每个添加的区间递增指针 `i`。
3. 处理重叠区间：
   1. 当当前区间的开始小于或等于新区间的结束时，通过更新新区间的开始和结束来合并区间。
   2. 合并后递增指针 `i`。
4. 将合并后的区间（新区间）添加到结果数组 `res`。
5. 处理新区间之后的区间：
   1. 从当前指针位置 `i` 开始，将所有剩余区间添加到 `res`。
   2. 为每个添加的区间递增指针 `i`。
6. 返回结果数组 `res`。

<MDXCodeBlock>
  {mergeNewInterval}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个区间只处理一次，导致线性运行时长。
* **空间复杂度：O(n)**。结果数组 `res` 存储所有区间，需要与输入大小成比例的空间。

## 2. 使用二分查找

这种方法结合了二分查找和合并，以有效地将一个新区间插入到已排序的区间列表中，并合并任何重叠部分。二分查找用于确定插入新区间基于其开始时间的正确位置。插入后，只需遍历一次区间即可合并重叠区间。合并过程通过检查结果列表中相邻的区间，确保将重叠区间合并成一个区间。

### 算法

1. 处理 `intervals` 数组为空的边缘情况，返回仅包含 `newInterval` 的列表。
2. 使用二分查找找到插入 `newInterval` 的合适位置：
   1. 初始化两个指针 `left` 和 `right`，以表示搜索范围。
   2. 将 `newInterval` 的开始值与当前范围的中间元素进行比较。
   3. 调整指针，直到找到插入 `newInterval` 的位置。
3. 使用 `splice` 方法将 `newInterval` 插入到确定的位置。
4. 初始化一个空数组 `res` 以存储合并后的区间。
5. 遍历 `intervals` 数组：
   1. 如果 `res` 为空，或者当前区间与 `res` 中的最后一个区间不重叠，则将当前区间添加到 `res`。
   2. 如果存在重叠，则通过将 `res` 中最后一个区间的结束更新为两个重叠区间的最大值来合并区间。
6. 返回包含合并区间的 `res` 数组。

<MDXCodeBlock>
  {mergeNewIntervalUsingBinarySearch}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。二分查找需要 O(log n) 时间，但与合并区间所需的 O(n) 时间相比，这可以忽略不计。
* **空间复杂度：O(n)**。结果数组 `res` 需要与输入大小成比例的空间。
