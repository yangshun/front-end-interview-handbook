import MDXCodeBlock from 'MDXCodeBlock';

import dijkstraJs from '../setup/src/dijkstra.js';
import dijkstraTs from '../setup/src/dijkstra.ts';

### 理由

Dijkstra 算法计算图中从具有非负边权重的源节点的**最短路径**。它使用贪心方法：在每一步中，它选择具有最小已知距离的未访问节点。 最小堆可以有效地执行此选择。 当找到到邻居的更短路径时，算法会更新其距离（松弛）并将其推入堆中。 这种策略保证了正确性，因为所有边权重都是非负的。

Dijkstra 算法假设非负权重。 对于具有负权重的图，需要使用其他算法，如 Bellman-Ford。

### 算法

提供的解决方案使用优先级队列（最小堆）来实现 Dijkstra 算法，以提高效率。

1. **初始化**：从所有节点设置为无穷大的距离开始，除了源节点设置为零。
2. **优先级队列**：使用优先级队列贪婪地选择具有最小已知距离的下一个节点。
3. **松弛**：对于每个选定的节点，如果通过当前节点找到更短的路径，则更新到其相邻节点的最短距离。 随后在优先级队列中添加或更新该邻居的距离。
4. **终止**：当优先级队列为空时，算法终止，表明所有可到达的节点都已处理完毕。

![Dijkstra Illustration](/img/questions/dijkstra/dijkstra.png)

<MDXCodeBlock languages={{jsx:dijkstraJs,tsx:dijkstraTs}} />

## 边缘情况

* **空图**：返回一个空字典或映射，而不会崩溃
* **一个或两个节点的图**：确保算法可以处理小图
* **具有非连接组件的图**：从源无法到达的节点应保持其距离为无穷大
* **具有零权重边的图**：确认零权重边不会导致算法逻辑出现问题

### Big-O 分析

* **时间复杂度：O((V + E) log V)**。 使用最小堆，提取最小值需要 O(log V)（最多执行 V 次），并且松弛每个 E 边也可能触发 O(log V) 堆更新。
* **空间复杂度：O(v)**。 存储距离（`O(v)`）、已访问集合（`O(v)`）和优先级队列（最坏情况下为 `O(v)`）。
