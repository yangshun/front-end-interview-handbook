---
title: Dijkstra 算法
excerpt: 实现 Dijkstra 算法，以找到图中从源顶点开始的最短路径，该图表示为邻接表。
---

给定一个加权有向图，表示为邻接表 (`graph`) 和一个起始节点 (`source`)，实现 Dijkstra 算法以找到从 `source` 到图中所有其他节点的最短路径距离。该图包含节点和加权边。

### 输入

- `graph`：一个表示图的邻接表的对象。每个键都是一个节点标识符（例如 `'A'`、`'B'`），其值是另一个对象，将每个相邻节点映射到连接它们的边的非负权重。
- `source`：用于计算最短路径的起始节点的标识符。

### 输出

- 一个对象，其中键是节点标识符，值表示从 `source` 到该节点的最短距离。从 `source` 无法到达的节点应将其距离设置为 `Infinity`（使用内置的 `Infinity` 常量）。

### 例子

```js
const graph1 = {
  A: { B: 1, C: 4 },
  B: { E: 3, F: 2 },
  C: { G: 2 },
  D: { C: 3, J: 5 },
  E: { D: 2 },
  F: {},
  G: { H: 1 },
  H: { F: 4, J: 3 },
  I: {},
  J: {},
};

dijkstra(graph1, 'A'); // Returns distances: { A: 0, B: 1, C: 4, D: 6, E: 4, F: 3, G: 6, H: 7, I: Infinity, J: 10 }

const graph2 = {
  A: { B: 2, C: 5 },
  B: { D: 1, E: 4 },
  C: { F: 3, G: 2 },
  D: {},
  E: {},
  F: {},
  G: {},
};

dijkstra(graph2, 'A'); // Returns distances: { A: 0, B: 2, C: 5, D: 3, E: 6, F: 8, G: 7 }
```

### 约束

- 1 &lt;= 节点数 &lt;= 1000
- 0 &lt;= 边权重 &lt;= 10000
- 图可能包含循环
- 图可能断开连接

## 回顾（提示）

Dijkstra 算法是一种用于查找加权图中节点之间最短路径的基本算法。该算法可以处理具有非负权重的图，通常用于路由以及其他图算法的子程序。以下是一些典型的用例：

1. 在 GPS 系统中，用于查找位置之间的最短驾驶路线。
2. 在网络路由算法中，用于查找数据包的最短路径。
3. 在调度理论中，用于查找通过一系列任务的最短（耗时最少）路径。
4. 生成加权图的最小生成树 (MST)。

以下是 Dijkstra 算法的工作原理：

1. 从图中所有节点的集合开始，为它们分配一个暂定的距离值：对于初始节点为零，对于所有其他节点为无穷大。将初始节点设置为当前节点。
2. 对于当前节点，考虑其所有未访问的邻居并计算它们的暂定距离。将新计算的暂定距离与当前分配的值进行比较，并分配较小的一个。
3. 一旦我们考虑了当前节点的所有未访问邻居，就将当前节点标记为已访问。已访问的节点将不再被检查。
4. 如果目标节点已被标记为已访问，或者未访问集合中节点之间的最小暂定距离为无穷大（当初始节点和剩余未访问节点之间没有连接时发生），则停止。算法已完成。
5. 否则，选择标有最小暂定距离的未访问节点，将其设置为新的“当前节点”，然后返回到步骤 2。
6. 结果是从初始节点到所有其他节点的最短距离的映射。
