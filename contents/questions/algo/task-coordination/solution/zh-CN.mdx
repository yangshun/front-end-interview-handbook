import MDXCodeBlock from 'MDXCodeBlock';

import taskCoordinator from '../setup/src/task-coordination.ts';
import taskCoordinatorHeap from '../setup/src/task-coordination-heap.ts';

## 1. 使用贪心算法

此解决方案最大限度地减少了使用冷却期 `k` 执行一系列任务所需的时间，确保在 `k` 个间隔内不执行两个相同的任务。 核心思想是关注频率最高的任务，因为它们在调度过程中占主导地位。 这些任务必须尽可能均匀地分布，从而在调度中创建“分区”。 剩余的任务填补了这些分区之间的空白，减少了空闲时间。

频率最高的任务定义了调度的框架，因为它们的分布决定了所有其他任务的放置。 这些任务的每次出现至少间隔 `k` 个间隔。 如果有其他任务来填补这些空白，则空闲时间会减少；否则，空闲时隙仍然存在，从而增加了总时间。

贪心算法确保调度通过首先填补由最频繁的任务创建的空白来压缩。 这避免了不必要的空闲时间，并确保调度在保持尽可能短的同时遵守冷却约束。

### 算法

1. 初始化一个大小为 26 的数组 `counter` 以计算每个任务的频率。
2. 遍历 `tasks` 数组以填充 `counter` 数组：
   1. 对于每个任务，增加其在 `counter` 中的频率计数。
   2. 更新 `maximum` 以跟踪任何任务的最高频率。
   3. 更新 `maxCount` 以计算有多少任务具有此最大频率。
3. 计算分区数，即 `maximum - 1`。
4. 计算每个分区的长度，即 `k - (maxCount - 1)`。
5. 计算空槽总数，即 `partCount * partLength`。
6. 计算可用任务数，即任务总数减去具有最大频率的任务。
7. 计算空闲槽数，即 `Math.max(0, emptySlots - availableTasks)`。
8. 将所需总时间作为 `tasks.length + idles` 返回。

<MDXCodeBlock> {taskCoordinator} </MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。 遍历 `tasks` 数组和更新 `counter` 数组都需要线性时间。
* **空间复杂度：O(1)**。 无论输入大小如何，`counter` 数组的大小都固定为 26。

## 2. 使用堆

关键思想是通过始终首先执行最频繁的任务来最大限度地减少空闲时间。 使用最大堆可以有效地检索剩余频率最高的任务。 这确保了以更高的频率执行任务，从而减少了空闲周期的可能性。

### 算法

1. 构建一个频率映射来计算每个任务的出现次数。
2. 使用任务频率填充最大堆。堆的结构优先考虑最高频率的任务。
3. 将总时间计数器初始化为 `0`。
4. 当堆不为空时：
   1. 执行一个冷却周期（`n + 1` 次）的任务，或者直到堆为空。
   2. 减少已执行任务的频率并存储更新后的频率。
   3. 周期结束后，将更新后的任务频率重新插入堆中。
   4. 更新总时间计数器。如果一个周期后堆为空，则仅添加该周期内执行的任务；否则，添加 `n + 1` 个时间单位，用于整个周期。
5. 将总时间计数器作为结果返回。

<MDXCodeBlock> {taskCoordinatorHeap} </MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log k)**。 迭代 `tasks` 数组并构建频率映射为 O(n)。 堆上的操作（插入和删除）为 O(log k)，其中 `k` 是唯一任务的数量。
* **空间复杂度：O(k)**。 堆和频率映射所需的存储空间与唯一任务的数量成正比，即 `k`。
