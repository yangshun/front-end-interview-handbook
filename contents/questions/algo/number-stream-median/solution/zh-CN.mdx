import MDXCodeBlock from 'MDXCodeBlock';

import getMedianFromDataStream from '../setup/src/number-stream-median.ts';
import getMedianFromDataStreamBruteForce from '../setup/src/number-stream-median-brute-force.ts';

## 1. 使用排序的暴力方法

此问题的目标是动态地计算数字流的中位数。暴力方法维护一个到目前为止收到的所有数字的列表，并在每次请求中位数时对列表进行排序后计算中位数。

中位数定义为：

* 如果数字总数为奇数，则为中间元素。
* 如果数字总数为偶数，则为两个中间元素的平均值。

此方法通过以下方式工作：

1. 将所有传入的数字存储在一个数组中。
2. 每次调用 `getMedian` 方法时对数组进行排序，以确保数字按升序排列。
3. 根据排序后的数组计算中位数。

### 算法

1. 创建一个 `NumberStream` 类，其中包含一个私有数组 `store`，用于保存所有传入的数字。
2. 定义一个 `add` 方法，用于将数字追加到 `store` 数组中。
3. 定义一个 `getMedian` 方法来计算中位数：
   1. 按升序对 `store` 数组进行排序。
   2. 确定数组的大小 (`n`)。
   3. 如果 `n` 为奇数，则返回中间元素。
   4. 如果 `n` 为偶数，则计算两个中间元素的平均值并返回结果。

<MDXCodeBlock>
  {getMedianFromDataStreamBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。对数组进行排序主导了 `getMedian` 方法的运行时。将数字添加到 `store` 数组需要 O(1) 的时间。
* **空间复杂度：O(n)**。`store` 数组随流中元素的数量线性增长。

## 2. 使用两个堆

此解决方案通过使用两个堆来优化在动态数据流中查找中位数的过程：一个最大堆和一个最小堆。核心思想是维护两个平衡的堆：

1. 一个最大堆 (`maxHeap`)，包含较小的一半数字。
2. 一个最小堆 (`minHeap`)，包含较大的一半数字。

堆的结构使得最大堆的顶部表示较小一半中的最大数字，最小堆的顶部表示较大一半中的最小数字。这种结构允许高效地检索中位数：

* 如果堆的大小是平衡的，则中位数是两个堆的顶部的平均值。
* 如果最大堆比最小堆多一个元素，则中位数是最大堆的顶部。

该方法确保堆在每次插入后保持平衡：

1. 首先将一个新数字添加到最大堆中。
2. 将最大堆中的最大数字移动到最小堆中以保持顺序。
3. 如果最小堆增长到大于最大堆，则将最小堆中的最小数字移回最大堆。

通过使用堆属性，该解决方案避免了暴力方法中的 O(n log n) 排序步骤，实现了插入和中位数计算的 O(log n) 时间复杂度。

### 算法

1. 初始化两个堆：
   * `maxHeap` 用于较小的一半数字。
   * `minHeap` 用于较大的一半数字。
2. 定义一个 `add` 方法，用于将新数字插入数据流：
   1. 将数字添加到 `maxHeap`。
   2. 将 `maxHeap` 中最大的数字移动到 `minHeap` 以保持顺序。
   3. 如果 `minHeap` 增长大于 `maxHeap`，则将 `minHeap` 中最小的数字移回 `maxHeap`。
3. 定义一个 `getMedian` 方法来计算中位数：
   1. 如果 `maxHeap` 的元素多于 `minHeap`，则返回 `maxHeap` 的顶部元素。
   2. 否则，返回两个堆顶部的平均值。
4. 使用堆操作的实用函数：
   * `addNumberToHeap` 用于在保持堆属性的同时插入数字。
   * `removeTopFromHeap` 用于在恢复堆属性的同时删除顶部元素。
   * `heapify` 用于确保从给定索引向下的堆属性。

<MDXCodeBlock>{getMedianFromDataStream}</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n log n)**。每次插入都涉及 O(log n) 的时间复杂度来维护堆属性。
* **空间复杂度：O(n)**。堆一起存储数据流中的所有元素。
