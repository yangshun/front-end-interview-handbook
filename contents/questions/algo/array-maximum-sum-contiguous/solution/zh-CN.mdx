import MDXCodeBlock from 'MDXCodeBlock';

import maxSumSubArray from '../setup/src/array-maximum-sum-contiguous.ts';
import maxSumSubArrayBruteForce from '../setup/src/array-maximum-sum-contiguous-bruteforce.ts';

## 1. 暴力破解方法

暴力破解方法用于查找最大和连续子数组，它会检查每个可能的子数组。这包括将每个元素作为起始点进行迭代，然后通过逐个包含后续元素来扩展子数组。当形成每个子数组时，计算其总和，并更新到目前为止找到的最大总和。这确保了每个子数组的总和都被评估和比较。

### 算法

1. 将变量 `maxSubarray` 初始化为 `Number.NEGATIVE_INFINITY`。
2. 使用循环索引 `i` 从数组的开头开始迭代。
3. 对于每个 `i`，将 `currentSubarray` 初始化为 0。
4. 使用另一个循环索引 `j` 从 `i` 迭代到数组的末尾。
5. 将 `numbers[j]` 添加到 `currentSubarray`。
6. 使用 `maxSubarray` 和 `currentSubarray` 之间的最大值更新 `maxSubarray`。
7. 在两个循环完成后，返回 `maxSubarray`。

<MDXCodeBlock>
  {maxSumSubArrayBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n²)**。使用两个嵌套循环来考虑所有可能的子数组。
* **空间复杂度：O(1)**。仅使用常量数量的额外空间。

## 2. 使用 Kadane 算法

之前的暴力破解方法枚举了所有可能的子数组并计算了它们的总和。这个过程涉及重复对重叠子数组求和，这会产生不必要的工作，导致 O(n²) 的复杂度。Kadane 算法通过维护一个运行的 `currentSum` 并在每一步更新它来解决这个问题。该算法没有重新计算整个子数组的总和，而是决定是扩展现有的子数组还是从当前元素开始一个新的子数组。全局 `maxSum` 会不断更新，确保跟踪遇到的最大总和，而无需枚举每个可能的子数组。这消除了不必要的重复工作，并将复杂度降低到 O(n)。

### 算法

1. 将 `currentSum` 初始化为 `0`，将 `maxSum` 初始化为 `-Infinity`。
2. 遍历数组中的每个元素 `num`。
3. 将 `currentSum` 更新为 `Math.max(num, currentSum + num)`。
4. 将 `maxSum` 更新为 `Math.max(maxSum, currentSum)`。
5. 返回 `maxSum`。

<MDXCodeBlock>
  {maxSumSubArray}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。每个元素只访问一次。
* **空间复杂度：O(1)**。除了几个变量外，不需要额外的空间。
