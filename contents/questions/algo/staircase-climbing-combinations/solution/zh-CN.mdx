import MDXCodeBlock from 'MDXCodeBlock';

import staircaseClimbingCombinations from '../setup/src/staircase-climbing-combinations.ts';
import staircaseClimbingCombinationsBruteForce from '../setup/src/staircase-climbing-combinations-bruteforce.ts';

## 1. 暴力解法

此解决方案使用递归计算爬楼梯的不同方式的数量，给定楼梯的步数。在每一步，爬楼梯的人可以选择走 1 步或 2 步。通过递归计算从当前步数到达顶部的总方式数来解决该问题。

该算法使用一个辅助函数来探索所有可能的步数组合：

1. 如果当前步数超过总步数，则路径无效，因此返回 0。
2. 如果当前步数等于总步数，则表示有效路径，因此返回 1。
3. 对于所有其他情况，它通过从当前步数走 1 步或 2 步来递归计算到达顶部的总方式数。

这种暴力方法探索所有可能的路径以找到组合的总数。但是，它会进行冗余计算，因为多次解决相同的子问题，这会增加其计算成本。

### 算法

1. 定义一个函数 `staircaseClimbingCombinations`，该函数从第 `0` 步开始调用辅助函数 `climbFromStep`。
2. 辅助函数 `climbFromStep` 将当前步数和总步数作为输入：
   1. 如果当前步数超过总步数，则返回 `0`，因为它无效。
   2. 如果当前步数等于总步数，则返回 `1`，因为它表示有效路径。
   3. 通过求和递归计算总方式数：
      * 走 1 步的结果 (`climbFromStep(currentStep + 1, totalSteps)`)。
      * 走 2 步的结果 (`climbFromStep(currentStep + 2, totalSteps)`)。
3. 返回辅助函数的结果。

<MDXCodeBlock>
  {staircaseClimbingCombinationsBruteForce}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(2<sup>n</sup>)**。每一步都分支为两个递归调用，导致指数级的函数调用。
* **空间复杂度：O(n)**。递归堆栈最多可以增长到 `n` 的深度，其中 `n` 是总步数。

## 2. 使用动态规划

此解决方案使用动态规划 (DP) 计算爬楼梯的不同方式的数量，给定楼梯的步数。通过将其分解为较小的子问题并将这些子问题的结果存储在 `dp` 数组中以避免冗余计算来解决该问题。

直觉是，要到达第 `i` 步，有两种可能的方式：

1. 从第 `i-1` 步走一步。
2. 从第 `i-2` 步走两步。

这种关系导致了递归公式：`dp[i] = dp[i-1] + dp[i-2]`。使用此公式，该解决方案迭代地构建 `dp` 数组，从基本情况开始：

* 停留在第 `0` 步只有 1 种方式（什么都不做）。
* 到达第 `1` 步只有 1 种方式（一步）。

`dp[steps]` 中的最终值给出了到达楼梯顶部的总方式数。

### 算法

1. 创建一个大小为 `steps + 1` 的 `dp` 数组，初始化为 `-1`，用于存储到达每一步的方式数。
2. 初始化基本情况：
   1. 设置 `dp[0] = 1`，因为停留在第 `0` 步有一种方式。
   2. 设置 `dp[1] = 1`，因为到达第 `1` 步有一种方式（一步）。
3. 使用循环从第 `2` 步到 `steps` 填充 `dp` 数组：
   1. 对于每一步 `i`，将 `dp[i]` 计算为 `dp[i-1]`（从前一步到达的方式）和 `dp[i-2]`（从前两步到达的方式）的总和。
4. 返回 `dp[steps]` 中的值，作为到达楼梯顶部的不同方式的总数。

<MDXCodeBlock>
  {staircaseClimbingCombinations}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(n)**。`dp` 数组在从 `0` 到 `steps` 的单次遍历中被填充。
* **空间复杂度：O(n)**。`dp` 数组需要额外的空间，与步数成正比。
