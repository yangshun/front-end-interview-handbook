import MDXCodeBlock from 'MDXCodeBlock';

import lowestCommonAncestorOfABinarySearchTree from '../setup/src/binary-search-tree-lowest-common-ancestor.ts';
import lowestCommonAncestorOfABinarySearchTreeIteration from '../setup/src/binary-search-tree-lowest-common-ancestor-iteration.ts';

## 1. 使用递归

在二叉搜索树 (BST) 中寻找最近公共祖先 (LCA) 的问题利用了 BST 的有序属性。 LCA 是一个节点，其中一个节点 (`a`) 位于当前节点的一侧，而另一个节点 (`b`) 位于另一侧，或者当前节点本身是要搜索的节点之一。

对于 BST 中的任何节点，左子树中的所有值都较小，右子树中的所有值都较大。 此属性简化了查找 LCA 的过程。

该算法检查 `a` 和 `b` 的值相对于当前节点 (`root`) 的值。

* 如果两个值都大于当前节点的值，则 LCA 必须位于右子树中。
* 如果两个值都较小，则 LCA 必须位于左子树中。
* 如果一个值在左侧，另一个值在右侧（或者其中一个节点与当前节点匹配），则当前节点是 LCA。

该算法根据 `a` 和 `b` 的相对值递归遍历树，直到找到 LCA。

### 算法

1. 检查基本情况：
   * 如果 `root` 为 `null`，则返回 `null`，因为没有祖先。
2. 检索当前节点 (`parentVal`)、`a` (`aVal`) 和 `b` (`bVal`) 的值。
3. 将 `aVal` 和 `bVal` 与 `parentVal` 进行比较：
   1. 如果 `aVal` 和 `bVal` 都大于 `parentVal`，则使用右子树 (`root.right`) 作为新根递归调用该函数。
   2. 如果 `aVal` 和 `bVal` 都小于 `parentVal`，则使用左子树 (`root.left`) 作为新根递归调用该函数。
   3. 如果一个值在左侧，另一个值在右侧，或者一个值与 `parentVal` 匹配，则返回当前节点 (`root`) 作为 LCA。

<MDXCodeBlock>
  {lowestCommonAncestorOfABinarySearchTree}
</MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(h)**。 该算法遍历树的高度，其中 `h` 是 BST 的高度。 在平衡的 BST 中，这是 O(log n)，在最坏的情况下（不平衡树），这是 O(n)。
* **空间复杂度：O(h)**。 递归堆栈需要与树的高度成比例的空间。

## 2. 使用迭代

在二叉搜索树 (BST) 中寻找最近公共祖先 (LCA) 的迭代方法使用 BST 的属性，无需递归即可从根节点导航到 LCA。 LCA 被标识为两个节点 (`a` 和 `b`) 的路径发散或其中一个节点与当前节点匹配的节点。

在 BST 中，左子树中的所有值都小于根，右子树中的所有值都大于根。 此属性有助于确定遍历方向：

* 如果 `a` 和 `b` 都小于当前节点，则 LCA 位于左子树中。
* 如果 `a` 和 `b` 都大于当前节点，则 LCA 位于右子树中。
* 如果一个节点在左侧，另一个节点在右侧，或者一个节点与当前节点匹配，则当前节点是 LCA。

该算法通过基于比较迭代移动指针 (`node`) 来消除递归，从而保持效率和简单性。

找到 LCA 后，遍历立即停止，避免了不必要的操作。

### 算法

1. 检索 `a` 和 `b` 的值 (`aVal` 和 `bVal`)。
2. 将指针 `node` 初始化为 BST 的根。
3. 使用 `while` 循环遍历 BST，直到 `node` 为 `null`：
   1. 检索当前节点的值 (`parentVal`)。
   2. 将 `aVal` 和 `bVal` 与 `parentVal` 进行比较：
      * 如果两者都大于 `parentVal`，则将 `node` 移动到右子节点 (`node = node.right`)。
      * 如果两者都小于 `parentVal`，则将 `node` 移动到左子节点 (`node = node.left`)。
      * 否则，当前节点是 LCA；返回它。
4. 如果未找到 LCA（边缘情况），则返回 `null`。

<MDXCodeBlock> {lowestCommonAncestorOfABinarySearchTreeIteration} </MDXCodeBlock>

### Big-O 分析

* **时间复杂度：O(h)**。该算法遍历树的高度，其中 `h` 是 BST 的高度。在平衡 BST 中，这是 O(log n)，在最坏情况下（不平衡树），这是 O(n)。
* **空间复杂度：O(1)**。该算法使用恒定的空间量，因为没有递归或辅助数据结构。
