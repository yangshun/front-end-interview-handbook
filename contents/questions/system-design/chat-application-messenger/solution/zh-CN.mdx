## 需求探索

### 需要哪些核心功能？

* 向用户发送消息。
* 接收来自用户的消息。
* 查看用户与用户的聊天记录。

### 消息接收是实时的吗？

是的，用户应该尽可能快地实时接收消息，而无需刷新页面。

### 应该支持什么样的消息格式？

让我们支持可以包含表情符号的文本格式。 如果有时间，我们可以讨论支持图像。

### 应用程序需要离线工作吗？

是的，如果可能的话。 传出的消息应该被存储并在应用程序上线时发送出去，即使它们处于离线状态，也应该允许用户浏览消息。

### 是否有群聊？

我们可以假设它是一对一的消息服务。

***

## 架构/高级设计

传统应用程序与可以离线使用的聊天应用程序之间的主要区别在于，如果应用程序失去网络连接，理想情况下，某些功能（例如浏览设备上的消息和搜索）仍应起作用。 这极大地影响了应用程序架构，并且它将与传统的 Web 应用程序大相径庭。

### 要处理的棘手场景

首先，让我们意识到我们需要在聊天应用程序中处理的各种棘手场景及其影响。

* **在同一浏览器的不同选项卡中使用该应用程序。** 用户可能会这样做，因为他们想同时与不同的人聊天，而不是在同一选项卡中切换对话，而是在选项卡之间切换。
  * 用户应该看到每个对话的相同消息 -> 依赖于可在同一浏览器中的不同选项卡之间访问的存储。
* **在不同的设备/浏览器上使用该应用程序。** 相同设备，不同浏览器的情况很少见，但用户同时使用多个设备（工作和个人设备）的情况并不少见。
  * 用户应该看到每个对话的相同消息 -> 在初始加载时与服务器同步并获取最新数据。
* **应用程序在使用过程中离线。** 用户在移动过程中可能会失去连接，并且会穿过低连接区域（地铁中常见的情况）。
  * 传出的消息尚未全部完成 -> 应用程序再次上线时应重试，或者如果它们已写入服务器但未收到更新，则应更新其状态。
  * 应用程序离线时正在发送消息 -> 这些消息应在应用程序下次上线时发送出去。 但是，这应该仅针对最近发送的消息完成。 如果这些消息发送的时间太长，则对话可能已经超出了主题（可能使用其他设备），并且重试发送它不再有意义。
* **上述场景的组合。** 生活变得更加艰难！

我们选择的架构应该处理所有这些场景。

### 客户端数据库

在客户端存储数据的一种方法是使用客户端数据库（以下简称数据库）。UI 从数据库中读取数据，就像它是一个仅客户端的应用程序，而不是传统的应用程序，在传统应用程序中，UI 直接发出 HTTP 查询并显示获取的数据。UI 不知道也不应该知道数据库从哪里获取数据。数据库从哪里获取数据应该是数据层的实现细节。

同一浏览器中的不同标签页访问相同的客户端数据库。这确保了标签页之间的数据一致性，并有助于解决“在同一浏览器中的不同标签页上使用应用程序”场景中的 UI 一致性问题。但是，当收到“新消息”事件的通知时，我们必须注意不要向数据库中插入两次。

### 数据同步器

数据同步器是一个负责将客户端数据库与服务器同步的模块。

#### 发送消息

当用户发出消息（或用户通常进行的任何更新）时，我们希望立即反映这些更改。在显示更新的 UI 之前等待服务器的确认会带来糟糕的用户体验。

因此，传出的聊天消息/用户操作首先被插入到数据库中，并且它们被标记为待处理。待处理的消息也会立即反映在 UI 中。请注意，聊天应用程序中的消息具有指示各种消息传递状态的指示器。

| 消息状态 | 描述 | Messenger | WhatsApp |
| --- | --- | --- | --- |
| 正在发送 | 应用程序正在尝试发送消息 | 空心圆 | 时钟图标 |
| 已发送 | 消息已成功发送到服务器 | 轮廓圆中的复选标记 | 单个灰色复选标记 |
| 已送达 | 消息已送达给收件人 | 填充圆中的复选标记 | 双灰色复选标记 |
| 已读 | 收件人已阅读消息 | 用户资料图片的微型版本 | 双蓝色复选标记（或勾号） |
| 失败 | 消息发送失败 | 圆圈中的感叹号图标 | 圆圈中的感叹号图标 |

*来源：[Messenger 帮助中心](https://www.facebook.com/help/messenger-app/926389207386625) 和 [WhatsApp 帮助中心](https://faq.whatsapp.com/665923838265756/)*

{/* TODO: 替换为图片 */}

您可能听说过“她给我打了双蓝勾”这句话，意思是某人阅读了消息但没有回复。现在您知道了其他消息状态是什么 😎。

在数据库同步期间，服务器收到并确认该操作后，它会向应用程序发回响应，并且这些消息可以被标记为“已发送”。

由于可以在不同的对话中并行发送多条消息（在实际应用中，甚至有更多操作，如反应、删除消息），因此需要一个调度程序来确保操作以正确的顺序发送到服务器，跟踪请求状态，重试请求失败等。

#### 接收实时更新

因为我们希望实时接收消息更新，所以应用程序需要尽快收到来自后端的关于新消息的通知。我们将在“优化”部分讨论几种获取实时更新的方法。

### 服务器端渲染还是客户端渲染？

聊天应用程序具有以下特征：

* 由于发送和接收消息的频率很高，因此本质上具有高度交互性。该页面可能需要大量的 JavaScript。
* 只能在登录后才能访问消息。
* 消息不必（也不应该！）被搜索引擎索引。
* 期望快速的初始加载速度，但不是最关键的。

考虑到以上几点，纯客户端渲染和单页应用程序的整体架构将运行良好。我们可以使用服务器端渲染 (SSR) 和客户端水合，就像在 [新闻提要系统设计](/questions/system-design/news-feed-facebook) 和 [照片共享应用程序系统设计](/questions/system-design/photo-sharing-instagram) 中一样，以实现快速的初始加载，但 SSR 的好处将仅限于性能提升，因为聊天应用程序不需要对 SEO 友好。启用 SSR 带来的额外工程复杂性可能不值得。

### 架构图

![聊天应用程序架构](/img/questions/chat-application-messenger/chat-application-architecture.png)

#### 组件职责

* **聊天 UI**：包含一个对话列表和当前选定的对话/会话
  * **对话列表**：显示对话列表（用户、最后一条消息、最后一条消息时间戳）。
  * **选定的对话**：对话中的消息列表和一个用于输入新消息的输入框。
* **控制器**：控制应用程序内的数据流。从数据库中获取数据以在 UI 中显示。将数据写入数据库。
* **数据同步器**：包含数据库并管理传出消息的模块。 还会从服务器接收更新并相应地更新数据库。
  * **客户端数据库**：用于存储 UI 中需要显示的所有数据的数据库。
  * **消息调度程序**：监视传出消息，安排它们发送并管理它们的状态。

***

## 数据模型

为了简单起见，我们将只关注应用程序的聊天功能。

### 客户端数据库

应用程序所需的大部分数据将存储在客户端数据库中。 任何需要离线功能的数据都应该进入数据库。 这是数据库表的实体关系图。

<img alt="聊天应用程序数据模型" className="mx-auto w-full max-w-5xl" src="/img/questions/chat-application-messenger/chat-application-data-model.png" />

| 表/实体 | 同步到服务器 | 由...使用 | 描述 |
| --- | --- | --- | --- |
| `Conversation` | 是 | 对话列表 | 用户之间的对话（目前只有两个用户） |
| `Message` | 是 | 对话 | 用户发送的文本消息。 `status` 是 `sending`、`sent`、`delivered`、`read`、`failed` 之一 |
| `User` | 是 | 全部 | 用户身份 |
| `ConversationUser` | 是 | - | 将用户和对话关联起来以允许多对多关系。 `Conversation` 目前最多只有两个 `User`，但通过这种设计，它可以支持所需的数量 |
| `DraftMessage` | 否 | 对话 | 存储半写、未发送的消息 |
| `SendMessageRequest` | 否 | 消息调度程序 | 跟踪要发送的消息的状态 |

请注意，`DraftMessage` 和 `SendMessageRequest` 表不会同步到服务器，并且仅限客户端。 但是，它们仍应位于数据库中，而不是仅限客户端状态，因为它们应该在会话之间保持持久性。

* `DraftMessage`：此表存储用户在对话的消息输入框中键入但尚未发送的消息。 这必须持久保存在数据库中（而不是仅限客户端状态），这样如果用户退出应用程序并再次打开它，他们就不会丢失未发送的消息。 每个对话每个用户最多可以有一个 `DraftMessage`。
  * 请注意，草稿消息不会与服务器同步，因此它保留在当前设备中。 将草稿消息与服务器同步以便它们可以在所有设备上访问是完全可行的，但这是一个产品决策，为了专注于核心用例，我们现在不会对此进行探讨。
* `SendMessageRequest`：此表存储与用户已发送但尚未被服务器确认的每条消息相关的数据。 `status` 是一个枚举，可以是以下之一：
  * `pending`：要发送的新消息的默认状态。
  * `in_flight`：应用程序已将消息发送到服务器，但尚未收到响应。
  * `fail`：当服务器返回错误或发送请求超时时。 我们跟踪它失败的次数 `fail_count`，以便我们知道是继续重试（使用指数退避）还是在一定次数的失败后停止重试。
  * `success`：表示消息已收到并被服务器确认。 严格来说，不需要此枚举值，因为当客户端收到服务器确认时，可以从表中删除此行。

### 仅客户端状态

这些是无需在数据库中持久保存的状态字段，即如果用户通过关闭浏览器选项卡/窗口退出应用程序，则丢失此数据是可以的。

* **选定的对话**：当前选定的对话。
* **对话滚动位置**：每个对话中的滚动位置。 每当用户在对话之间切换时，恢复滚动位置很有用。
* **对话传出消息**：这是用户在特定对话中键入的任何内容。 它几乎与 `DraftMessage` 相同，只是我们不应该在每次按键时保存到数据库中。 我们仅在用户停止键入（通过模糊/去抖动）或节流以在每 X 毫秒后将值保存到数据库后才持久保存到 `DraftMessage` 表中。

***

## 接口定义 (API)

需要以下 API：

* 发送消息
* 同步传出消息
* 服务器事件
* 获取对话
* 获取对话消息

### 发送消息

1. 将一行添加到 `Message` 表中，状态为 `sending`。
2. 将一行添加到 `SendMessageRequest` 表中，状态为 `pending`。
3. 对话 UI 从 `Message` 表中读取并显示带有“正在发送”指示器的新消息。
4. 删除当前对话/会话的任何 `DraftMessage` 行。
5. 此时，没有剩余的同步步骤需要完成。 消息调度程序将负责将 `pending` 消息与服务器同步。

### 同步传出消息

消息调度程序将负责将传出消息与服务器同步。 它将维护自己的任务队列并监视 `SendMessageRequest` 表。 由于任务队列需要在选项卡之间同步，因此它不应存储在浏览器内存中，也可以使用另一个表。

只要表不为空，它就会获取前 X 行（按 id 排序），并尝试通过将任务添加到其自己的任务队列来处理它们。X 是一个可配置的值。取决于行的 `status` 列：

* `pending`：将任务排队，通过实时通道将消息发送到服务器。将行的 `status` 更新为 `in_flight`。
* `in_flight`：检查 `last_sent_at` 时间戳。如果它超过了超时阈值，则将行的 `status` 更新为 `fail`，并将 `fail_count` 增加 1。
* `fail`：将任务排队，以便在将来的某个时间重试发送此消息。延迟时间取决于 `fail_count`。使用指数退避重试策略，延迟时间将随 `fail_count` 呈指数增长。

### 服务器事件

数据同步器将以事件的形式从服务器接收实时更新。每个事件可以有一个类型和一个 payload 字段。payload 的形状取决于实际事件。

```json
// 服务器推送的示例事件 payload。
{
  "event_name": "incoming_message",
  "payload": {
    "foo": "value_a",
    "bar": "value_b"
  }
}
```

这些是必要的各种事件：

#### `message_sent` 事件

1. 将 `Message` 的 `status` 更新为 `sent`。
2. 在消息调度程序中清理此消息：
   1. 从 `SendMessageRequest` 表中删除与此消息对应的行。此消息已由服务器接收，不再处于 `pending` 或 `in_flight` 状态。
   2. 删除任务队列中与此消息相关的任何任务。
3. 更新 UI
   * 如果当前显示该消息的对话，则通知对话 UI 进行更新。

#### `message_delivered` 事件

1. 将 `Message` 的 `status` 更新为 `delivered`。
2. 更新 UI
   * 如果当前显示该消息的对话，则通知对话 UI 进行更新。

#### `message_failed` 事件

1. 更新 `SendMessageRequest` 表中与此消息对应的行，并将 `status` 更改为 `fail`，并将 `fail_count` 增加 1。
   1. 请注意，我们尚未将 `Message` 表中行的 `status` 修改为 `fail`。在重试发送消息之前，该消息尚未被视为失败。
2. 更新 UI
   * 如果当前显示该消息的对话，则通知对话 UI 进行更新。

#### `incoming_message` 事件

1. 将新消息追加到 `Message` 表中。
   1. 如果不存在，则在 `Conversation` 表中创建一个新行。
   2. 如果消息的发件人尚未存在，则在 `User` 表中为该发件人创建一个新行。
2. 更新 UI
   * 通知对话列表 UI 进行更新。更新 UI 以将此对话显示在顶部。如果对话列表按每个对话的最新消息的递减时间戳排序，它将自动显示在顶部。
   * 如果当前显示该消息的对话，则通知对话 UI 进行更新。

#### `sync` 事件

{/* TODO */}

**进行中。** 当客户端首次连接到服务器时，会触发此事件。当客户端首次连接到服务器时，它们可能在它们包含的数据方面滞后。这里的目标是通过服务器发送客户端缺少的所有数据，使每个客户端与最新的服务器状态保持同步。

指示客户端状态给服务器的可能方法：

1. **客户端的上次更新时间戳**：服务器将收集时间戳之后创建的所有新实体（消息、对话），并发送给客户端，供客户端插入到数据库中。
2. **每个对话的游标**：数据库游标是一种机制，用于遍历数据库中的记录。类似于基于游标的分页 API，游标可用于指示客户端收到的对话中的最后一条消息，以及该消息之后的消息。

## 优化和深入研究

### 客户端数据库

#### 决定客户端存储

有几种在客户端存储数据的方法：Cookies、Web Storage 和 IndexedDB。请参考测验问题，了解[关于 cookies 和 Web Storage 机制的比较](/questions/quiz/describe-the-difference-between-a-cookie-sessionstorage-and-localstorage)。

由于容量极小（每个域 4kb），Cookies 无法使用。`localStorage`（Web Storages 之一）不太适合，因为它不支持结构化数据，而结构化数据对于像聊天这样重要的应用程序至关重要。

[IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) 是我们在这里的最佳选择，它是一个用于客户端存储大量**结构化数据**（包括文件/blob）的低级 API。其他有用的功能包括数据库索引、表、游标、事务，主要通过异步 API 实现。

#### 跨标签页同步

由于 IndexedDB 是一种客户端存储机制，因此数据可以在各个标签页之间访问，并且它解决了顶部概述的“用户应该在同一浏览器中的不同标签页上的应用程序中看到相同的消息”场景。

但是，浏览器标签页并不知道其他标签页中的 `IndexedDB` 数据更改。要通知其他标签页有关数据库更改的信息，请使用 [`BroadcastChannel`](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel)，它允许同一来源的不同窗口/标签页/框架之间进行通信。

#### 将客户端数据库与服务器同步

客户端和服务器之间的消息双向同步很复杂。

* **乱序消息**：不能保证消息按发送顺序接收。是否应该根据时间戳将乱序消息插入到现有消息之间，或者是否应该始终将它们附加到对话的底部？
* **获取新消息**：客户端需要告诉服务器上次更新的时间（可以是收到的最后一条消息，也可以是上次从服务器提取的时间戳），服务器会找出尚未发送给客户端的消息并发送它们。
* **发送待处理消息**：应用程序离线时发送的消息应存储在待处理的传出消息队列中，并在应用程序上线时发送。

#### 其他问题

* 不支持的环境，例如 Firefox 和 Safari 上的隐私/隐身模式。
* 存储限制。
* 初始化/打开数据库时出错。
* IndexedDB 附带许多[问题、错误和怪癖](https://gist.github.com/pesterhazy/4de96193af89a6dd5ce682ce2adff49a)。
* [使用 IndexedDB 的最佳实践](https://web.dev/indexeddb-best-practices/)

{/* TODO: 详细讨论其中一些问题。 */}

### 实时更新

实时消息传递意味着消息的接收者会立即（或接近立即）收到新消息，而无需他们重新启动应用程序/刷新页面或手动触发按钮来获取新消息。

实现实时消息传递的几种方法：

* 短轮询（或定期轮询）
* 长轮询
* Web Sockets

**进行中**：评估每种实时机制的优缺点。Web Sockets 是现代选择，也是大多数聊天应用程序使用的机制。

{/* TODO */}

参考：[WebSockets vs 长轮询](https://ably.com/blog/websockets-vs-long-polling)

### 网络

连接失败非常常见，因为用户可能在交通工具上使用聊天应用程序，并且进出连接不良的区域。消息可能无法发送出去，以及其他问题：

* **离线使用**：应用程序应检测设备是否离线，如果离线，则不尝试发送消息。消息应添加到 `SendMessageRequest` 表中。
* **失败**：应使用指数退避重试失败的传出消息。
  * 如果在 X 次重试后消息未成功发送，则显示错误消息。
* **批处理**：如果消息发送速度很快（在几秒钟内），则可以将传出消息分批发送并作为单个消息发送。如果用户在发送最后一条消息后仍在键入，则应用程序可以检测到，并且可能等待下一条消息完成，然后再发出请求（类似于防抖）。此批处理逻辑最好在消息调度程序中实现。
* **乱序**：如果我们通过单独的请求发送每条消息，则无法保证消息以客户端发送的顺序到达服务器。但是，顺序发送消息也不是很理想。批处理通过在一个有效负载中发送多条消息，但也保持顺序来帮助缓解此问题。
* **断开连接**：应用程序应在断开连接后自动尝试重新连接，而无需用户刷新页面。

### 性能

* 延迟加载初始加载不需要的组件（例如表情符号选择器、任何弹出窗口/模态框）。
* 对话中的长消息列表使用窗口化/虚拟化。

### 可访问性

实现基本的键盘快捷键：

* 消息撰写器
  * 按 Enter 键发送消息。
  * Shift + Enter 在消息中添加新行。
* 在对话之间
  * 快捷方式聚焦搜索栏。
  * <kbd>Ctrl</kbd>/<kbd>Cmd</kbd> + <kbd>Up</kbd>/<kbd>Down</kbd> 在
    对话之间切换。
  * 在某些桌面客户端上，<kbd>Ctrl</kbd>/<kbd>Cmd</kbd> + 数字键将带您进入对话列表中的第 n 个对话。

### 离线支持

该应用程序可以构建为渐进式 Web 应用程序 (PWA)，它使用服务工作者来缓存资产 (HTML/JS/CSS)，以便该应用程序同时具有离线使用的代码和数据。

使用 PWA 还允许浏览器通知，这对于通知用户即使选项卡未处于焦点/可见状态也有新消息非常有用。

### 用户体验

#### 保持滚动位置

由于可能会在列表的上方和下方添加新消息，因此滚动位置是消息传递应用程序中一个棘手的问题。

滚动位置应为：

1. 当新消息进入并且滚动位置已位于列表底部时，保持在消息列表的底部。这是大多数情况下的默认方案。
2. 当滚动位置不在底部时保持，以便当前可见的内容仍然可见。向上滚动以阅读较旧的聊天消息时，应保持滚动位置，并且当前可见的元素不应移动，即使更多 DOM 元素将添加到顶部。应用程序可以计算当前的滚动偏移量、要附加的新元素的高度，并修改滚动高度以添加新元素的高度。

以下是可能更改（滚动/客户端）高度的事件：

* 在下方插入新消息（接收新消息时）。
* 在上方插入新消息（搜索历史记录时）。
* 窗口调整大小。
* 媒体完全加载，其高度与加载占位符不同。
  * 通过使用固定高度的占位符并在该元素内呈现媒体来避免此问题。
* 页面缩放更改。

应根据上面列出的情况保持滚动位置（位于底部或显示相同的内容）。

#### 其他可能的改进

* 添加一个“滚动到底部”按钮，当用户在对话消息中向上滚动时可见。

### 渐变效果

这篇文章由 CSS Trick 撰写，向您展示了实现 [Messenger 的聊天消息渐变背景](https://css-tricks.com/recreating-the-facebook-messenger-gradient-effect-with-css/) 的各种方法。

### 过时客户端

对于非常过时的客户端，他们将不得不下载自上次同步以来所有缺少的邮件列表，这可能非常庞大。这会导致启动应用程序和能够使用它之间出现明显的延迟。很少有人会喜欢等待数以万计的消息被提取并插入到客户端数据库中，然后才能使用该应用程序的过程。

一种可行的方法是将其视为数据库中不存在的全新加载/现有数据，并与服务器进行完全同步，仅获取最新 M 个对话的最新 N 条消息。

### 高级

这些功能不会在此解决方案中讨论，但如果时间允许，您可能希望与面试官讨论它们。

* 搜索（使用在线和离线搜索的混合）
* i18n
* 端到端加密
  * [Facebook Messenger 中的 E2E 加密的挑战](https://www.youtube.com/watch?v=-IXJ7Q01gpY)
* 传递/已读回执
* 离线/乐观读取
* 反应
* 正在输入指示器
* 消失的消息
* 通知

***

## 参考

* Facebook & Messenger
  * [在桌面上启动 Instagram 消息传递](https://engineering.fb.com/2022/07/26/web/launching-instagram-messaging-on-desktop/)
  * [构建 Facebook Messenger](https://www.facebook.com/notes/10158791547142200/)
  * [逆向工程 Facebook Messenger API](https://intuitiveexplanations.com/tech/messenger)
  * [与 Mohsen Agsen 一起进行 Facebook Messenger 工程](https://softwareengineeringdaily.com/2020/03/31/facebook-messenger-engineering-with-mohsen-agsen/)
  * [F8 2019：Facebook：更轻、更快、更简单的 Messenger](https://www.youtube.com/watch?v=ulVLD2yzCrc)
  * [在 Facebook 上构建实时基础设施 - Facebook - SRECon2017](https://www.youtube.com/watch?v=ODkEWsO5I30)
  * [Facebook Messenger RTC – 规模的挑战和机遇](https://www.youtube.com/watch?v=F7UWvflUZoc)
  * [为 Messenger 构建移动优先的基础设施](https://engineering.fb.com/2014/10/09/production-engineering/building-mobile-first-infrastructure-for-messenger/)
  * [用于消息传递的 MySQL - @Scale 2014 - 数据](https://www.youtube.com/watch?v=eADBCKKf8PA)
  * [LightSpeed 项目：重写 Messenger 代码库，以实现更快、更小、更简单的消息传递应用程序](https://engineering.fb.com/2020/03/02/data-infrastructure/messenger/)
* Slack
  * [在 Slack 中管理焦点转换](https://slack.engineering/managing-focus-transitions-in-slack/)
  * [Gantry：Slack 的快速启动前端框架](https://slack.engineering/gantry-slacks-fast-booting-frontend-framework/)
  * [通过懒惰让 Slack 变得更快](https://slack.engineering/making-slack-faster-by-being-lazy/)
  * [通过懒惰让 Slack 变得更快：第 2 部分](https://slack.engineering/making-slack-faster-by-being-lazy-part-2/)
  * [通过增量启动更快地进入 Slack](https://slack.engineering/getting-to-slack-faster-with-incremental-boot/)
  * [Slack 上的 Service Workers：我们对更快启动时间和离线支持的追求](https://slack.engineering/service-workers-at-slack-our-quest-for-faster-boot-times-and-offline-support/)
  * [本地化 Slack](https://slack.engineering/localizing-slack/)
* Airbnb
  * [消息同步 — 在 Airbnb 上扩展移动消息传递](https://medium.com/airbnb-engineering/messaging-sync-scaling-mobile-messaging-at-airbnb-659142036f06)
