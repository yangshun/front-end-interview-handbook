## 解决方案

对于这个问题，我们能够重用现有的标记。复杂性在于渲染当前图像和新图像，以及动画过渡。

### CSS 过渡的复杂性

涉及在结束时移除动画元素的 CSS 过渡可能很难很好地实现。该元素需要在过渡期间保留在 DOM 中，然后被移除。移除该元素通常需要 JavaScript 干预。您需要协调 CSS 过渡持续时间与用于元素移除的 JavaScript 定时，这可能导致同步问题。

如果过渡被取消或中断（例如，通过快速切换状态），您需要优雅地处理这些情况，可能立即移除该元素或恢复到不同的状态。

确定如何处理正在过渡的元素上的事件可能很棘手。它们还应该具有交互性吗？如何防止意外交互？

当使用声明式 UI 框架时，很难构建涉及进入和离开 DOM 的过渡，因为这些框架根据当前状态呈现 UI。过渡通常涉及同时显示当前状态和新状态，这意味着您的 UI 代码必须同时包含当前状态和新状态值，并包含在它们之间正确过渡并具有正确时序的逻辑。在考虑了上面列出的场景后，这些可能很难正确实现。

因此，框架通常提供抽象来使实现动画更容易：

* React 没有提供任何一流的抽象，但支持 React 专用的动画库，如 [React Transition Group](https://reactcommunity.org/react-transition-group/) 和 [Framer Motion](https://framer.com/motion)。
* Angular 提供了 [`@angular/animations`](https://angular.dev/guide/animations) 模块。
* Vue 提供了 [`<Transition>`](https://vuejs.org/guide/built-ins/transition.html) 和 [`<TransitionGroup>`](https://vuejs.org/guide/built-ins/transition-group.html) 组件。
* Svelte 提供了 [`svelte/animate`](https://svelte.dev/docs/svelte-animate) 模块。

在生产案例中，大多数应用程序最好使用上述经过实战考验的库，而不是滚动自定义动画和过渡。

但是，为了练习目的，让我们通过从头开始实现过渡来完成这个问题。

### 如何过渡

由于当前图像和新图像不影响 DOM 布局，因此 CSS `transform` 属性是过渡的完美选择，原因如下：

* **GPU 加速**：许多浏览器可以将转换操作卸载到 GPU，从而产生更流畅的动画和更好的整体性能。
* **减少重绘**：与更改 `left` 和 `margin` 等属性不同，CSS `transform` 不会触发整个页面布局的重绘。

假设我们正在从第一张图像过渡到第二张图像，则可以这样执行过渡：

* 当前图像是默认状态，并且在没有任何 CSS 转换的情况下开始。它以 `transform: transformX(-100%)` 结束（向左移位，隐藏在视图之外）。
* 下一张图像以 `transform: transformX(100%)` 的 CSS 转换开始（向右移位，隐藏在视图之外）。它在没有任何 CSS 转换的情况下结束，因为它旨在以默认状态结束并替换当前图像。

我们可以创建以下 CSS 类来支持这些 CSS 过渡：

```css
.image-carousel__image {
  /* 其他不相关的 CSS 已省略。 */
  transition: transform 0.5s linear;
}

.image-carousel__image--displaced-left {
  transform: translateX(-100%);
}

.image-carousel__image--displaced-right {
  transform: translateX(100%);
}
```

通过切换顺序，这些类也可以用于支持从右到左方向的过渡。

### 过渡阶段

对于在两张图片之间过渡的图片轮播，过渡可以在以下阶段完成：

1. **空闲**: 仅在 DOM 中渲染当前图片。
2. **过渡前**: 收到导航到新图片的指令后（例如通过点击按钮），将两张图片（当前图片和下一张图片）渲染到 DOM 中。下一张图片尚未可见，但存在于 DOM 中，以便可以进行过渡。
3. **过渡中**: 当前图片移出（退出过渡）。下一张图片移入（进入过渡）。
4. **过渡结束**: 图片位于它们的新位置。当前图片不应再可见，可以从 DOM 中删除。只有下一张图片可见。
5. **回到空闲**: 下一张图片现在是当前图片，并且是 DOM 中渲染的唯一可见图片。

如前所述，该组件将需要支持当前状态和新状态，除了 `currIndex` 值之外，还需要两个新的状态值来支持上述过渡阶段——`nextIndex` 和 `isTransitioning`。

1. **空闲**: 在空闲阶段，图片轮播基于 `currIndex` 显示图片。
2. **过渡前**: 当按下按钮时，将调用 `changeImageIndex` 函数，该函数设置 `nextIndex` 值，轮播现在处于“过渡前”阶段。使用新的 `nextIndex` 值，将下一张图片渲染到 DOM 中（尚未可见）。在此阶段，两张图片都在 DOM 中，下一张图片位于不可见的位置。如上所述，可以使用 `transform: translateX(...)` 来实现位移。
3. **过渡中**: 过渡在下一帧中启动，借助 `requestAnimationFrame()`。如果没有在下一帧中启动过渡，则下一张图片没有初始状态可供过渡，并且过渡将不会发生。当前图片通过 `transform: translateX(...)` 移出，而下一张图片移入。下一张图片的结束状态没有任何 `transform` 属性。
4. **过渡结束**: 此时，原始图片已被移位且不再可见，下一张图片是唯一可见的剩余图片。将 `transitionend` 侦听器添加到下一张图片元素，以通知组件过渡已结束。
5. **回到空闲**: 各种状态值可以重置为“空闲”阶段。通过将 `currIndex` 设置为新值，将从 DOM 中删除上一张图片。对于使用虚拟 DOM 的框架，新的 `<img>` 元素应被用作当前图片。在 React 中，指定 `key` 值有助于向框架发出信号，以在渲染之间重用特定元素。如果没有 `key` 值，React 将尝试销毁 `<img>` 元素并重新创建它，从而弄乱过渡。

这是一个表格，演示了从第一张图片到第二张图片的各个阶段和相应的状态值：

| 阶段 | `currIndex` | `nextIndex` | `isTransitioning` | `currImage` | `nextImage` |
| --- | --- | --- | --- | --- | --- |
| 空闲 | 0 | `null` | `false` | 可见 | 不在 DOM 中 |
| 准备过渡 | 0 | 1 | `false` | 可见 | 移位（不可见） |
| 过渡中 | 0 | 1 | `true` | 过渡中 | 过渡中 |
| 过渡结束 | 0 | 1 | `true` | 移位（不可见） | 可见 |
| 返回空闲 | 1 | `null` | `false` | 不在 DOM 中 | 可见 |

如您所见，仅水平动画两张图片已经需要多个状态转换，添加更多动画时，代码很容易变得复杂。

### 过渡时的事件

如上所述，确定如何处理正在过渡的元素上的事件可能很棘手。它们是否仍应具有交互性？如何防止意外交互？

最简单、最合理的方法是在过渡进行时禁用按钮。`isTransitioning` 值可用于确定正在进行的过渡，并在这种情况下禁用按钮上的事件处理。

## 后续行动

我们实现的是一个简单的图片轮播。但是图片轮播可以包含更多功能和多个进一步的改进。以下是您可以期待的一些常见后续问题：

* 请注意，新图片可能需要一些时间来加载，并且会看到黑屏（由于背景颜色）。如何积极加载图片，以便不会出现加载闪烁？
* 如何支持自动播放功能，即轮播在指定持续时间后过渡到下一张图片？
* 如何支持无限的图片列表？
