## 解决方案

我们将在[数据表 II 的解决方案](/questions/user-interface/data-table-ii/solution)的基础上进行构建。

虽然在面试中可能不会逐字逐句地问到重构问题，但从这个练习中可以学到很多东西。

您也可以从一开始就以类似的方式构建数据表，以便可以轻松地扩展以满足新需求。

## 解耦组件

请注意，标头列已经声明为数组。 我们可以将其用作基础。 让我们看看 `DataTable` 的哪些部分仍然与用户数据耦合：

1. `sortUsers` 函数
2. `paginateUsers` 函数
3. 渲染表格单元格

为了进行重构，需要注意的一个重要概念是一流函数——将函数编写为变量，以便在其他地方传递和调用。 这使得特定于数据的逻辑可以存在于 `DataTable` 组件之外。

### `sortUsers` 函数

`sortUsers` 函数与用户数据高度耦合。 但是，仔细观察后，请注意函数中的分支对应于每一列，而每一列唯一的区别是比较器函数。

我们可以为每一列定义一个比较器函数，并让 `sortData` 函数（从 `sortUsers` 重命名）调用该列的比较器函数。 比较器函数返回一个数字，该数字用于确定数据数组中两个项目的相对位置。 每一列都可以在其中定义自定义排序逻辑，无论是比较数字还是字符串。

### `paginateUsers` 函数

此函数根本不与用户数据耦合。 它不关心数据的形状，只关心总大小和页面大小。 概括此功能非常简单。

### 渲染表格单元格

在当前阶段，渲染每一行的数据很简单——只需要不需要特殊格式的文本/数字数据。 但是，将来可能会有其他类型的数据，例如图像，或特殊的格式要求。

与比较器函数一样，可以为每一列定义一个 `renderCell()` 一流函数，该函数确定如何渲染该列的单元格数据。

### 提取数据、列和配置

现在我们已经设法概括了 `DataTable` 的必要部分，我们可以将数据和列移出组件，并将它们作为 props 传入。

如果用户数据包含一个新字段，我们只需在列配置中添加一个新项目，即可在表格中显示并按该列排序。

为了演示 `DataTable` 组件的灵活性，我们还使用它来渲染房屋数据。

## 后续行动

现在我们有了一个支持分页和排序的通用数据表，花点时间思考一下如何实现以下功能：

* 对每一列/字段进行过滤
* 从远程 API 获取已排序、分页和过滤的数据

看看[TanStack Table](https://tanstack.com/table/)，了解一下生产就绪的数据表库有哪些功能，以及复杂的数据表可以有多复杂。
