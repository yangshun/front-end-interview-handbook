## 解决方案

我们将在[Modal Dialog II 的解决方案](/questions/user-interface/modal-dialog-ii/solution)的基础上进行构建。由于我们正在为模态对话框组件添加新的交互，因此大部分样式和结构都可以重复使用，而无需进行太多修改。

为了关闭对话框，需要支持两种新的交互方式：（1）按下 <kbd>Escape</kbd> 键，以及（2）点击对话框内容之外的区域。

要关闭对话框，我们只需调用 `onClose` 回调函数，所以关键在于何时触发该回调函数。

### 1. 按下 <kbd>Escape</kbd> 键

我们创建一个名为 `useOnKeyDown` 的通用 hook，它接受一个表示要响应的键盘按键的字符串键和一个在按下该键时触发的回调函数。

该 hook 为 `document` 添加了 `keydown` 事件监听器。在事件监听器回调函数中，检查 `event.key` 是否与 `key` 参数对应，如果对应，则触发回调参数。

要使用该 hook，请使用以下参数调用它：`useOnKeyDown('Escape', onClose)`。

### 2. 点击对话框内容之外的区域

实现此逻辑的棘手部分是确定点击是发生在对话框内容主体内部还是外部。值得庆幸的是，[`Node.contains()` 方法](https://developer.mozilla.org/en-US/docs/Web/API/Node/contains)是一个方便的方法，可用于确定一个节点是否是给定节点的后代，或者节点本身。当发生 `mousedown` 或 `touchstart` 事件时，检查 `event.target` 是否是模态对话框内容的后代，例如 `dialogEl.contains(event.target)`。

您可能尝试过使用 `click` 事件而不是 `mousedown`，但这不起作用，并且无法打开模态对话框。下面可以找到关于原因的解释。

有必要获取对模态对话框主体的引用。在 React 中，这是使用 `useRef()` hook 实现的。

此功能可以封装为 `useOnClickOutside` hook，它接受元素 ref 和回调函数。“点击外部”实际上是一个常见的实用程序 hook，并且可以在 [`usehooks-ts`](https://usehooks-ts.com/react-hook/use-on-click-outside#hook) 上找到该 hook 的更强大的实现（尽管它的名称如此，但默认事件实际上是 `mousedown`）。要使用该 hook，请使用以下参数调用它：`useOnClickOutside(dialogRef, onClose)`。

#### 为什么使用 `click` 事件不起作用

事件在 DOM 上冒泡，并且默认情况下，DOM 元素上的事件处理程序在事件的冒泡阶段被触发。当单击按钮时：

1. 当用户单击按钮时，将创建一个 click 事件，并从文档根节点向下传递到用户单击的元素（捕获阶段），在本例中为按钮
2. 当它到达按钮时，该事件会冒泡回文档根节点
3. 具有 `click` 事件处理程序的按钮会通过挂载对话框来响应该事件
4. 对话框被渲染，并在 `document` 上添加 `click` 事件处理程序，以便在单击其外部的元素时关闭对话框
5. `click` 事件传递到 `document` 并触发对话框添加的事件处理程序。按钮确实在对话框之外，因此对话框被关闭

`mousedown` 事件适用于点击外部交互，因为 `click` 事件是在 `mousedown` 和 `mouseup` 事件完成后触发的。由按钮点击引起的 `mousedown` 事件甚至在对话框呈现之前就已经完成。

#### 我们还能使用 `click` 事件吗？

另一种方法是添加一个 `click` 事件处理程序，该处理程序仅在捕获阶段响应：

```
document.addEventListener('click', onClickOutside, true); // 在捕获阶段而不是冒泡阶段调用
```

虽然它有效，但仍然首选`mousedown`事件，因为它不需要在触发前抬起鼠标按钮，并提供更灵敏的体验。
