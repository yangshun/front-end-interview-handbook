import TestCases from '../../../test-cases.mdx';
import A11y from '../../../a11y.mdx';

## Solution

The complexity of an auth code input component lies in the user experience, the custom input handling, and focus management:

- Instead of a single `<input>`, the code is split across N `<input>` fields
- Focus management is extremely hard to get right for an auth code input component:
  - Entering values
    - Users should be able to type in the values without using any arrow keys
    - The focus should shift automatically after an input field is filled
  - Erasing values
    - Users should to be able to erase all the input fields just by using the <kbd>Backspace</kbd> key
    - Hitting the <kbd>Backspace</kbd> key should erase the current value. It should also focus on the previous value if the current input field is empty
  - Traversing between fields
    - Traversal of input fields should be possible using just the usual arrow keys and <kbd>Tab</kbd> key
  - When users is focused on an input field, they expect to be able to type the new value – any existing values should be replaced and focus should move to the next field

### State

There aren't too many state variables necessary as the complexity lies in focus management.

Naturally, we will need state to store the code. Strictly speaking, uncontrolled inputs can be used but keeping the input values within state will enable us to enable/disable the "Reset" and "Submit" button appropriately.

It will be necessary to have finegrain control over which input field is focused, thus a `focusedIndex` state value will be helpful.

Thus, two state values are present:

- `code`: This state stores the auth code entered by the user as a string.
- `focusedIndex`: This state stores the index of the currently focused input field.

### Input handling

In React, a behavior of the `onChange` prop on `<input>` that people might not pay attention to is that it is **only fired when the value of an input changes**. For the input fields in this component, we want to respond to keypress events even if the user enters the same value within the field, as we want to move to the next input field if a valid number was entered.

Since we also need to handle other keyboard events like left/right arrows (move to previous/next fields), backspace (erase current value and move to next field), we can add a listener for the `keydown` event that handles these special keys as well as the number keys. This is one of the rare instances where you respond to input without using the `onChange` callback. This allows us to ignore whatever is in the input field, replace with a new value, and focus on the next field.

To handle the following keys:

- **Left Arrow**: Shifts the focus to the left of the currently focused input field.
- **Right Arrow**: Shifts the focus to the right of the currently focused input field.
- **Backspace**: If the currently focused input field is filled, delete it. Otherwise, shift the focus to the previous input field and delete any character present from the previous input field.
- **Others**: Check if the newly-entered value is valid. If so, update `code` and shift the focus to the next input field.

### Convenient way of deleting and replacing of values

Normally, when focusing on input fields, a cursor is created within the field to allow modification of the value. However for auth code inputs, each input field only allows a single digit, and it's not meaningful to render the cursor at all if the input field is already filled. It would be more useful to let the user delete the field or replace existing value with a single keystroke – via the <kbd>Backspace</kbd> key or a new number key respectively. By listening to `keydown` events, we can respond appropriately as explained in the previous section. This is harder to achieve using the `onChange` callback.

### Pasting values

Often, rather than entering the numbers manually, users will copy out the auth code from an email or a message to be pasted in. Hence we also support pasting of auth codes. This is done by adding a `paste` event listener to the `<input>`s and using `event.clipboardData.getData('text')` to get the clipboard value. Validation should be done on the clipboard value to ensure the pasted values is valid, and if so, fills the input fields accordingly.

The current implementation replaces the values from the start, regardless of which input field received the paste event. Hence it is not possible to complete the code a partially-filled component by pasting the rest of the code.

This behavior might not be the most ideal, but is acceptable given that:

1. When the auth code is copied, it is usually the entire code.
2. Usually, the auth code is pasted when focus is on the first input field.

<TestCases />
<A11y />
