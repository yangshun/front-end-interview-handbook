## 解决方案

文件资源管理器通常以树状导航方式实现，具有层次性和递归性。

### 组件

就前端组件而言，递归意味着组件可以渲染自身，或者渲染一个渲染自身的组件。因此，良好地设计递归组件以实现可重用性非常重要。

这里有两种不同的组件类型：

1. `FileObject`：它接受一个 `FileData` prop 并渲染项目名称。根据该项目是否为目录（基于 `children` 字段的存在），它可以渲染 `FileList` 组件。如果该项目是目录，则该项目可以切换。是否显示 `children` 项目的状态也将包含在此文件中。
2. `FileList`：它接受一个 `FileData` 数组，并将它们中的每一个映射到渲染 `FileObject` 组件。此组件还会按字母顺序对项目列表进行排序，并使目录排在最前面。

严格来说，我们可以将 `FileList` 合并到 `FileObject` 中，这样就不需要两个不同的组件了，但这会使 `FileObject` 变得非常复杂，因为它还将包含排序逻辑。

### 渲染

有两种常见的渲染树状结构的方法：

#### 1. 嵌套结构

最直观的方法是使用嵌套元素方法，其中每个父节点渲染左侧填充，以便子项缩进。它类似于拥有嵌套的 `<ul>` 和 `<li>`。

```html
<ul>
  <li>
    <div>docs</div>
    <ul>
      <li>foo.md</li>
      <li>bar.md</li>
    </ul>
  </li>
  <li>
    <div>README.md</div>
  </li>
</ul>
```

这种方法的优点是子项的缩进更容易实现。每个级别的缩进是前一个级别左侧填充的总和。此外，如果需要删除一个目录及其所有后代，可以通过删除该目录的单个节点来完成，因为它的后代包含在其中。

但是，如果需要 DOM 操作，那么由于需要在内部组件之间进行遍历，遍历 DOM 将会更加麻烦。

Figma 的工作区图层面板和 [GitHub 的文件资源管理器视图](https://github.com/yangshun/top-javascript-interview-questions/tree/main/questions) 使用了这种嵌套方法。

#### 2. 平铺结构

另一种可能的结构是拥有一个项目的单一平面列表，并为后代项目添加适当的填充。在递归时，当前级别将需要作为参数传递，以便后代项目知道要渲染多少填充。

```html
<!-- 必须隐藏项目符号，因为
它们仍然会向左对齐。 -->
<ul>
  <li>docs</li>
  <li style="padding-left: 16px">foo.md</li>
  <li style="padding-left: 16px">bar.md</li>
  <li>README.md</li>
</ul>
```

一个单一的 DOM 元素平面列表更容易遍历。此外，这种平面方法提供了对渲染的最大控制，并允许在包含许多文件的大型目录中进行虚拟化。使用嵌套结构不容易实现虚拟化，因为为了使项目缩进正确的量，它们的父项也必须被渲染——嵌套结构使得仅渲染需要显示的最小项目变得困难甚至不可能。

但是，如果需要删除一个目录及其所有后代，则必须选择正确的节点进行删除。

这种扁平方法被[VS Code](https://github.dev/yangshun/top-javascript-interview-questions/)使用，因为它需要处理大量文件。事实上，VS Code 使用`position: absolute; left: Xpx; top: Ypx;`以及一个扁平列表进行定位，并且它只渲染可见的文件项目。

#### 选择方法

使用的方法取决于应用程序的技术栈和要渲染的项目的数量。如果该组件是为小型目录构建的，并且使用带有大量手动 DOM 操作的 vanilla JavaScript，那么嵌套结构可能更容易实现。否则，建议使用扁平结构，原因在于其灵活性和可扩展性。

官方解决方案实现了嵌套结构，因为它是最常见的。在面试中，预计候选人会实现嵌套结构版本。但是，您应该了解每种方法的优点和局限性，以便在被问及时可以详细说明。

无论采用嵌套结构还是扁平结构，一个不容错过的重要事项是组件的可访问性。为了在面试中脱颖而出，您应该讨论文件资源管理器的可访问性方面。它们在[文件资源管理器 II](/questions/user-interface/file-explorer-ii)问题中进行了介绍。
