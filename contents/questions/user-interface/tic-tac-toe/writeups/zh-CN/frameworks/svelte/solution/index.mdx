import TestCases from '../../../test-cases.mdx';

## 解决方案

### 渲染

为了使棋盘具有响应性，代码中使用了 CSS Grid。 CSS Grid 是一个强大的布局系统，允许创建二维网格布局。 以下是使用 CSS Grid 使游戏棋盘具有响应性的方法：

1. **网格容器**：游戏棋盘包含在带有类名`board`的`<div>`元素中。 此元素用作我们单元格的网格容器。
2. **网格模板列**：网格容器被指定为`display: grid`，并应用属性`grid-template-columns: repeat(3, 1fr)`。 这指定网格应有三列，每列的宽度相等。 符号`repeat(3, 1fr)`是一种简洁的说法，意思是“三列，每列占据可用空间的 1/3”。
3. **单元格大小调整**：每个网格单元格都由来自`Cell`组件的按钮元素表示，类名为“cell”。 对于单元格的外观：
   * 使用`min()`函数设置`font-size`，确保文本根据视口的宽度自适应缩放。 指定了后备大小`48px`，但它也可以使用高达`10vw`（或视口宽度的 10%）。
   * 属性`aspect-ratio: 1 / 1`确保每个单元格保持正方形，而不管内容如何。
4. **响应式行为**：通过使用 CSS Grid 并根据视口宽度定义单元格大小，游戏棋盘变得具有响应性。 随着视口宽度的减小，网格布局会进行调整，单元格也会相应地调整其大小。 `font-size`属性中的`min()`函数确保字体大小在较小的屏幕上不会变得太大，从而提供更好的用户体验。

总的来说，CSS Grid 通过定义列数并根据可用空间调整单元格大小，为游戏棋盘提供了灵活且响应式的布局。 这使得游戏棋盘能够在不同的屏幕尺寸和设备上保持其结构和可用性。

### 状态

游戏的逻辑由两个主要的状态变量组合在一起：

1. `board`：一个表示游戏棋盘当前状态的数组。 初始化为一个填充了`undefined`的数组，长度为 9，每个数组元素对应一个棋盘单元格。 每个元素可以保存的可能值是`'X'`、`'O'`或`undefined`，分别表示玩家 X 和 O 做的标记或一个空单元格。
2. `xIsPlaying`：一个布尔值，用于跟踪轮到哪个玩家，最初设置为`true`（表示玩家 X）。

### `determineWinner`

`determineWinner`函数是游戏逻辑的核心，用于确定玩家是否获胜。 通过迭代每个可能的获胜线组合，此函数检查给定线中的所有单元格是否具有相同的标记。 如果找到获胜线，则该函数返回获胜玩家的标记（`'X'`或`'O'`），否则返回`null`（表示尚未有获胜者）。

该函数接受一个`board`参数，该参数是一个表示游戏棋盘状态的数组。 它迭代`CELLS_IN_A_LINE`数组，该数组包含在井字游戏中形成获胜线的所有可能的单元格索引组合。 每个组合由三个索引组成，表示一行、一列或对角线中的单元格。 由于棋盘大小相对较小，因此可以枚举所有可能的组合。 如果棋盘大小较大，则此方法将无法很好地扩展。

在循环内部，将当前单元格索引组合解构为三个变量：`x`、`y`和`z`。 这些变量表示需要检查是否相等的单元格的索引。

然后，该函数检查`board`数组中索引`x`、`y`和`z`处的值是否不为`undefined`（表示单元格不为空）并且都彼此相等。 如果满足此条件，则表示单元格中的标记形成了获胜线。 如果找到获胜线，则该函数返回获胜线中存在的标记的值（`'X'`或`'O'`）。 这表示哪个玩家赢得了比赛。

如果在检查所有组合后未找到获胜线，则该函数返回`null`，表示尚未有获胜者。

### 组件和交互性

游戏的交互性和用户交互性封装在两个 Svelte 组件中：

1. **App 组件**：它管理游戏的整体状态和逻辑。 在这里，我们确定轮到谁了，是否有获胜者，并处理游戏重置。 我们还迭代`board`状态，使用`Cell`组件渲染每个单元格。
2. **Cell 组件**：它表示单个游戏单元格。 它接受 props 以确定其外观和行为，例如是否应禁用它或它当前持有什么标记。 当单击单元格时，该组件会发出“click”事件以通知父组件（`App`）。

使用这两个组件，我们可以有效地管理游戏的状态，并确保为玩家提供流畅的交互。

<TestCases />
