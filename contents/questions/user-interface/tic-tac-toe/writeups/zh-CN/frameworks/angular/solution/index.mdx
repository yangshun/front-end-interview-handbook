import TestCases from '../../../test-cases.mdx';
import A11y from '../../../a11y.mdx';

## 解决方案

首先，我们将通过调用`adjustStatusMessage`在顶部显示一个`statusMessage`，每回合都会显示，以表明轮到谁以及传达游戏结果。 在该文本下方，我们将设置我们的 3x3 棋盘。 在其下方，将放置一个重置按钮以重新开始游戏。

在我们的例子中，玩家 X 总是先走。 当点击一个单元格时，我们使用棋盘上提供的索引运行`onCellClick`方法。 如果该单元格已被填充，我们将立即退出该函数。 否则，我们会在棋盘上放置一个`X`或`O`，具体取决于当前轮到谁，然后检查是否已经有获胜者或平局。

`determineWinner()`方法负责根据棋盘的当前状态确定井字游戏中是否有`winner`，它通过遍历所有可能的获胜组合并检查每个组合中的单元格是否具有相同的标记。 如果找到获胜线，它将返回获胜标记，如果没有获胜者，则返回`null`。

该方法接受一个`board`参数，该参数是一个表示游戏棋盘状态的数组。 它遍历`CELLS_IN_A_LINE`数组，该数组包含构成井字游戏中获胜线的所有可能的单元格索引组合。 每个组合由三个索引组成，表示一行、一列或对角线中的单元格。 由于棋盘大小相对较小，因此可以枚举所有可能的组合。 如果棋盘大小较大，则此方法将无法很好地扩展。

在循环内部，将当前单元格索引的组合解构为三个变量：`x`、`y`和`z`。 这些变量表示需要检查是否相等的单元格的索引。

然后，该方法检查`board`数组中索引`x`、`y`和`z`处的值是否不为`null`（表示单元格不为空）并且都彼此相等。 如果满足此条件，则意味着单元格中的标记形成了一条获胜线。 如果找到获胜线，该方法将返回标记的值（`'X'`或`'O'`），该标记存在于获胜线中。 这表明哪个玩家赢得了比赛。

如果在检查所有组合后未找到获胜线，则该方法返回`null`，表示还没有获胜者。

### 状态

有两个核心状态：

1. `board` - 一个表示游戏棋盘状态的数组。 它被初始化为长度为 9 的`null`值数组。 数组的每个元素对应于游戏棋盘上的一个单元格，并且可以具有三个值之一：`'X'`、`'O'`或`null`，分别表示玩家`X`、`O`或空单元格所做的标记。 状态通过将`board`分配给`turn`的当前索引来更新。 2. `xIsPlaying` - 一个布尔值，指示当前是否轮到玩家 X。 它被初始化为`true`。 状态使用`get turn()`方法更新。

## 渲染

为了使棋盘具有响应性，代码中使用了 CSS Grid。 CSS Grid 是一个强大的布局系统，允许创建二维网格布局。 以下是使用 CSS Grid 使游戏棋盘具有响应性的方法：

1. 网格容器：游戏棋盘被包装在一个带有类名`board`的`<div>`元素中。 此元素用作单元格的网格容器。 2. 网格模板列：为了定义网格中列的数量和宽度，将`display: grid`和`grid-template-columns: repeat(3, 1fr)`应用于网格容器。 此规则将网格容器设置为使用网格布局，并指定它应该有三列，宽度相等。 `repeat(3, 1fr)`语法表示重复列大小定义 (`1fr`) 三次。 3. 单元格大小调整：网格中的每个单元格都由一个带有类名“cell”的`<button>`元素表示。 以下 CSS 规则定义了单元格的大小和外观： * 使用`min()`函数设置`font-size`属性。 它确保单元格的字体大小具有响应性，并根据视口的可用宽度进行调整。 `48px`值是后备大小，`10vw`表示视口宽度的 10%。 * `aspect-ratio`属性设置为`1 / 1`，确保每个单元格保持正方形，而不管其内容如何。 4. 响应式行为：通过使用 CSS Grid 并根据视口宽度定义单元格大小，游戏棋盘变得具有响应性。 随着视口宽度的减小，网格布局会进行调整，单元格也会相应地调整其大小。 `font-size`属性中的`min()`函数确保字体大小在较小的屏幕上不会变得太大，从而提供更好的用户体验。

总的来说，CSS Grid 通过定义列数并根据可用空间调整单元格大小，为游戏棋盘提供了灵活且响应式的布局。 这使得游戏棋盘能够在不同的屏幕尺寸和设备上保持其结构和可用性。

### 模型

我们建议为棋盘单元格创建一个简单的类型，以防止键入`board: (string | null)[];`。

```typescript
type Cell = string | null;
```

### Angular 见解

* 您可以使用 RxJS 采用更高级的、类似响应式的方案（尽可能不使用订阅）。但是，如果您选择订阅，请记住销毁它们以防止内存泄漏。

* 您可以创建用于维护状态的服务。在智能组件中注入服务，并创建仅显示和与 UI 交互的哑组件，并且哑组件的所有事件都传递给智能组件。

* 如果您对最新的 Angular 版本有信心，请考虑使用信号独立 API。

* 您可以尝试更多地关注诸如 `readonly`、`private`、`public` 和 `void` 等关键字。

* 如果您正在创建一个更大的应用程序，最好为每个组件使用样式，而不是将所有样式放在一个文件中。

<TestCases />

<A11y />
