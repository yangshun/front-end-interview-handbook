## 解决方案

该解决方案由两部分组成：(1) 画布和 (2) 工具栏。

### 状态

我们需要在应用程序中使用以下状态：

* 模式：应用程序处于绘图模式还是擦除模式。
* 选定颜色：用于绘图的活动颜色。
* 画布颜色：一个二维颜色值数组，表示像素艺术画布。
* 拖动：光标是否处于拖动状态。

当前模式和选定颜色状态可以驻留在顶层组件中，而画布颜色和拖动状态仅在画布中需要。

### 工具栏

渲染工具栏组件非常简单。工具栏中的各种按钮将更新模式和选定颜色。

唯一需要注意的是，对于白色单元格使用非透明边框，对于黑色单元格使用非黑色边框。

### 画布

有很多方法可以渲染画布，我们选择使用 flexbox 行而不是 CSS grid（它使用单元格的线性数组），因为这样更容易渲染空单元格的交替背景。

我们将在画布中的顶层 DOM 元素中添加一个 `mousedown` 侦听器，并在发生这种情况时将状态更改为拖动。当触发 `mouseup` 事件时，拖动状态将重置。

画布包含许多单元格，每个单元格都是一个像素，要么是空的，要么填充了颜色。单元格监听两个事件：

1. `mousedown`：触发单元格的绘图/擦除。我们希望在按下鼠标时立即触发选定的操作，因此使用 `mousedown` 事件而不是 `click`。
2. `mouseenter`：触发单元格的绘图/擦除。仅当画布处于拖动状态时才需要此事件。

根据当前模式，单元格网格将使用新颜色进行更新，或者从单元格中擦除颜色。

内联样式用于单元格的背景颜色，以便于更改十六进制值，而无需为每种可能的颜色创建 CSS 类。
