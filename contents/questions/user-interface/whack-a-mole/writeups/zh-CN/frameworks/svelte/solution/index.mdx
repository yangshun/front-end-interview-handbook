import TestCases from '../../../test-cases.mdx';
import Notes from '../../../notes.mdx';

## 解决方案

### Props

我们的游戏保留了其可定制性，提供以下输入：

* `rows`: 行数。
* `cols`: 列数。
* `roundDuration`: 每局游戏的时长。
* `molesAtOnce`: 可以同时弹出的鼹鼠数量。
* `molesAppearingInterval`: 鼹鼠保持可见的时长。

### 状态管理

为了维护游戏状态，Svelte 依赖于响应式声明和简单变量：

* `visible`: 一个集合，表示当前哪些洞有鼹鼠。
* `score`: 跟踪玩家的分数。
* `running`: 一个标志，指示游戏是否正在进行。
* `timeLeft`: 当前游戏回合的倒计时。

### 游戏逻辑

#### 开始游戏

`startGame` 初始化游戏。它设置了两个主要的计时器：

1. `countdownTimerId`: 每秒减少 `timeLeft`，并在其达到零时停止游戏。
2. `moleTimerId`: 使用 `generateMolePositions` 以固定间隔生成新的鼹鼠位置。

`stopGame` 补充 `startGame`，确保当游戏结束时，鼹鼠生成计时器停止。

#### 清理

使用 `onDestroy` 函数，我们确保在组件被销毁时清除任何残留的计时器，防止意外的副作用。

#### 敲鼹鼠

`whackMole` 检查玩家点击的鼹鼠（单元格）是否真的包含鼹鼠。如果是，则鼹鼠被“敲掉”，从 `visible` 集合中移除，并且玩家的分数增加。

### 渲染

由于 Svelte 的响应式特性，更新游戏的视觉状态非常简单：

* 游戏网格仍然使用 CSS 网格设计，使用线性 DOM 元素列表实现灵活的 2D 布局。
* 在 Svelte 的 `{#if ...}` 块的帮助下，我们根据游戏状态有条件地渲染“开始游戏”按钮或分数和“再玩一次”按钮。
* `{#each ...}` 块动态创建游戏网格按钮。它还根据 `visible` 集合是否包含特定单元格的索引，有条件地应用 `mole-head--visible` 类，该类确定是否显示鼹鼠。

### 生成鼹鼠位置

鼹鼠的位置是使用`generateMolePositions`函数随机确定的，该函数采用了Fisher-Yates洗牌算法。此函数创建一个潜在位置的数组，对其进行洗牌，并选择前`molesAtOnce`个位置作为鼹鼠将出现的位置。

### 总结

与React对应版本相比，Svelte版本简化了结构和响应性。它提供了一种更直接、更直观的方法来进行状态管理和UI更新，简化了游戏逻辑，而没有牺牲灵活性或功能。

<TestCases />

<Notes />
