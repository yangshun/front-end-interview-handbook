## 解决方案

该解决方案可以分解为两个部分：(1) 渲染和 (2) 状态更新

### 渲染

正如您所知，提供的数据本质上是递归的，并且可以是任意深度。因此，我们的组件还必须支持通过递归渲染任意深度的嵌套复选框。

就前端组件而言，递归意味着组件可以渲染自身，或者渲染一个渲染自身的组件。设计良好的递归组件对于可重用性非常重要。

渲染递归分层结构最直观的方法是使用 `<ul>` 和 `<li>`。`<ul>` 可以嵌套在 `<li>` 中：

```html
<ul>
  <li>
    <div><input type="checkbox"><label>电子产品</div>
    <ul>
      <li><div><input type="checkbox"><label>手机</div></li>
      <li><div><input type="checkbox"><label>笔记本电脑</div></li>
    </ul>
  </li>
  <li>
    <div><div><input type="checkbox"><label>书籍</div></div>
  </li>
</ul>
```

只要使用缩进（例如 `padding-left`）渲染 `<ul>`，嵌套的 `<ul>` 就会自动缩进正确的量 - 它自己的填充和祖先填充的总和。

我们可以创建一个 `CheckboxList` 组件，它接受一个 `CheckboxItem` 数组并渲染 `<input type="checkbox">` 列表。根据 `CheckboxItem` 是否有子项，它将使用 `CheckboxList` 递归渲染子项。

### 不确定复选框

您是否知道除了已选中和未选中状态之外，`<input type="checkbox>` 还有不确定状态？不确定状态通常用于表示“部分选中”状态。

默认情况下，浏览器使用框内的短划线/连字符渲染不确定状态的复选框。关于不确定复选框的一个怪癖是，它没有 HTML 属性，只能使用 JavaScript 设置：

```js
const $checkboxElement = document.querySelector(
  'input[type="checkbox"]',
);
$checkboxElement.indeterminate = true;
```

我们可以创建一个组件 `CheckboxInput` 来抽象这个逻辑。该组件将接受一个 `checked` 属性，该属性是一个布尔值或字符串 `indeterminate`。

当复选框输入元素的 `indeterminate` 属性为 `true` 时，`checked` 的值是什么并不重要，将显示不确定的虚线状态。这就引出了一个问题，当复选框设置为不确定时，`checked` 的值应该是什么？当用户单击不确定的复选框时，它通常会变为选中状态。因此，当复选框处于不确定状态时，最好将复选框的 `checked` 属性设置为 `false`，这样单击不确定的复选框就会将其变为 `checked`。

### 状态更新

在介绍了布局和结构之后，下一步将是管理复选框的状态更新。

单击/触发复选框时，会发生以下操作：

1. 更新复选框状态。
2. 更新复选框后代的状态。
3. 更新复选框祖先的状态。

让我们详细介绍每个操作：

#### 1. 更新复选框状态

复选框的状态会根据其当前状态进行更新：

* **未选中**：它将变为选中状态。
* **已选中**：它将变为未选中状态。
* **不确定**：它将变为选中状态。

#### 2. 更新后代的状态

复选框的后代会递归更新为相同的状态，即选中或未选中。

由于父级需要更新后代的状态，如果触发最顶层的复选框，则可能需要遍历整个树，因此应将整体状态提升并保存在根组件中作为真理来源，而不是让每个复选框管理自己的状态。

步骤 1 和 2 在 `updateCheckboxAndDescendants` 函数中实现，该函数接受一个复选框项、新值，并递归地将其自身及其所有后代设置为该新值。

#### 3. 更新祖先的状态

复选框的祖先会根据已修改复选框的新状态进行更新。它们可以更新为任何可能的状态。

祖先需要检查其**直接子级**的选中状态以确定其新状态。它不需要查看孙子级及更远的后代，因为父级的状态反映了子级的状态。只要以自底向上的方式更新新状态（从叶节点开始），父级只需要查看其直接子级的状态。

步骤 3 作为 `resolveCheckboxStates` 函数实现。它首先解析后代的状态，即它们应该更新为 true/false/不确定，并向上工作，在顶级复选框处终止。请注意，只有已修改复选框的直接祖先链中的复选框会受到影响。

#### 整合

根组件将包含所有复选框的层次结构和状态。默认数据已采用此格式。

* 每个复选框接收自身及其后代所需的最小状态。
* 状态更改在根/顶层完成，因为它包含真理来源。

更改/点击处理程序必须包含当前复选框的索引（在其同级中的位置）。当根组件由于其树中的某个复选框被修改而收到更新时，它会收到两个参数：

* **新的复选框状态**：一个布尔值。这永远不会是 `indeterminate`，因为复选框的 `indeterminate` 状态是用户更新后代复选框的结果。
* **索引数组**：一个表示复选框位置的整数数组。例如 `[0, 1]` 表示从根开始的第一个孩子的第二个孩子，也就是“笔记本电脑”。顶层组件需要它来跟踪哪个复选框已被触发。

在根组件中，状态更新函数将接收新的复选框状态和索引数组，使用它们来计算复选框的新状态。

1. 它会深度克隆现有的复选框数据。这可能需要也可能不需要，具体取决于所选的框架。执行深度克隆的一种简单方法是 `JSON.parse(JSON.stringify(data))`。这很有效，因为手头的数据是可序列化的。使用数据的克隆，我们可以根据需要对其进行修改。
2. 执行步骤 1 和 2，即调用 `updateCheckboxAndDescendants()` 将后代更新为新状态。
3. 执行步骤 3，即调用 `resolveCheckboxStates()` 以更新已修改复选框的祖先。
4. 提交状态更新。
