## Solution

The solution can be broken down into two parts: (1) Rendering and (2) State updates

### Rendering

As you can tell, the data provided is recursive in nature and can be of any depth. Hence our component must also support rendering nested checkboxes of arbitrary depth via recursion.

In terms of front end components, recursion means that the components can be rendering itself, or render a component that renders itself. It's important to design the recursive components well to allow for reusability.

The most intuitive way to render recursive hierarchical structures is using `<ul>` and `<li>`. `<ul>`s can be nested within `<li>`s:

```html
<ul>
  <li>
    <div><input type="checkbox"><label>Electronics</div>
    <ul>
      <li><div><input type="checkbox"><label>Mobile phones</div></li>
      <li><div><input type="checkbox"><label>Laptop</div></li>
    </ul>
  </li>
  <li>
    <div><div><input type="checkbox"><label>Book</div></div>
  </li>
</ul>
```

As long as the `<ul>`s are rendered with an indentation (e.g. `padding-left`), nested `<ul>`s will automatically be indented by the right amount â€“ a summation of its own padding and ancestors' paddings.

We can create a `CheckboxList` component, that accepts an array of `CheckboxItem`s and renders the list of `<input type="checkbox">`s. Depending on whether the `CheckboxItem` has children, it will recursively render the children using `CheckboxList`.

### Indeterminate checkboxes

Did you know that besides the checked and unchecked states, `<input type="checkbox>` have an indeterminate state? Indeterminate state is often used to represent a "partially checked" state.

By default, browsers render checkboxes in the indeterminate state using a dash/hyphen within the box. One quirk about indeterminate checkboxes is that there's no HTML attribute for it, and it can only be set using JavaScript:

```js
const $checkboxElement = document.querySelector(
  'input[type="checkbox"]',
);
$checkboxElement.indeterminate = true;
```

We can create a component `CheckboxInput` that abstracts this logic away. The component will accept a `checked` prop that is either a boolean value or the string `indeterminate`.

When an checkbox input element's `indeterminate` property is `true`, it does not matter what the value of `checked` is, the indeterminate dashed state will be displayed. This begs the question, what should the value of `checked` be when a checkbox is set to indeterminate? When a user clicks on an indeterminate checkbox, it typically becomes checked. So it's better to make the checkbox's `checked` property to be `false` when it is indeterminate, such that clicking on indeterminate checkboxes will turn it into `checked`.

### State updates

After covering the layout and structure, the next step will be to manage the state updates of the checkboxes.

When a checkbox is clicked/triggered, the following operations occur:

1. Update checkbox state.
2. Update the checkbox descendants' state.
3. Update the checkbox's ancestors' state.

Let's go through each operation in detail:

#### 1. Update checkbox state

The checkbox's state is updated, depending on its current state:

- **Unchecked**: It will become checked.
- **Checked**: It will become unchecked.
- **Indeterminate**: It will become checked.

#### 2. Update descendants' state

The checkbox's descendants are updated recursively to be of the same state, either checked or unchecked.

Because parents need to update the descendants' state, potentially across the entire tree if the top-most checkbox is triggered, the overall state should be lifted up and housed within the root component as the source of truth, instead of having each checkbox manage its own state.

Step 1 and 2 is implemented within the `updateCheckboxAndDescendants` function, which takes in a checkbox item, the new value, and recursively sets itself + all descendants to be that new value.

#### 3. Update ancestors' state

The checkbox's ancestors are updated based on the modified checkbox's new state. They could be updated to any of the possible states.

Ancestors need to inspect its **direct children's** checked state to determine its new state. It does not need to look at grandchildren and beyond, because a parent's state reflects the child's state. As long as the new state is updated in a bottom-up fashion (starting from the leaf nodes), parents only need to look at its direct children's state.

Step 3 is implemented as the `resolveCheckboxStates` function. It firstly resolves the descendants' states, whether they should be updated to true/false/indeterminate and work its way upwards, terminating at a top-level checkbox. Note that only checkboxes in the direct ancestry chain of the modified checkbox will be affected.

#### Putting it together

The root component will house the hierarchy and state of all the checkboxes. The default data is already in this format.

- Each checkbox receives the minimal state needed for itself and its descendants.
- State mutations are done at the root / top-level since it contains the source of truth.

The change/click handlers have to include the index of the current checkbox (position among its siblings). When the root component receives an update due to a checkbox somewhere in its tree being modified, it receives two arguments:

- **New checkbox state**: A boolean value. This will never be `indeterminate`, because `indeterminate` state of a checkbox is a result of a user updating descendant checkboxes.
- **Indices array**: An array of integers representing the positions of the checkboxes. E.g. `[0, 1]` means the second child of the first child starting from the root, aka the "Laptops". This is needed by the top-level component to trace which checkbox has been triggered.

In the root component, the state update function will receive the new checkbox state and indices array, using them to compute the new state of the checkboxes.

1. It makes a deep clone of the existing checkbox data. This may or may not be needed depending on the framework of choice. A simple way to perform a deep clone is `JSON.parse(JSON.stringify(data))`. This works well since the data at hand is serializable. With a clone of the data, we can mutate it however we want.
2. Perform steps 1 and 2, aka call `updateCheckboxAndDescendants()` to update the descendants to be the new state.
3. Perform step 3, aka call `resolveCheckboxStates()` to update the ancestors of the modified checkbox.
4. Commit the state update.
