import TestCases from '../../../test-cases.mdx';
import Notes from '../../../notes.mdx';

## 解决方案

### 变量

Svelte 代码引入了以下变量来管理应用程序的行为和数据流：

* `PAGE_SIZE`：一个常量，定义了每页要显示的作业数量。
* `pageCount`：此变量维护用户已浏览的页数，这决定了要获取的作业详细信息集。
* `jobIdsCache`：它充当缓存，用于存储来自 Hacker News API 的作业 ID 数组。这避免了多次获取相同的数据并提高了应用程序的性能。

### 获取数据

#### `fetchJobIds`

此异步函数根据当前页面 (`currPage`) 从 Hacker News API 检索作业 ID 列表。如果 `jobIdsCache` 为空（即，之前未获取数据），则该函数从 API 获取作业 ID，然后使用获取的数据更新 `jobIdsCache`。之后，该函数根据 `PAGE_SIZE` 计算当前页的开始和结束索引，并对数组进行切片以返回相关的作业 ID 集。

#### `fetchJobs`

另一个异步函数 `fetchJobs` 的任务是根据从 `fetchJobIds` 获得的作业 ID 获取每个作业的详细信息。它首先获取当前页的作业 ID，然后使用 `Promise.all`，它启动对 Hacker News API 的多个请求以获取每个作业的详细信息。一旦所有 promise 都得到解决，它将返回一个作业详细信息数组，然后将其呈现在页面上。

### 渲染

渲染代码的一些显著方面包括：

#### `{#each}` 块：

* `{#each}` 块用于迭代由 `pageCount` 定义的范围。对于每一页，它都会获取并呈现与该页面对应的职位发布。这是通过行 `{#each { length: pageCount } as _, page}` 实现的。在这里，`_` 是一个占位符（我们没有使用），而 `page` 给了我们当前的页码。
* 在此块内部，使用了另一个块 `{#await fetchJobs(page)}`。 Svelte 中的 `{#await}` 块是一个特殊结构，旨在处理 promise。在 promise（在本例中为获取作业详细信息）未解决时，它会显示 `loading` 消息。一旦 promise 得到解决，就会执行 `{:then jobs}` 块，使用 `JobPosting` 组件呈现当前页的作业列表。

#### “加载更多”按钮：

* 在 `{#each}` 块中，在列出当前页的作业之后，有一个条件 `{#if}` 块，用于检查是否应显示“加载更多作业”按钮。如果当前页面是最后加载的页面，并且为该页面获取的作业数量等于 `PAGE_SIZE`（表明可能还有更多作业要加载），则此条件评估为 true。这是通过条件 `{#if page === pageCount - 1 && jobs.length === PAGE_SIZE}` 实现的。

* 单击“加载更多作业”按钮后，会增加 `pageCount`，有效地将另一页添加到我们的 `{#each}` 块中，并触发下一组职位发布的获取和呈现。这是一个巧妙的技巧，用于实现分页，而无需处理复杂的状态管理。该按钮的行为由行 `on:click={() => pageCount++}` 决定。

通过利用上述结构，Svelte 应用程序实现了对职位发布的有效分页渲染，将数据获取与用户交互无缝集成。

<TestCases />

<Notes />
