import TestCases from '../../../test-cases.mdx';

## Solution

Overall, the trickiest part of this question is to select the right data structure to use considering the operations we need to do on the data.

Since the items are unique, a `Map` data structure is feasible as it gives us O(1) access, insertion, and removal of items. Moreover, JavaScript `Map`s are ordered, so the items order can be preserved. The key will be the item name and value is a boolean indicating whether the item is selected/checked. We only need two JavaScript Maps in total, one for each list.

Based on events from the `ItemList` component, which is considered a dumb component solely for displaying the UI, we will call `setItemsLeft` or `setItemsRight` to update our state. The method `hasNoSelectedItems` checks if a button should be disabled. Note that we only need this method for selected transfers.

Methods `transferAllItems` and `transferSelectedItems` are almost identical. The first simply transfers all items from the source map to the destination map, which are our `itemsRight` and `itemsLeft`. The second one has a condition to transfer only truthy values.

`ItemListComponent` is used only for displaying the UI without changing state. If the values in this component are changed, they are sent to our container component to handle state.

### State

The intuitive thing to do would be to use an arrays for each list since arrays are the most natural data structure to represent a list of ordered items. However, marking items as checked/unchecked and removing items from the list will require O(N) time if an array is used.

### Rendering

There's nothing particularly special about rendering the UI for the transfer lists. Flexboxes can help us render the three columns. Since the UI and the functionality of columns are identical, we can define a component `ItemList` that takes in a list of items and a setter callback to manipulate the list.

To determine if the buttons should be disabled:

- Transfer all buttons: check if the source list is empty.
- Transfer selected buttons: write a helper function `hasNoSelectedItems`, to count if the source list has any selected items, and disable the transfer buttons.

### Angular Insights

- If you have time always consider pipes instead of functions in the template or extract data from an object. It improves performance and do not need to be calculated so many times.

- You can adopt a more advanced, reactive-like approach using RxJS (without using subscriptions as possible). However, if you opt for subscriptions, remember about destroying them to prevent memory leaks.

- You might create service for maintaining the state. Inject the service in smart component and crete dumb components that only display and interact with the UI and all events from dumb components are passed to the smart one.

- If you're confident with the latest Angular versions, consider using signals standalone API.

- You can try to focus more on keywords such as `readonly`, `private`, `public` and `void`.

- If you're creating a bigger application it would be good practice to use styles per component instead of putting all styles in one file.

<TestCases />
