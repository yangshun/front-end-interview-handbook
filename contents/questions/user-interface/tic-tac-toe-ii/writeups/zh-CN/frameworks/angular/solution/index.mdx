import TestCases from '../../../test-cases.mdx';

## 解决方案

以下解释假设您对[井字棋的 Angular 解决方案](/questions/user-interface/tic-tac-toe/angular/solution)有很好的理解。

标准的井字棋游戏使用 n = 3 和 m = 3。一般来说，对您正在构建的应用程序/组件进行参数化是一个好习惯，但是通用版本的井字棋需要更长的实现时间。

一旦我们初始化组件并进入 `ngOnInit` 钩子，我们将重置游戏。这包括将所有属性设置为其初始值，并根据 `@Input` 值配置游戏板

我们会在每回合后调用 `determineWinner`，因为只有在回合后才能决出胜负。

`determineWinner` 方法需要处理四个核心值：`board`（游戏板的当前状态）、`index`（最后标记的单元格的传递索引）、`n`（棋盘的大小）和 `m`（获胜所需的连续标记数）。

它首先生成四个代表获胜 `lines` 的数组：

* `rowLine`：包含与最后一个标记单元格在同一行中的所有单元格的索引。
* `colLine`：包含与最后一个标记单元格在同一列中的所有单元格的索引。
* `leftToRightDiagonalLine`：包含包含最后一个标记单元格的从左到右对角线中所有单元格的索引。
* `rightToLeftDiagonalLine`：包含包含最后一个标记单元格的从右到左对角线中所有单元格的索引。

对于 `lines` 中的每一行，它会计算是否有 `m` 个连续的单元格具有相同的标记，如果有，则返回该标记，否则返回 `null`，表示棋盘还没有获胜者。

基于 `board`、`xIsPlaying` 和 `winner` 字段，我们可以使用 `statusMessage` pipe 确定谁是获胜者或轮流顺序。

### 状态

在我们的状态中，我们有 `board`、`xIsPlaying` 和 `winner`（当然还有 `n` 和 `m`，但这些值不应该被更改）。

除了 3 x 3 井字棋的两个核心状态之外，我们现在还包括一个新的 `winner` 状态来跟踪棋盘获胜标记的状态。严格来说，`winner` 是派生状态，可以通过处理 `board` 来确定，这是 3 x 3 版本的做法。但是，对于 N x N 棋盘，其中 N 和 M 可以非常大，我们仅在每回合后确定获胜者并将其存储在状态中，与在每次渲染时确定相比，这是一种更有效的方法。

### 渲染

由于棋盘的尺寸不是固定的，只能在运行时确定，因此我们必须使用内联样式来生成所需的 `grid-template-columns` 属性值。

### 模型

棋盘单元格的类型，以防止键入 `board: (string | null)[];`。

```typescript
type Cell = string | null;
```

### Angular 见解

* 您可以使用 RxJS 采用更高级的、类似响应式的方案（尽可能不使用订阅）。但是，如果您选择订阅，请记住销毁它们以防止内存泄漏。

* 您可以创建用于维护状态的服务。将服务注入智能组件，并创建仅显示和与 UI 交互的哑组件，并且哑组件的所有事件都将传递给智能组件。

* 如果您对最新的 Angular 版本有信心，请考虑使用信号独立 API。

* 您可以尝试更多地关注 `readonly`、`private`、`public` 和 `void` 等关键字。

* 如果您正在创建更大的应用程序，最好为每个组件使用样式，而不是将所有样式放在一个文件中。

<TestCases />
