import TestCases from '../../../test-cases.mdx';

## 解决方案

### Props

图中所示的默认记忆游戏是 4 x 4，目标是匹配对。为了使游戏可定制，我们可以引入以下 props：

* `rows`：行数。
* `cols`：列数。
* `matchCount`：相同图像的数量。默认值为 2，但将其设为参数是一个积极的信号。
* `delay`：在翻转回未匹配的卡片之前，延迟时间。

由于这些参数可以以使游戏无法玩的方式组合，我们可以对单元格总数是否可被匹配计数整除进行基本检查。

### State

* `cards`：游戏板可以表示为一个一维数组，称为 `cards`，其中包含正确数量的唯一表情符号组。在 4 x 4 的棋盘上，数组的长度为 16，`cards[4]` 将对应于第 2 行第 1 列。此数组在初始化期间生成，并且在游戏的整个过程中不会被修改。仅当用户选择再次玩时，才会重新生成它。
* `flipped`：一个索引数组，用于跟踪哪些卡片被翻转。此数组不包括匹配的卡片。
* `matched`：一组已匹配的图像（表情符号）。
* `waitTimer`：一个引用，用于跟踪计时器 ID，用于在 `delay` 持续时间后是否自动翻转回卡片。
* `gameCompleted`：布尔值，表示游戏是否已完成。

### 渲染

CSS 网格用于以二维格式渲染卡片。这是一个不错的选择，因为您可以将卡片渲染为单个 DOM 元素列表，但使用正确的 CSS 网格设置，它们可以显示在行 x 列布局中。

### 卡片生成

以下过程可用于生成卡片：

1. 在单个数组中制作 N 组 `matchCount` 表情符号，其中 N = 总单元格 / `matchCount`。
2. 随机排列数组。

### `onFlip`

在大多数情况下，`onFlip` 将卡片添加到 `selected` 数组中。如果没有足够的卡片来决定是否匹配，则该函数将终止。当选择了足够的卡片时，检查所有选定的卡片是否相似。如果是，我们可以将选定的表情符号添加到 `matched` 集合中，并将 `selected` 重置为空，以便玩家可以继续游戏。如果没有匹配项，我们会在 `delay` 持续时间过去后等待，然后再翻转选定的卡片。我们对 `waitTimer` 使用 `useRef`，以便我们可以在 `setTimeout` 回调中访问相同的 timerID 值。如果我们使用 `useState`，由于闭包，我们可能会访问过时的计时器 ID 值。当在 React 组件中使用 `setTimeout` 或 `setInterval` 时，这是非常常见的错误来源，请阅读 [Dan Abramov 的这篇文章](https://overreacted.io/making-setinterval-declarative-with-react-hooks/) 了解更多信息。

我们必须处理的另一种情况是，用户在 `delay` 过去之前选择了更多卡片。必须清除 `waitTimer` 并且必须翻转当前未匹配的打开卡片。

<TestCases />
