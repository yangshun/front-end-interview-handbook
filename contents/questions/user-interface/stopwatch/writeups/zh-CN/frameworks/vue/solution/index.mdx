import TestCases from '../../../test-cases.mdx';
import Notes from '../../../notes.mdx';

## 解决方案

这个问题乍一看很简单，但实际上比看起来更复杂。请注意，`setInterval` 的 `delay` 参数是不可靠的。由于各种原因，回调函数被调用的实际时间可能[比给定的延迟时间长](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout#reasons_for_delays_longer_than_specified)。由于这种行为，我们不能假设每次触发间隔回调时，经过的时间都相同。我们需要在回调代码中读取当前时间，以确保我们使用最新的计时。

### 状态

这个问题的棘手之处在于决定组件状态中包含什么以及如何管理它们。我们需要几个状态：

* `totalDuration`：到目前为止经过的总时间。
* `timerId`：当前正在运行的间隔计时器的计时器 ID，如果没有当前正在运行的计时器，则为 `null`。
* `lastTickTiming`：这是上次间隔回调运行的时间。我们将通过当前时间 (`Date.now()`) 和 `lastTickTiming` 之间的差值来增加 `totalDuration`。使用这种方法，即使回调以不规则的间隔运行，`totalDuration` 仍然是准确的。由于它未在渲染代码中使用，我们可以将其存储为局部变量而不是 Vue 的响应式状态。
* `isRunning`：一个[计算属性](https://vuejs.org/guide/essentials/computed.html)，用于检查计时器当前是否正在运行。这取决于 `timerId` 是否为 null。

由于需求中有几个按钮具有重复的功能，我们应该将这些功能定义为几个将由按钮触发的函数：

### `startTimer`

此函数启动计时器，并在每次运行 `setInterval` 回调时更新 `totalDuration` 值，更新值为上次更新时间 (`lastTickTiming`) 和当前时间之间的差值。我们使用 1 毫秒的间隔计时，因为秒表对时间非常敏感，并且需要毫秒级的精度。

### `stopInterval`

一个简单的函数，用于停止间隔计时器运行（通过 `clearInterval`）并清除当前的 `timerId`。这被“停止”按钮和“重置”按钮使用。

### `resetTimer`

我们希望在此函数中将组件重置为其初始状态。它通过调用 `stopInterval()` 来停止间隔计时器，并将总持续时间重置为 0。重置 `lastTickTiming` 的值并不重要，因为它将在 `startTimer()` 开始时设置，在第一个间隔回调执行之前。由“重置”按钮使用。

### `toggleTimer`

一个函数，用于根据当前是否有计时器在调用 `stopInterval()` 和 `startTimer()` 之间切换。由时间显示和“开始”/“停止”按钮使用。

<TestCases />

<Notes />
