import TestCases from '../../../test-cases.mdx';
import Notes from '../../../notes.mdx';

## 解决方案

这个问题乍一看很简单，但实际上比看起来更复杂。请注意，setInterval 的延迟参数是不可靠的。由于各种原因，回调之间经过的实际时间可能比给定的延迟时间长。由于这种行为，我们不能假设每次触发间隔回调时，经过的时间都相同。我们需要在回调代码中读取当前时间，以确保我们使用最新的计时。

要运行计时器，我们需要调用 `toggleTimer()` 方法，该方法检查我们是否有活动的计时器。如果没有，我们将启动它。

在 `startTimer()` 方法中，我们像上面描述的那样计算 `lastTickTiming`，并启动 `setInterval()`。每次变量都会单独重新计算，每 1 毫秒（应该如此）。关于最后一个变量 `milliseconds`，我们将使用管道 `padTwoDigit` 在模板上更清晰地显示它，例如，显示 65 而不是显示 06.5，依此类推。

调用 `resetTimer()`，我们运行 `stopInterval`，它使用 window 函数 `clearInterval` 来防止内存泄漏，并将所有变量设置为初始状态 0。

### 状态

在 `AppComponent` 中，我们将存储以下变量：

* `timerId` - `setInterval` 函数的返回值，用于停止间隔以防止内存泄漏。默认情况下，我们将其设置为 0。
* `totalDuration`：到目前为止经过的总时间。
* `lastTickTiming`：这是上次间隔回调运行的时间。我们将通过当前时间 (`Date.now()`) 和 `lastTickTiming` 之间的差值来增加 `totalDuration`。使用这种方法，即使回调以不规则的间隔运行，`totalDuration` 仍然是准确的。
* `hours`、`minutes`、`seconds`、`milliseconds` - 要在模板上显示的时间变量。

### Angular 见解

* 您可以使用更高级的、类似反应式的方法，使用 RxJS（尽可能不使用订阅）。但是，如果您选择订阅，请记住销毁它们以防止内存泄漏。

* 您可以创建用于维护状态的服务。在智能组件中注入服务，并创建仅显示和与 UI 交互的哑组件，并且哑组件的所有事件都传递给智能组件。

* 如果您对最新的 Angular 版本有信心，请考虑使用信号独立 API。

* 您可以尝试更多地关注诸如 `readonly`、`private`、`public` 和 `void` 等关键字。

* 如果您正在创建一个更大的应用程序，最好为每个组件使用样式，而不是将所有样式放在一个文件中。

<TestCases />

<Notes />
