import MDXCodeBlock from 'MDXCodeBlock';

import deepCloneJs from '../setup/src/deep-clone-ii.js';
import deepCloneTs from '../setup/src/deep-clone-ii.ts';

**Note:** This is an advanced version of the [Deep Clone](/questions/javascript/deep-clone) question, which you should complete first before attempting this question.

This is a follow-up question based on Deep Clone, with much more depth and obscure corners of the JavaScript language covered.

It is not realistic to expect anyone to come up with a complete deep clone solution in typical interview settings. However, this question serves a good tool to test your knowledge on checking various data types, object properties, leverage various built-in APIs and `Object` methods to traverse a given object and various edge cases you might only encounter when writing library code.

## Solution

Before we go about writing out the deep clone function, we need a way to identify the data type of a given JavaScript value. It is ok to go with `typeof` and `instanceof` but you have to be aware of their limitations. In this solution, we leverage `Object.prototype.toString`. Check out Zhenghao's post ["A Complete Guide To Check Data Types In JavaScript"](https://www.zhenghao.io/posts/js-data-type) if you like to understand how this works exactly.

Since we want to implement it as thoroughly as possible, here are a few things to consider:

- This advanced `deepClone` should work with objects that have symbol-keyed properties. That is, symbol-keyed properties are also copied. On top of that, non-enumerable properties should also be copied. Neither the `for ... in` statement or the `Object.entries()`/`Object.keys()` reveals them, so we need to leverage a lesser-known API called `Reflect.ownKeys()`. Check out [this MDN page](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys) to learn more about it.
- The input object's property descriptors should also be copied. For that, we can use the method `Object.getOwnPropertyDescriptors()`.
- The input object's prototype should not be lost after the copying. We can use `Object.getPrototypeOf()` to get a reference to the prototype of a given object.
- We should account for circular references in the input object and avoid erroring. We can achieve this by having a `cache` (a `Map` underneath) that acts as a cache to store visited properties. After cloning an object, we can put the cloned object in `cache` with the original object as the key. If we encounter the same value again in the original object while cloning, we can retrieve the cloned value from the `cache`.

<MDXCodeBlock languages={{ jsx: deepCloneJs, tsx: deepCloneTs }} />

## One-liner solution

As of writing, all major browsers have native support for performing deep clone via the `structuredClone` API. Check out ["Deep-copying in JavaScript using structuredClone" on web.dev](https://web.dev/structured-clone/) if you want to learn more about `structuredClone`'s features and limitations.

```js
const clonedObj = structuredClone(obj);
```

## Edge cases

- [Property descriptors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors) are not copied.
