import MDXCodeBlock from 'MDXCodeBlock';

import functionApplyJs from '../setup/src/function-apply.js';
import functionApplyTs from '../setup/src/function-apply.ts';
import functionApplyAlt from '../setup/src/function-apply-alt';
import functionApplyCall from '../setup/src/function-apply-call';
import functionApplySymbol from '../setup/src/function-apply-symbol';

``Function.prototype.apply()`` 函数是 JavaScript 中的一个内置方法，允许您使用指定的 this 值和参数数组来调用函数。 类似于 ``Function.prototype.call()``，它允许您显式定义将执行该函数的上下文（``this`` 值）。

## 解决方案

由于 ``Function.prototype.apply()`` 接受参数数组，因此如果我们要展开它，则必须为 ``argArray`` 定义一个默认的空数组参数，因为我们只能展开可迭代对象。

### 方法 1：使用 `bind`

``bind``、``apply`` 和 ``call`` 可以被视为同级函数。 它们在函数签名和用法方面非常相似。 在 ``Function.prototype`` 方法中，``this`` 指的是 ``Function`` 对象本身。 如果根本不使用 ``this`` 上下文，则以下方法将起作用：

```js
Function.prototype.myApply = function (thisArg, argArray = []) {
  return this(...argArray);
};
```

但是，``thisArg`` 仍然在现代代码中被广泛使用，因此我们需要另一种方法来执行此操作。 ``Function.prototype.bind`` 创建一个具有指定的 ``this`` 值和初始参数的新函数，而无需立即执行原始函数。 它允许我们永久地将特定的上下文（``this`` 值）绑定到该函数，并在需要时部分应用参数。 这正是我们需要弥合上述解决方案中的差距的地方。

<MDXCodeBlock languages={{ jsx: functionApplyJs, tsx: functionApplyTs }} />

或者您也可以在执行之前将 ``argArray`` 传递给 ``bind()``。

<MDXCodeBlock>
  {functionApplyAlt}
</MDXCodeBlock>

### 方法 2：使用 `call`

``Function.prototype.call`` 和 ``Function.prototype.apply`` 非常相似。 这是一个记住每个函数签名的简单方法：

* ``Function.prototype.call`` 接受一个以**逗号**分隔的参数列表。
* ``Function.prototype.apply`` 接受一个参数**数组**。

<MDXCodeBlock>
  {functionApplyCall}
</MDXCodeBlock>

### 方法 3：使用 `Symbol`

另一种方法是创建一个 ``Symbol`` 并将其作为属性添加到新创建的 ``Object`` 中，并将 ``thisArg`` 绑定到该对象。 这与 [`Function.prototype.bind`](/questions/javascript/function-bind) 问题的解决方案之一非常相似。

<MDXCodeBlock>
  {functionApplySymbol}
</MDXCodeBlock>
