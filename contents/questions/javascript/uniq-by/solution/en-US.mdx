import MDXCodeBlock from 'MDXCodeBlock';

import uniqByJs from '../setup/src/uniq-by.js';
import uniqByTs from '../setup/src/uniq-by.ts';
import uniqBySetJs from '../setup/src/uniqBySet.js';
import uniqBySetTs from '../setup/src/uniqBySet.ts';

## Solution

### Approach 1: Using array to store unique key values

1. Create an empty `compare` array to store the unique keys.
1. Iterate through `array` and determine the key for each element by calling `iteratee(element)`. If the key does not exist within `compare`, insert the key into `compare`. Next, append the element into `result`.

Two variables are used:

- `result`: Tracks the unique elements from `array`.
- `compare`: Tracks the unique computed value of the elements through `iteratee` to be used for comparison.

<MDXCodeBlock languages={{ jsx: uniqByJs, tsx: uniqByTs }} />

### Approach 2: Using Set instead of array for `compare`

Alternatively, we can use a `Set` to replace the `compare` array to check for unique elements. A `Set` can help in tracking uniqueness which ensures faster lookups (constant time complexity) for large datasets, making it more efficient than the previous code which uses an array (`compare.includes`) for tracking, resulting in slower (linear time complexity) lookups as the dataset grows.

<MDXCodeBlock languages={{ jsx: uniqBySetJs, tsx: uniqBySetTs }} />

## Edge cases

To handle mixed data types, the `iteratee` function must be able to process them by either converting the elements to a common type or process them separately.

## Resources

- [Lodash `_.uniqBy`](https://lodash.com/docs/4.17.15#uniqBy)
