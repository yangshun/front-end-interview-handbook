import MDXCodeBlock from 'MDXCodeBlock';

import promiseTimeoutJs from '../setup/src/promise-timeout.js';
import promiseTimeoutTs from '../setup/src/promise-timeout.ts';
import promiseTimeoutRaceJs from '../setup/src/promise-timeout-race.js';
import promiseTimeoutRaceTs from '../setup/src/promise-timeout-race.ts';

## Solution

1. The `promiseTimeout` function takes two parameters: the original `promise` and the timeout `duration` in milliseconds.
1. Inside the function, create and return a new `Promise` which will `reject()` with a custom error after the specified `duration`.
1. If the `promise` argument is fulfilled before `duration` is up, we can `resolve()` the promise with the fulfilled value. If it is rejected, we can `reject()` with the rejected reason.
1. We use `setTimeout` to set up the timeout mechanism. When the timeout is reached, the returned promise will `reject()` with the custom error message.
1. If the promise is settled before the timeout, we should clear the timer. We can keep a reference the id returned from `setTimeout`, and in the `.finally()` method, clear the timeout using `clearTimeout` so that the `reject()` within the timeout is not unnecessarily called.

<MDXCodeBlock languages={{ jsx: promiseTimeoutJs, tsx: promiseTimeoutTs }} />

### Using `Promise.race()`

The `setTimeout` is also an async operation and hence be wrapped in a `Promise`. We can simplify the execution logic by using `Promise.race()`; whichever promise that is settled first will determine the outcome of the returned `Promise`.

<MDXCodeBlock
  languages={{ jsx: promiseTimeoutRaceJs, tsx: promiseTimeoutRaceTs }}
/>

## Edge cases

- If the `promise` argument resolves immediately, the overall result should be resolved regardless of the timeout duration, even if it is 0.
