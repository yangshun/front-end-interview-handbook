import MDXCodeBlock from 'MDXCodeBlock';

import withoutJs from '../setup/src/without.js';
import withoutTs from '../setup/src/without.ts';
import withoutFilterJS from '../setup/src/without-filter.js';
import withoutFilterTS from '../setup/src/without-filter.ts';
import withoutFilterSetJS from '../setup/src/without-filter-set.js';
import withoutFilterSetTS from '../setup/src/without-filter-set.ts';

## Solution

### Approach 1: Uses Set to filter the values

This solution employs a Set to efficiently store and look up the values to be excluded, then iterates over `array` and builds `result` with only those elements not present in the Set, effectively filtering out the specified values.

<MDXCodeBlock languages={{ jsx: withoutJs, tsx: withoutTs }} />

### Approach 2: Uses `Array.prototype.filter`

Here's a simpler solution that leverages `Array.prototype.filter`.

<MDXCodeBlock languages={{ jsx: withoutFilterJS, tsx: withoutFilterTS }} />

### Approach 3: Uses `Array.prototype.filter` to filter the Set instead of manually checking the values

Alternatively, we can use Set to make it more efficient.

<MDXCodeBlock
  languages={{ jsx: withoutFilterSetJS, tsx: withoutFilterSetTS }}
/>

## Edge cases

A possible edge case is when the function is used with arrays containing objects or arrays as elements; since these are reference types, direct comparison using a Set may not work as expected. To address this, you could implement a deep comparison function for objects/arrays or ensure the function is used with primitive data types only for reliable results.

## Resources

- [Lodash `_.without`](https://lodash.com/docs/#without)
