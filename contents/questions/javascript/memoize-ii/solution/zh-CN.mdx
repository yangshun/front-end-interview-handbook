import MDXCodeBlock from 'MDXCodeBlock';

import memoizeJs from '../setup/src/memoize-ii.js';
import memoizeTs from '../setup/src/memoize-ii.ts';
import memoizeTrie from '../setup/src/memoize-ii-trie';

## 解决方案

解决这个问题的关键是使用一个缓存，用于存储输入参数的结果。如果输入参数存在缓存条目，则返回缓存结果。否则，像往常一样调用该函数，将结果放入缓存中，并将输入参数作为键，以便后续使用相同参数调用该函数时，将是缓存命中，并直接返回该值，而无需调用原始函数。

### 方法 1：基于 `Map` 的缓存和序列化参数作为缓存键

这个问题可以分解为三个部分：

#### 确定缓存键

缓存键是与 `func` 可以调用的参数具有一一对应关系的值。由于输入类型是字符串和数字，我们可以通过将它们连接在一起来构造一个唯一的键。

尝试为参数构造一个哈希函数，可以执行 `args.join('_')`（或其他一些标记），但这存在一些问题：

1. 如果字符串包含 `_`，则可能出现非唯一的哈希。例如，`['hello_', 'world']` 和 `['hello', '_world']` 都将导致 `hello_world` 作为键。
2. 数字与字符串没有区别。例如，`['1', 'foo']` 和 `[1, 'foo']` 都将导致 `1_foo` 作为键。

哈希是一个棘手的问题，我们可以使用的一个内置函数是 `JSON.stringify()`。它在字符串周围添加双引号，有效地区分数字和字符串，并正确地分割字符串化结果中的参数。请注意，我们只能使用 `JSON.stringify()`，因为对字符串和数字输入有约束。如果还有其他类型的输入，如 `Set`，`JSON.stringify()` 默认情况下会将它们转换为 `{}`，而不管内容如何，并且不再为唯一的参数组合生成唯一的值。

#### 决定缓存的结构

缓存查找必须快速，理想情况下具有 O(1) 的时间复杂度。在 JavaScript 中，对象和 `Map` 能够用作快速查找键和相应值的目的。由于键是字符串，我们可以使用对象和 `Map` 作为缓存结构

返回的函数可以通过闭包访问缓存。使用闭包，每个唯一的记忆化函数实例都将拥有自己的缓存。

#### 使用缓存

在调用原始函数 `func` 之前，记忆化函数首先检查 `cache` 是否已经包含当前参数的条目（使用 `JSON.stringify(args)` 作为键）。这将导致以下两种情况之一：

1. 缓存包含 `key` 的条目。存在缓存结果，这意味着该函数之前已使用相同的参数调用，并且无需重新计算结果。在这种情况下，记忆化函数只需使用 `cache.get(key)` 返回缓存结果。
2. 缓存不包含这些 `args` 的条目。如果缓存不包含当前 `args` 的结果，则意味着该函数使用以前未见过的参数调用。然后，记忆化函数使用 `Function.prototype.apply()` 调用原始函数 func。`Function.prototype.apply()` 用于确保在从记忆化函数调用原始函数时保留原始函数的上下文（`this`）。参数将传递给原始函数 `func`，在使用原始函数计算结果后，记忆化函数通过使用 `cache.set(key, result)` 将结果存储在缓存中，并将其与相应的键关联起来。最后，记忆化函数返回计算结果。

<MDXCodeBlock languages={{ jsx: memoizeJs, tsx: memoizeTs }} />

### 方法 2：基于 Trie 的缓存

除了从参数构造单个字符串键之外，我们还可以使用单个参数项作为 trie 数据结构中的节点。在这里，我们实现了一个 `Trie` 和 `TrieNode` 类，它们具有与 `Map` 相同的相关 `set`、`has`、`get` API，并且可以更改缓存初始化步骤，并使代码的其余部分保持不变。使用 trie 作为缓存的好处是所需的内存空间更少，但查找时间复杂度与 `JSON.stringify` 版本大致相同。

<MDXCodeBlock>
  {memoizeTrie}
</MDXCodeBlock>

## 边缘情况

* 在实践中，函数可以接受字符串和数字以外的各种类型的参数，因此当前的 `memoize` 实现对于这些情况是不够的。
* 虽然可以毫无问题地访问 `this`，但结果仅根据输入参数进行记忆，即使 `this` 值在调用之间不同，对于相同的输入参数也会返回相同的记忆结果。
